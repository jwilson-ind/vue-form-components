import * as NF from "vue";
import { withDirectives as G1, openBlock as kn, createElementBlock as no, createElementVNode as Co, toDisplayString as ji, vShow as K2, computed as Qo, vModelCheckbox as qF, normalizeClass as tc, withKeys as Ty, withModifiers as vc, renderSlot as kl, Fragment as th, renderList as Oy, createCommentVNode as Ks, createVNode as Qf, Transition as MF, withCtx as bf, normalizeStyle as Y2, createTextVNode as Bm, ref as Jr, watch as Od, unref as ng, onMounted as Ad, createBlock as Ju, vModelRadio as Mq, defineComponent as em, nextTick as I5, toRefs as Bq, onBeforeUnmount as Lq, onActivated as Pq, onDeactivated as Iq, h as Xu, watchEffect as Jh, cloneVNode as Fq, inject as nh, provide as Ay, onUnmounted as Qh, shallowRef as $q, getCurrentInstance as Hq, Teleport as Vq, reactive as Uq } from "vue";
const jq = { "aria-live": "assertive" }, Zq = { class: "text-sm text-red-600" }, Wq = {
  __name: "InputError",
  props: ["message"],
  setup(v) {
    return (L, N) => G1((kn(), no("div", jq, [
      Co("p", Zq, ji(v.message), 1)
    ], 512)), [
      [K2, v.message]
    ]);
  }
}, qq = ["id", "value", "disabled"], Gq = {
  __name: "Checkbox",
  props: {
    id: {},
    checked: {
      type: [Array, Boolean],
      default: !1
    },
    value: {
      default: null
    },
    disabled: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update:checked"],
  setup(v, { emit: L }) {
    const N = L, W = v, ue = Qo({
      get() {
        return W.checked;
      },
      set(ce) {
        N("update:checked", ce);
      }
    });
    return (ce, he) => G1((kn(), no("input", {
      id: v.id,
      type: "checkbox",
      value: v.value,
      "onUpdate:modelValue": he[0] || (he[0] = (pe) => ue.value = pe),
      disabled: v.disabled,
      class: "disabled:cursor-not-allowed"
    }, null, 8, qq)), [
      [qF, ue.value]
    ]);
  }
};
function m8(v) {
  return v === 0 ? !1 : Array.isArray(v) && v.length === 0 ? !0 : !v;
}
function Kq(v) {
  return (...L) => !v(...L);
}
function Yq(v, L) {
  return v === void 0 && (v = "undefined"), v === null && (v = "null"), v === !1 && (v = "false"), v.toString().toLowerCase().indexOf(L.trim()) !== -1;
}
function Xq(v) {
  return v.filter((L) => !L.$isLabel);
}
function p8(v, L) {
  return (N) => N.reduce((W, ue) => ue[v] && ue[v].length ? (W.push({
    $groupLabel: ue[L],
    $isLabel: !0
  }), W.concat(ue[v])) : W, []);
}
const BF = (...v) => (L) => v.reduce((N, W) => W(N), L);
var Jq = {
  data() {
    return {
      search: "",
      isOpen: !1,
      preferredOpenDirection: "below",
      optimizedHeight: this.maxHeight
    };
  },
  props: {
    /**
     * Decide whether to filter the results based on search query.
     * Useful for async filtering, where we search through more complex data.
     * @type {Boolean}
     */
    internalSearch: {
      type: Boolean,
      default: !0
    },
    /**
     * Array of available options: Objects, Strings or Integers.
     * If array of objects, visible label will default to option.label.
     * If `labal` prop is passed, label will equal option['label']
     * @type {Array}
     */
    options: {
      type: Array,
      required: !0
    },
    /**
     * Equivalent to the `multiple` attribute on a `<select>` input.
     * @default false
     * @type {Boolean}
     */
    multiple: {
      type: Boolean,
      default: !1
    },
    /**
     * Key to compare objects
     * @default 'id'
     * @type {String}
     */
    trackBy: {
      type: String
    },
    /**
     * Label to look for in option Object
     * @default 'label'
     * @type {String}
     */
    label: {
      type: String
    },
    /**
     * Enable/disable search in options
     * @default true
     * @type {Boolean}
     */
    searchable: {
      type: Boolean,
      default: !0
    },
    /**
     * Clear the search input after `)
     * @default true
     * @type {Boolean}
     */
    clearOnSelect: {
      type: Boolean,
      default: !0
    },
    /**
     * Hide already selected options
     * @default false
     * @type {Boolean}
     */
    hideSelected: {
      type: Boolean,
      default: !1
    },
    /**
     * Equivalent to the `placeholder` attribute on a `<select>` input.
     * @default 'Select option'
     * @type {String}
     */
    placeholder: {
      type: String,
      default: "Select option"
    },
    /**
     * Allow to remove all selected values
     * @default true
     * @type {Boolean}
     */
    allowEmpty: {
      type: Boolean,
      default: !0
    },
    /**
     * Reset this.internalValue, this.search after this.internalValue changes.
     * Useful if want to create a stateless dropdown.
     * @default false
     * @type {Boolean}
     */
    resetAfter: {
      type: Boolean,
      default: !1
    },
    /**
     * Enable/disable closing after selecting an option
     * @default true
     * @type {Boolean}
     */
    closeOnSelect: {
      type: Boolean,
      default: !0
    },
    /**
     * Function to interpolate the custom label
     * @default false
     * @type {Function}
     */
    customLabel: {
      type: Function,
      default(v, L) {
        return m8(v) ? "" : L ? v[L] : v;
      }
    },
    /**
     * Disable / Enable tagging
     * @default false
     * @type {Boolean}
     */
    taggable: {
      type: Boolean,
      default: !1
    },
    /**
     * String to show when highlighting a potential tag
     * @default 'Press enter to create a tag'
     * @type {String}
    */
    tagPlaceholder: {
      type: String,
      default: "Press enter to create a tag"
    },
    /**
     * By default new tags will appear above the search results.
     * Changing to 'bottom' will revert this behaviour
     * and will proritize the search results
     * @default 'top'
     * @type {String}
    */
    tagPosition: {
      type: String,
      default: "top"
    },
    /**
     * Number of allowed selected options. No limit if 0.
     * @default 0
     * @type {Number}
    */
    max: {
      type: [Number, Boolean],
      default: !1
    },
    /**
     * Will be passed with all events as second param.
     * Useful for identifying events origin.
     * @default null
     * @type {String|Integer}
    */
    id: {
      default: null
    },
    /**
     * Limits the options displayed in the dropdown
     * to the first X options.
     * @default 1000
     * @type {Integer}
    */
    optionsLimit: {
      type: Number,
      default: 1e3
    },
    /**
     * Name of the property containing
     * the group values
     * @default 1000
     * @type {String}
    */
    groupValues: {
      type: String
    },
    /**
     * Name of the property containing
     * the group label
     * @default 1000
     * @type {String}
    */
    groupLabel: {
      type: String
    },
    /**
     * Allow to select all group values
     * by selecting the group label
     * @default false
     * @type {Boolean}
     */
    groupSelect: {
      type: Boolean,
      default: !1
    },
    /**
     * Array of keyboard keys to block
     * when selecting
     * @default 1000
     * @type {String}
    */
    blockKeys: {
      type: Array,
      default() {
        return [];
      }
    },
    /**
     * Prevent from wiping up the search value
     * @default false
     * @type {Boolean}
    */
    preserveSearch: {
      type: Boolean,
      default: !1
    },
    /**
     * Select 1st options if value is empty
     * @default false
     * @type {Boolean}
    */
    preselectFirst: {
      type: Boolean,
      default: !1
    },
    /**
     * Prevent autofocus
     * @default false
     * @type {Boolean}
     */
    preventAutofocus: {
      type: Boolean,
      default: !1
    },
    /**
     * Allows a custom function for sorting search/filtered results.
     * @default null
     * @type {Function}
     */
    filteringSortFunc: {
      type: Function,
      default: null
    }
  },
  mounted() {
    !this.multiple && this.max && console.warn("[Vue-Multiselect warn]: Max prop should not be used when prop Multiple equals false."), this.preselectFirst && !this.internalValue.length && this.options.length && this.select(this.filteredOptions[0]);
  },
  computed: {
    internalValue() {
      return this.modelValue || this.modelValue === 0 ? Array.isArray(this.modelValue) ? this.modelValue : [this.modelValue] : [];
    },
    filteredOptions() {
      const v = this.search || "", L = v.toLowerCase().trim();
      let N = this.options.concat();
      return this.internalSearch ? N = this.groupValues ? this.filterAndFlat(N, L, this.label) : this.filterOptions(N, L, this.label, this.customLabel) : N = this.groupValues ? p8(this.groupValues, this.groupLabel)(N) : N, N = this.hideSelected ? N.filter(Kq(this.isSelected)) : N, this.taggable && L.length && !this.isExistingOption(L) && (this.tagPosition === "bottom" ? N.push({ isTag: !0, label: v }) : N.unshift({ isTag: !0, label: v })), N.slice(0, this.optionsLimit);
    },
    valueKeys() {
      return this.trackBy ? this.internalValue.map((v) => v[this.trackBy]) : this.internalValue;
    },
    optionKeys() {
      return (this.groupValues ? this.flatAndStrip(this.options) : this.options).map((L) => this.customLabel(L, this.label).toString().toLowerCase());
    },
    currentOptionLabel() {
      return this.multiple ? this.searchable ? "" : this.placeholder : this.internalValue.length ? this.getOptionLabel(this.internalValue[0]) : this.searchable ? "" : this.placeholder;
    }
  },
  watch: {
    internalValue: {
      handler() {
        this.resetAfter && this.internalValue.length && (this.search = "", this.$emit("update:modelValue", this.multiple ? [] : null));
      },
      deep: !0
    },
    search() {
      this.$emit("search-change", this.search);
    }
  },
  emits: ["open", "search-change", "close", "select", "update:modelValue", "remove", "tag"],
  methods: {
    /**
     * Returns the internalValue in a way it can be emited to the parent
     * @returns {Object||Array||String||Integer}
     */
    getValue() {
      return this.multiple ? this.internalValue : this.internalValue.length === 0 ? null : this.internalValue[0];
    },
    /**
     * Filters and then flattens the options list
     * @param  {Array}
     * @return {Array} returns a filtered and flat options list
     */
    filterAndFlat(v, L, N) {
      return BF(
        this.filterGroups(L, N, this.groupValues, this.groupLabel, this.customLabel),
        p8(this.groupValues, this.groupLabel)
      )(v);
    },
    /**
     * Flattens and then strips the group labels from the options list
     * @param  {Array}
     * @return {Array} returns a flat options list without group labels
     */
    flatAndStrip(v) {
      return BF(
        p8(this.groupValues, this.groupLabel),
        Xq
      )(v);
    },
    /**
     * Updates the search value
     * @param  {String}
     */
    updateSearch(v) {
      this.search = v;
    },
    /**
     * Finds out if the given query is already present
     * in the available options
     * @param  {String}
     * @return {Boolean} returns true if element is available
     */
    isExistingOption(v) {
      return this.options ? this.optionKeys.indexOf(v) > -1 : !1;
    },
    /**
     * Finds out if the given element is already present
     * in the result value
     * @param  {Object||String||Integer} option passed element to check
     * @returns {Boolean} returns true if element is selected
     */
    isSelected(v) {
      const L = this.trackBy ? v[this.trackBy] : v;
      return this.valueKeys.indexOf(L) > -1;
    },
    /**
     * Finds out if the given option is disabled
     * @param  {Object||String||Integer} option passed element to check
     * @returns {Boolean} returns true if element is disabled
     */
    isOptionDisabled(v) {
      return !!v.$isDisabled;
    },
    /**
     * Returns empty string when options is null/undefined
     * Returns tag query if option is tag.
     * Returns the customLabel() results and casts it to string.
     *
     * @param  {Object||String||Integer} Passed option
     * @returns {Object||String}
     */
    getOptionLabel(v) {
      if (m8(v))
        return "";
      if (v.isTag)
        return v.label;
      if (v.$isLabel)
        return v.$groupLabel;
      const L = this.customLabel(v, this.label);
      return m8(L) ? "" : L;
    },
    /**
     * Add the given option to the list of selected options
     * or sets the option as the selected option.
     * If option is already selected -> remove it from the results.
     *
     * @param  {Object||String||Integer} option to select/deselect
     * @param  {Boolean} block removing
     */
    select(v, L) {
      if (v.$isLabel && this.groupSelect) {
        this.selectGroup(v);
        return;
      }
      if (!(this.blockKeys.indexOf(L) !== -1 || this.disabled || v.$isDisabled || v.$isLabel) && !(this.max && this.multiple && this.internalValue.length === this.max) && !(L === "Tab" && !this.pointerDirty)) {
        if (v.isTag)
          this.$emit("tag", v.label, this.id), this.search = "", this.closeOnSelect && !this.multiple && this.deactivate();
        else {
          if (this.isSelected(v)) {
            L !== "Tab" && this.removeElement(v);
            return;
          }
          this.multiple ? this.$emit("update:modelValue", this.internalValue.concat([v])) : this.$emit("update:modelValue", v), this.$emit("select", v, this.id), this.clearOnSelect && (this.search = "");
        }
        this.closeOnSelect && this.deactivate();
      }
    },
    /**
     * Add the given group options to the list of selected options
     * If all group optiona are already selected -> remove it from the results.
     *
     * @param  {Object||String||Integer} group to select/deselect
     */
    selectGroup(v) {
      const L = this.options.find((N) => N[this.groupLabel] === v.$groupLabel);
      if (L) {
        if (this.wholeGroupSelected(L)) {
          this.$emit("remove", L[this.groupValues], this.id);
          const N = this.trackBy ? L[this.groupValues].map((ue) => ue[this.trackBy]) : L[this.groupValues], W = this.internalValue.filter(
            (ue) => N.indexOf(this.trackBy ? ue[this.trackBy] : ue) === -1
          );
          this.$emit("update:modelValue", W);
        } else {
          const N = L[this.groupValues].filter(
            (W) => !(this.isOptionDisabled(W) || this.isSelected(W))
          );
          this.max && N.splice(this.max - this.internalValue.length), this.$emit("select", N, this.id), this.$emit(
            "update:modelValue",
            this.internalValue.concat(N)
          );
        }
        this.closeOnSelect && this.deactivate();
      }
    },
    /**
     * Helper to identify if all values in a group are selected
     *
     * @param {Object} group to validated selected values against
     */
    wholeGroupSelected(v) {
      return v[this.groupValues].every(
        (L) => this.isSelected(L) || this.isOptionDisabled(L)
      );
    },
    /**
     * Helper to identify if all values in a group are disabled
     *
     * @param {Object} group to check for disabled values
     */
    wholeGroupDisabled(v) {
      return v[this.groupValues].every(this.isOptionDisabled);
    },
    /**
     * Removes the given option from the selected options.
     * Additionally checks this.allowEmpty prop if option can be removed when
     * it is the last selected option.
     *
     * @param  {type} option description
     * @return {type}        description
     */
    removeElement(v, L = !0) {
      if (this.disabled || v.$isDisabled)
        return;
      if (!this.allowEmpty && this.internalValue.length <= 1) {
        this.deactivate();
        return;
      }
      const N = typeof v == "object" ? this.valueKeys.indexOf(v[this.trackBy]) : this.valueKeys.indexOf(v);
      if (this.multiple) {
        const W = this.internalValue.slice(0, N).concat(this.internalValue.slice(N + 1));
        this.$emit("update:modelValue", W);
      } else
        this.$emit("update:modelValue", null);
      this.$emit("remove", v, this.id), this.closeOnSelect && L && this.deactivate();
    },
    /**
     * Calls this.removeElement() with the last element
     * from this.internalValue (selected element Array)
     *
     * @fires this#removeElement
     */
    removeLastElement() {
      this.blockKeys.indexOf("Delete") === -1 && this.search.length === 0 && Array.isArray(this.internalValue) && this.internalValue.length && this.removeElement(this.internalValue[this.internalValue.length - 1], !1);
    },
    /**
     * Opens the multiselect’s dropdown.
     * Sets this.isOpen to TRUE
     */
    activate() {
      this.isOpen || this.disabled || (this.adjustPosition(), this.groupValues && this.pointer === 0 && this.filteredOptions.length && (this.pointer = 1), this.isOpen = !0, this.searchable ? (this.preserveSearch || (this.search = ""), this.preventAutofocus || this.$nextTick(() => this.$refs.search && this.$refs.search.focus())) : this.preventAutofocus || typeof this.$el < "u" && this.$el.focus(), this.$emit("open", this.id));
    },
    /**
     * Closes the multiselect’s dropdown.
     * Sets this.isOpen to FALSE
     */
    deactivate() {
      this.isOpen && (this.isOpen = !1, this.searchable ? this.$refs.search !== null && typeof this.$refs.search < "u" && this.$refs.search.blur() : typeof this.$el < "u" && this.$el.blur(), this.preserveSearch || (this.search = ""), this.$emit("close", this.getValue(), this.id));
    },
    /**
     * Call this.activate() or this.deactivate()
     * depending on this.isOpen value.
     *
     * @fires this#activate || this#deactivate
     * @property {Boolean} isOpen indicates if dropdown is open
     */
    toggle() {
      this.isOpen ? this.deactivate() : this.activate();
    },
    /**
     * Updates the hasEnoughSpace variable used for
     * detecting where to expand the dropdown
     */
    adjustPosition() {
      if (typeof window > "u")
        return;
      const v = this.$el.getBoundingClientRect().top, L = window.innerHeight - this.$el.getBoundingClientRect().bottom;
      L > this.maxHeight || L > v || this.openDirection === "below" || this.openDirection === "bottom" ? (this.preferredOpenDirection = "below", this.optimizedHeight = Math.min(L - 40, this.maxHeight)) : (this.preferredOpenDirection = "above", this.optimizedHeight = Math.min(v - 40, this.maxHeight));
    },
    /**
     * Filters and sorts the options ready for selection
     * @param {Array} options
     * @param {String} search
     * @param {String} label
     * @param {Function} customLabel
     * @returns {Array}
     */
    filterOptions(v, L, N, W) {
      return L ? v.filter((ue) => Yq(W(ue, N), L)).sort((ue, ce) => typeof this.filteringSortFunc == "function" ? this.filteringSortFunc(ue, ce) : W(ue, N).length - W(ce, N).length) : v;
    },
    /**
     *
     * @param {String} search
     * @param {String} label
     * @param {String} values
     * @param {String} groupLabel
     * @param {function} customLabel
     * @returns {function(*): *}
     */
    filterGroups(v, L, N, W, ue) {
      return (ce) => ce.map((he) => {
        if (!he[N])
          return console.warn("Options passed to vue-multiselect do not contain groups, despite the config."), [];
        const pe = this.filterOptions(he[N], v, L, ue);
        return pe.length ? {
          [W]: he[W],
          [N]: pe
        } : [];
      });
    }
  }
}, Qq = {
  data() {
    return {
      pointer: 0,
      pointerDirty: !1
    };
  },
  props: {
    /**
     * Enable/disable highlighting of the pointed value.
     * @type {Boolean}
     * @default true
     */
    showPointer: {
      type: Boolean,
      default: !0
    },
    optionHeight: {
      type: Number,
      default: 40
    }
  },
  computed: {
    pointerPosition() {
      return this.pointer * this.optionHeight;
    },
    visibleElements() {
      return this.optimizedHeight / this.optionHeight;
    }
  },
  watch: {
    filteredOptions() {
      this.pointerAdjust();
    },
    isOpen() {
      this.pointerDirty = !1;
    },
    pointer() {
      this.$refs.search && this.$refs.search.setAttribute("aria-activedescendant", this.id + "-" + this.pointer.toString());
    }
  },
  methods: {
    optionHighlight(v, L) {
      return {
        "multiselect__option--highlight": v === this.pointer && this.showPointer,
        "multiselect__option--selected": this.isSelected(L)
      };
    },
    groupHighlight(v, L) {
      if (!this.groupSelect)
        return [
          "multiselect__option--disabled",
          { "multiselect__option--group": L.$isLabel }
        ];
      const N = this.options.find((W) => W[this.groupLabel] === L.$groupLabel);
      return N && !this.wholeGroupDisabled(N) ? [
        "multiselect__option--group",
        { "multiselect__option--highlight": v === this.pointer && this.showPointer },
        { "multiselect__option--group-selected": this.wholeGroupSelected(N) }
      ] : "multiselect__option--disabled";
    },
    addPointerElement({ key: v } = "Enter") {
      this.filteredOptions.length > 0 && this.select(this.filteredOptions[this.pointer], v), this.pointerReset();
    },
    pointerForward() {
      this.pointer < this.filteredOptions.length - 1 && (this.pointer++, this.$refs.list.scrollTop <= this.pointerPosition - (this.visibleElements - 1) * this.optionHeight && (this.$refs.list.scrollTop = this.pointerPosition - (this.visibleElements - 1) * this.optionHeight), this.filteredOptions[this.pointer] && this.filteredOptions[this.pointer].$isLabel && !this.groupSelect && this.pointerForward()), this.pointerDirty = !0;
    },
    pointerBackward() {
      this.pointer > 0 ? (this.pointer--, this.$refs.list.scrollTop >= this.pointerPosition && (this.$refs.list.scrollTop = this.pointerPosition), this.filteredOptions[this.pointer] && this.filteredOptions[this.pointer].$isLabel && !this.groupSelect && this.pointerBackward()) : this.filteredOptions[this.pointer] && this.filteredOptions[0].$isLabel && !this.groupSelect && this.pointerForward(), this.pointerDirty = !0;
    },
    pointerReset() {
      this.closeOnSelect && (this.pointer = 0, this.$refs.list && (this.$refs.list.scrollTop = 0));
    },
    pointerAdjust() {
      this.pointer >= this.filteredOptions.length - 1 && (this.pointer = this.filteredOptions.length ? this.filteredOptions.length - 1 : 0), this.filteredOptions.length > 0 && this.filteredOptions[this.pointer].$isLabel && !this.groupSelect && this.pointerForward();
    },
    pointerSet(v) {
      this.pointer = v, this.pointerDirty = !0;
    }
  }
}, yT = {
  name: "vue-multiselect",
  mixins: [Jq, Qq],
  compatConfig: {
    MODE: 3,
    ATTR_ENUMERATED_COERCION: !1
  },
  props: {
    /**
       * name attribute to match optional label element
       * @default ''
       * @type {String}
       */
    name: {
      type: String,
      default: ""
    },
    /**
       * Presets the selected options value.
       * @type {Object||Array||String||Integer}
       */
    modelValue: {
      type: null,
      default() {
        return [];
      }
    },
    /**
       * String to show when pointing to an option
       * @default 'Press enter to select'
       * @type {String}
       */
    selectLabel: {
      type: String,
      default: "Press enter to select"
    },
    /**
       * String to show when pointing to an option
       * @default 'Press enter to select'
       * @type {String}
       */
    selectGroupLabel: {
      type: String,
      default: "Press enter to select group"
    },
    /**
       * String to show next to selected option
       * @default 'Selected'
       * @type {String}
       */
    selectedLabel: {
      type: String,
      default: "Selected"
    },
    /**
       * String to show when pointing to an already selected option
       * @default 'Press enter to remove'
       * @type {String}
       */
    deselectLabel: {
      type: String,
      default: "Press enter to remove"
    },
    /**
       * String to show when pointing to an already selected option
       * @default 'Press enter to remove'
       * @type {String}
       */
    deselectGroupLabel: {
      type: String,
      default: "Press enter to deselect group"
    },
    /**
       * Decide whether to show pointer labels
       * @default true
       * @type {Boolean}
       */
    showLabels: {
      type: Boolean,
      default: !0
    },
    /**
       * Limit the display of selected options. The rest will be hidden within the limitText string.
       * @default 99999
       * @type {Integer}
       */
    limit: {
      type: Number,
      default: 99999
    },
    /**
       * Sets maxHeight style value of the dropdown
       * @default 300
       * @type {Integer}
       */
    maxHeight: {
      type: Number,
      default: 300
    },
    /**
       * Function that process the message shown when selected
       * elements pass the defined limit.
       * @default 'and * more'
       * @param {Int} count Number of elements more than limit
       * @type {Function}
       */
    limitText: {
      type: Function,
      default: (v) => `and ${v} more`
    },
    /**
       * Set true to trigger the loading spinner.
       * @default False
       * @type {Boolean}
       */
    loading: {
      type: Boolean,
      default: !1
    },
    /**
       * Disables the multiselect if true.
       * @default false
       * @type {Boolean}
       */
    disabled: {
      type: Boolean,
      default: !1
    },
    /**
     * Enables search input's spellcheck if true.
     * @default false
     * @type {Boolean}
     */
    spellcheck: {
      type: Boolean,
      default: !1
    },
    /**
       * Fixed opening direction
       * @default ''
       * @type {String}
       */
    openDirection: {
      type: String,
      default: ""
    },
    /**
       * Shows slot with message about empty options
       * @default true
       * @type {Boolean}
       */
    showNoOptions: {
      type: Boolean,
      default: !0
    },
    showNoResults: {
      type: Boolean,
      default: !0
    },
    tabindex: {
      type: Number,
      default: 0
    },
    /**
     * Adds Required attribute to the input element when there is no value selected
     * @default false
     * @type {Boolean}
     */
    required: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    hasOptionGroup() {
      return this.groupValues && this.groupLabel && this.groupSelect;
    },
    isSingleLabelVisible() {
      return (this.singleValue || this.singleValue === 0) && (!this.isOpen || !this.searchable) && !this.visibleValues.length;
    },
    isPlaceholderVisible() {
      return !this.internalValue.length && (!this.searchable || !this.isOpen);
    },
    visibleValues() {
      return this.multiple ? this.internalValue.slice(0, this.limit) : [];
    },
    singleValue() {
      return this.internalValue[0];
    },
    deselectLabelText() {
      return this.showLabels ? this.deselectLabel : "";
    },
    deselectGroupLabelText() {
      return this.showLabels ? this.deselectGroupLabel : "";
    },
    selectLabelText() {
      return this.showLabels ? this.selectLabel : "";
    },
    selectGroupLabelText() {
      return this.showLabels ? this.selectGroupLabel : "";
    },
    selectedLabelText() {
      return this.showLabels ? this.selectedLabel : "";
    },
    inputStyle() {
      return this.searchable || this.multiple && this.modelValue && this.modelValue.length ? this.isOpen ? { width: "100%" } : { width: "0", position: "absolute", padding: "0" } : "";
    },
    contentStyle() {
      return this.options.length ? { display: "inline-block" } : { display: "block" };
    },
    isAbove() {
      return this.openDirection === "above" || this.openDirection === "top" ? !0 : this.openDirection === "below" || this.openDirection === "bottom" ? !1 : this.preferredOpenDirection === "above";
    },
    showSearchInput() {
      return this.searchable && (this.hasSingleSelectedSlot && (this.visibleSingleValue || this.visibleSingleValue === 0) ? this.isOpen : !0);
    },
    isRequired() {
      return this.required === !1 ? !1 : this.internalValue.length <= 0;
    }
  }
};
const eG = ["tabindex", "aria-expanded", "aria-owns", "aria-activedescendant"], tG = {
  ref: "tags",
  class: "multiselect__tags"
}, nG = { class: "multiselect__tags-wrap" }, oG = ["textContent"], rG = ["onKeypress", "onMousedown"], sG = ["textContent"], aG = { class: "multiselect__spinner" }, iG = ["name", "id", "spellcheck", "placeholder", "required", "value", "disabled", "tabindex", "aria-label", "aria-controls"], lG = ["id", "aria-multiselectable"], cG = { key: 0 }, uG = { class: "multiselect__option" }, dG = ["aria-selected", "id", "role"], fG = ["onClick", "onMouseenter", "data-select", "data-selected", "data-deselect"], mG = ["data-select", "data-deselect", "onMouseenter", "onMousedown"], pG = { class: "multiselect__option" }, gG = { class: "multiselect__option" };
function hG(v, L, N, W, ue, ce) {
  return kn(), no("div", {
    tabindex: v.searchable ? -1 : N.tabindex,
    class: tc([{ "multiselect--active": v.isOpen, "multiselect--disabled": N.disabled, "multiselect--above": ce.isAbove, "multiselect--has-options-group": ce.hasOptionGroup }, "multiselect"]),
    onFocus: L[14] || (L[14] = (he) => v.activate()),
    onBlur: L[15] || (L[15] = (he) => v.searchable ? !1 : v.deactivate()),
    onKeydown: [
      L[16] || (L[16] = Ty(vc((he) => v.pointerForward(), ["self", "prevent"]), ["down"])),
      L[17] || (L[17] = Ty(vc((he) => v.pointerBackward(), ["self", "prevent"]), ["up"]))
    ],
    onKeypress: L[18] || (L[18] = Ty(vc((he) => v.addPointerElement(he), ["stop", "self"]), ["enter", "tab"])),
    onKeyup: L[19] || (L[19] = Ty((he) => v.deactivate(), ["esc"])),
    role: "combobox",
    "aria-expanded": v.isOpen,
    "aria-owns": "listbox-" + v.id,
    "aria-activedescendant": v.isOpen && v.pointer !== null ? v.id + "-" + v.pointer : null
  }, [
    kl(v.$slots, "caret", { toggle: v.toggle }, () => [
      Co(
        "div",
        {
          onMousedown: L[0] || (L[0] = vc((he) => v.toggle(), ["prevent", "stop"])),
          class: "multiselect__select"
        },
        null,
        32
        /* NEED_HYDRATION */
      )
    ]),
    kl(v.$slots, "clear", { search: v.search }),
    Co(
      "div",
      tG,
      [
        kl(v.$slots, "selection", {
          search: v.search,
          remove: v.removeElement,
          values: ce.visibleValues,
          isOpen: v.isOpen
        }, () => [
          G1(Co(
            "div",
            nG,
            [
              (kn(!0), no(
                th,
                null,
                Oy(ce.visibleValues, (he, pe) => kl(v.$slots, "tag", {
                  option: he,
                  search: v.search,
                  remove: v.removeElement
                }, () => [
                  (kn(), no(
                    "span",
                    {
                      class: "multiselect__tag",
                      key: pe,
                      onMousedown: L[1] || (L[1] = vc(() => {
                      }, ["prevent"]))
                    },
                    [
                      Co("span", {
                        textContent: ji(v.getOptionLabel(he))
                      }, null, 8, oG),
                      Co("i", {
                        tabindex: "1",
                        onKeypress: Ty(vc((Me) => v.removeElement(he), ["prevent"]), ["enter"]),
                        onMousedown: vc((Me) => v.removeElement(he), ["prevent"]),
                        class: "multiselect__tag-icon"
                      }, null, 40, rG)
                    ],
                    32
                    /* NEED_HYDRATION */
                  ))
                ])),
                256
                /* UNKEYED_FRAGMENT */
              ))
            ],
            512
            /* NEED_PATCH */
          ), [
            [K2, ce.visibleValues.length > 0]
          ]),
          v.internalValue && v.internalValue.length > N.limit ? kl(v.$slots, "limit", { key: 0 }, () => [
            Co("strong", {
              class: "multiselect__strong",
              textContent: ji(N.limitText(v.internalValue.length - N.limit))
            }, null, 8, sG)
          ]) : Ks("v-if", !0)
        ]),
        Qf(MF, { name: "multiselect__loading" }, {
          default: bf(() => [
            kl(v.$slots, "loading", {}, () => [
              G1(Co(
                "div",
                aG,
                null,
                512
                /* NEED_PATCH */
              ), [
                [K2, N.loading]
              ])
            ])
          ]),
          _: 3
          /* FORWARDED */
        }),
        v.searchable ? (kn(), no("input", {
          key: 0,
          ref: "search",
          name: N.name,
          id: v.id,
          type: "text",
          autocomplete: "off",
          spellcheck: N.spellcheck,
          placeholder: v.placeholder,
          required: ce.isRequired,
          style: Y2(ce.inputStyle),
          value: v.search,
          disabled: N.disabled,
          tabindex: N.tabindex,
          "aria-label": N.name + "-searchbox",
          onInput: L[2] || (L[2] = (he) => v.updateSearch(he.target.value)),
          onFocus: L[3] || (L[3] = vc((he) => v.activate(), ["prevent"])),
          onBlur: L[4] || (L[4] = vc((he) => v.deactivate(), ["prevent"])),
          onKeyup: L[5] || (L[5] = Ty((he) => v.deactivate(), ["esc"])),
          onKeydown: [
            L[6] || (L[6] = Ty(vc((he) => v.pointerForward(), ["prevent"]), ["down"])),
            L[7] || (L[7] = Ty(vc((he) => v.pointerBackward(), ["prevent"]), ["up"])),
            L[9] || (L[9] = Ty(vc((he) => v.removeLastElement(), ["stop"]), ["delete"]))
          ],
          onKeypress: L[8] || (L[8] = Ty(vc((he) => v.addPointerElement(he), ["prevent", "stop", "self"]), ["enter"])),
          class: "multiselect__input",
          "aria-controls": "listbox-" + v.id
        }, null, 44, iG)) : Ks("v-if", !0),
        ce.isSingleLabelVisible ? (kn(), no(
          "span",
          {
            key: 1,
            class: "multiselect__single",
            onMousedown: L[10] || (L[10] = vc((...he) => v.toggle && v.toggle(...he), ["prevent"]))
          },
          [
            kl(v.$slots, "singleLabel", { option: ce.singleValue }, () => [
              Bm(
                ji(v.currentOptionLabel),
                1
                /* TEXT */
              )
            ])
          ],
          32
          /* NEED_HYDRATION */
        )) : Ks("v-if", !0),
        ce.isPlaceholderVisible ? (kn(), no(
          "span",
          {
            key: 2,
            class: "multiselect__placeholder",
            onMousedown: L[11] || (L[11] = vc((...he) => v.toggle && v.toggle(...he), ["prevent"]))
          },
          [
            kl(v.$slots, "placeholder", {}, () => [
              Bm(
                ji(v.placeholder),
                1
                /* TEXT */
              )
            ])
          ],
          32
          /* NEED_HYDRATION */
        )) : Ks("v-if", !0)
      ],
      512
      /* NEED_PATCH */
    ),
    Qf(MF, {
      name: "multiselect",
      persisted: ""
    }, {
      default: bf(() => [
        G1(Co(
          "div",
          {
            class: "multiselect__content-wrapper",
            onFocus: L[12] || (L[12] = (...he) => v.activate && v.activate(...he)),
            tabindex: "-1",
            onMousedown: L[13] || (L[13] = vc(() => {
            }, ["prevent"])),
            style: Y2({ maxHeight: v.optimizedHeight + "px" }),
            ref: "list"
          },
          [
            Co("ul", {
              class: "multiselect__content",
              style: Y2(ce.contentStyle),
              role: "listbox",
              id: "listbox-" + v.id,
              "aria-multiselectable": v.multiple
            }, [
              kl(v.$slots, "beforeList"),
              v.multiple && v.max === v.internalValue.length ? (kn(), no("li", cG, [
                Co("span", uG, [
                  kl(v.$slots, "maxElements", {}, () => [
                    Bm(
                      "Maximum of " + ji(v.max) + " options selected. First remove a selected option to select another.",
                      1
                      /* TEXT */
                    )
                  ])
                ])
              ])) : Ks("v-if", !0),
              !v.max || v.internalValue.length < v.max ? (kn(!0), no(
                th,
                { key: 1 },
                Oy(v.filteredOptions, (he, pe) => (kn(), no("li", {
                  class: "multiselect__element",
                  key: pe,
                  "aria-selected": v.isSelected(he),
                  id: v.id + "-" + pe,
                  role: he && (he.$isLabel || he.$isDisabled) ? null : "option"
                }, [
                  he && (he.$isLabel || he.$isDisabled) ? Ks("v-if", !0) : (kn(), no("span", {
                    key: 0,
                    class: tc([v.optionHighlight(pe, he), "multiselect__option"]),
                    onClick: vc((Me) => v.select(he), ["stop"]),
                    onMouseenter: vc((Me) => v.pointerSet(pe), ["self"]),
                    "data-select": he && he.isTag ? v.tagPlaceholder : ce.selectLabelText,
                    "data-selected": ce.selectedLabelText,
                    "data-deselect": ce.deselectLabelText
                  }, [
                    kl(v.$slots, "option", {
                      option: he,
                      search: v.search,
                      index: pe
                    }, () => [
                      Co(
                        "span",
                        null,
                        ji(v.getOptionLabel(he)),
                        1
                        /* TEXT */
                      )
                    ])
                  ], 42, fG)),
                  he && (he.$isLabel || he.$isDisabled) ? (kn(), no("span", {
                    key: 1,
                    "data-select": v.groupSelect && ce.selectGroupLabelText,
                    "data-deselect": v.groupSelect && ce.deselectGroupLabelText,
                    class: tc([v.groupHighlight(pe, he), "multiselect__option"]),
                    onMouseenter: vc((Me) => v.groupSelect && v.pointerSet(pe), ["self"]),
                    onMousedown: vc((Me) => v.selectGroup(he), ["prevent"])
                  }, [
                    kl(v.$slots, "option", {
                      option: he,
                      search: v.search,
                      index: pe
                    }, () => [
                      Co(
                        "span",
                        null,
                        ji(v.getOptionLabel(he)),
                        1
                        /* TEXT */
                      )
                    ])
                  ], 42, mG)) : Ks("v-if", !0)
                ], 8, dG))),
                128
                /* KEYED_FRAGMENT */
              )) : Ks("v-if", !0),
              G1(Co(
                "li",
                null,
                [
                  Co("span", pG, [
                    kl(v.$slots, "noResult", { search: v.search }, () => [
                      L[20] || (L[20] = Bm("No elements found. Consider changing the search query."))
                    ])
                  ])
                ],
                512
                /* NEED_PATCH */
              ), [
                [K2, N.showNoResults && v.filteredOptions.length === 0 && v.search && !N.loading]
              ]),
              G1(Co(
                "li",
                null,
                [
                  Co("span", gG, [
                    kl(v.$slots, "noOptions", {}, () => [
                      L[21] || (L[21] = Bm("List is empty."))
                    ])
                  ])
                ],
                512
                /* NEED_PATCH */
              ), [
                [K2, N.showNoOptions && (v.options.length === 0 || ce.hasOptionGroup === !0 && v.filteredOptions.length === 0) && !v.search && !N.loading]
              ]),
              kl(v.$slots, "afterList")
            ], 12, lG)
          ],
          36
          /* STYLE, NEED_HYDRATION */
        ), [
          [K2, v.isOpen]
        ])
      ]),
      _: 3
      /* FORWARDED */
    })
  ], 42, eG);
}
yT.render = hG;
const bG = { class: "field-select" }, GF = {
  __name: "FieldSelect",
  props: {
    modelValue: {},
    multiple: {
      type: Boolean,
      default() {
        return !1;
      }
    },
    options: {
      default() {
        return [];
      }
    },
    field: {
      default() {
        return "id";
      }
    },
    label: {
      default() {
        return "name";
      }
    },
    placeholder: {
      default() {
        return "Select";
      }
    },
    disabled: {
      default() {
        return !1;
      }
    },
    loading: {
      default() {
        return !1;
      }
    }
  },
  emits: ["update:modelValue", "searchChange"],
  setup(v, { emit: L }) {
    const N = L, W = v, ue = Jr(ce(W.modelValue));
    function ce(pe) {
      if (W.multiple) {
        const Me = Array.isArray(pe) ? pe[0] && pe[0].hasOwnProperty(W.field) ? pe.map((Ze) => Ze[W.field]) : pe : [pe];
        return W.options.filter((Ze) => Me.indexOf(Ze[W.field]) > -1);
      }
      return W.options.find((Me) => Me[W.field] == pe);
    }
    function he(pe, Me) {
      return W.multiple ? JSON.stringify(pe.map((Ze) => Ze[W.field]).sort()) == JSON.stringify((Array.isArray(Me) ? Me[0] && Me[0].hasOwnProperty(W.field) ? Me.map((Ze) => Ze[W.field]) : Me : [Me]).sort()) : pe && Me == pe[W.field];
    }
    return Od(ue, (pe) => {
      if (!he(pe, W.modelValue)) {
        const Me = pe ? W.multiple ? pe.map((Ze) => Ze[W.field]) : pe[W.field] : null;
        N("update:modelValue", Me);
      }
    }), Od(() => W.modelValue, (pe) => {
      he(ue.value, pe) || (ue.value = ce(pe));
    }), Od(() => W.options, () => {
      (!ue.value || !ue.value.length) && (ue.value = ce(W.modelValue));
    }), (pe, Me) => (kn(), no("div", bG, [
      Qf(ng(yT), {
        modelValue: ue.value,
        "onUpdate:modelValue": Me[0] || (Me[0] = (Ze) => ue.value = Ze),
        options: v.options,
        label: v.label,
        "track-by": v.field,
        placeholder: v.placeholder,
        multiple: v.multiple,
        "show-labels": !1,
        disabled: v.disabled,
        loading: v.loading,
        "show-no-options": !1,
        onSearchChange: Me[1] || (Me[1] = (Ze) => N("searchChange", Ze))
      }, {
        singleLabel: bf(({ option: Ze }) => [
          kl(pe.$slots, "selectedOption", { option: Ze })
        ]),
        option: bf(({ option: Ze }) => [
          kl(pe.$slots, "option", { option: Ze })
        ]),
        noResult: bf(() => Me[2] || (Me[2] = [
          Bm("No Results Found")
        ])),
        _: 3
      }, 8, ["modelValue", "options", "label", "track-by", "placeholder", "multiple", "disabled", "loading"])
    ]));
  }
}, yG = {
  __name: "AsyncSelect",
  props: {
    modelValue: {},
    url: {
      type: String,
      required: !0
    },
    id: {
      type: String,
      default() {
        return Math.random().toString(36).slice(2);
      }
    },
    multiple: {
      type: Boolean,
      default() {
        return !1;
      }
    },
    field: {
      type: String
    },
    label: {
      type: String,
      required: !0
    },
    searchColumns: {
      type: Array,
      default() {
        return [];
      }
    },
    filters: {
      type: Array
    },
    relations: {
      type: Array
    },
    limit: {
      type: Number,
      default: 50
    },
    preload: {
      type: Boolean,
      default: !1
    },
    placeholder: {
      default() {
        return "Select";
      }
    },
    disabled: {
      default() {
        return !1;
      }
    }
  },
  emits: ["update:modelValue"],
  setup(v, { emit: L }) {
    const N = v, W = Jr(N.modelValue);
    Od(() => N.modelValue, (Me) => {
      W.value = Me;
    });
    const ue = Jr([]), ce = Jr(!1);
    Ad(() => {
      let Me = [];
      if (N.modelValue) {
        const Ze = N.field ?? "id";
        let Ye = N.modelValue.hasOwnProperty(Ze) ? N.modelValue[Ze] : N.modelValue;
        Ye = Array.isArray(Ye) && Ye[0] && Ye[0].hasOwnProperty(N.field) ? Ye.map((jt) => jt[N.field]) : Ye;
        const yt = N.multiple && Array.isArray(Ye) ? "in" : "=";
        Ye && Me.push({ column: Ze, operator: yt, value: Ye });
      }
      N.preload && Me.push({ logic: Me.length ? "or" : "and", column: N.field ?? "id", operator: "!=", value: 0 }), Me.length && pe(Me);
    });
    function he(Me) {
      var Ze;
      if (Me && Me !== "" && Me.length > 3) {
        const Ye = [
          ...((Ze = N.filters) == null ? void 0 : Ze.map((yt) => (yt.hasOwnProperty("value") || (yt.value = Me), yt))) ?? [],
          ...N.searchColumns.length ? [{ rawColumn: N.searchColumns.join(" || ' ' || "), operator: "contains", value: Me }] : [{ column: N.field ?? N.label, operator: "contains", value: Me }]
        ];
        pe(Ye);
      }
    }
    function pe(Me) {
      ce.value = !0, axios.post(N.url, {
        search: Me,
        relations: N.relations,
        limit: N.limit
      }).then((Ze) => {
        Ze.data.success && Ze.data.records && (ue.value = Ze.data.records), ce.value = !1;
      });
    }
    return (Me, Ze) => v.field ? (kn(), Ju(GF, {
      key: 0,
      id: v.id,
      modelValue: W.value,
      "onUpdate:modelValue": [
        Ze[0] || (Ze[0] = (Ye) => W.value = Ye),
        Ze[1] || (Ze[1] = (Ye) => Me.$emit("update:modelValue", Ye))
      ],
      field: v.field,
      label: v.label,
      options: ue.value,
      multiple: v.multiple,
      placeholder: v.placeholder,
      disabled: v.disabled,
      loading: ce.value,
      onSearchChange: he
    }, null, 8, ["id", "modelValue", "field", "label", "options", "multiple", "placeholder", "disabled", "loading"])) : (kn(), Ju(ng(yT), {
      key: 1,
      id: v.id,
      modelValue: W.value,
      "onUpdate:modelValue": [
        Ze[2] || (Ze[2] = (Ye) => W.value = Ye),
        Ze[3] || (Ze[3] = (Ye) => Me.$emit("update:modelValue", Ye))
      ],
      label: v.label,
      options: ue.value,
      multiple: v.multiple,
      placeholder: v.placeholder,
      disabled: v.disabled,
      loading: ce.value,
      "show-no-options": !1,
      onSearchChange: he
    }, {
      noResult: bf(() => Ze[4] || (Ze[4] = [
        Bm("No Results Found")
      ])),
      _: 1
    }, 8, ["id", "modelValue", "label", "options", "multiple", "placeholder", "disabled", "loading"]));
  }
};
function z8(v) {
  return typeof v == "string" ? v.replaceAll(".", " ").replaceAll("_", " ").replace(/\w\S*/g, function(L) {
    return L.charAt(0).toUpperCase() + L.substring(1).toLowerCase();
  }) : "";
}
const vG = ["for"], xG = ["id", "value", "disabled"], wG = ["id", "value", "disabled"], kG = { class: "cursor-pointer ml-2 align-middle" }, _G = ["value", "disabled"], CG = ["disabled"], SG = ["value"], EG = {
  __name: "Select",
  props: {
    modelValue: {},
    id: {
      type: String,
      default() {
        return Math.random().toString(36).slice(2);
      }
    },
    type: {
      type: String
    },
    multiple: {
      type: Boolean,
      default() {
        return !1;
      }
    },
    url: {
      type: String
    },
    options: {
      type: Array,
      default() {
        return [];
      }
    },
    field: {
      type: String
    },
    label: {
      type: String
    },
    listItemClass: {
      type: String
    },
    filters: {
      type: Array
    },
    searchColumns: {
      type: Array
    },
    limit: {
      type: Number
    },
    preload: {
      type: Boolean,
      default: !1
    },
    placeholder: {
      default() {
        return "Select";
      }
    },
    disabled: {
      default() {
        return !1;
      }
    },
    required: {},
    titleCaseOptions: {
      default() {
        return !1;
      }
    }
  },
  emits: ["update:modelValue"],
  setup(v, { emit: L }) {
    const N = L, W = v, ue = Jr(Array.isArray(W.modelValue) ? W.modelValue : []);
    Od(ue, (Ze) => {
      N("update:modelValue", Ze);
    });
    const ce = Jr(W.modelValue);
    Od(() => W.modelValue, (Ze) => {
      ce.value = Ze;
    });
    const he = Qo(() => W.options ? W.options.filter((Ze) => !!Ze) : []), pe = Qo(() => typeof he.value[0] && typeof he.value[0] == "object" && he.value[0].hasOwnProperty(W.field ?? "id") && he.value[0].hasOwnProperty(W.label ?? "name"));
    function Me(Ze) {
      return typeof Ze == "string" && W.titleCaseOptions ? z8(Ze) : Ze;
    }
    return (Ze, Ye) => v.type === "list" ? (kn(!0), no(th, { key: 0 }, Oy(he.value, (yt, jt) => (kn(), no("label", {
      for: v.id + "_list_item_" + jt,
      class: tc([v.multiple ? "checkbox-label" : "radio-label", { disabled: v.disabled }, v.listItemClass])
    }, [
      v.multiple ? G1((kn(), no("input", {
        key: 0,
        id: v.id + "_list_item_" + jt,
        class: "input-checkbox",
        type: "checkbox",
        value: pe.value ? yt[v.field ?? "id"] : yt,
        disabled: v.disabled,
        "onUpdate:modelValue": Ye[0] || (Ye[0] = (it) => ue.value = it)
      }, null, 8, xG)), [
        [qF, ue.value]
      ]) : G1((kn(), no("input", {
        key: 1,
        id: v.id + "_list_item_" + jt,
        class: "input-radio",
        type: "radio",
        value: pe.value ? yt[v.field ?? "id"] : yt,
        disabled: v.disabled,
        "onUpdate:modelValue": Ye[1] || (Ye[1] = (it) => ce.value = it),
        onChange: Ye[2] || (Ye[2] = (it) => Ze.$emit("update:modelValue", it.target.value))
      }, null, 40, wG)), [
        [Mq, ce.value]
      ]),
      Co("span", kG, ji(pe.value ? yt[v.label ?? "name"] : Me(yt)), 1)
    ], 10, vG))), 256)) : v.type === "async" ? (kn(), Ju(yG, {
      key: 1,
      url: v.url,
      modelValue: ce.value,
      "onUpdate:modelValue": [
        Ye[3] || (Ye[3] = (yt) => ce.value = yt),
        Ye[4] || (Ye[4] = (yt) => Ze.$emit("update:modelValue", yt))
      ],
      multiple: v.multiple,
      field: v.field,
      label: v.label,
      filters: v.filters,
      "search-columns": v.searchColumns,
      limit: v.limit,
      preload: v.preload,
      placeholder: v.placeholder,
      disabled: v.disabled
    }, null, 8, ["url", "modelValue", "multiple", "field", "label", "filters", "search-columns", "limit", "preload", "placeholder", "disabled"])) : pe.value ? (kn(), Ju(GF, {
      key: 2,
      modelValue: ce.value,
      "onUpdate:modelValue": [
        Ye[5] || (Ye[5] = (yt) => ce.value = yt),
        Ye[6] || (Ye[6] = (yt) => Ze.$emit("update:modelValue", yt))
      ],
      multiple: v.multiple,
      field: v.field,
      label: v.label,
      options: he.value,
      placeholder: v.placeholder,
      disabled: v.disabled
    }, null, 8, ["modelValue", "multiple", "field", "label", "options", "placeholder", "disabled"])) : v.type === "basic" ? (kn(), no("select", {
      key: 3,
      class: "input-select",
      value: v.modelValue,
      disabled: v.disabled,
      onChange: Ye[7] || (Ye[7] = (yt) => Ze.$emit("update:modelValue", yt.target.value))
    }, [
      Co("option", {
        value: "",
        disabled: v.required === !0
      }, "select...", 8, CG),
      (kn(!0), no(th, null, Oy(he.value, (yt) => (kn(), no("option", { value: yt }, ji(Me(yt)), 9, SG))), 256))
    ], 40, _G)) : (kn(), Ju(ng(yT), {
      key: 4,
      modelValue: ce.value,
      "onUpdate:modelValue": [
        Ye[8] || (Ye[8] = (yt) => ce.value = yt),
        Ye[9] || (Ye[9] = (yt) => Ze.$emit("update:modelValue", yt))
      ],
      options: he.value,
      placeholder: v.placeholder,
      multiple: v.multiple,
      "show-labels": !1,
      disabled: v.disabled
    }, null, 8, ["modelValue", "options", "placeholder", "multiple", "disabled"]));
  }
};
var fT = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function TG(v) {
  return v && v.__esModule && Object.prototype.hasOwnProperty.call(v, "default") ? v.default : v;
}
var F5 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
F5.exports;
(function(v, L) {
  (function() {
    var N, W = "4.17.21", ue = 200, ce = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", he = "Expected a function", pe = "Invalid `variable` option passed into `_.template`", Me = "__lodash_hash_undefined__", Ze = 500, Ye = "__lodash_placeholder__", yt = 1, jt = 2, it = 4, Rt = 1, en = 2, Gt = 1, gt = 2, an = 4, Ot = 8, Ee = 16, wt = 32, Se = 64, We = 128, Cn = 256, ko = 512, jn = 30, Xe = "...", un = 800, M = 16, Et = 1, ht = 2, mn = 3, lo = 1 / 0, dt = 9007199254740991, Bn = 17976931348623157e292, jr = 0 / 0, Tt = 4294967295, yo = Tt - 1, Ct = Tt >>> 1, tn = [
      ["ary", We],
      ["bind", Gt],
      ["bindKey", gt],
      ["curry", Ot],
      ["curryRight", Ee],
      ["flip", ko],
      ["partial", wt],
      ["partialRight", Se],
      ["rearg", Cn]
    ], oa = "[object Arguments]", Pn = "[object Array]", Mo = "[object AsyncFunction]", K = "[object Boolean]", Go = "[object Date]", Zi = "[object DOMException]", er = "[object Error]", Qr = "[object Function]", nc = "[object GeneratorFunction]", So = "[object Map]", cr = "[object Number]", oo = "[object Null]", ut = "[object Object]", kt = "[object Promise]", It = "[object Proxy]", ct = "[object RegExp]", xn = "[object Set]", co = "[object String]", Ko = "[object Symbol]", po = "[object Undefined]", Ra = "[object WeakMap]", Mr = "[object WeakSet]", ho = "[object ArrayBuffer]", Ns = "[object DataView]", Ca = "[object Float32Array]", Zr = "[object Float64Array]", $r = "[object Int8Array]", Po = "[object Int16Array]", ha = "[object Int32Array]", ro = "[object Uint8Array]", cn = "[object Uint8ClampedArray]", _n = "[object Uint16Array]", Ys = "[object Uint32Array]", Si = /\b__p \+= '';/g, Nt = /\b(__p \+=) '' \+/g, fi = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Zo = /&(?:amp|lt|gt|quot|#39);/g, mi = /[&<>"']/g, kr = RegExp(Zo.source), Qu = RegExp(mi.source), ba = /<%-([\s\S]+?)%>/g, xc = /<%([\s\S]+?)%>/g, _l = /<%=([\s\S]+?)%>/g, Wi = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, oc = /^\w*$/, Hr = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Yn = /[\\^$.*+?()[\]{}|]/g, qi = RegExp(Yn.source), Ei = /^\s+/, Cl = /\s/, Xc = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Xt = /\{\n\/\* \[wrapped with (.+)\] \*/, Dd = /,? & /, es = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, yf = /[()=,{}\[\]\/\s]/, Rd = /\\(\\)?/g, Ti = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, wc = /\w*$/, pi = /^[-+]0x[0-9a-f]+$/i, ra = /^0b[01]+$/i, Gi = /^\[object .+?Constructor\]$/, vf = /^0o[0-7]+$/i, rc = /^(?:0|[1-9]\d*)$/, tm = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Sl = /($^)/, Nd = /['\n\r\u2028\u2029\\]/g, tr = "\\ud800-\\udfff", Ms = "\\u0300-\\u036f", ni = "\\ufe20-\\ufe2f", Jc = "\\u20d0-\\u20ff", Md = Ms + ni + Jc, Bd = "\\u2700-\\u27bf", cl = "a-z\\xdf-\\xf6\\xf8-\\xff", sa = "\\xac\\xb1\\xd7\\xf7", nm = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", _r = "\\u2000-\\u206f", Dr = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", El = "A-Z\\xc0-\\xd6\\xd8-\\xde", ul = "\\ufe0e\\ufe0f", Lc = sa + nm + _r + Dr, kc = "['’]", gu = "[" + tr + "]", Na = "[" + Lc + "]", us = "[" + Md + "]", Ma = "\\d+", Us = "[" + Bd + "]", dl = "[" + cl + "]", Rr = "[^" + tr + Lc + Ma + Bd + cl + El + "]", Wa = "\\ud83c[\\udffb-\\udfff]", zi = "(?:" + us + "|" + Wa + ")", qa = "[^" + tr + "]", eo = "(?:\\ud83c[\\udde6-\\uddff]){2}", gi = "[\\ud800-\\udbff][\\udc00-\\udfff]", js = "[" + El + "]", Sa = "\\u200d", Ki = "(?:" + dl + "|" + Rr + ")", ts = "(?:" + js + "|" + Rr + ")", Bs = "(?:" + kc + "(?:d|ll|m|re|s|t|ve))?", sc = "(?:" + kc + "(?:D|LL|M|RE|S|T|VE))?", qn = zi + "?", ac = "[" + ul + "]?", Yi = "(?:" + Sa + "(?:" + [qa, eo, gi].join("|") + ")" + ac + qn + ")*", Ts = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", fl = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", Xs = ac + qn + Yi, hu = "(?:" + [Us, eo, gi].join("|") + ")" + Xs, xf = "(?:" + [qa + us + "?", us, eo, gi, gu].join("|") + ")", ar = RegExp(kc, "g"), te = RegExp(us, "g"), ze = RegExp(Wa + "(?=" + Wa + ")|" + xf + Xs, "g"), Pe = RegExp([
      js + "?" + dl + "+" + Bs + "(?=" + [Na, js, "$"].join("|") + ")",
      ts + "+" + sc + "(?=" + [Na, js + Ki, "$"].join("|") + ")",
      js + "?" + Ki + "+" + Bs,
      js + "+" + sc,
      fl,
      Ts,
      Ma,
      hu
    ].join("|"), "g"), Qe = RegExp("[" + Sa + tr + Md + ul + "]"), Ft = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, An = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], so = -1, Zn = {};
    Zn[Ca] = Zn[Zr] = Zn[$r] = Zn[Po] = Zn[ha] = Zn[ro] = Zn[cn] = Zn[_n] = Zn[Ys] = !0, Zn[oa] = Zn[Pn] = Zn[ho] = Zn[K] = Zn[Ns] = Zn[Go] = Zn[er] = Zn[Qr] = Zn[So] = Zn[cr] = Zn[ut] = Zn[ct] = Zn[xn] = Zn[co] = Zn[Ra] = !1;
    var $n = {};
    $n[oa] = $n[Pn] = $n[ho] = $n[Ns] = $n[K] = $n[Go] = $n[Ca] = $n[Zr] = $n[$r] = $n[Po] = $n[ha] = $n[So] = $n[cr] = $n[ut] = $n[ct] = $n[xn] = $n[co] = $n[Ko] = $n[ro] = $n[cn] = $n[_n] = $n[Ys] = !0, $n[er] = $n[Qr] = $n[Ra] = !1;
    var ds = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, Cr = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, Wr = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, Ba = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, ml = parseFloat, nr = parseInt, wf = typeof fT == "object" && fT && fT.Object === Object && fT, Qc = typeof self == "object" && self && self.Object === Object && self, Ga = wf || Qc || Function("return this")(), Ld = L && !L.nodeType && L, aa = Ld && !0 && v && !v.nodeType && v, sg = aa && aa.exports === Ld, oi = sg && wf.process, $l = function() {
      try {
        var Le = aa && aa.require && aa.require("util").types;
        return Le || oi && oi.binding && oi.binding("util");
      } catch {
      }
    }(), kp = $l && $l.isArrayBuffer, oh = $l && $l.isDate, Ht = $l && $l.isMap, Pd = $l && $l.isRegExp, _p = $l && $l.isSet, ed = $l && $l.isTypedArray;
    function ns(Le, Dt, vt) {
      switch (vt.length) {
        case 0:
          return Le.call(Dt);
        case 1:
          return Le.call(Dt, vt[0]);
        case 2:
          return Le.call(Dt, vt[0], vt[1]);
        case 3:
          return Le.call(Dt, vt[0], vt[1], vt[2]);
      }
      return Le.apply(Dt, vt);
    }
    function ag(Le, Dt, vt, Sn) {
      for (var Fo = -1, ur = Le == null ? 0 : Le.length; ++Fo < ur; ) {
        var Br = Le[Fo];
        Dt(Sn, Br, vt(Br), Le);
      }
      return Sn;
    }
    function Xi(Le, Dt) {
      for (var vt = -1, Sn = Le == null ? 0 : Le.length; ++vt < Sn && Dt(Le[vt], vt, Le) !== !1; )
        ;
      return Le;
    }
    function Id(Le, Dt) {
      for (var vt = Le == null ? 0 : Le.length; vt-- && Dt(Le[vt], vt, Le) !== !1; )
        ;
      return Le;
    }
    function Cp(Le, Dt) {
      for (var vt = -1, Sn = Le == null ? 0 : Le.length; ++vt < Sn; )
        if (!Dt(Le[vt], vt, Le))
          return !1;
      return !0;
    }
    function Pc(Le, Dt) {
      for (var vt = -1, Sn = Le == null ? 0 : Le.length, Fo = 0, ur = []; ++vt < Sn; ) {
        var Br = Le[vt];
        Dt(Br, vt, Le) && (ur[Fo++] = Br);
      }
      return ur;
    }
    function bu(Le, Dt) {
      var vt = Le == null ? 0 : Le.length;
      return !!vt && ia(Le, Dt, 0) > -1;
    }
    function rh(Le, Dt, vt) {
      for (var Sn = -1, Fo = Le == null ? 0 : Le.length; ++Sn < Fo; )
        if (vt(Dt, Le[Sn]))
          return !0;
      return !1;
    }
    function Ea(Le, Dt) {
      for (var vt = -1, Sn = Le == null ? 0 : Le.length, Fo = Array(Sn); ++vt < Sn; )
        Fo[vt] = Dt(Le[vt], vt, Le);
      return Fo;
    }
    function yu(Le, Dt) {
      for (var vt = -1, Sn = Dt.length, Fo = Le.length; ++vt < Sn; )
        Le[Fo + vt] = Dt[vt];
      return Le;
    }
    function ig(Le, Dt, vt, Sn) {
      var Fo = -1, ur = Le == null ? 0 : Le.length;
      for (Sn && ur && (vt = Le[++Fo]); ++Fo < ur; )
        vt = Dt(vt, Le[Fo], Fo, Le);
      return vt;
    }
    function eu(Le, Dt, vt, Sn) {
      var Fo = Le == null ? 0 : Le.length;
      for (Sn && Fo && (vt = Le[--Fo]); Fo--; )
        vt = Dt(vt, Le[Fo], Fo, Le);
      return vt;
    }
    function om(Le, Dt) {
      for (var vt = -1, Sn = Le == null ? 0 : Le.length; ++vt < Sn; )
        if (Dt(Le[vt], vt, Le))
          return !0;
      return !1;
    }
    var kf = Zs("length");
    function _c(Le) {
      return Le.split("");
    }
    function Ic(Le) {
      return Le.match(es) || [];
    }
    function Eo(Le, Dt, vt) {
      var Sn;
      return vt(Le, function(Fo, ur, Br) {
        if (Dt(Fo, ur, Br))
          return Sn = ur, !1;
      }), Sn;
    }
    function Fd(Le, Dt, vt, Sn) {
      for (var Fo = Le.length, ur = vt + (Sn ? 1 : -1); Sn ? ur-- : ++ur < Fo; )
        if (Dt(Le[ur], ur, Le))
          return ur;
      return -1;
    }
    function ia(Le, Dt, vt) {
      return Dt === Dt ? xu(Le, Dt, vt) : Fd(Le, $d, vt);
    }
    function td(Le, Dt, vt, Sn) {
      for (var Fo = vt - 1, ur = Le.length; ++Fo < ur; )
        if (Sn(Le[Fo], Dt))
          return Fo;
      return -1;
    }
    function $d(Le) {
      return Le !== Le;
    }
    function Ji(Le, Dt) {
      var vt = Le == null ? 0 : Le.length;
      return vt ? Ls(Le, Dt) / vt : jr;
    }
    function Zs(Le) {
      return function(Dt) {
        return Dt == null ? N : Dt[Le];
      };
    }
    function nd(Le) {
      return function(Dt) {
        return Le == null ? N : Le[Dt];
      };
    }
    function rm(Le, Dt, vt, Sn, Fo) {
      return Fo(Le, function(ur, Br, Lr) {
        vt = Sn ? (Sn = !1, ur) : Dt(vt, ur, Br, Lr);
      }), vt;
    }
    function ya(Le, Dt) {
      var vt = Le.length;
      for (Le.sort(Dt); vt--; )
        Le[vt] = Le[vt].value;
      return Le;
    }
    function Ls(Le, Dt) {
      for (var vt, Sn = -1, Fo = Le.length; ++Sn < Fo; ) {
        var ur = Dt(Le[Sn]);
        ur !== N && (vt = vt === N ? ur : vt + ur);
      }
      return vt;
    }
    function Vr(Le, Dt) {
      for (var vt = -1, Sn = Array(Le); ++vt < Le; )
        Sn[vt] = Dt(vt);
      return Sn;
    }
    function zs(Le, Dt) {
      return Ea(Dt, function(vt) {
        return [vt, Le[vt]];
      });
    }
    function Qi(Le) {
      return Le && Le.slice(0, Sp(Le) + 1).replace(Ei, "");
    }
    function Js(Le) {
      return function(Dt) {
        return Le(Dt);
      };
    }
    function La(Le, Dt) {
      return Ea(Dt, function(vt) {
        return Le[vt];
      });
    }
    function xs(Le, Dt) {
      return Le.has(Dt);
    }
    function Hd(Le, Dt) {
      for (var vt = -1, Sn = Le.length; ++vt < Sn && ia(Dt, Le[vt], 0) > -1; )
        ;
      return vt;
    }
    function Ws(Le, Dt) {
      for (var vt = Le.length; vt-- && ia(Dt, Le[vt], 0) > -1; )
        ;
      return vt;
    }
    function va(Le, Dt) {
      for (var vt = Le.length, Sn = 0; vt--; )
        Le[vt] === Dt && ++Sn;
      return Sn;
    }
    var la = nd(ds), od = nd(Cr);
    function os(Le) {
      return "\\" + Ba[Le];
    }
    function sm(Le, Dt) {
      return Le == null ? N : Le[Dt];
    }
    function vu(Le) {
      return Qe.test(Le);
    }
    function Cc(Le) {
      return Ft.test(Le);
    }
    function To(Le) {
      for (var Dt, vt = []; !(Dt = Le.next()).done; )
        vt.push(Dt.value);
      return vt;
    }
    function ca(Le) {
      var Dt = -1, vt = Array(Le.size);
      return Le.forEach(function(Sn, Fo) {
        vt[++Dt] = [Fo, Sn];
      }), vt;
    }
    function rd(Le, Dt) {
      return function(vt) {
        return Le(Dt(vt));
      };
    }
    function Oi(Le, Dt) {
      for (var vt = -1, Sn = Le.length, Fo = 0, ur = []; ++vt < Sn; ) {
        var Br = Le[vt];
        (Br === Dt || Br === Ye) && (Le[vt] = Ye, ur[Fo++] = vt);
      }
      return ur;
    }
    function Vd(Le) {
      var Dt = -1, vt = Array(Le.size);
      return Le.forEach(function(Sn) {
        vt[++Dt] = Sn;
      }), vt;
    }
    function Fc(Le) {
      var Dt = -1, vt = Array(Le.size);
      return Le.forEach(function(Sn) {
        vt[++Dt] = [Sn, Sn];
      }), vt;
    }
    function xu(Le, Dt, vt) {
      for (var Sn = vt - 1, Fo = Le.length; ++Sn < Fo; )
        if (Le[Sn] === Dt)
          return Sn;
      return -1;
    }
    function lg(Le, Dt, vt) {
      for (var Sn = vt + 1; Sn--; )
        if (Le[Sn] === Dt)
          return Sn;
      return Sn;
    }
    function wu(Le) {
      return vu(Le) ? Sc(Le) : kf(Le);
    }
    function ri(Le) {
      return vu(Le) ? Ai(Le) : _c(Le);
    }
    function Sp(Le) {
      for (var Dt = Le.length; Dt-- && Cl.test(Le.charAt(Dt)); )
        ;
      return Dt;
    }
    var be = nd(Wr);
    function Sc(Le) {
      for (var Dt = ze.lastIndex = 0; ze.test(Le); )
        ++Dt;
      return Dt;
    }
    function Ai(Le) {
      return Le.match(ze) || [];
    }
    function tu(Le) {
      return Le.match(Pe) || [];
    }
    var _f = function Le(Dt) {
      Dt = Dt == null ? Ga : sd.defaults(Ga.Object(), Dt, sd.pick(Ga, An));
      var vt = Dt.Array, Sn = Dt.Date, Fo = Dt.Error, ur = Dt.Function, Br = Dt.Math, Lr = Dt.Object, hi = Dt.RegExp, Nn = Dt.String, Ps = Dt.TypeError, Di = vt.prototype, cg = ur.prototype, Ec = Lr.prototype, Pr = Dt["__core-js_shared__"], Tc = cg.toString, qr = Ec.hasOwnProperty, xa = 0, $c = function() {
        var u = /[^.]+$/.exec(Pr && Pr.keys && Pr.keys.IE_PROTO || "");
        return u ? "Symbol(src)_1." + u : "";
      }(), Ud = Ec.toString, am = Tc.call(Lr), Ep = Ga._, ku = hi(
        "^" + Tc.call(qr).replace(Yn, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Tl = sg ? Dt.Buffer : N, pl = Dt.Symbol, Gr = Dt.Uint8Array, ic = Tl ? Tl.allocUnsafe : N, Ta = rd(Lr.getPrototypeOf, Lr), nu = Lr.create, bi = Ec.propertyIsEnumerable, ad = Di.splice, Qs = pl ? pl.isConcatSpreadable : N, ua = pl ? pl.iterator : N, si = pl ? pl.toStringTag : N, st = function() {
        try {
          var u = Mf(Lr, "defineProperty");
          return u({}, "", {}), u;
        } catch {
        }
      }(), zl = Dt.clearTimeout !== Ga.clearTimeout && Dt.clearTimeout, Lm = Sn && Sn.now !== Ga.Date.now && Sn.now, Is = Dt.setTimeout !== Ga.setTimeout && Dt.setTimeout, Pa = Br.ceil, Ia = Br.floor, el = Lr.getOwnPropertySymbols, jd = Tl ? Tl.isBuffer : N, Ka = Dt.isFinite, pr = Di.join, Hl = rd(Lr.keys, Lr), ea = Br.max, Nr = Br.min, Pm = Sn.now, Vl = Dt.parseInt, Ya = Br.random, Ol = Di.reverse, He = Mf(Dt, "DataView"), za = Mf(Dt, "Map"), ou = Mf(Dt, "Promise"), Al = Mf(Dt, "Set"), Fs = Mf(Dt, "WeakMap"), rs = Mf(Lr, "create"), fs = Fs && new Fs(), Ir = {}, im = rf(He), Ln = rf(za), Fa = rf(ou), yi = rf(Al), dr = rf(Fs), wa = pl ? pl.prototype : N, zc = wa ? wa.valueOf : N, lc = wa ? wa.toString : N;
      function de(u) {
        if (ge(u) && !ir(u) && !(u instanceof Yo)) {
          if (u instanceof ls)
            return u;
          if (qr.call(u, "__wrapped__"))
            return bh(u);
        }
        return new ls(u);
      }
      var Hc = function() {
        function u() {
        }
        return function(g) {
          if (!Ce(g))
            return {};
          if (nu)
            return nu(g);
          u.prototype = g;
          var S = new u();
          return u.prototype = N, S;
        };
      }();
      function Oc() {
      }
      function ls(u, g) {
        this.__wrapped__ = u, this.__actions__ = [], this.__chain__ = !!g, this.__index__ = 0, this.__values__ = N;
      }
      de.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: ba,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: xc,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: _l,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: de
        }
      }, de.prototype = Oc.prototype, de.prototype.constructor = de, ls.prototype = Hc(Oc.prototype), ls.prototype.constructor = ls;
      function Yo(u) {
        this.__wrapped__ = u, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = Tt, this.__views__ = [];
      }
      function id() {
        var u = new Yo(this.__wrapped__);
        return u.__actions__ = Va(this.__actions__), u.__dir__ = this.__dir__, u.__filtered__ = this.__filtered__, u.__iteratees__ = Va(this.__iteratees__), u.__takeCount__ = this.__takeCount__, u.__views__ = Va(this.__views__), u;
      }
      function Ac() {
        if (this.__filtered__) {
          var u = new Yo(this);
          u.__dir__ = -1, u.__filtered__ = !0;
        } else
          u = this.clone(), u.__dir__ *= -1;
        return u;
      }
      function Cf() {
        var u = this.__wrapped__.value(), g = this.__dir__, S = ir(u), V = g < 0, Q = S ? u.length : 0, we = rl(0, Q, this.__views__), Be = we.start, Ve = we.end, ot = Ve - Be, Yt = V ? Ve : Be - 1, Kt = this.__iteratees__, dn = Kt.length, Kn = 0, No = Nr(ot, this.__takeCount__);
        if (!S || !V && Q == ot && No == ot)
          return dm(u, this.__actions__);
        var sr = [];
        e:
          for (; ot-- && Kn < No; ) {
            Yt += g;
            for (var Or = -1, Wo = u[Yt]; ++Or < dn; ) {
              var Jt = Kt[Or], bs = Jt.iteratee, Nc = Jt.type, Mc = bs(Wo);
              if (Nc == ht)
                Wo = Mc;
              else if (!Mc) {
                if (Nc == Et)
                  continue e;
                break e;
              }
            }
            sr[Kn++] = Wo;
          }
        return sr;
      }
      Yo.prototype = Hc(Oc.prototype), Yo.prototype.constructor = Yo;
      function da(u) {
        var g = -1, S = u == null ? 0 : u.length;
        for (this.clear(); ++g < S; ) {
          var V = u[g];
          this.set(V[0], V[1]);
        }
      }
      function z() {
        this.__data__ = rs ? rs(null) : {}, this.size = 0;
      }
      function F(u) {
        var g = this.has(u) && delete this.__data__[u];
        return this.size -= g ? 1 : 0, g;
      }
      function X(u) {
        var g = this.__data__;
        if (rs) {
          var S = g[u];
          return S === Me ? N : S;
        }
        return qr.call(g, u) ? g[u] : N;
      }
      function _e(u) {
        var g = this.__data__;
        return rs ? g[u] !== N : qr.call(g, u);
      }
      function Oe(u, g) {
        var S = this.__data__;
        return this.size += this.has(u) ? 0 : 1, S[u] = rs && g === N ? Me : g, this;
      }
      da.prototype.clear = z, da.prototype.delete = F, da.prototype.get = X, da.prototype.has = _e, da.prototype.set = Oe;
      function zt(u) {
        var g = -1, S = u == null ? 0 : u.length;
        for (this.clear(); ++g < S; ) {
          var V = u[g];
          this.set(V[0], V[1]);
        }
      }
      function bn() {
        this.__data__ = [], this.size = 0;
      }
      function ao(u) {
        var g = this.__data__, S = At(g, u);
        if (S < 0)
          return !1;
        var V = g.length - 1;
        return S == V ? g.pop() : ad.call(g, S, 1), --this.size, !0;
      }
      function Hn(u) {
        var g = this.__data__, S = At(g, u);
        return S < 0 ? N : g[S][1];
      }
      function En(u) {
        return At(this.__data__, u) > -1;
      }
      function yr(u, g) {
        var S = this.__data__, V = At(S, u);
        return V < 0 ? (++this.size, S.push([u, g])) : S[V][1] = g, this;
      }
      zt.prototype.clear = bn, zt.prototype.delete = ao, zt.prototype.get = Hn, zt.prototype.has = En, zt.prototype.set = yr;
      function ws(u) {
        var g = -1, S = u == null ? 0 : u.length;
        for (this.clear(); ++g < S; ) {
          var V = u[g];
          this.set(V[0], V[1]);
        }
      }
      function Ri() {
        this.size = 0, this.__data__ = {
          hash: new da(),
          map: new (za || zt)(),
          string: new da()
        };
      }
      function _u(u) {
        var g = fh(this, u).delete(u);
        return this.size -= g ? 1 : 0, g;
      }
      function Ni(u) {
        return fh(this, u).get(u);
      }
      function ka(u) {
        return fh(this, u).has(u);
      }
      function vi(u, g) {
        var S = fh(this, u), V = S.size;
        return S.set(u, g), this.size += S.size == V ? 0 : 1, this;
      }
      ws.prototype.clear = Ri, ws.prototype.delete = _u, ws.prototype.get = Ni, ws.prototype.has = ka, ws.prototype.set = vi;
      function Mi(u) {
        var g = -1, S = u == null ? 0 : u.length;
        for (this.__data__ = new ws(); ++g < S; )
          this.add(u[g]);
      }
      function Im(u) {
        return this.__data__.set(u, Me), this;
      }
      function wn(u) {
        return this.__data__.has(u);
      }
      Mi.prototype.add = Mi.prototype.push = Im, Mi.prototype.has = wn;
      function ta(u) {
        var g = this.__data__ = new zt(u);
        this.size = g.size;
      }
      function gl() {
        this.__data__ = new zt(), this.size = 0;
      }
      function Vc(u) {
        var g = this.__data__, S = g.delete(u);
        return this.size = g.size, S;
      }
      function Ul(u) {
        return this.__data__.get(u);
      }
      function Zd(u) {
        return this.__data__.has(u);
      }
      function Tp(u, g) {
        var S = this.__data__;
        if (S instanceof zt) {
          var V = S.__data__;
          if (!za || V.length < ue - 1)
            return V.push([u, g]), this.size = ++S.size, this;
          S = this.__data__ = new ws(V);
        }
        return S.set(u, g), this.size = S.size, this;
      }
      ta.prototype.clear = gl, ta.prototype.delete = Vc, ta.prototype.get = Ul, ta.prototype.has = Zd, ta.prototype.set = Tp;
      function ug(u, g) {
        var S = ir(u), V = !S && pa(u), Q = !S && !V && wd(u), we = !S && !V && !Q && Gn(u), Be = S || V || Q || we, Ve = Be ? Vr(u.length, Nn) : [], ot = Ve.length;
        for (var Yt in u)
          (g || qr.call(u, Yt)) && !(Be && // Safari 9 has enumerable `arguments.length` in strict mode.
          (Yt == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          Q && (Yt == "offset" || Yt == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          we && (Yt == "buffer" || Yt == "byteLength" || Yt == "byteOffset") || // Skip index properties.
          nf(Yt, ot))) && Ve.push(Yt);
        return Ve;
      }
      function ru(u) {
        var g = u.length;
        return g ? u[su(0, g - 1)] : N;
      }
      function sh(u, g) {
        return Wl(Va(u), cs(g, 0, u.length));
      }
      function Cu(u) {
        return Wl(Va(u));
      }
      function Wd(u, g, S) {
        (S !== N && !xd(u[g], S) || S === N && !(g in u)) && Dl(u, g, S);
      }
      function Uc(u, g, S) {
        var V = u[g];
        (!(qr.call(u, g) && xd(V, S)) || S === N && !(g in u)) && Dl(u, g, S);
      }
      function At(u, g) {
        for (var S = u.length; S--; )
          if (xd(u[S][0], g))
            return S;
        return -1;
      }
      function Fm(u, g, S, V) {
        return pn(u, function(Q, we, Be) {
          g(V, Q, S(Q), Be);
        }), V;
      }
      function qd(u, g) {
        return u && hd(g, Yl(g), u);
      }
      function Gd(u, g) {
        return u && hd(g, Lu(g), u);
      }
      function Dl(u, g, S) {
        g == "__proto__" && st ? st(u, g, {
          configurable: !0,
          enumerable: !0,
          value: S,
          writable: !0
        }) : u[g] = S;
      }
      function lm(u, g) {
        for (var S = -1, V = g.length, Q = vt(V), we = u == null; ++S < V; )
          Q[S] = we ? N : t1(u, g[S]);
        return Q;
      }
      function cs(u, g, S) {
        return u === u && (S !== N && (u = u <= S ? u : S), g !== N && (u = u >= g ? u : g)), u;
      }
      function Rl(u, g, S, V, Q, we) {
        var Be, Ve = g & yt, ot = g & jt, Yt = g & it;
        if (S && (Be = Q ? S(u, V, Q, we) : S(u)), Be !== N)
          return Be;
        if (!Ce(u))
          return u;
        var Kt = ir(u);
        if (Kt) {
          if (Be = ma(u), !Ve)
            return Va(u, Be);
        } else {
          var dn = Tr(u), Kn = dn == Qr || dn == nc;
          if (wd(u))
            return nb(u, Ve);
          if (dn == ut || dn == oa || Kn && !Q) {
            if (Be = ot || Kn ? {} : Li(u), !Ve)
              return ot ? Ou(u, Gd(Be, u)) : fa(u, qd(Be, u));
          } else {
            if (!$n[dn])
              return Q ? u : {};
            Be = ph(u, dn, Ve);
          }
        }
        we || (we = new ta());
        var No = we.get(u);
        if (No)
          return No;
        we.set(u, Be), Vn(u) ? u.forEach(function(Wo) {
          Be.add(Rl(Wo, g, S, Wo, u, we));
        }) : Te(u) && u.forEach(function(Wo, Jt) {
          Be.set(Jt, Rl(Wo, g, S, Jt, u, we));
        });
        var sr = Yt ? ot ? tf : Np : ot ? Lu : Yl, Or = Kt ? N : sr(u);
        return Xi(Or || u, function(Wo, Jt) {
          Or && (Jt = Wo, Wo = u[Jt]), Uc(Be, Jt, Rl(Wo, g, S, Jt, u, we));
        }), Be;
      }
      function cc(u) {
        var g = Yl(u);
        return function(S) {
          return Kr(S, u, g);
        };
      }
      function Kr(u, g, S) {
        var V = S.length;
        if (u == null)
          return !V;
        for (u = Lr(u); V--; ) {
          var Q = S[V], we = g[Q], Be = u[Q];
          if (Be === N && !(Q in u) || !we(Be))
            return !1;
        }
        return !0;
      }
      function Sf(u, g, S) {
        if (typeof u != "function")
          throw new Ps(he);
        return mm(function() {
          u.apply(N, S);
        }, g);
      }
      function Io(u, g, S, V) {
        var Q = -1, we = bu, Be = !0, Ve = u.length, ot = [], Yt = g.length;
        if (!Ve)
          return ot;
        S && (g = Ea(g, Js(S))), V ? (we = rh, Be = !1) : g.length >= ue && (we = xs, Be = !1, g = new Mi(g));
        e:
          for (; ++Q < Ve; ) {
            var Kt = u[Q], dn = S == null ? Kt : S(Kt);
            if (Kt = V || Kt !== 0 ? Kt : 0, Be && dn === dn) {
              for (var Kn = Yt; Kn--; )
                if (g[Kn] === dn)
                  continue e;
              ot.push(Kt);
            } else
              we(g, dn, V) || ot.push(Kt);
          }
        return ot;
      }
      var pn = wi(dc), Kd = wi(ld, !0);
      function zp(u, g) {
        var S = !0;
        return pn(u, function(V, Q, we) {
          return S = !!g(V, Q, we), S;
        }), S;
      }
      function Ef(u, g, S) {
        for (var V = -1, Q = u.length; ++V < Q; ) {
          var we = u[V], Be = g(we);
          if (Be != null && (Ve === N ? Be === Be && !Do(Be) : S(Be, Ve)))
            var Ve = Be, ot = we;
        }
        return ot;
      }
      function uc(u, g, S, V) {
        var Q = u.length;
        for (S = Dn(S), S < 0 && (S = -S > Q ? 0 : Q + S), V = V === N || V > Q ? Q : Dn(V), V < 0 && (V += Q), V = S > V ? 0 : ii(V); S < V; )
          u[S++] = g;
        return u;
      }
      function Bo(u, g) {
        var S = [];
        return pn(u, function(V, Q, we) {
          g(V, Q, we) && S.push(V);
        }), S;
      }
      function $a(u, g, S, V, Q) {
        var we = -1, Be = u.length;
        for (S || (S = vg), Q || (Q = []); ++we < Be; ) {
          var Ve = u[we];
          g > 0 && S(Ve) ? g > 1 ? $a(Ve, g - 1, S, V, Q) : yu(Q, Ve) : V || (Q[Q.length] = Ve);
        }
        return Q;
      }
      var $m = Rf(), ft = Rf(!0);
      function dc(u, g) {
        return u && $m(u, g, Yl);
      }
      function ld(u, g) {
        return u && ft(u, g, Yl);
      }
      function cd(u, g) {
        return Pc(g, function(S) {
          return Y(u[S]);
        });
      }
      function Yd(u, g) {
        g = Zm(g, u);
        for (var S = 0, V = g.length; u != null && S < V; )
          u = u[ql(g[S++])];
        return S && S == V ? u : N;
      }
      function Su(u, g, S) {
        var V = g(u);
        return ir(u) ? V : yu(V, S(u));
      }
      function jl(u) {
        return u == null ? u === N ? po : oo : si && si in Lr(u) ? mh(u) : Gm(u);
      }
      function Xd(u, g) {
        return u > g;
      }
      function ss(u, g) {
        return u != null && qr.call(u, g);
      }
      function ud(u, g) {
        return u != null && g in Lr(u);
      }
      function eb(u, g, S) {
        return u >= Nr(g, S) && u < ea(g, S);
      }
      function hl(u, g, S) {
        for (var V = S ? rh : bu, Q = u[0].length, we = u.length, Be = we, Ve = vt(we), ot = 1 / 0, Yt = []; Be--; ) {
          var Kt = u[Be];
          Be && g && (Kt = Ea(Kt, Js(g))), ot = Nr(Kt.length, ot), Ve[Be] = !S && (g || Q >= 120 && Kt.length >= 120) ? new Mi(Be && Kt) : N;
        }
        Kt = u[0];
        var dn = -1, Kn = Ve[0];
        e:
          for (; ++dn < Q && Yt.length < ot; ) {
            var No = Kt[dn], sr = g ? g(No) : No;
            if (No = S || No !== 0 ? No : 0, !(Kn ? xs(Kn, sr) : V(Yt, sr, S))) {
              for (Be = we; --Be; ) {
                var Or = Ve[Be];
                if (!(Or ? xs(Or, sr) : V(u[Be], sr, S)))
                  continue e;
              }
              Kn && Kn.push(sr), Yt.push(No);
            }
          }
        return Yt;
      }
      function Hm(u, g, S, V) {
        return dc(u, function(Q, we, Be) {
          g(V, S(Q), we, Be);
        }), V;
      }
      function tl(u, g, S) {
        g = Zm(g, u), u = pc(u, g);
        var V = u == null ? u : u[ql(Ii(g))];
        return V == null ? N : ns(V, u, S);
      }
      function cm(u) {
        return ge(u) && jl(u) == oa;
      }
      function Eu(u) {
        return ge(u) && jl(u) == ho;
      }
      function Jd(u) {
        return ge(u) && jl(u) == Go;
      }
      function Tu(u, g, S, V, Q) {
        return u === g ? !0 : u == null || g == null || !ge(u) && !ge(g) ? u !== u && g !== g : Tf(u, g, S, V, Tu, Q);
      }
      function Tf(u, g, S, V, Q, we) {
        var Be = ir(u), Ve = ir(g), ot = Be ? Pn : Tr(u), Yt = Ve ? Pn : Tr(g);
        ot = ot == oa ? ut : ot, Yt = Yt == oa ? ut : Yt;
        var Kt = ot == ut, dn = Yt == ut, Kn = ot == Yt;
        if (Kn && wd(u)) {
          if (!wd(g))
            return !1;
          Be = !0, Kt = !1;
        }
        if (Kn && !Kt)
          return we || (we = new ta()), Be || Gn(u) ? ib(u, g, S, V, Q, we) : K1(u, g, ot, S, V, Q, we);
        if (!(S & Rt)) {
          var No = Kt && qr.call(u, "__wrapped__"), sr = dn && qr.call(g, "__wrapped__");
          if (No || sr) {
            var Or = No ? u.value() : u, Wo = sr ? g.value() : g;
            return we || (we = new ta()), Q(Or, Wo, S, V, we);
          }
        }
        return Kn ? (we || (we = new ta()), lb(u, g, S, V, Q, we)) : !1;
      }
      function um(u) {
        return ge(u) && Tr(u) == So;
      }
      function hn(u, g, S, V) {
        var Q = S.length, we = Q, Be = !V;
        if (u == null)
          return !we;
        for (u = Lr(u); Q--; ) {
          var Ve = S[Q];
          if (Be && Ve[2] ? Ve[1] !== u[Ve[0]] : !(Ve[0] in u))
            return !1;
        }
        for (; ++Q < we; ) {
          Ve = S[Q];
          var ot = Ve[0], Yt = u[ot], Kt = Ve[1];
          if (Be && Ve[2]) {
            if (Yt === N && !(ot in u))
              return !1;
          } else {
            var dn = new ta();
            if (V)
              var Kn = V(Yt, Kt, ot, u, g, dn);
            if (!(Kn === N ? Tu(Kt, Yt, Rt | en, V, dn) : Kn))
              return !1;
          }
        }
        return !0;
      }
      function Op(u) {
        if (!Ce(u) || vv(u))
          return !1;
        var g = Y(u) ? ku : Gi;
        return g.test(rf(u));
      }
      function Vm(u) {
        return ge(u) && jl(u) == ct;
      }
      function zf(u) {
        return ge(u) && Tr(u) == xn;
      }
      function tb(u) {
        return ge(u) && ve(u.length) && !!Zn[jl(u)];
      }
      function C(u) {
        return typeof u == "function" ? u : u == null ? Iu : typeof u == "object" ? ir(u) ? Pt(u[0], u[1]) : rt(u) : Nv(u);
      }
      function R(u) {
        if (!Bf(u))
          return Hl(u);
        var g = [];
        for (var S in Lr(u))
          qr.call(u, S) && S != "constructor" && g.push(S);
        return g;
      }
      function q(u) {
        if (!Ce(u))
          return hh(u);
        var g = Bf(u), S = [];
        for (var V in u)
          V == "constructor" && (g || !qr.call(u, V)) || S.push(V);
        return S;
      }
      function se(u, g) {
        return u < g;
      }
      function De(u, g) {
        var S = -1, V = $i(u) ? vt(u.length) : [];
        return pn(u, function(Q, we, Be) {
          V[++S] = g(Q, we, Be);
        }), V;
      }
      function rt(u) {
        var g = cb(u);
        return g.length == 1 && g[0][2] ? $t(g[0][0], g[0][1]) : function(S) {
          return S === u || hn(S, u, g);
        };
      }
      function Pt(u, g) {
        return xg(u) && au(g) ? $t(ql(u), g) : function(S) {
          var V = t1(S, u);
          return V === N && V === g ? n1(S, u) : Tu(g, V, Rt | en);
        };
      }
      function on(u, g, S, V, Q) {
        u !== g && $m(g, function(we, Be) {
          if (Q || (Q = new ta()), Ce(we))
            Tn(u, g, Be, S, on, V, Q);
          else {
            var Ve = V ? V(gc(u, Be), we, Be + "", u, g, Q) : N;
            Ve === N && (Ve = we), Wd(u, Be, Ve);
          }
        }, Lu);
      }
      function Tn(u, g, S, V, Q, we, Be) {
        var Ve = gc(u, S), ot = gc(g, S), Yt = Be.get(ot);
        if (Yt) {
          Wd(u, S, Yt);
          return;
        }
        var Kt = we ? we(Ve, ot, S + "", u, g, Be) : N, dn = Kt === N;
        if (dn) {
          var Kn = ir(ot), No = !Kn && wd(ot), sr = !Kn && !No && Gn(ot);
          Kt = ot, Kn || No || sr ? ir(Ve) ? Kt = Ve : Ua(Ve) ? Kt = Va(Ve) : No ? (dn = !1, Kt = nb(ot, !0)) : sr ? (dn = !1, Kt = Ml(ot, !0)) : Kt = [] : Lt(ot) || pa(ot) ? (Kt = Ve, pa(Ve) ? Kt = Ng(Ve) : (!Ce(Ve) || Y(Ve)) && (Kt = Li(ot))) : dn = !1;
        }
        dn && (Be.set(ot, Kt), Q(Kt, ot, V, we, Be), Be.delete(ot)), Wd(u, S, Kt);
      }
      function uo(u, g) {
        var S = u.length;
        if (S)
          return g += g < 0 ? S : 0, nf(g, S) ? u[g] : N;
      }
      function ks(u, g, S) {
        g.length ? g = Ea(g, function(we) {
          return ir(we) ? function(Be) {
            return Yd(Be, we.length === 1 ? we[0] : we);
          } : we;
        }) : g = [Iu];
        var V = -1;
        g = Ea(g, Js(Ao()));
        var Q = De(u, function(we, Be, Ve) {
          var ot = Ea(g, function(Yt) {
            return Yt(we);
          });
          return { criteria: ot, index: ++V, value: we };
        });
        return ya(Q, function(we, Be) {
          return sb(we, Be, S);
        });
      }
      function _o(u, g) {
        return fr(u, g, function(S, V) {
          return n1(u, V);
        });
      }
      function fr(u, g, S) {
        for (var V = -1, Q = g.length, we = {}; ++V < Q; ) {
          var Be = g[V], Ve = Yd(u, Be);
          S(Ve, Be) && fd(we, Zm(Be, u), Ve);
        }
        return we;
      }
      function as(u) {
        return function(g) {
          return Yd(g, u);
        };
      }
      function Ha(u, g, S, V) {
        var Q = V ? td : ia, we = -1, Be = g.length, Ve = u;
        for (u === g && (g = Va(g)), S && (Ve = Ea(u, Js(S))); ++we < Be; )
          for (var ot = 0, Yt = g[we], Kt = S ? S(Yt) : Yt; (ot = Q(Ve, Kt, ot, V)) > -1; )
            Ve !== u && ad.call(Ve, ot, 1), ad.call(u, ot, 1);
        return u;
      }
      function Xa(u, g) {
        for (var S = u ? g.length : 0, V = S - 1; S--; ) {
          var Q = g[S];
          if (S == V || Q !== we) {
            var we = Q;
            nf(Q) ? ad.call(u, Q, 1) : jc(u, Q);
          }
        }
        return u;
      }
      function su(u, g) {
        return u + Ia(Ya() * (g - u + 1));
      }
      function Um(u, g, S, V) {
        for (var Q = -1, we = ea(Pa((g - u) / (S || 1)), 0), Be = vt(we); we--; )
          Be[V ? we : ++Q] = u, u += S;
        return Be;
      }
      function Of(u, g) {
        var S = "";
        if (!u || g < 1 || g > dt)
          return S;
        do
          g % 2 && (S += u), g = Ia(g / 2), g && (u += u);
        while (g);
        return S;
      }
      function or(u, g) {
        return Zc(of(u, g, Iu), u + "");
      }
      function jm(u) {
        return ru(Up(u));
      }
      function dd(u, g) {
        var S = Up(u);
        return Wl(S, cs(g, 0, S.length));
      }
      function fd(u, g, S, V) {
        if (!Ce(u))
          return u;
        g = Zm(g, u);
        for (var Q = -1, we = g.length, Be = we - 1, Ve = u; Ve != null && ++Q < we; ) {
          var ot = ql(g[Q]), Yt = S;
          if (ot === "__proto__" || ot === "constructor" || ot === "prototype")
            return u;
          if (Q != Be) {
            var Kt = Ve[ot];
            Yt = V ? V(Kt, ot, Ve) : N, Yt === N && (Yt = Ce(Kt) ? Kt : nf(g[Q + 1]) ? [] : {});
          }
          Uc(Ve, ot, Yt), Ve = Ve[ot];
        }
        return u;
      }
      var Ap = fs ? function(u, g) {
        return fs.set(u, g), u;
      } : Iu, dg = st ? function(u, g) {
        return st(u, "toString", {
          configurable: !0,
          enumerable: !1,
          value: l1(g),
          writable: !0
        });
      } : Iu;
      function md(u) {
        return Wl(Up(u));
      }
      function Oo(u, g, S) {
        var V = -1, Q = u.length;
        g < 0 && (g = -g > Q ? 0 : Q + g), S = S > Q ? Q : S, S < 0 && (S += Q), Q = g > S ? 0 : S - g >>> 0, g >>>= 0;
        for (var we = vt(Q); ++V < Q; )
          we[V] = u[V + g];
        return we;
      }
      function Sr(u, g) {
        var S;
        return pn(u, function(V, Q, we) {
          return S = g(V, Q, we), !S;
        }), !!S;
      }
      function xi(u, g, S) {
        var V = 0, Q = u == null ? V : u.length;
        if (typeof g == "number" && g === g && Q <= Ct) {
          for (; V < Q; ) {
            var we = V + Q >>> 1, Be = u[we];
            Be !== null && !Do(Be) && (S ? Be <= g : Be < g) ? V = we + 1 : Q = we;
          }
          return Q;
        }
        return vr(u, g, Iu, S);
      }
      function vr(u, g, S, V) {
        var Q = 0, we = u == null ? 0 : u.length;
        if (we === 0)
          return 0;
        g = S(g);
        for (var Be = g !== g, Ve = g === null, ot = Do(g), Yt = g === N; Q < we; ) {
          var Kt = Ia((Q + we) / 2), dn = S(u[Kt]), Kn = dn !== N, No = dn === null, sr = dn === dn, Or = Do(dn);
          if (Be)
            var Wo = V || sr;
          else
            Yt ? Wo = sr && (V || Kn) : Ve ? Wo = sr && Kn && (V || !No) : ot ? Wo = sr && Kn && !No && (V || !Or) : No || Or ? Wo = !1 : Wo = V ? dn <= g : dn < g;
          Wo ? Q = Kt + 1 : we = Kt;
        }
        return Nr(we, yo);
      }
      function fg(u, g) {
        for (var S = -1, V = u.length, Q = 0, we = []; ++S < V; ) {
          var Be = u[S], Ve = g ? g(Be) : Be;
          if (!S || !xd(Ve, ot)) {
            var ot = Ve;
            we[Q++] = Be === 0 ? 0 : Be;
          }
        }
        return we;
      }
      function $s(u) {
        return typeof u == "number" ? u : Do(u) ? jr : +u;
      }
      function _s(u) {
        if (typeof u == "string")
          return u;
        if (ir(u))
          return Ea(u, _s) + "";
        if (Do(u))
          return lc ? lc.call(u) : "";
        var g = u + "";
        return g == "0" && 1 / u == -lo ? "-0" : g;
      }
      function nl(u, g, S) {
        var V = -1, Q = bu, we = u.length, Be = !0, Ve = [], ot = Ve;
        if (S)
          Be = !1, Q = rh;
        else if (we >= ue) {
          var Yt = g ? null : By(u);
          if (Yt)
            return Vd(Yt);
          Be = !1, Q = xs, ot = new Mi();
        } else
          ot = g ? [] : Ve;
        e:
          for (; ++V < we; ) {
            var Kt = u[V], dn = g ? g(Kt) : Kt;
            if (Kt = S || Kt !== 0 ? Kt : 0, Be && dn === dn) {
              for (var Kn = ot.length; Kn--; )
                if (ot[Kn] === dn)
                  continue e;
              g && ot.push(dn), Ve.push(Kt);
            } else
              Q(ot, dn, S) || (ot !== Ve && ot.push(dn), Ve.push(Kt));
          }
        return Ve;
      }
      function jc(u, g) {
        return g = Zm(g, u), u = pc(u, g), u == null || delete u[ql(Ii(g))];
      }
      function pd(u, g, S, V) {
        return fd(u, g, S(Yd(u, g)), V);
      }
      function zu(u, g, S, V) {
        for (var Q = u.length, we = V ? Q : -1; (V ? we-- : ++we < Q) && g(u[we], we, u); )
          ;
        return S ? Oo(u, V ? 0 : we, V ? we + 1 : Q) : Oo(u, V ? we + 1 : 0, V ? Q : we);
      }
      function dm(u, g) {
        var S = u;
        return S instanceof Yo && (S = S.value()), ig(g, function(V, Q) {
          return Q.func.apply(Q.thisArg, yu([V], Q.args));
        }, S);
      }
      function mg(u, g, S) {
        var V = u.length;
        if (V < 2)
          return V ? nl(u[0]) : [];
        for (var Q = -1, we = vt(V); ++Q < V; )
          for (var Be = u[Q], Ve = -1; ++Ve < V; )
            Ve != Q && (we[Q] = Io(we[Q] || Be, u[Ve], g, S));
        return nl($a(we, 1), g, S);
      }
      function fm(u, g, S) {
        for (var V = -1, Q = u.length, we = g.length, Be = {}; ++V < Q; ) {
          var Ve = V < we ? g[V] : N;
          S(Be, u[V], Ve);
        }
        return Be;
      }
      function Af(u) {
        return Ua(u) ? u : [];
      }
      function ah(u) {
        return typeof u == "function" ? u : Iu;
      }
      function Zm(u, g) {
        return ir(u) ? u : xg(u, g) ? [u] : db(hs(u));
      }
      var Ry = or;
      function gd(u, g, S) {
        var V = u.length;
        return S = S === N ? V : S, !g && S >= V ? u : Oo(u, g, S);
      }
      var Os = zl || function(u) {
        return Ga.clearTimeout(u);
      };
      function nb(u, g) {
        if (g)
          return u.slice();
        var S = u.length, V = ic ? ic(S) : new u.constructor(S);
        return u.copy(V), V;
      }
      function ob(u) {
        var g = new u.constructor(u.byteLength);
        return new Gr(g).set(new Gr(u)), g;
      }
      function rb(u, g) {
        var S = g ? ob(u.buffer) : u.buffer;
        return new u.constructor(S, u.byteOffset, u.byteLength);
      }
      function Nl(u) {
        var g = new u.constructor(u.source, wc.exec(u));
        return g.lastIndex = u.lastIndex, g;
      }
      function Yr(u) {
        return zc ? Lr(zc.call(u)) : {};
      }
      function Ml(u, g) {
        var S = g ? ob(u.buffer) : u.buffer;
        return new u.constructor(S, u.byteOffset, u.length);
      }
      function pg(u, g) {
        if (u !== g) {
          var S = u !== N, V = u === null, Q = u === u, we = Do(u), Be = g !== N, Ve = g === null, ot = g === g, Yt = Do(g);
          if (!Ve && !Yt && !we && u > g || we && Be && ot && !Ve && !Yt || V && Be && ot || !S && ot || !Q)
            return 1;
          if (!V && !we && !Yt && u < g || Yt && S && Q && !V && !we || Ve && S && Q || !Be && Q || !ot)
            return -1;
        }
        return 0;
      }
      function sb(u, g, S) {
        for (var V = -1, Q = u.criteria, we = g.criteria, Be = Q.length, Ve = S.length; ++V < Be; ) {
          var ot = pg(Q[V], we[V]);
          if (ot) {
            if (V >= Ve)
              return ot;
            var Yt = S[V];
            return ot * (Yt == "desc" ? -1 : 1);
          }
        }
        return u.index - g.index;
      }
      function Ny(u, g, S, V) {
        for (var Q = -1, we = u.length, Be = S.length, Ve = -1, ot = g.length, Yt = ea(we - Be, 0), Kt = vt(ot + Yt), dn = !V; ++Ve < ot; )
          Kt[Ve] = g[Ve];
        for (; ++Q < Be; )
          (dn || Q < we) && (Kt[S[Q]] = u[Q]);
        for (; Yt--; )
          Kt[Ve++] = u[Q++];
        return Kt;
      }
      function ih(u, g, S, V) {
        for (var Q = -1, we = u.length, Be = -1, Ve = S.length, ot = -1, Yt = g.length, Kt = ea(we - Ve, 0), dn = vt(Kt + Yt), Kn = !V; ++Q < Kt; )
          dn[Q] = u[Q];
        for (var No = Q; ++ot < Yt; )
          dn[No + ot] = g[ot];
        for (; ++Be < Ve; )
          (Kn || Q < we) && (dn[No + S[Be]] = u[Q++]);
        return dn;
      }
      function Va(u, g) {
        var S = -1, V = u.length;
        for (g || (g = vt(V)); ++S < V; )
          g[S] = u[S];
        return g;
      }
      function hd(u, g, S, V) {
        var Q = !S;
        S || (S = {});
        for (var we = -1, Be = g.length; ++we < Be; ) {
          var Ve = g[we], ot = V ? V(S[Ve], u[Ve], Ve, S, u) : N;
          ot === N && (ot = u[Ve]), Q ? Dl(S, Ve, ot) : Uc(S, Ve, ot);
        }
        return S;
      }
      function fa(u, g) {
        return hd(u, yg(u), g);
      }
      function Ou(u, g) {
        return hd(u, Bi(u), g);
      }
      function Df(u, g) {
        return function(S, V) {
          var Q = ir(S) ? ag : Fm, we = g ? g() : {};
          return Q(S, u, Ao(V, 2), we);
        };
      }
      function Qd(u) {
        return or(function(g, S) {
          var V = -1, Q = S.length, we = Q > 1 ? S[Q - 1] : N, Be = Q > 2 ? S[2] : N;
          for (we = u.length > 3 && typeof we == "function" ? (Q--, we) : N, Be && Pi(S[0], S[1], Be) && (we = Q < 3 ? N : we, Q = 1), g = Lr(g); ++V < Q; ) {
            var Ve = S[V];
            Ve && u(g, Ve, V, we);
          }
          return g;
        });
      }
      function wi(u, g) {
        return function(S, V) {
          if (S == null)
            return S;
          if (!$i(S))
            return u(S, V);
          for (var Q = S.length, we = g ? Q : -1, Be = Lr(S); (g ? we-- : ++we < Q) && V(Be[we], we, Be) !== !1; )
            ;
          return S;
        };
      }
      function Rf(u) {
        return function(g, S, V) {
          for (var Q = -1, we = Lr(g), Be = V(g), Ve = Be.length; Ve--; ) {
            var ot = Be[u ? Ve : ++Q];
            if (S(we[ot], ot, we) === !1)
              break;
          }
          return g;
        };
      }
      function lh(u, g, S) {
        var V = g & Gt, Q = ch(u);
        function we() {
          var Be = this && this !== Ga && this instanceof we ? Q : u;
          return Be.apply(V ? S : this, arguments);
        }
        return we;
      }
      function ab(u) {
        return function(g) {
          g = hs(g);
          var S = vu(g) ? ri(g) : N, V = S ? S[0] : g.charAt(0), Q = S ? gd(S, 1).join("") : g.slice(1);
          return V[u]() + Q;
        };
      }
      function Wm(u) {
        return function(g) {
          return ig(c0(Lw(g).replace(ar, "")), u, "");
        };
      }
      function ch(u) {
        return function() {
          var g = arguments;
          switch (g.length) {
            case 0:
              return new u();
            case 1:
              return new u(g[0]);
            case 2:
              return new u(g[0], g[1]);
            case 3:
              return new u(g[0], g[1], g[2]);
            case 4:
              return new u(g[0], g[1], g[2], g[3]);
            case 5:
              return new u(g[0], g[1], g[2], g[3], g[4]);
            case 6:
              return new u(g[0], g[1], g[2], g[3], g[4], g[5]);
            case 7:
              return new u(g[0], g[1], g[2], g[3], g[4], g[5], g[6]);
          }
          var S = Hc(u.prototype), V = u.apply(S, g);
          return Ce(V) ? V : S;
        };
      }
      function Dp(u, g, S) {
        var V = ch(u);
        function Q() {
          for (var we = arguments.length, Be = vt(we), Ve = we, ot = Du(Q); Ve--; )
            Be[Ve] = arguments[Ve];
          var Yt = we < 3 && Be[0] !== ot && Be[we - 1] !== ot ? [] : Oi(Be, ot);
          if (we -= Yt.length, we < S)
            return ms(
              u,
              g,
              ef,
              Q.placeholder,
              N,
              Be,
              Yt,
              N,
              N,
              S - we
            );
          var Kt = this && this !== Ga && this instanceof Q ? V : u;
          return ns(Kt, this, Be);
        }
        return Q;
      }
      function qm(u) {
        return function(g, S, V) {
          var Q = Lr(g);
          if (!$i(g)) {
            var we = Ao(S, 3);
            g = Yl(g), S = function(Ve) {
              return we(Q[Ve], Ve, Q);
            };
          }
          var Be = u(g, S, V);
          return Be > -1 ? Q[we ? g[Be] : Be] : N;
        };
      }
      function gg(u) {
        return Nf(function(g) {
          var S = g.length, V = S, Q = ls.prototype.thru;
          for (u && g.reverse(); V--; ) {
            var we = g[V];
            if (typeof we != "function")
              throw new Ps(he);
            if (Q && !Be && ki(we) == "wrapper")
              var Be = new ls([], !0);
          }
          for (V = Be ? V : S; ++V < S; ) {
            we = g[V];
            var Ve = ki(we), ot = Ve == "wrapper" ? Dc(we) : N;
            ot && Iy(ot[0]) && ot[1] == (We | Ot | wt | Cn) && !ot[4].length && ot[9] == 1 ? Be = Be[ki(ot[0])].apply(Be, ot[3]) : Be = we.length == 1 && Iy(we) ? Be[Ve]() : Be.thru(we);
          }
          return function() {
            var Yt = arguments, Kt = Yt[0];
            if (Be && Yt.length == 1 && ir(Kt))
              return Be.plant(Kt).value();
            for (var dn = 0, Kn = S ? g[dn].apply(this, Yt) : Kt; ++dn < S; )
              Kn = g[dn].call(this, Kn);
            return Kn;
          };
        });
      }
      function ef(u, g, S, V, Q, we, Be, Ve, ot, Yt) {
        var Kt = g & We, dn = g & Gt, Kn = g & gt, No = g & (Ot | Ee), sr = g & ko, Or = Kn ? N : ch(u);
        function Wo() {
          for (var Jt = arguments.length, bs = vt(Jt), Nc = Jt; Nc--; )
            bs[Nc] = arguments[Nc];
          if (No)
            var Mc = Du(Wo), Fu = va(bs, Mc);
          if (V && (bs = Ny(bs, V, Q, No)), we && (bs = ih(bs, we, Be, No)), Jt -= Fu, No && Jt < Yt) {
            var al = Oi(bs, Mc);
            return ms(
              u,
              g,
              ef,
              Wo.placeholder,
              S,
              bs,
              al,
              Ve,
              ot,
              Yt - Jt
            );
          }
          var Wc = dn ? S : this, _a = Kn ? Wc[u] : u;
          return Jt = bs.length, Ve ? bs = xv(bs, Ve) : sr && Jt > 1 && bs.reverse(), Kt && ot < Jt && (bs.length = ot), this && this !== Ga && this instanceof Wo && (_a = Or || ch(_a)), _a.apply(Wc, bs);
        }
        return Wo;
      }
      function hg(u, g) {
        return function(S, V) {
          return Hm(S, u, g(V), {});
        };
      }
      function Au(u, g) {
        return function(S, V) {
          var Q;
          if (S === N && V === N)
            return g;
          if (S !== N && (Q = S), V !== N) {
            if (Q === N)
              return V;
            typeof S == "string" || typeof V == "string" ? (S = _s(S), V = _s(V)) : (S = $s(S), V = $s(V)), Q = u(S, V);
          }
          return Q;
        };
      }
      function Rp(u) {
        return Nf(function(g) {
          return g = Ea(g, Js(Ao())), or(function(S) {
            var V = this;
            return u(g, function(Q) {
              return ns(Q, V, S);
            });
          });
        });
      }
      function Vo(u, g) {
        g = g === N ? " " : _s(g);
        var S = g.length;
        if (S < 2)
          return S ? Of(g, u) : g;
        var V = Of(g, Pa(u / wu(g)));
        return vu(g) ? gd(ri(V), 0, u).join("") : V.slice(0, u);
      }
      function fc(u, g, S, V) {
        var Q = g & Gt, we = ch(u);
        function Be() {
          for (var Ve = -1, ot = arguments.length, Yt = -1, Kt = V.length, dn = vt(Kt + ot), Kn = this && this !== Ga && this instanceof Be ? we : u; ++Yt < Kt; )
            dn[Yt] = V[Yt];
          for (; ot--; )
            dn[Yt++] = arguments[++Ve];
          return ns(Kn, Q ? S : this, dn);
        }
        return Be;
      }
      function bd(u) {
        return function(g, S, V) {
          return V && typeof V != "number" && Pi(g, S, V) && (S = V = N), g = ai(g), S === N ? (S = g, g = 0) : S = ai(S), V = V === N ? g < S ? 1 : -1 : ai(V), Um(g, S, V, u);
        };
      }
      function bg(u) {
        return function(g, S) {
          return typeof g == "string" && typeof S == "string" || (g = yl(g), S = yl(S)), u(g, S);
        };
      }
      function ms(u, g, S, V, Q, we, Be, Ve, ot, Yt) {
        var Kt = g & Ot, dn = Kt ? Be : N, Kn = Kt ? N : Be, No = Kt ? we : N, sr = Kt ? N : we;
        g |= Kt ? wt : Se, g &= ~(Kt ? Se : wt), g & an || (g &= ~(Gt | gt));
        var Or = [
          u,
          g,
          Q,
          No,
          dn,
          sr,
          Kn,
          Ve,
          ot,
          Yt
        ], Wo = S.apply(N, Or);
        return Iy(u) && ub(Wo, Or), Wo.placeholder = V, iu(Wo, u, g);
      }
      function My(u) {
        var g = Br[u];
        return function(S, V) {
          if (S = yl(S), V = V == null ? 0 : Nr(Dn(V), 292), V && Ka(S)) {
            var Q = (hs(S) + "e").split("e"), we = g(Q[0] + "e" + (+Q[1] + V));
            return Q = (hs(we) + "e").split("e"), +(Q[0] + "e" + (+Q[1] - V));
          }
          return g(S);
        };
      }
      var By = Al && 1 / Vd(new Al([, -0]))[1] == lo ? function(u) {
        return new Al(u);
      } : Dv;
      function ol(u) {
        return function(g) {
          var S = Tr(g);
          return S == So ? ca(g) : S == xn ? Fc(g) : zs(g, u(g));
        };
      }
      function mc(u, g, S, V, Q, we, Be, Ve) {
        var ot = g & gt;
        if (!ot && typeof u != "function")
          throw new Ps(he);
        var Yt = V ? V.length : 0;
        if (Yt || (g &= ~(wt | Se), V = Q = N), Be = Be === N ? Be : ea(Dn(Be), 0), Ve = Ve === N ? Ve : Dn(Ve), Yt -= Q ? Q.length : 0, g & Se) {
          var Kt = V, dn = Q;
          V = Q = N;
        }
        var Kn = ot ? N : Dc(u), No = [
          u,
          g,
          S,
          V,
          Q,
          Kt,
          dn,
          we,
          Be,
          Ve
        ];
        if (Kn && _i(No, Kn), u = No[0], g = No[1], S = No[2], V = No[3], Q = No[4], Ve = No[9] = No[9] === N ? ot ? 0 : u.length : ea(No[9] - Yt, 0), !Ve && g & (Ot | Ee) && (g &= ~(Ot | Ee)), !g || g == Gt)
          var sr = lh(u, g, S);
        else
          g == Ot || g == Ee ? sr = Dp(u, g, Ve) : (g == wt || g == (Gt | wt)) && !Q.length ? sr = fc(u, g, S, V) : sr = ef.apply(N, No);
        var Or = Kn ? Ap : ub;
        return iu(Or(sr, No), u, g);
      }
      function uh(u, g, S, V) {
        return u === N || xd(u, Ec[S]) && !qr.call(V, S) ? g : u;
      }
      function dh(u, g, S, V, Q, we) {
        return Ce(u) && Ce(g) && (we.set(g, u), on(u, g, N, dh, we), we.delete(g)), u;
      }
      function Ly(u) {
        return Lt(u) ? N : u;
      }
      function ib(u, g, S, V, Q, we) {
        var Be = S & Rt, Ve = u.length, ot = g.length;
        if (Ve != ot && !(Be && ot > Ve))
          return !1;
        var Yt = we.get(u), Kt = we.get(g);
        if (Yt && Kt)
          return Yt == g && Kt == u;
        var dn = -1, Kn = !0, No = S & en ? new Mi() : N;
        for (we.set(u, g), we.set(g, u); ++dn < Ve; ) {
          var sr = u[dn], Or = g[dn];
          if (V)
            var Wo = Be ? V(Or, sr, dn, g, u, we) : V(sr, Or, dn, u, g, we);
          if (Wo !== N) {
            if (Wo)
              continue;
            Kn = !1;
            break;
          }
          if (No) {
            if (!om(g, function(Jt, bs) {
              if (!xs(No, bs) && (sr === Jt || Q(sr, Jt, S, V, we)))
                return No.push(bs);
            })) {
              Kn = !1;
              break;
            }
          } else if (!(sr === Or || Q(sr, Or, S, V, we))) {
            Kn = !1;
            break;
          }
        }
        return we.delete(u), we.delete(g), Kn;
      }
      function K1(u, g, S, V, Q, we, Be) {
        switch (S) {
          case Ns:
            if (u.byteLength != g.byteLength || u.byteOffset != g.byteOffset)
              return !1;
            u = u.buffer, g = g.buffer;
          case ho:
            return !(u.byteLength != g.byteLength || !we(new Gr(u), new Gr(g)));
          case K:
          case Go:
          case cr:
            return xd(+u, +g);
          case er:
            return u.name == g.name && u.message == g.message;
          case ct:
          case co:
            return u == g + "";
          case So:
            var Ve = ca;
          case xn:
            var ot = V & Rt;
            if (Ve || (Ve = Vd), u.size != g.size && !ot)
              return !1;
            var Yt = Be.get(u);
            if (Yt)
              return Yt == g;
            V |= en, Be.set(u, g);
            var Kt = ib(Ve(u), Ve(g), V, Q, we, Be);
            return Be.delete(u), Kt;
          case Ko:
            if (zc)
              return zc.call(u) == zc.call(g);
        }
        return !1;
      }
      function lb(u, g, S, V, Q, we) {
        var Be = S & Rt, Ve = Np(u), ot = Ve.length, Yt = Np(g), Kt = Yt.length;
        if (ot != Kt && !Be)
          return !1;
        for (var dn = ot; dn--; ) {
          var Kn = Ve[dn];
          if (!(Be ? Kn in g : qr.call(g, Kn)))
            return !1;
        }
        var No = we.get(u), sr = we.get(g);
        if (No && sr)
          return No == g && sr == u;
        var Or = !0;
        we.set(u, g), we.set(g, u);
        for (var Wo = Be; ++dn < ot; ) {
          Kn = Ve[dn];
          var Jt = u[Kn], bs = g[Kn];
          if (V)
            var Nc = Be ? V(bs, Jt, Kn, g, u, we) : V(Jt, bs, Kn, u, g, we);
          if (!(Nc === N ? Jt === bs || Q(Jt, bs, S, V, we) : Nc)) {
            Or = !1;
            break;
          }
          Wo || (Wo = Kn == "constructor");
        }
        if (Or && !Wo) {
          var Mc = u.constructor, Fu = g.constructor;
          Mc != Fu && "constructor" in u && "constructor" in g && !(typeof Mc == "function" && Mc instanceof Mc && typeof Fu == "function" && Fu instanceof Fu) && (Or = !1);
        }
        return we.delete(u), we.delete(g), Or;
      }
      function Nf(u) {
        return Zc(of(u, N, kg), u + "");
      }
      function Np(u) {
        return Su(u, Yl, yg);
      }
      function tf(u) {
        return Su(u, Lu, Bi);
      }
      var Dc = fs ? function(u) {
        return fs.get(u);
      } : Dv;
      function ki(u) {
        for (var g = u.name + "", S = Ir[g], V = qr.call(Ir, g) ? S.length : 0; V--; ) {
          var Q = S[V], we = Q.func;
          if (we == null || we == u)
            return Q.name;
        }
        return g;
      }
      function Du(u) {
        var g = qr.call(de, "placeholder") ? de : u;
        return g.placeholder;
      }
      function Ao() {
        var u = de.iteratee || Vb;
        return u = u === Vb ? C : u, arguments.length ? u(arguments[0], arguments[1]) : u;
      }
      function fh(u, g) {
        var S = u.__data__;
        return gh(g) ? S[typeof g == "string" ? "string" : "hash"] : S.map;
      }
      function cb(u) {
        for (var g = Yl(u), S = g.length; S--; ) {
          var V = g[S], Q = u[V];
          g[S] = [V, Q, au(Q)];
        }
        return g;
      }
      function Mf(u, g) {
        var S = sm(u, g);
        return Op(S) ? S : N;
      }
      function mh(u) {
        var g = qr.call(u, si), S = u[si];
        try {
          u[si] = N;
          var V = !0;
        } catch {
        }
        var Q = Ud.call(u);
        return V && (g ? u[si] = S : delete u[si]), Q;
      }
      var yg = el ? function(u) {
        return u == null ? [] : (u = Lr(u), Pc(el(u), function(g) {
          return bi.call(u, g);
        }));
      } : Ub, Bi = el ? function(u) {
        for (var g = []; u; )
          yu(g, yg(u)), u = Ta(u);
        return g;
      } : Ub, Tr = jl;
      (He && Tr(new He(new ArrayBuffer(1))) != Ns || za && Tr(new za()) != So || ou && Tr(ou.resolve()) != kt || Al && Tr(new Al()) != xn || Fs && Tr(new Fs()) != Ra) && (Tr = function(u) {
        var g = jl(u), S = g == ut ? u.constructor : N, V = S ? rf(S) : "";
        if (V)
          switch (V) {
            case im:
              return Ns;
            case Ln:
              return So;
            case Fa:
              return kt;
            case yi:
              return xn;
            case dr:
              return Ra;
          }
        return g;
      });
      function rl(u, g, S) {
        for (var V = -1, Q = S.length; ++V < Q; ) {
          var we = S[V], Be = we.size;
          switch (we.type) {
            case "drop":
              u += Be;
              break;
            case "dropRight":
              g -= Be;
              break;
            case "take":
              g = Nr(g, u + Be);
              break;
            case "takeRight":
              u = ea(u, g - Be);
              break;
          }
        }
        return { start: u, end: g };
      }
      function ps(u) {
        var g = u.match(Xt);
        return g ? g[1].split(Dd) : [];
      }
      function Zl(u, g, S) {
        g = Zm(g, u);
        for (var V = -1, Q = g.length, we = !1; ++V < Q; ) {
          var Be = ql(g[V]);
          if (!(we = u != null && S(u, Be)))
            break;
          u = u[Be];
        }
        return we || ++V != Q ? we : (Q = u == null ? 0 : u.length, !!Q && ve(Q) && nf(Be, Q) && (ir(u) || pa(u)));
      }
      function ma(u) {
        var g = u.length, S = new u.constructor(g);
        return g && typeof u[0] == "string" && qr.call(u, "index") && (S.index = u.index, S.input = u.input), S;
      }
      function Li(u) {
        return typeof u.constructor == "function" && !Bf(u) ? Hc(Ta(u)) : {};
      }
      function ph(u, g, S) {
        var V = u.constructor;
        switch (g) {
          case ho:
            return ob(u);
          case K:
          case Go:
            return new V(+u);
          case Ns:
            return rb(u, S);
          case Ca:
          case Zr:
          case $r:
          case Po:
          case ha:
          case ro:
          case cn:
          case _n:
          case Ys:
            return Ml(u, S);
          case So:
            return new V();
          case cr:
          case co:
            return new V(u);
          case ct:
            return Nl(u);
          case xn:
            return new V();
          case Ko:
            return Yr(u);
        }
      }
      function Py(u, g) {
        var S = g.length;
        if (!S)
          return u;
        var V = S - 1;
        return g[V] = (S > 1 ? "& " : "") + g[V], g = g.join(S > 2 ? ", " : " "), u.replace(Xc, `{
/* [wrapped with ` + g + `] */
`);
      }
      function vg(u) {
        return ir(u) || pa(u) || !!(Qs && u && u[Qs]);
      }
      function nf(u, g) {
        var S = typeof u;
        return g = g ?? dt, !!g && (S == "number" || S != "symbol" && rc.test(u)) && u > -1 && u % 1 == 0 && u < g;
      }
      function Pi(u, g, S) {
        if (!Ce(S))
          return !1;
        var V = typeof g;
        return (V == "number" ? $i(S) && nf(g, S.length) : V == "string" && g in S) ? xd(S[g], u) : !1;
      }
      function xg(u, g) {
        if (ir(u))
          return !1;
        var S = typeof u;
        return S == "number" || S == "symbol" || S == "boolean" || u == null || Do(u) ? !0 : oc.test(u) || !Wi.test(u) || g != null && u in Lr(g);
      }
      function gh(u) {
        var g = typeof u;
        return g == "string" || g == "number" || g == "symbol" || g == "boolean" ? u !== "__proto__" : u === null;
      }
      function Iy(u) {
        var g = ki(u), S = de[g];
        if (typeof S != "function" || !(g in Yo.prototype))
          return !1;
        if (u === S)
          return !0;
        var V = Dc(S);
        return !!V && u === V[0];
      }
      function vv(u) {
        return !!$c && $c in u;
      }
      var wg = Pr ? Y : m0;
      function Bf(u) {
        var g = u && u.constructor, S = typeof g == "function" && g.prototype || Ec;
        return u === S;
      }
      function au(u) {
        return u === u && !Ce(u);
      }
      function $t(u, g) {
        return function(S) {
          return S == null ? !1 : S[u] === g && (g !== N || u in Lr(S));
        };
      }
      function Fy(u) {
        var g = zo(u, function(V) {
          return S.size === Ze && S.clear(), V;
        }), S = g.cache;
        return g;
      }
      function _i(u, g) {
        var S = u[1], V = g[1], Q = S | V, we = Q < (Gt | gt | We), Be = V == We && S == Ot || V == We && S == Cn && u[7].length <= g[8] || V == (We | Cn) && g[7].length <= g[8] && S == Ot;
        if (!(we || Be))
          return u;
        V & Gt && (u[2] = g[2], Q |= S & Gt ? 0 : an);
        var Ve = g[3];
        if (Ve) {
          var ot = u[3];
          u[3] = ot ? Ny(ot, Ve, g[4]) : Ve, u[4] = ot ? Oi(u[3], Ye) : g[4];
        }
        return Ve = g[5], Ve && (ot = u[5], u[5] = ot ? ih(ot, Ve, g[6]) : Ve, u[6] = ot ? Oi(u[5], Ye) : g[6]), Ve = g[7], Ve && (u[7] = Ve), V & We && (u[8] = u[8] == null ? g[8] : Nr(u[8], g[8])), u[9] == null && (u[9] = g[9]), u[0] = g[0], u[1] = Q, u;
      }
      function hh(u) {
        var g = [];
        if (u != null)
          for (var S in Lr(u))
            g.push(S);
        return g;
      }
      function Gm(u) {
        return Ud.call(u);
      }
      function of(u, g, S) {
        return g = ea(g === N ? u.length - 1 : g, 0), function() {
          for (var V = arguments, Q = -1, we = ea(V.length - g, 0), Be = vt(we); ++Q < we; )
            Be[Q] = V[g + Q];
          Q = -1;
          for (var Ve = vt(g + 1); ++Q < g; )
            Ve[Q] = V[Q];
          return Ve[g] = S(Be), ns(u, this, Ve);
        };
      }
      function pc(u, g) {
        return g.length < 2 ? u : Yd(u, Oo(g, 0, -1));
      }
      function xv(u, g) {
        for (var S = u.length, V = Nr(g.length, S), Q = Va(u); V--; ) {
          var we = g[V];
          u[V] = nf(we, S) ? Q[we] : N;
        }
        return u;
      }
      function gc(u, g) {
        if (!(g === "constructor" && typeof u[g] == "function") && g != "__proto__")
          return u[g];
      }
      var ub = Mp(Ap), mm = Is || function(u, g) {
        return Ga.setTimeout(u, g);
      }, Zc = Mp(dg);
      function iu(u, g, S) {
        var V = g + "";
        return Zc(u, Py(V, $y(ps(V), S)));
      }
      function Mp(u) {
        var g = 0, S = 0;
        return function() {
          var V = Pm(), Q = M - (V - S);
          if (S = V, Q > 0) {
            if (++g >= un)
              return arguments[0];
          } else
            g = 0;
          return u.apply(N, arguments);
        };
      }
      function Wl(u, g) {
        var S = -1, V = u.length, Q = V - 1;
        for (g = g === N ? V : g; ++S < g; ) {
          var we = su(S, Q), Be = u[we];
          u[we] = u[S], u[S] = Be;
        }
        return u.length = g, u;
      }
      var db = Fy(function(u) {
        var g = [];
        return u.charCodeAt(0) === 46 && g.push(""), u.replace(Hr, function(S, V, Q, we) {
          g.push(Q ? we.replace(Rd, "$1") : V || S);
        }), g;
      });
      function ql(u) {
        if (typeof u == "string" || Do(u))
          return u;
        var g = u + "";
        return g == "0" && 1 / u == -lo ? "-0" : g;
      }
      function rf(u) {
        if (u != null) {
          try {
            return Tc.call(u);
          } catch {
          }
          try {
            return u + "";
          } catch {
          }
        }
        return "";
      }
      function $y(u, g) {
        return Xi(tn, function(S) {
          var V = "_." + S[0];
          g & S[1] && !bu(u, V) && u.push(V);
        }), u.sort();
      }
      function bh(u) {
        if (u instanceof Yo)
          return u.clone();
        var g = new ls(u.__wrapped__, u.__chain__);
        return g.__actions__ = Va(u.__actions__), g.__index__ = u.__index__, g.__values__ = u.__values__, g;
      }
      function wv(u, g, S) {
        (S ? Pi(u, g, S) : g === N) ? g = 1 : g = ea(Dn(g), 0);
        var V = u == null ? 0 : u.length;
        if (!V || g < 1)
          return [];
        for (var Q = 0, we = 0, Be = vt(Pa(V / g)); Q < V; )
          Be[we++] = Oo(u, Q, Q += g);
        return Be;
      }
      function Hy(u) {
        for (var g = -1, S = u == null ? 0 : u.length, V = 0, Q = []; ++g < S; ) {
          var we = u[g];
          we && (Q[V++] = we);
        }
        return Q;
      }
      function Vy() {
        var u = arguments.length;
        if (!u)
          return [];
        for (var g = vt(u - 1), S = arguments[0], V = u; V--; )
          g[V - 1] = arguments[V];
        return yu(ir(S) ? Va(S) : [S], $a(g, 1));
      }
      var Uy = or(function(u, g) {
        return Ua(u) ? Io(u, $a(g, 1, Ua, !0)) : [];
      }), yh = or(function(u, g) {
        var S = Ii(g);
        return Ua(S) && (S = N), Ua(u) ? Io(u, $a(g, 1, Ua, !0), Ao(S, 2)) : [];
      }), Y1 = or(function(u, g) {
        var S = Ii(g);
        return Ua(S) && (S = N), Ua(u) ? Io(u, $a(g, 1, Ua, !0), N, S) : [];
      });
      function Km(u, g, S) {
        var V = u == null ? 0 : u.length;
        return V ? (g = S || g === N ? 1 : Dn(g), Oo(u, g < 0 ? 0 : g, V)) : [];
      }
      function bl(u, g, S) {
        var V = u == null ? 0 : u.length;
        return V ? (g = S || g === N ? 1 : Dn(g), g = V - g, Oo(u, 0, g < 0 ? 0 : g)) : [];
      }
      function Ym(u, g) {
        return u && u.length ? zu(u, Ao(g, 3), !0, !0) : [];
      }
      function Lf(u, g) {
        return u && u.length ? zu(u, Ao(g, 3), !0) : [];
      }
      function As(u, g, S, V) {
        var Q = u == null ? 0 : u.length;
        return Q ? (S && typeof S != "number" && Pi(u, g, S) && (S = 0, V = Q), uc(u, g, S, V)) : [];
      }
      function pm(u, g, S) {
        var V = u == null ? 0 : u.length;
        if (!V)
          return -1;
        var Q = S == null ? 0 : Dn(S);
        return Q < 0 && (Q = ea(V + Q, 0)), Fd(u, Ao(g, 3), Q);
      }
      function sl(u, g, S) {
        var V = u == null ? 0 : u.length;
        if (!V)
          return -1;
        var Q = V - 1;
        return S !== N && (Q = Dn(S), Q = S < 0 ? ea(V + Q, 0) : Nr(Q, V - 1)), Fd(u, Ao(g, 3), Q, !0);
      }
      function kg(u) {
        var g = u == null ? 0 : u.length;
        return g ? $a(u, 1) : [];
      }
      function fb(u) {
        var g = u == null ? 0 : u.length;
        return g ? $a(u, lo) : [];
      }
      function _g(u, g) {
        var S = u == null ? 0 : u.length;
        return S ? (g = g === N ? 1 : Dn(g), $a(u, g)) : [];
      }
      function gm(u) {
        for (var g = -1, S = u == null ? 0 : u.length, V = {}; ++g < S; ) {
          var Q = u[g];
          V[Q[0]] = Q[1];
        }
        return V;
      }
      function mb(u) {
        return u && u.length ? u[0] : N;
      }
      function hm(u, g, S) {
        var V = u == null ? 0 : u.length;
        if (!V)
          return -1;
        var Q = S == null ? 0 : Dn(S);
        return Q < 0 && (Q = ea(V + Q, 0)), ia(u, g, Q);
      }
      function Bp(u) {
        var g = u == null ? 0 : u.length;
        return g ? Oo(u, 0, -1) : [];
      }
      var Lp = or(function(u) {
        var g = Ea(u, Af);
        return g.length && g[0] === u[0] ? hl(g) : [];
      }), pb = or(function(u) {
        var g = Ii(u), S = Ea(u, Af);
        return g === Ii(S) ? g = N : S.pop(), S.length && S[0] === u[0] ? hl(S, Ao(g, 2)) : [];
      }), gb = or(function(u) {
        var g = Ii(u), S = Ea(u, Af);
        return g = typeof g == "function" ? g : N, g && S.pop(), S.length && S[0] === u[0] ? hl(S, N, g) : [];
      });
      function gs(u, g) {
        return u == null ? "" : pr.call(u, g);
      }
      function Ii(u) {
        var g = u == null ? 0 : u.length;
        return g ? u[g - 1] : N;
      }
      function vh(u, g, S) {
        var V = u == null ? 0 : u.length;
        if (!V)
          return -1;
        var Q = V;
        return S !== N && (Q = Dn(S), Q = Q < 0 ? ea(V + Q, 0) : Nr(Q, V - 1)), g === g ? lg(u, g, Q) : Fd(u, $d, Q, !0);
      }
      function bm(u, g) {
        return u && u.length ? uo(u, Dn(g)) : N;
      }
      var Pf = or(jy);
      function jy(u, g) {
        return u && u.length && g && g.length ? Ha(u, g) : u;
      }
      function Gl(u, g, S) {
        return u && u.length && g && g.length ? Ha(u, g, Ao(S, 2)) : u;
      }
      function Ja(u, g, S) {
        return u && u.length && g && g.length ? Ha(u, g, N, S) : u;
      }
      var X1 = Nf(function(u, g) {
        var S = u == null ? 0 : u.length, V = lm(u, g);
        return Xa(u, Ea(g, function(Q) {
          return nf(Q, S) ? +Q : Q;
        }).sort(pg)), V;
      });
      function ym(u, g) {
        var S = [];
        if (!(u && u.length))
          return S;
        var V = -1, Q = [], we = u.length;
        for (g = Ao(g, 3); ++V < we; ) {
          var Be = u[V];
          g(Be, V, u) && (S.push(Be), Q.push(V));
        }
        return Xa(u, Q), S;
      }
      function Pp(u) {
        return u == null ? u : Ol.call(u);
      }
      function Xm(u, g, S) {
        var V = u == null ? 0 : u.length;
        return V ? (S && typeof S != "number" && Pi(u, g, S) ? (g = 0, S = V) : (g = g == null ? 0 : Dn(g), S = S === N ? V : Dn(S)), Oo(u, g, S)) : [];
      }
      function hb(u, g) {
        return xi(u, g);
      }
      function bb(u, g, S) {
        return vr(u, g, Ao(S, 2));
      }
      function Zy(u, g) {
        var S = u == null ? 0 : u.length;
        if (S) {
          var V = xi(u, g);
          if (V < S && xd(u[V], g))
            return V;
        }
        return -1;
      }
      function Cw(u, g) {
        return xi(u, g, !0);
      }
      function Cg(u, g, S) {
        return vr(u, g, Ao(S, 2), !0);
      }
      function Wy(u, g) {
        var S = u == null ? 0 : u.length;
        if (S) {
          var V = xi(u, g, !0) - 1;
          if (xd(u[V], g))
            return V;
        }
        return -1;
      }
      function J1(u) {
        return u && u.length ? fg(u) : [];
      }
      function Sw(u, g) {
        return u && u.length ? fg(u, Ao(g, 2)) : [];
      }
      function yb(u) {
        var g = u == null ? 0 : u.length;
        return g ? Oo(u, 1, g) : [];
      }
      function Rc(u, g, S) {
        return u && u.length ? (g = S || g === N ? 1 : Dn(g), Oo(u, 0, g < 0 ? 0 : g)) : [];
      }
      function Bl(u, g, S) {
        var V = u == null ? 0 : u.length;
        return V ? (g = S || g === N ? 1 : Dn(g), g = V - g, Oo(u, g < 0 ? 0 : g, V)) : [];
      }
      function vb(u, g) {
        return u && u.length ? zu(u, Ao(g, 3), !1, !0) : [];
      }
      function xb(u, g) {
        return u && u.length ? zu(u, Ao(g, 3)) : [];
      }
      var sf = or(function(u) {
        return nl($a(u, 1, Ua, !0));
      }), xh = or(function(u) {
        var g = Ii(u);
        return Ua(g) && (g = N), nl($a(u, 1, Ua, !0), Ao(g, 2));
      }), Ru = or(function(u) {
        var g = Ii(u);
        return g = typeof g == "function" ? g : N, nl($a(u, 1, Ua, !0), N, g);
      });
      function If(u) {
        return u && u.length ? nl(u) : [];
      }
      function Jm(u, g) {
        return u && u.length ? nl(u, Ao(g, 2)) : [];
      }
      function vm(u, g) {
        return g = typeof g == "function" ? g : N, u && u.length ? nl(u, N, g) : [];
      }
      function xm(u) {
        if (!(u && u.length))
          return [];
        var g = 0;
        return u = Pc(u, function(S) {
          if (Ua(S))
            return g = ea(S.length, g), !0;
        }), Vr(g, function(S) {
          return Ea(u, Zs(S));
        });
      }
      function yd(u, g) {
        if (!(u && u.length))
          return [];
        var S = xm(u);
        return g == null ? S : Ea(S, function(V) {
          return ns(g, N, V);
        });
      }
      var Sg = or(function(u, g) {
        return Ua(u) ? Io(u, g) : [];
      }), wh = or(function(u) {
        return mg(Pc(u, Ua));
      }), wb = or(function(u) {
        var g = Ii(u);
        return Ua(g) && (g = N), mg(Pc(u, Ua), Ao(g, 2));
      }), Kl = or(function(u) {
        var g = Ii(u);
        return g = typeof g == "function" ? g : N, mg(Pc(u, Ua), N, g);
      }), qy = or(xm);
      function Gy(u, g) {
        return fm(u || [], g || [], Uc);
      }
      function kb(u, g) {
        return fm(u || [], g || [], fd);
      }
      var kv = or(function(u) {
        var g = u.length, S = g > 1 ? u[g - 1] : N;
        return S = typeof S == "function" ? (u.pop(), S) : N, yd(u, S);
      });
      function kh(u) {
        var g = de(u);
        return g.__chain__ = !0, g;
      }
      function Ky(u, g) {
        return g(u), u;
      }
      function wm(u, g) {
        return g(u);
      }
      var km = Nf(function(u) {
        var g = u.length, S = g ? u[0] : 0, V = this.__wrapped__, Q = function(we) {
          return lm(we, u);
        };
        return g > 1 || this.__actions__.length || !(V instanceof Yo) || !nf(S) ? this.thru(Q) : (V = V.slice(S, +S + (g ? 1 : 0)), V.__actions__.push({
          func: wm,
          args: [Q],
          thisArg: N
        }), new ls(V, this.__chain__).thru(function(we) {
          return g && !we.length && we.push(N), we;
        }));
      });
      function Q1() {
        return kh(this);
      }
      function _b() {
        return new ls(this.value(), this.__chain__);
      }
      function Cb() {
        this.__values__ === N && (this.__values__ = ja(this.value()));
        var u = this.__index__ >= this.__values__.length, g = u ? N : this.__values__[this.__index__++];
        return { done: u, value: g };
      }
      function _m() {
        return this;
      }
      function Qm(u) {
        for (var g, S = this; S instanceof Oc; ) {
          var V = bh(S);
          V.__index__ = 0, V.__values__ = N, g ? Q.__wrapped__ = V : g = V;
          var Q = V;
          S = S.__wrapped__;
        }
        return Q.__wrapped__ = u, g;
      }
      function Sb() {
        var u = this.__wrapped__;
        if (u instanceof Yo) {
          var g = u;
          return this.__actions__.length && (g = new Yo(this)), g = g.reverse(), g.__actions__.push({
            func: wm,
            args: [Pp],
            thisArg: N
          }), new ls(g, this.__chain__);
        }
        return this.thru(Pp);
      }
      function _h() {
        return dm(this.__wrapped__, this.__actions__);
      }
      var ep = Df(function(u, g, S) {
        qr.call(u, S) ? ++u[S] : Dl(u, S, 1);
      });
      function tp(u, g, S) {
        var V = ir(u) ? Cp : zp;
        return S && Pi(u, g, S) && (g = N), V(u, Ao(g, 3));
      }
      function Ip(u, g) {
        var S = ir(u) ? Pc : Bo;
        return S(u, Ao(g, 3));
      }
      var af = qm(pm), np = qm(sl);
      function _v(u, g) {
        return $a(lf(u, g), 1);
      }
      function Ch(u, g) {
        return $a(lf(u, g), lo);
      }
      function op(u, g, S) {
        return S = S === N ? 1 : Dn(S), $a(lf(u, g), S);
      }
      function Fp(u, g) {
        var S = ir(u) ? Xi : pn;
        return S(u, Ao(g, 3));
      }
      function Eb(u, g) {
        var S = ir(u) ? Id : Kd;
        return S(u, Ao(g, 3));
      }
      var Yy = Df(function(u, g, S) {
        qr.call(u, S) ? u[S].push(g) : Dl(u, S, [g]);
      });
      function Xy(u, g, S, V) {
        u = $i(u) ? u : Up(u), S = S && !V ? Dn(S) : 0;
        var Q = u.length;
        return S < 0 && (S = ea(Q + S, 0)), Un(u) ? S <= Q && u.indexOf(g, S) > -1 : !!Q && ia(u, g, S) > -1;
      }
      var Ll = or(function(u, g, S) {
        var V = -1, Q = typeof g == "function", we = $i(u) ? vt(u.length) : [];
        return pn(u, function(Be) {
          we[++V] = Q ? ns(g, Be, S) : tl(Be, g, S);
        }), we;
      }), Tb = Df(function(u, g, S) {
        Dl(u, S, g);
      });
      function lf(u, g) {
        var S = ir(u) ? Ea : De;
        return S(u, Ao(g, 3));
      }
      function Nu(u, g, S, V) {
        return u == null ? [] : (ir(g) || (g = g == null ? [] : [g]), S = V ? N : S, ir(S) || (S = S == null ? [] : [S]), ks(u, g, S));
      }
      var Jy = Df(function(u, g, S) {
        u[S ? 0 : 1].push(g);
      }, function() {
        return [[], []];
      });
      function Sh(u, g, S) {
        var V = ir(u) ? ig : rm, Q = arguments.length < 3;
        return V(u, Ao(g, 4), S, Q, pn);
      }
      function rp(u, g, S) {
        var V = ir(u) ? eu : rm, Q = arguments.length < 3;
        return V(u, Ao(g, 4), S, Q, Kd);
      }
      function sp(u, g) {
        var S = ir(u) ? Pc : Bo;
        return S(u, Pl(Ao(g, 3)));
      }
      function zb(u) {
        var g = ir(u) ? ru : jm;
        return g(u);
      }
      function Ob(u, g, S) {
        (S ? Pi(u, g, S) : g === N) ? g = 1 : g = Dn(g);
        var V = ir(u) ? sh : dd;
        return V(u, g);
      }
      function Cm(u) {
        var g = ir(u) ? Cu : md;
        return g(u);
      }
      function ap(u) {
        if (u == null)
          return 0;
        if ($i(u))
          return Un(u) ? wu(u) : u.length;
        var g = Tr(u);
        return g == So || g == xn ? u.size : R(u).length;
      }
      function Eh(u, g, S) {
        var V = ir(u) ? om : Sr;
        return S && Pi(u, g, S) && (g = N), V(u, Ao(g, 3));
      }
      var ip = or(function(u, g) {
        if (u == null)
          return [];
        var S = g.length;
        return S > 1 && Pi(u, g[0], g[1]) ? g = [] : S > 2 && Pi(g[0], g[1], g[2]) && (g = [g[0]]), ks(u, $a(g, 1), []);
      }), Th = Lm || function() {
        return Ga.Date.now();
      };
      function zh(u, g) {
        if (typeof g != "function")
          throw new Ps(he);
        return u = Dn(u), function() {
          if (--u < 1)
            return g.apply(this, arguments);
        };
      }
      function Eg(u, g, S) {
        return g = S ? N : g, g = u && g == null ? u.length : g, mc(u, We, N, N, N, N, g);
      }
      function Ab(u, g) {
        var S;
        if (typeof g != "function")
          throw new Ps(he);
        return u = Dn(u), function() {
          return --u > 0 && (S = g.apply(this, arguments)), u <= 1 && (g = N), S;
        };
      }
      var $p = or(function(u, g, S) {
        var V = Gt;
        if (S.length) {
          var Q = Oi(S, Du($p));
          V |= wt;
        }
        return mc(u, V, g, S, Q);
      }), Ff = or(function(u, g, S) {
        var V = Gt | gt;
        if (S.length) {
          var Q = Oi(S, Du(Ff));
          V |= wt;
        }
        return mc(g, V, u, S, Q);
      });
      function Sm(u, g, S) {
        g = S ? N : g;
        var V = mc(u, Ot, N, N, N, N, N, g);
        return V.placeholder = Sm.placeholder, V;
      }
      function Tg(u, g, S) {
        g = S ? N : g;
        var V = mc(u, Ee, N, N, N, N, N, g);
        return V.placeholder = Tg.placeholder, V;
      }
      function Db(u, g, S) {
        var V, Q, we, Be, Ve, ot, Yt = 0, Kt = !1, dn = !1, Kn = !0;
        if (typeof u != "function")
          throw new Ps(he);
        g = yl(g) || 0, Ce(S) && (Kt = !!S.leading, dn = "maxWait" in S, we = dn ? ea(yl(S.maxWait) || 0, g) : we, Kn = "trailing" in S ? !!S.trailing : Kn);
        function No(al) {
          var Wc = V, _a = Q;
          return V = Q = N, Yt = al, Be = u.apply(_a, Wc), Be;
        }
        function sr(al) {
          return Yt = al, Ve = mm(Jt, g), Kt ? No(al) : Be;
        }
        function Or(al) {
          var Wc = al - ot, _a = al - Yt, ak = g - Wc;
          return dn ? Nr(ak, we - _a) : ak;
        }
        function Wo(al) {
          var Wc = al - ot, _a = al - Yt;
          return ot === N || Wc >= g || Wc < 0 || dn && _a >= we;
        }
        function Jt() {
          var al = Th();
          if (Wo(al))
            return bs(al);
          Ve = mm(Jt, Or(al));
        }
        function bs(al) {
          return Ve = N, Kn && V ? No(al) : (V = Q = N, Be);
        }
        function Nc() {
          Ve !== N && Os(Ve), Yt = 0, V = ot = Q = Ve = N;
        }
        function Mc() {
          return Ve === N ? Be : bs(Th());
        }
        function Fu() {
          var al = Th(), Wc = Wo(al);
          if (V = arguments, Q = this, ot = al, Wc) {
            if (Ve === N)
              return sr(ot);
            if (dn)
              return Os(Ve), Ve = mm(Jt, g), No(ot);
          }
          return Ve === N && (Ve = mm(Jt, g)), Be;
        }
        return Fu.cancel = Nc, Fu.flush = Mc, Fu;
      }
      var vd = or(function(u, g) {
        return Sf(u, 1, g);
      }), Hp = or(function(u, g, S) {
        return Sf(u, yl(g) || 0, S);
      });
      function zg(u) {
        return mc(u, ko);
      }
      function zo(u, g) {
        if (typeof u != "function" || g != null && typeof g != "function")
          throw new Ps(he);
        var S = function() {
          var V = arguments, Q = g ? g.apply(this, V) : V[0], we = S.cache;
          if (we.has(Q))
            return we.get(Q);
          var Be = u.apply(this, V);
          return S.cache = we.set(Q, Be) || we, Be;
        };
        return S.cache = new (zo.Cache || ws)(), S;
      }
      zo.Cache = ws;
      function Pl(u) {
        if (typeof u != "function")
          throw new Ps(he);
        return function() {
          var g = arguments;
          switch (g.length) {
            case 0:
              return !u.call(this);
            case 1:
              return !u.call(this, g[0]);
            case 2:
              return !u.call(this, g[0], g[1]);
            case 3:
              return !u.call(this, g[0], g[1], g[2]);
          }
          return !u.apply(this, g);
        };
      }
      function Og(u) {
        return Ab(2, u);
      }
      var nt = Ry(function(u, g) {
        g = g.length == 1 && ir(g[0]) ? Ea(g[0], Js(Ao())) : Ea($a(g, 1), Js(Ao()));
        var S = g.length;
        return or(function(V) {
          for (var Q = -1, we = Nr(V.length, S); ++Q < we; )
            V[Q] = g[Q].call(this, V[Q]);
          return ns(u, this, V);
        });
      }), Ag = or(function(u, g) {
        var S = Oi(g, Du(Ag));
        return mc(u, wt, N, g, S);
      }), Rb = or(function(u, g) {
        var S = Oi(g, Du(Rb));
        return mc(u, Se, N, g, S);
      }), e0 = Nf(function(u, g) {
        return mc(u, Cn, N, N, N, g);
      });
      function Dg(u, g) {
        if (typeof u != "function")
          throw new Ps(he);
        return g = g === N ? g : Dn(g), or(u, g);
      }
      function Mu(u, g) {
        if (typeof u != "function")
          throw new Ps(he);
        return g = g == null ? 0 : ea(Dn(g), 0), or(function(S) {
          var V = S[g], Q = gd(S, 0, g);
          return V && yu(Q, V), ns(u, this, Q);
        });
      }
      function Rg(u, g, S) {
        var V = !0, Q = !0;
        if (typeof u != "function")
          throw new Ps(he);
        return Ce(S) && (V = "leading" in S ? !!S.leading : V, Q = "trailing" in S ? !!S.trailing : Q), Db(u, g, {
          leading: V,
          maxWait: g,
          trailing: Q
        });
      }
      function Nb(u) {
        return Eg(u, 1);
      }
      function Qy(u, g) {
        return Ag(ah(g), u);
      }
      function Oh() {
        if (!arguments.length)
          return [];
        var u = arguments[0];
        return ir(u) ? u : [u];
      }
      function Mb(u) {
        return Rl(u, it);
      }
      function e1(u, g) {
        return g = typeof g == "function" ? g : N, Rl(u, it, g);
      }
      function t0(u) {
        return Rl(u, yt | it);
      }
      function Bb(u, g) {
        return g = typeof g == "function" ? g : N, Rl(u, yt | it, g);
      }
      function n0(u, g) {
        return g == null || Kr(u, g, Yl(g));
      }
      function xd(u, g) {
        return u === g || u !== u && g !== g;
      }
      var Cv = bg(Xd), ln = bg(function(u, g) {
        return u >= g;
      }), pa = cm(function() {
        return arguments;
      }()) ? cm : function(u) {
        return ge(u) && qr.call(u, "callee") && !bi.call(u, "callee");
      }, ir = vt.isArray, Fi = kp ? Js(kp) : Eu;
      function $i(u) {
        return u != null && ve(u.length) && !Y(u);
      }
      function Ua(u) {
        return ge(u) && $i(u);
      }
      function Lb(u) {
        return u === !0 || u === !1 || ge(u) && jl(u) == K;
      }
      var wd = jd || m0, p = oh ? Js(oh) : Jd;
      function y(u) {
        return ge(u) && u.nodeType === 1 && !Lt(u);
      }
      function _(u) {
        if (u == null)
          return !0;
        if ($i(u) && (ir(u) || typeof u == "string" || typeof u.splice == "function" || wd(u) || Gn(u) || pa(u)))
          return !u.length;
        var g = Tr(u);
        if (g == So || g == xn)
          return !u.size;
        if (Bf(u))
          return !R(u).length;
        for (var S in u)
          if (qr.call(u, S))
            return !1;
        return !0;
      }
      function T(u, g) {
        return Tu(u, g);
      }
      function P(u, g, S) {
        S = typeof S == "function" ? S : N;
        var V = S ? S(u, g) : N;
        return V === N ? Tu(u, g, N, S) : !!V;
      }
      function I(u) {
        if (!ge(u))
          return !1;
        var g = jl(u);
        return g == er || g == Zi || typeof u.message == "string" && typeof u.name == "string" && !Lt(u);
      }
      function j(u) {
        return typeof u == "number" && Ka(u);
      }
      function Y(u) {
        if (!Ce(u))
          return !1;
        var g = jl(u);
        return g == Qr || g == nc || g == Mo || g == It;
      }
      function ne(u) {
        return typeof u == "number" && u == Dn(u);
      }
      function ve(u) {
        return typeof u == "number" && u > -1 && u % 1 == 0 && u <= dt;
      }
      function Ce(u) {
        var g = typeof u;
        return u != null && (g == "object" || g == "function");
      }
      function ge(u) {
        return u != null && typeof u == "object";
      }
      var Te = Ht ? Js(Ht) : um;
      function Ae(u, g) {
        return u === g || hn(u, g, cb(g));
      }
      function Ge(u, g, S) {
        return S = typeof S == "function" ? S : N, hn(u, g, cb(g), S);
      }
      function $e(u) {
        return xt(u) && u != +u;
      }
      function lt(u) {
        if (wg(u))
          throw new Fo(ce);
        return Op(u);
      }
      function pt(u) {
        return u === null;
      }
      function Bt(u) {
        return u == null;
      }
      function xt(u) {
        return typeof u == "number" || ge(u) && jl(u) == cr;
      }
      function Lt(u) {
        if (!ge(u) || jl(u) != ut)
          return !1;
        var g = Ta(u);
        if (g === null)
          return !0;
        var S = qr.call(g, "constructor") && g.constructor;
        return typeof S == "function" && S instanceof S && Tc.call(S) == am;
      }
      var Vt = Pd ? Js(Pd) : Vm;
      function rn(u) {
        return ne(u) && u >= -dt && u <= dt;
      }
      var Vn = _p ? Js(_p) : zf;
      function Un(u) {
        return typeof u == "string" || !ir(u) && ge(u) && jl(u) == co;
      }
      function Do(u) {
        return typeof u == "symbol" || ge(u) && jl(u) == Ko;
      }
      var Gn = ed ? Js(ed) : tb;
      function Ro(u) {
        return u === N;
      }
      function xo(u) {
        return ge(u) && Tr(u) == Ra;
      }
      function zr(u) {
        return ge(u) && jl(u) == Mr;
      }
      var Wt = bg(se), Hi = bg(function(u, g) {
        return u <= g;
      });
      function ja(u) {
        if (!u)
          return [];
        if ($i(u))
          return Un(u) ? ri(u) : Va(u);
        if (ua && u[ua])
          return To(u[ua]());
        var g = Tr(u), S = g == So ? ca : g == xn ? Vd : Up;
        return S(u);
      }
      function ai(u) {
        if (!u)
          return u === 0 ? u : 0;
        if (u = yl(u), u === lo || u === -lo) {
          var g = u < 0 ? -1 : 1;
          return g * Bn;
        }
        return u === u ? u : 0;
      }
      function Dn(u) {
        var g = ai(u), S = g % 1;
        return g === g ? S ? g - S : g : 0;
      }
      function ii(u) {
        return u ? cs(Dn(u), 0, Tt) : 0;
      }
      function yl(u) {
        if (typeof u == "number")
          return u;
        if (Do(u))
          return jr;
        if (Ce(u)) {
          var g = typeof u.valueOf == "function" ? u.valueOf() : u;
          u = Ce(g) ? g + "" : g;
        }
        if (typeof u != "string")
          return u === 0 ? u : +u;
        u = Qi(u);
        var S = ra.test(u);
        return S || vf.test(u) ? nr(u.slice(2), S ? 2 : 8) : pi.test(u) ? jr : +u;
      }
      function Ng(u) {
        return hd(u, Lu(u));
      }
      function Ah(u) {
        return u ? cs(Dn(u), -dt, dt) : u === 0 ? u : 0;
      }
      function hs(u) {
        return u == null ? "" : _s(u);
      }
      var Dh = Qd(function(u, g) {
        if (Bf(g) || $i(g)) {
          hd(g, Yl(g), u);
          return;
        }
        for (var S in g)
          qr.call(g, S) && Uc(u, S, g[S]);
      }), li = Qd(function(u, g) {
        hd(g, Lu(g), u);
      }), Mg = Qd(function(u, g, S, V) {
        hd(g, Lu(g), u, V);
      }), Ew = Qd(function(u, g, S, V) {
        hd(g, Yl(g), u, V);
      }), Sv = Nf(lm);
      function Tw(u, g) {
        var S = Hc(u);
        return g == null ? S : qd(S, g);
      }
      var J2 = or(function(u, g) {
        u = Lr(u);
        var S = -1, V = g.length, Q = V > 2 ? g[2] : N;
        for (Q && Pi(g[0], g[1], Q) && (V = 1); ++S < V; )
          for (var we = g[S], Be = Lu(we), Ve = -1, ot = Be.length; ++Ve < ot; ) {
            var Yt = Be[Ve], Kt = u[Yt];
            (Kt === N || xd(Kt, Ec[Yt]) && !qr.call(u, Yt)) && (u[Yt] = we[Yt]);
          }
        return u;
      }), Q2 = or(function(u) {
        return u.push(N, dh), ns(Xn, N, u);
      });
      function Bu(u, g) {
        return Eo(u, Ao(g, 3), dc);
      }
      function hc(u, g) {
        return Eo(u, Ao(g, 3), ld);
      }
      function Pb(u, g) {
        return u == null ? u : $m(u, Ao(g, 3), Lu);
      }
      function zw(u, g) {
        return u == null ? u : ft(u, Ao(g, 3), Lu);
      }
      function eC(u, g) {
        return u && dc(u, Ao(g, 3));
      }
      function rr(u, g) {
        return u && ld(u, Ao(g, 3));
      }
      function tC(u) {
        return u == null ? [] : cd(u, Yl(u));
      }
      function Ow(u) {
        return u == null ? [] : cd(u, Lu(u));
      }
      function t1(u, g, S) {
        var V = u == null ? N : Yd(u, g);
        return V === N ? S : V;
      }
      function nC(u, g) {
        return u != null && Zl(u, g, ss);
      }
      function n1(u, g) {
        return u != null && Zl(u, g, ud);
      }
      var Aw = hg(function(u, g, S) {
        g != null && typeof g.toString != "function" && (g = Ud.call(g)), u[g] = S;
      }, l1(Iu)), oC = hg(function(u, g, S) {
        g != null && typeof g.toString != "function" && (g = Ud.call(g)), qr.call(u, g) ? u[g].push(S) : u[g] = [S];
      }, Ao), o0 = or(tl);
      function Yl(u) {
        return $i(u) ? ug(u) : R(u);
      }
      function Lu(u) {
        return $i(u) ? ug(u, !0) : q(u);
      }
      function rC(u, g) {
        var S = {};
        return g = Ao(g, 3), dc(u, function(V, Q, we) {
          Dl(S, g(V, Q, we), V);
        }), S;
      }
      function Dw(u, g) {
        var S = {};
        return g = Ao(g, 3), dc(u, function(V, Q, we) {
          Dl(S, Q, g(V, Q, we));
        }), S;
      }
      var sC = Qd(function(u, g, S) {
        on(u, g, S);
      }), Xn = Qd(function(u, g, S, V) {
        on(u, g, S, V);
      }), Ev = Nf(function(u, g) {
        var S = {};
        if (u == null)
          return S;
        var V = !1;
        g = Ea(g, function(we) {
          return we = Zm(we, u), V || (V = we.length > 1), we;
        }), hd(u, tf(u), S), V && (S = Rl(S, yt | jt | it, Ly));
        for (var Q = g.length; Q--; )
          jc(S, g[Q]);
        return S;
      });
      function o1(u, g) {
        return r0(u, Pl(Ao(g)));
      }
      var Tv = Nf(function(u, g) {
        return u == null ? {} : _o(u, g);
      });
      function r0(u, g) {
        if (u == null)
          return {};
        var S = Ea(tf(u), function(V) {
          return [V];
        });
        return g = Ao(g), fr(u, S, function(V, Q) {
          return g(V, Q[0]);
        });
      }
      function Rw(u, g, S) {
        g = Zm(g, u);
        var V = -1, Q = g.length;
        for (Q || (Q = 1, u = N); ++V < Q; ) {
          var we = u == null ? N : u[ql(g[V])];
          we === N && (V = Q, we = S), u = Y(we) ? we.call(u) : we;
        }
        return u;
      }
      function Rh(u, g, S) {
        return u == null ? u : fd(u, g, S);
      }
      function Nw(u, g, S, V) {
        return V = typeof V == "function" ? V : N, u == null ? u : fd(u, g, S, V);
      }
      var s0 = ol(Yl), Mw = ol(Lu);
      function mr(u, g, S) {
        var V = ir(u), Q = V || wd(u) || Gn(u);
        if (g = Ao(g, 4), S == null) {
          var we = u && u.constructor;
          Q ? S = V ? new we() : [] : Ce(u) ? S = Y(we) ? Hc(Ta(u)) : {} : S = {};
        }
        return (Q ? Xi : dc)(u, function(Be, Ve, ot) {
          return g(S, Be, Ve, ot);
        }), S;
      }
      function aC(u, g) {
        return u == null ? !0 : jc(u, g);
      }
      function Vp(u, g, S) {
        return u == null ? u : pd(u, g, ah(S));
      }
      function lp(u, g, S, V) {
        return V = typeof V == "function" ? V : N, u == null ? u : pd(u, g, ah(S), V);
      }
      function Up(u) {
        return u == null ? [] : La(u, Yl(u));
      }
      function Pu(u) {
        return u == null ? [] : La(u, Lu(u));
      }
      function Ib(u, g, S) {
        return S === N && (S = g, g = N), S !== N && (S = yl(S), S = S === S ? S : 0), g !== N && (g = yl(g), g = g === g ? g : 0), cs(yl(u), g, S);
      }
      function r1(u, g, S) {
        return g = ai(g), S === N ? (S = g, g = 0) : S = ai(S), u = yl(u), eb(u, g, S);
      }
      function a0(u, g, S) {
        if (S && typeof S != "boolean" && Pi(u, g, S) && (g = S = N), S === N && (typeof g == "boolean" ? (S = g, g = N) : typeof u == "boolean" && (S = u, u = N)), u === N && g === N ? (u = 0, g = 1) : (u = ai(u), g === N ? (g = u, u = 0) : g = ai(g)), u > g) {
          var V = u;
          u = g, g = V;
        }
        if (S || u % 1 || g % 1) {
          var Q = Ya();
          return Nr(u + Q * (g - u + ml("1e-" + ((Q + "").length - 1))), g);
        }
        return su(u, g);
      }
      var Fb = Wm(function(u, g, S) {
        return g = g.toLowerCase(), u + (S ? Bw(g) : g);
      });
      function Bw(u) {
        return i1(hs(u).toLowerCase());
      }
      function Lw(u) {
        return u = hs(u), u && u.replace(tm, la).replace(te, "");
      }
      function iC(u, g, S) {
        u = hs(u), g = _s(g);
        var V = u.length;
        S = S === N ? V : cs(Dn(S), 0, V);
        var Q = S;
        return S -= g.length, S >= 0 && u.slice(S, Q) == g;
      }
      function Pw(u) {
        return u = hs(u), u && Qu.test(u) ? u.replace(mi, od) : u;
      }
      function lr(u) {
        return u = hs(u), u && qi.test(u) ? u.replace(Yn, "\\$&") : u;
      }
      var $f = Wm(function(u, g, S) {
        return u + (S ? "-" : "") + g.toLowerCase();
      }), cp = Wm(function(u, g, S) {
        return u + (S ? " " : "") + g.toLowerCase();
      }), lC = ab("toLowerCase");
      function s1(u, g, S) {
        u = hs(u), g = Dn(g);
        var V = g ? wu(u) : 0;
        if (!g || V >= g)
          return u;
        var Q = (g - V) / 2;
        return Vo(Ia(Q), S) + u + Vo(Pa(Q), S);
      }
      function gr(u, g, S) {
        u = hs(u), g = Dn(g);
        var V = g ? wu(u) : 0;
        return g && V < g ? u + Vo(g - V, S) : u;
      }
      function Iw(u, g, S) {
        u = hs(u), g = Dn(g);
        var V = g ? wu(u) : 0;
        return g && V < g ? Vo(g - V, S) + u : u;
      }
      function i0(u, g, S) {
        return S || g == null ? g = 0 : g && (g = +g), Vl(hs(u).replace(Ei, ""), g || 0);
      }
      function cC(u, g, S) {
        return (S ? Pi(u, g, S) : g === N) ? g = 1 : g = Dn(g), Of(hs(u), g);
      }
      function $b() {
        var u = arguments, g = hs(u[0]);
        return u.length < 3 ? g : g.replace(u[1], u[2]);
      }
      var Nh = Wm(function(u, g, S) {
        return u + (S ? "_" : "") + g.toLowerCase();
      });
      function Fw(u, g, S) {
        return S && typeof S != "number" && Pi(u, g, S) && (g = S = N), S = S === N ? Tt : S >>> 0, S ? (u = hs(u), u && (typeof g == "string" || g != null && !Vt(g)) && (g = _s(g), !g && vu(u)) ? gd(ri(u), 0, S) : u.split(g, S)) : [];
      }
      var uC = Wm(function(u, g, S) {
        return u + (S ? " " : "") + i1(g);
      });
      function dC(u, g, S) {
        return u = hs(u), S = S == null ? 0 : cs(Dn(S), 0, u.length), g = _s(g), u.slice(S, S + g.length) == g;
      }
      function a1(u, g, S) {
        var V = de.templateSettings;
        S && Pi(u, g, S) && (g = N), u = hs(u), g = Mg({}, g, V, uh);
        var Q = Mg({}, g.imports, V.imports, uh), we = Yl(Q), Be = La(Q, we), Ve, ot, Yt = 0, Kt = g.interpolate || Sl, dn = "__p += '", Kn = hi(
          (g.escape || Sl).source + "|" + Kt.source + "|" + (Kt === _l ? Ti : Sl).source + "|" + (g.evaluate || Sl).source + "|$",
          "g"
        ), No = "//# sourceURL=" + (qr.call(g, "sourceURL") ? (g.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++so + "]") + `
`;
        u.replace(Kn, function(Wo, Jt, bs, Nc, Mc, Fu) {
          return bs || (bs = Nc), dn += u.slice(Yt, Fu).replace(Nd, os), Jt && (Ve = !0, dn += `' +
__e(` + Jt + `) +
'`), Mc && (ot = !0, dn += `';
` + Mc + `;
__p += '`), bs && (dn += `' +
((__t = (` + bs + `)) == null ? '' : __t) +
'`), Yt = Fu + Wo.length, Wo;
        }), dn += `';
`;
        var sr = qr.call(g, "variable") && g.variable;
        if (!sr)
          dn = `with (obj) {
` + dn + `
}
`;
        else if (yf.test(sr))
          throw new Fo(pe);
        dn = (ot ? dn.replace(Si, "") : dn).replace(Nt, "$1").replace(fi, "$1;"), dn = "function(" + (sr || "obj") + `) {
` + (sr ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (Ve ? ", __e = _.escape" : "") + (ot ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + dn + `return __p
}`;
        var Or = Ov(function() {
          return ur(we, No + "return " + dn).apply(N, Be);
        });
        if (Or.source = dn, I(Or))
          throw Or;
        return Or;
      }
      function Hb(u) {
        return hs(u).toLowerCase();
      }
      function l0(u) {
        return hs(u).toUpperCase();
      }
      function $w(u, g, S) {
        if (u = hs(u), u && (S || g === N))
          return Qi(u);
        if (!u || !(g = _s(g)))
          return u;
        var V = ri(u), Q = ri(g), we = Hd(V, Q), Be = Ws(V, Q) + 1;
        return gd(V, we, Be).join("");
      }
      function fC(u, g, S) {
        if (u = hs(u), u && (S || g === N))
          return u.slice(0, Sp(u) + 1);
        if (!u || !(g = _s(g)))
          return u;
        var V = ri(u), Q = Ws(V, ri(g)) + 1;
        return gd(V, 0, Q).join("");
      }
      function Hw(u, g, S) {
        if (u = hs(u), u && (S || g === N))
          return u.replace(Ei, "");
        if (!u || !(g = _s(g)))
          return u;
        var V = ri(u), Q = Hd(V, ri(g));
        return gd(V, Q).join("");
      }
      function mC(u, g) {
        var S = jn, V = Xe;
        if (Ce(g)) {
          var Q = "separator" in g ? g.separator : Q;
          S = "length" in g ? Dn(g.length) : S, V = "omission" in g ? _s(g.omission) : V;
        }
        u = hs(u);
        var we = u.length;
        if (vu(u)) {
          var Be = ri(u);
          we = Be.length;
        }
        if (S >= we)
          return u;
        var Ve = S - wu(V);
        if (Ve < 1)
          return V;
        var ot = Be ? gd(Be, 0, Ve).join("") : u.slice(0, Ve);
        if (Q === N)
          return ot + V;
        if (Be && (Ve += ot.length - Ve), Vt(Q)) {
          if (u.slice(Ve).search(Q)) {
            var Yt, Kt = ot;
            for (Q.global || (Q = hi(Q.source, hs(wc.exec(Q)) + "g")), Q.lastIndex = 0; Yt = Q.exec(Kt); )
              var dn = Yt.index;
            ot = ot.slice(0, dn === N ? Ve : dn);
          }
        } else if (u.indexOf(_s(Q), Ve) != Ve) {
          var Kn = ot.lastIndexOf(Q);
          Kn > -1 && (ot = ot.slice(0, Kn));
        }
        return ot + V;
      }
      function Vw(u) {
        return u = hs(u), u && kr.test(u) ? u.replace(Zo, be) : u;
      }
      var zv = Wm(function(u, g, S) {
        return u + (S ? " " : "") + g.toUpperCase();
      }), i1 = ab("toUpperCase");
      function c0(u, g, S) {
        return u = hs(u), g = S ? N : g, g === N ? Cc(u) ? tu(u) : Ic(u) : u.match(g) || [];
      }
      var Ov = or(function(u, g) {
        try {
          return ns(u, N, g);
        } catch (S) {
          return I(S) ? S : new Fo(S);
        }
      }), Uw = Nf(function(u, g) {
        return Xi(g, function(S) {
          S = ql(S), Dl(u, S, $p(u[S], u));
        }), u;
      });
      function jw(u) {
        var g = u == null ? 0 : u.length, S = Ao();
        return u = g ? Ea(u, function(V) {
          if (typeof V[1] != "function")
            throw new Ps(he);
          return [S(V[0]), V[1]];
        }) : [], or(function(V) {
          for (var Q = -1; ++Q < g; ) {
            var we = u[Q];
            if (ns(we[0], this, V))
              return ns(we[1], this, V);
          }
        });
      }
      function u0(u) {
        return cc(Rl(u, yt));
      }
      function l1(u) {
        return function() {
          return u;
        };
      }
      function Zw(u, g) {
        return u == null || u !== u ? g : u;
      }
      var Ww = gg(), qw = gg(!0);
      function Iu(u) {
        return u;
      }
      function Vb(u) {
        return C(typeof u == "function" ? u : Rl(u, yt));
      }
      function pC(u) {
        return rt(Rl(u, yt));
      }
      function gC(u, g) {
        return Pt(u, Rl(g, yt));
      }
      var d0 = or(function(u, g) {
        return function(S) {
          return tl(S, u, g);
        };
      }), Gw = or(function(u, g) {
        return function(S) {
          return tl(u, S, g);
        };
      });
      function f0(u, g, S) {
        var V = Yl(g), Q = cd(g, V);
        S == null && !(Ce(g) && (Q.length || !V.length)) && (S = g, g = u, u = this, Q = cd(g, Yl(g)));
        var we = !(Ce(S) && "chain" in S) || !!S.chain, Be = Y(u);
        return Xi(Q, function(Ve) {
          var ot = g[Ve];
          u[Ve] = ot, Be && (u.prototype[Ve] = function() {
            var Yt = this.__chain__;
            if (we || Yt) {
              var Kt = u(this.__wrapped__), dn = Kt.__actions__ = Va(this.__actions__);
              return dn.push({ func: ot, args: arguments, thisArg: u }), Kt.__chain__ = Yt, Kt;
            }
            return ot.apply(u, yu([this.value()], arguments));
          });
        }), u;
      }
      function Av() {
        return Ga._ === this && (Ga._ = Ep), this;
      }
      function Dv() {
      }
      function hC(u) {
        return u = Dn(u), or(function(g) {
          return uo(g, u);
        });
      }
      var bC = Rp(Ea), yC = Rp(Cp), Rv = Rp(om);
      function Nv(u) {
        return xg(u) ? Zs(ql(u)) : as(u);
      }
      function Mv(u) {
        return function(g) {
          return u == null ? N : Yd(u, g);
        };
      }
      var c1 = bd(), Kw = bd(!0);
      function Ub() {
        return [];
      }
      function m0() {
        return !1;
      }
      function Yw() {
        return {};
      }
      function Xw() {
        return "";
      }
      function Jw() {
        return !0;
      }
      function vC(u, g) {
        if (u = Dn(u), u < 1 || u > dt)
          return [];
        var S = Tt, V = Nr(u, Tt);
        g = Ao(g), u -= Tt;
        for (var Q = Vr(V, g); ++S < u; )
          g(S);
        return Q;
      }
      function xC(u) {
        return ir(u) ? Ea(u, ql) : Do(u) ? [u] : Va(db(hs(u)));
      }
      function up(u) {
        var g = ++xa;
        return hs(u) + g;
      }
      var Qw = Au(function(u, g) {
        return u + g;
      }, 0), ek = My("ceil"), tk = Au(function(u, g) {
        return u / g;
      }, 1), nk = My("floor");
      function ok(u) {
        return u && u.length ? Ef(u, Iu, Xd) : N;
      }
      function wC(u, g) {
        return u && u.length ? Ef(u, Ao(g, 2), Xd) : N;
      }
      function p0(u) {
        return Ji(u, Iu);
      }
      function Bv(u, g) {
        return Ji(u, Ao(g, 2));
      }
      function jb(u) {
        return u && u.length ? Ef(u, Iu, se) : N;
      }
      function u1(u, g) {
        return u && u.length ? Ef(u, Ao(g, 2), se) : N;
      }
      var kC = Au(function(u, g) {
        return u * g;
      }, 1), Lv = My("round"), _C = Au(function(u, g) {
        return u - g;
      }, 0);
      function rk(u) {
        return u && u.length ? Ls(u, Iu) : 0;
      }
      function sk(u, g) {
        return u && u.length ? Ls(u, Ao(g, 2)) : 0;
      }
      return de.after = zh, de.ary = Eg, de.assign = Dh, de.assignIn = li, de.assignInWith = Mg, de.assignWith = Ew, de.at = Sv, de.before = Ab, de.bind = $p, de.bindAll = Uw, de.bindKey = Ff, de.castArray = Oh, de.chain = kh, de.chunk = wv, de.compact = Hy, de.concat = Vy, de.cond = jw, de.conforms = u0, de.constant = l1, de.countBy = ep, de.create = Tw, de.curry = Sm, de.curryRight = Tg, de.debounce = Db, de.defaults = J2, de.defaultsDeep = Q2, de.defer = vd, de.delay = Hp, de.difference = Uy, de.differenceBy = yh, de.differenceWith = Y1, de.drop = Km, de.dropRight = bl, de.dropRightWhile = Ym, de.dropWhile = Lf, de.fill = As, de.filter = Ip, de.flatMap = _v, de.flatMapDeep = Ch, de.flatMapDepth = op, de.flatten = kg, de.flattenDeep = fb, de.flattenDepth = _g, de.flip = zg, de.flow = Ww, de.flowRight = qw, de.fromPairs = gm, de.functions = tC, de.functionsIn = Ow, de.groupBy = Yy, de.initial = Bp, de.intersection = Lp, de.intersectionBy = pb, de.intersectionWith = gb, de.invert = Aw, de.invertBy = oC, de.invokeMap = Ll, de.iteratee = Vb, de.keyBy = Tb, de.keys = Yl, de.keysIn = Lu, de.map = lf, de.mapKeys = rC, de.mapValues = Dw, de.matches = pC, de.matchesProperty = gC, de.memoize = zo, de.merge = sC, de.mergeWith = Xn, de.method = d0, de.methodOf = Gw, de.mixin = f0, de.negate = Pl, de.nthArg = hC, de.omit = Ev, de.omitBy = o1, de.once = Og, de.orderBy = Nu, de.over = bC, de.overArgs = nt, de.overEvery = yC, de.overSome = Rv, de.partial = Ag, de.partialRight = Rb, de.partition = Jy, de.pick = Tv, de.pickBy = r0, de.property = Nv, de.propertyOf = Mv, de.pull = Pf, de.pullAll = jy, de.pullAllBy = Gl, de.pullAllWith = Ja, de.pullAt = X1, de.range = c1, de.rangeRight = Kw, de.rearg = e0, de.reject = sp, de.remove = ym, de.rest = Dg, de.reverse = Pp, de.sampleSize = Ob, de.set = Rh, de.setWith = Nw, de.shuffle = Cm, de.slice = Xm, de.sortBy = ip, de.sortedUniq = J1, de.sortedUniqBy = Sw, de.split = Fw, de.spread = Mu, de.tail = yb, de.take = Rc, de.takeRight = Bl, de.takeRightWhile = vb, de.takeWhile = xb, de.tap = Ky, de.throttle = Rg, de.thru = wm, de.toArray = ja, de.toPairs = s0, de.toPairsIn = Mw, de.toPath = xC, de.toPlainObject = Ng, de.transform = mr, de.unary = Nb, de.union = sf, de.unionBy = xh, de.unionWith = Ru, de.uniq = If, de.uniqBy = Jm, de.uniqWith = vm, de.unset = aC, de.unzip = xm, de.unzipWith = yd, de.update = Vp, de.updateWith = lp, de.values = Up, de.valuesIn = Pu, de.without = Sg, de.words = c0, de.wrap = Qy, de.xor = wh, de.xorBy = wb, de.xorWith = Kl, de.zip = qy, de.zipObject = Gy, de.zipObjectDeep = kb, de.zipWith = kv, de.entries = s0, de.entriesIn = Mw, de.extend = li, de.extendWith = Mg, f0(de, de), de.add = Qw, de.attempt = Ov, de.camelCase = Fb, de.capitalize = Bw, de.ceil = ek, de.clamp = Ib, de.clone = Mb, de.cloneDeep = t0, de.cloneDeepWith = Bb, de.cloneWith = e1, de.conformsTo = n0, de.deburr = Lw, de.defaultTo = Zw, de.divide = tk, de.endsWith = iC, de.eq = xd, de.escape = Pw, de.escapeRegExp = lr, de.every = tp, de.find = af, de.findIndex = pm, de.findKey = Bu, de.findLast = np, de.findLastIndex = sl, de.findLastKey = hc, de.floor = nk, de.forEach = Fp, de.forEachRight = Eb, de.forIn = Pb, de.forInRight = zw, de.forOwn = eC, de.forOwnRight = rr, de.get = t1, de.gt = Cv, de.gte = ln, de.has = nC, de.hasIn = n1, de.head = mb, de.identity = Iu, de.includes = Xy, de.indexOf = hm, de.inRange = r1, de.invoke = o0, de.isArguments = pa, de.isArray = ir, de.isArrayBuffer = Fi, de.isArrayLike = $i, de.isArrayLikeObject = Ua, de.isBoolean = Lb, de.isBuffer = wd, de.isDate = p, de.isElement = y, de.isEmpty = _, de.isEqual = T, de.isEqualWith = P, de.isError = I, de.isFinite = j, de.isFunction = Y, de.isInteger = ne, de.isLength = ve, de.isMap = Te, de.isMatch = Ae, de.isMatchWith = Ge, de.isNaN = $e, de.isNative = lt, de.isNil = Bt, de.isNull = pt, de.isNumber = xt, de.isObject = Ce, de.isObjectLike = ge, de.isPlainObject = Lt, de.isRegExp = Vt, de.isSafeInteger = rn, de.isSet = Vn, de.isString = Un, de.isSymbol = Do, de.isTypedArray = Gn, de.isUndefined = Ro, de.isWeakMap = xo, de.isWeakSet = zr, de.join = gs, de.kebabCase = $f, de.last = Ii, de.lastIndexOf = vh, de.lowerCase = cp, de.lowerFirst = lC, de.lt = Wt, de.lte = Hi, de.max = ok, de.maxBy = wC, de.mean = p0, de.meanBy = Bv, de.min = jb, de.minBy = u1, de.stubArray = Ub, de.stubFalse = m0, de.stubObject = Yw, de.stubString = Xw, de.stubTrue = Jw, de.multiply = kC, de.nth = bm, de.noConflict = Av, de.noop = Dv, de.now = Th, de.pad = s1, de.padEnd = gr, de.padStart = Iw, de.parseInt = i0, de.random = a0, de.reduce = Sh, de.reduceRight = rp, de.repeat = cC, de.replace = $b, de.result = Rw, de.round = Lv, de.runInContext = Le, de.sample = zb, de.size = ap, de.snakeCase = Nh, de.some = Eh, de.sortedIndex = hb, de.sortedIndexBy = bb, de.sortedIndexOf = Zy, de.sortedLastIndex = Cw, de.sortedLastIndexBy = Cg, de.sortedLastIndexOf = Wy, de.startCase = uC, de.startsWith = dC, de.subtract = _C, de.sum = rk, de.sumBy = sk, de.template = a1, de.times = vC, de.toFinite = ai, de.toInteger = Dn, de.toLength = ii, de.toLower = Hb, de.toNumber = yl, de.toSafeInteger = Ah, de.toString = hs, de.toUpper = l0, de.trim = $w, de.trimEnd = fC, de.trimStart = Hw, de.truncate = mC, de.unescape = Vw, de.uniqueId = up, de.upperCase = zv, de.upperFirst = i1, de.each = Fp, de.eachRight = Eb, de.first = mb, f0(de, function() {
        var u = {};
        return dc(de, function(g, S) {
          qr.call(de.prototype, S) || (u[S] = g);
        }), u;
      }(), { chain: !1 }), de.VERSION = W, Xi(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(u) {
        de[u].placeholder = de;
      }), Xi(["drop", "take"], function(u, g) {
        Yo.prototype[u] = function(S) {
          S = S === N ? 1 : ea(Dn(S), 0);
          var V = this.__filtered__ && !g ? new Yo(this) : this.clone();
          return V.__filtered__ ? V.__takeCount__ = Nr(S, V.__takeCount__) : V.__views__.push({
            size: Nr(S, Tt),
            type: u + (V.__dir__ < 0 ? "Right" : "")
          }), V;
        }, Yo.prototype[u + "Right"] = function(S) {
          return this.reverse()[u](S).reverse();
        };
      }), Xi(["filter", "map", "takeWhile"], function(u, g) {
        var S = g + 1, V = S == Et || S == mn;
        Yo.prototype[u] = function(Q) {
          var we = this.clone();
          return we.__iteratees__.push({
            iteratee: Ao(Q, 3),
            type: S
          }), we.__filtered__ = we.__filtered__ || V, we;
        };
      }), Xi(["head", "last"], function(u, g) {
        var S = "take" + (g ? "Right" : "");
        Yo.prototype[u] = function() {
          return this[S](1).value()[0];
        };
      }), Xi(["initial", "tail"], function(u, g) {
        var S = "drop" + (g ? "" : "Right");
        Yo.prototype[u] = function() {
          return this.__filtered__ ? new Yo(this) : this[S](1);
        };
      }), Yo.prototype.compact = function() {
        return this.filter(Iu);
      }, Yo.prototype.find = function(u) {
        return this.filter(u).head();
      }, Yo.prototype.findLast = function(u) {
        return this.reverse().find(u);
      }, Yo.prototype.invokeMap = or(function(u, g) {
        return typeof u == "function" ? new Yo(this) : this.map(function(S) {
          return tl(S, u, g);
        });
      }), Yo.prototype.reject = function(u) {
        return this.filter(Pl(Ao(u)));
      }, Yo.prototype.slice = function(u, g) {
        u = Dn(u);
        var S = this;
        return S.__filtered__ && (u > 0 || g < 0) ? new Yo(S) : (u < 0 ? S = S.takeRight(-u) : u && (S = S.drop(u)), g !== N && (g = Dn(g), S = g < 0 ? S.dropRight(-g) : S.take(g - u)), S);
      }, Yo.prototype.takeRightWhile = function(u) {
        return this.reverse().takeWhile(u).reverse();
      }, Yo.prototype.toArray = function() {
        return this.take(Tt);
      }, dc(Yo.prototype, function(u, g) {
        var S = /^(?:filter|find|map|reject)|While$/.test(g), V = /^(?:head|last)$/.test(g), Q = de[V ? "take" + (g == "last" ? "Right" : "") : g], we = V || /^find/.test(g);
        Q && (de.prototype[g] = function() {
          var Be = this.__wrapped__, Ve = V ? [1] : arguments, ot = Be instanceof Yo, Yt = Ve[0], Kt = ot || ir(Be), dn = function(Jt) {
            var bs = Q.apply(de, yu([Jt], Ve));
            return V && Kn ? bs[0] : bs;
          };
          Kt && S && typeof Yt == "function" && Yt.length != 1 && (ot = Kt = !1);
          var Kn = this.__chain__, No = !!this.__actions__.length, sr = we && !Kn, Or = ot && !No;
          if (!we && Kt) {
            Be = Or ? Be : new Yo(this);
            var Wo = u.apply(Be, Ve);
            return Wo.__actions__.push({ func: wm, args: [dn], thisArg: N }), new ls(Wo, Kn);
          }
          return sr && Or ? u.apply(this, Ve) : (Wo = this.thru(dn), sr ? V ? Wo.value()[0] : Wo.value() : Wo);
        });
      }), Xi(["pop", "push", "shift", "sort", "splice", "unshift"], function(u) {
        var g = Di[u], S = /^(?:push|sort|unshift)$/.test(u) ? "tap" : "thru", V = /^(?:pop|shift)$/.test(u);
        de.prototype[u] = function() {
          var Q = arguments;
          if (V && !this.__chain__) {
            var we = this.value();
            return g.apply(ir(we) ? we : [], Q);
          }
          return this[S](function(Be) {
            return g.apply(ir(Be) ? Be : [], Q);
          });
        };
      }), dc(Yo.prototype, function(u, g) {
        var S = de[g];
        if (S) {
          var V = S.name + "";
          qr.call(Ir, V) || (Ir[V] = []), Ir[V].push({ name: g, func: S });
        }
      }), Ir[ef(N, gt).name] = [{
        name: "wrapper",
        func: N
      }], Yo.prototype.clone = id, Yo.prototype.reverse = Ac, Yo.prototype.value = Cf, de.prototype.at = km, de.prototype.chain = Q1, de.prototype.commit = _b, de.prototype.next = Cb, de.prototype.plant = Qm, de.prototype.reverse = Sb, de.prototype.toJSON = de.prototype.valueOf = de.prototype.value = _h, de.prototype.first = de.prototype.head, ua && (de.prototype[ua] = _m), de;
    }, sd = _f();
    aa ? ((aa.exports = sd)._ = sd, Ld._ = sd) : Ga._ = sd;
  }).call(fT);
})(F5, F5.exports);
var gT = F5.exports;
const zG = /* @__PURE__ */ TG(gT), OG = {
  key: 1,
  class: "space-y-2 gray-300"
}, AG = { class: "flex" }, DG = ["for"], RG = ["id", "type", "value", "placeholder", "disabled", "onInput"], NG = ["onClick"], MG = {
  __name: "MultiInput",
  props: {
    modelValue: {},
    type: {},
    field: {},
    label: {},
    placeholder: {},
    disabled: {},
    canAdd: {
      type: Boolean,
      default: !0
    },
    taggable: {
      type: Boolean,
      default: !1
    },
    options: {
      type: Array,
      default: []
    }
  },
  emits: ["update:modelValue"],
  setup(v, { emit: L }) {
    const N = v, W = L, ue = Jr(Array.isArray(N.modelValue) ? N.modelValue : N.taggable && !N.modelValue ? [] : [N.modelValue]), ce = Qo(() => ue.value.map((yt) => N.label ? yt[N.label] + "_" + N.field + "_" + Math.random().toString(36).slice(2) : null)), he = Qo(() => ue.value.map((yt) => N.label ? yt[N.label] + " " + z8(N.field) : N.placeholder));
    function pe(yt) {
      ue.value.splice(yt, 1), W("update:modelValue", ue.value);
    }
    function Me(yt) {
      let jt = yt;
      N.field && (jt = zG.cloneDeep(ue.value[0]), jt[N.field] = yt), ue.value.push(jt), N.taggable && N.options.push(jt);
    }
    function Ze(yt, jt) {
      N.field ? ue.value[yt][N.field] = jt : !jt && ue.value.length === 1 ? ue.value = [] : ue.value[yt] = jt, W("update:modelValue", ue.value);
    }
    function Ye(yt) {
      Me(yt), W("update:modelValue", ue.value);
    }
    return (yt, jt) => v.taggable && v.canAdd ? (kn(), Ju(ng(yT), {
      key: 0,
      modelValue: ue.value,
      "onUpdate:modelValue": [
        jt[0] || (jt[0] = (it) => ue.value = it),
        jt[1] || (jt[1] = (it) => yt.$emit("update:modelValue", it))
      ],
      options: v.options,
      placeholder: `Type to add ${v.placeholder ?? "item"}`,
      multiple: "",
      "show-labels": !1,
      disabled: v.disabled,
      taggable: "",
      "tag-placeholder": `Create new ${v.placeholder ?? "item"}`,
      onTag: Ye
    }, null, 8, ["modelValue", "options", "placeholder", "disabled", "tag-placeholder"])) : (kn(), no("div", OG, [
      (kn(!0), no(th, null, Oy(ue.value, (it, Rt) => (kn(), no("div", {
        class: "relative",
        key: Rt
      }, [
        Co("div", AG, [
          v.label ? (kn(), no("label", {
            key: 0,
            for: ce.value[Rt],
            class: "multiple-label rounded-r-none bg-gray-300"
          }, ji(it[v.label]), 9, DG)) : Ks("", !0),
          Co("input", {
            id: ce.value[Rt],
            class: tc(["input-multiple flex-1", { "rounded-l-none": v.label, "rounded-r-none": v.canAdd && ue.value.length > 1 }]),
            type: v.type,
            value: v.field ? it[v.field] : it,
            placeholder: he.value[Rt],
            disabled: v.disabled,
            onInput: (en) => Ze(Rt, en.target.value)
          }, null, 42, RG),
          v.canAdd && ue.value.length > 1 ? (kn(), no("div", {
            key: 1,
            class: "multiple-remove rounded-l-none bg-gray-200 cursor-pointer hover:bg-gray-300",
            onClick: (en) => pe(Rt)
          }, "remove", 8, NG)) : Ks("", !0)
        ])
      ]))), 128)),
      v.canAdd ? (kn(), no("button", {
        key: 0,
        class: "cursor-pointer text-sm form-btn-green py-1 px-2",
        onClick: jt[2] || (jt[2] = vc((it) => Me(null), ["prevent"]))
      }, "Add " + ji(v.placeholder), 1)) : Ks("", !0)
    ]));
  }
}, BG = {
  key: 0,
  role: "list",
  class: "divide-y divide-gray-200 rounded-md bg-white"
}, LG = ["href"], PG = ["onClick"], IG = ["href"], FG = { key: 3 }, $G = {
  __name: "AttachmentsList",
  props: {
    attachments: {
      type: Array,
      default() {
        return [];
      }
    },
    can: {
      default() {
        return {
          delete: !0,
          download: !0
        };
      }
    }
  },
  emits: ["remove"],
  setup(v, { emit: L }) {
    const N = L;
    return (W, ue) => v.attachments.length ? (kn(), no("ul", BG, [
      (kn(!0), no(th, null, Oy(v.attachments, (ce) => (kn(), no("li", {
        key: ce.id,
        class: "p-2 flex items-center rounded-md"
      }, [
        v.can.download ? (kn(), no("a", {
          key: 0,
          href: ce.url,
          target: "_blank",
          class: "text-blue-500 rounded-full hover:bg-blue-200 p-1"
        }, ue[0] || (ue[0] = [
          Co("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            class: "h-6 w-6",
            fill: "none",
            viewBox: "0 0 24 24",
            stroke: "currentColor"
          }, [
            Co("path", {
              "stroke-linecap": "round",
              "stroke-linejoin": "round",
              "stroke-width": "2",
              d: "M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"
            })
          ], -1)
        ]), 8, LG)) : Ks("", !0),
        v.can.delete ? (kn(), no("button", {
          key: 1,
          onClick: (he) => N("remove", ce),
          type: "button",
          class: "ml-2 text-red-500 rounded-full hover:bg-red-200 p-1"
        }, ue[1] || (ue[1] = [
          Co("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            class: "h-6 w-6",
            fill: "none",
            viewBox: "0 0 24 24",
            stroke: "currentColor"
          }, [
            Co("path", {
              "stroke-linecap": "round",
              "stroke-linejoin": "round",
              "stroke-width": "2",
              d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
            })
          ], -1)
        ]), 8, PG)) : Ks("", !0),
        v.can.download ? (kn(), no("a", {
          key: 2,
          href: ce.url,
          target: "_blank",
          class: "mx-2 hover:text-blue-500"
        }, ji(ce.file_name), 9, IG)) : (kn(), no("div", FG, ji(ce.file_name), 1))
      ]))), 128))
    ])) : Ks("", !0);
  }
}, KF = (v) => {
  const L = new XMLHttpRequest();
  return L.open(v.method || "GET", v.url), L.responseType = "json", v.headers && Object.keys(v.headers).forEach((N) => {
    L.setRequestHeader(N, v.headers[N]);
  }), L;
}, HG = (v, L) => new Promise((N, W) => {
  v.onload = () => {
    if (v.status >= 200 && v.status < 300) {
      let ue;
      try {
        ue = JSON.parse(v.response);
      } catch {
        ue = v.response;
      }
      N(ue);
    } else
      W(v.response);
  }, v.onerror = () => W(v.response), v.send(JSON.stringify(L));
}), VG = (v, L) => {
  const N = new FormData();
  for (let W in L)
    N.append(W, L[W]);
  return new Promise((W, ue) => {
    v.onload = () => {
      if (v.status >= 200 && v.status < 300) {
        let ce;
        try {
          ce = JSON.parse(v.response);
        } catch {
          ce = v.response;
        }
        W(ce);
      } else
        ue(v.response);
    }, v.onerror = () => ue(v.response), v.send(N);
  });
};
function LF(v) {
  const L = KF(v);
  return HG(L, v.body);
}
class UG {
  /**
   * Constructor
   *
   * @param {File} file
   * @param {Object} options
   */
  constructor(L, N) {
    this.file = L, this.options = N, this.chunks = [], this.sessionId = null, this.chunkSize = null, this.speedInterval = null;
  }
  /**
   * Gets the max retries from options
   */
  get maxRetries() {
    return parseInt(this.options.maxRetries, 10);
  }
  /**
   * Gets the max number of active chunks being uploaded at once from options
   */
  get maxActiveChunks() {
    return parseInt(this.options.maxActive, 10);
  }
  /**
   * Gets the file type
   */
  get fileType() {
    return this.file.type;
  }
  /**
   * Gets the file size
   */
  get fileSize() {
    return this.file.size;
  }
  /**
   * Gets the file name
   */
  get fileName() {
    return this.file.name;
  }
  /**
   * Gets action (url) to upload the file
   */
  get action() {
    return this.options.action || null;
  }
  /**
   * Gets the body to be merged when sending the request in start phase
   */
  get startBody() {
    return this.options.startBody || {};
  }
  /**
   * Gets the body to be merged when sending the request in upload phase
   */
  get uploadBody() {
    return this.options.uploadBody || {};
  }
  /**
   * Gets the body to be merged when sending the request in finish phase
   */
  get finishBody() {
    return this.options.finishBody || {};
  }
  /**
   * Gets the headers of the requests from options
   */
  get headers() {
    return this.options.headers || {};
  }
  /**
   * Whether it's ready to upload files or not
   */
  get readyToUpload() {
    return !!this.chunks;
  }
  /**
   * Gets the progress of the chunk upload
   * - Gets all the completed chunks
   * - Gets the progress of all the chunks that are being uploaded
   */
  get progress() {
    const L = this.chunksUploaded.length / this.chunks.length * 100, N = this.chunksUploading.reduce((W, ue) => W + (ue.progress | 0) / this.chunks.length, 0);
    return Math.min(L + N, 100);
  }
  /**
   * Gets all the chunks that are pending to be uploaded
   */
  get chunksToUpload() {
    return this.chunks.filter((L) => !L.active && !L.uploaded);
  }
  /**
   * Whether there are chunks to upload or not
   */
  get hasChunksToUpload() {
    return this.chunksToUpload.length > 0;
  }
  /**
   * Gets all the chunks that are uploading
   */
  get chunksUploading() {
    return this.chunks.filter((L) => !!L.xhr && !!L.active);
  }
  /**
   * Gets all the chunks that have finished uploading
   */
  get chunksUploaded() {
    return this.chunks.filter((L) => !!L.uploaded);
  }
  /**
   * Creates all the chunks in the initial state
   */
  createChunks() {
    this.chunks = [];
    let L = 0, N = this.chunkSize;
    for (; L < this.fileSize; )
      this.chunks.push({
        blob: this.file.file.slice(L, N),
        startOffset: L,
        active: !1,
        retries: this.maxRetries
      }), L = N, N = L + this.chunkSize;
  }
  /**
   * Updates the progress of the file with the handler's progress
   */
  updateFileProgress() {
    this.file.progress = this.progress;
  }
  /**
   * Paues the upload process
   * - Stops all active requests
   * - Sets the file not active
   */
  pause() {
    this.file.active = !1, this.stopChunks();
  }
  /**
   * Stops all the current chunks
   */
  stopChunks() {
    this.chunksUploading.forEach((L) => {
      L.xhr.abort(), L.active = !1;
    }), this.stopSpeedCalc();
  }
  /**
   * Resumes the file upload
   * - Sets the file active
   * - Starts the following chunks
   */
  resume() {
    this.file.active = !0, this.startChunking();
  }
  /**
   * Starts the file upload
   *
   * @returns Promise
   * - resolve  The file was uploaded
   * - reject   The file upload failed
   */
  upload() {
    return this.promise = new Promise((L, N) => {
      this.resolve = L, this.reject = N;
    }), this.start(), this.promise;
  }
  /**
   * Start phase
   * Sends a request to the backend to initialise the chunks
   */
  start() {
    LF({
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      url: this.action,
      body: Object.assign(this.startBody, {
        phase: "start",
        mime_type: this.fileType,
        size: this.fileSize,
        name: this.fileName
      })
    }).then((L) => {
      if (L.status !== "success")
        return this.file.response = L, this.reject("server");
      this.sessionId = L.data.session_id, this.chunkSize = L.data.end_offset, this.createChunks(), this.startChunking();
    }).catch((L) => {
      this.file.response = L, this.reject("server");
    });
  }
  /**
   * Starts to upload chunks
   */
  startChunking() {
    for (let L = 0; L < this.maxActiveChunks; L++)
      this.uploadNextChunk();
    this.startSpeedCalc();
  }
  /**
   * Uploads the next chunk
   * - Won't do anything if the process is paused
   * - Will start finish phase if there are no more chunks to upload
   */
  uploadNextChunk() {
    if (this.file.active) {
      if (this.hasChunksToUpload)
        return this.uploadChunk(this.chunksToUpload[0]);
      if (this.chunksUploading.length === 0)
        return this.finish();
    }
  }
  /**
   * Uploads a chunk
   * - Sends the chunk to the backend
   * - Sets the chunk as uploaded if everything went well
   * - Decreases the number of retries if anything went wrong
   * - Fails if there are no more retries
   *
   * @param {Object} chunk
   */
  uploadChunk(L) {
    L.progress = 0, L.active = !0, this.updateFileProgress(), L.xhr = KF({
      method: "POST",
      headers: this.headers,
      url: this.action
    }), L.xhr.upload.addEventListener("progress", function(N) {
      N.lengthComputable && (L.progress = Math.round(N.loaded / N.total * 100));
    }, !1), VG(L.xhr, Object.assign(this.uploadBody, {
      phase: "upload",
      session_id: this.sessionId,
      start_offset: L.startOffset,
      chunk: L.blob
    })).then((N) => {
      if (L.active = !1, N.status === "success")
        L.uploaded = !0;
      else if (L.retries-- <= 0)
        return this.stopChunks(), this.reject("upload");
      this.uploadNextChunk();
    }).catch(() => {
      if (L.active = !1, L.retries-- <= 0)
        return this.stopChunks(), this.reject("upload");
      this.uploadNextChunk();
    });
  }
  /**
   * Finish phase
   * Sends a request to the backend to finish the process
   */
  finish() {
    this.updateFileProgress(), this.stopSpeedCalc(), LF({
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      url: this.action,
      body: Object.assign(this.finishBody, {
        phase: "finish",
        session_id: this.sessionId
      })
    }).then((L) => {
      if (this.file.response = L, L.status !== "success")
        return this.reject("server");
      this.resolve(L);
    }).catch((L) => {
      this.file.response = L, this.reject("server");
    });
  }
  /**
   * Sets an interval to calculate and
   * set upload speed every 3 seconds
   */
  startSpeedCalc() {
    this.file.speed = 0;
    let L = 0;
    this.speedInterval || (this.speedInterval = window.setInterval(() => {
      let N = this.progress / 100 * this.fileSize;
      this.file.speed = N - L, L = N;
    }, 1e3));
  }
  /**
   * Removes the upload speed interval
   */
  stopSpeedCalc() {
    this.speedInterval && window.clearInterval(this.speedInterval), this.speedInterval = null, this.file.speed = 0;
  }
}
const PF = {
  headers: {},
  action: "",
  minSize: 1048576,
  maxActive: 3,
  maxRetries: 5,
  handler: UG
}, jG = em({
  props: {
    inputId: {
      type: String
    },
    name: {
      type: String,
      default: "file"
    },
    accept: {
      type: String
    },
    capture: {},
    disabled: {
      default: !1
    },
    multiple: {
      type: Boolean,
      default: !1
    },
    maximum: {
      type: Number
    },
    addIndex: {
      type: [Boolean, Number]
    },
    directory: {
      type: Boolean
    },
    createDirectory: {
      type: Boolean,
      default: !1
    },
    postAction: {
      type: String
    },
    putAction: {
      type: String
    },
    customAction: {
      type: Function
    },
    headers: {
      type: Object,
      default: () => ({})
    },
    data: {
      type: Object,
      default: () => ({})
    },
    timeout: {
      type: Number,
      default: 0
    },
    drop: {
      type: [Boolean, String, HTMLElement],
      default: () => !1
    },
    dropDirectory: {
      type: Boolean,
      default: !0
    },
    size: {
      type: Number,
      default: 0
    },
    extensions: {
      type: [RegExp, String, Array],
      default: () => []
    },
    modelValue: {
      type: Array,
      default: () => []
    },
    thread: {
      type: Number,
      default: 1
    },
    // Chunk upload enabled
    chunkEnabled: {
      type: Boolean,
      default: !1
    },
    // Chunk upload properties
    chunk: {
      type: Object,
      default: () => PF
    }
  },
  emits: [
    "update:modelValue",
    "input-filter",
    "input-file"
  ],
  data() {
    return {
      files: this.modelValue,
      features: {
        html5: !0,
        directory: !1,
        drop: !1
      },
      active: !1,
      dropActive: !1,
      uploading: 0,
      destroy: !1,
      maps: {},
      dropElement: null,
      dropTimeout: null,
      reload: !1
    };
  },
  /**
   * mounted
   * @return {[type]} [description]
   */
  mounted() {
    const v = document.createElement("input");
    if (v.type = "file", v.multiple = !0, window.FormData && v.files ? ((typeof v.webkitdirectory == "boolean" || typeof v.directory == "boolean") && (this.features.directory = !0), this.features.html5 && typeof v.ondrop < "u" && (this.features.drop = !0)) : this.features.html5 = !1, this.maps = {}, this.files)
      for (let L = 0; L < this.files.length; L++) {
        const N = this.files[L];
        this.maps[N.id] = N;
      }
    this.$nextTick(() => {
      this.$parent ? (this.$parent.$forceUpdate(), this.$parent.$nextTick(() => {
        this.watchDrop(this.drop);
      })) : this.watchDrop(this.drop);
    });
  },
  /**
   * beforeUnmount
   * @return {[type]} [description]
   */
  beforeUnmount() {
    this.destroy = !0, this.active = !1, this.watchDrop(!1), this.watchActive(!1);
  },
  computed: {
    /**
     * uploading 正在上传的线程
     * @return {[type]} [description]
     */
    /**
     * uploaded 文件列表是否全部已上传
     * @return {[type]} [description]
     */
    uploaded() {
      let v;
      for (let L = 0; L < this.files.length; L++)
        if (v = this.files[L], v.fileObject && !v.error && !v.success)
          return !1;
      return !0;
    },
    chunkOptions() {
      return Object.assign(PF, this.chunk);
    },
    className() {
      return [
        "file-uploads",
        this.features.html5 ? "file-uploads-html5" : "file-uploads-html4",
        this.features.directory && this.directory ? "file-uploads-directory" : void 0,
        this.features.drop && this.drop ? "file-uploads-drop" : void 0,
        this.disabled ? "file-uploads-disabled" : void 0
      ];
    },
    forId() {
      return this.inputId || this.name;
    },
    iMaximum() {
      return this.maximum === void 0 ? this.multiple ? 0 : 1 : this.maximum;
    },
    iExtensions() {
      if (!this.extensions)
        return;
      if (this.extensions instanceof RegExp)
        return this.extensions;
      if (!this.extensions.length)
        return;
      let v = [];
      return typeof this.extensions == "string" ? v = this.extensions.split(",") : v = this.extensions, v = v.map(function(L) {
        return L.trim();
      }).filter(function(L) {
        return L;
      }), new RegExp("\\.(" + v.join("|").replace(/\./g, "\\.") + ")$", "i");
    },
    iDirectory() {
      if (this.directory && this.features.directory)
        return !0;
    }
  },
  watch: {
    active(v) {
      this.watchActive(v);
    },
    dropActive(v) {
      this.watchDropActive(v), this.$parent && this.$parent.$forceUpdate();
    },
    drop(v) {
      this.watchDrop(v);
    },
    modelValue(v) {
      if (this.files === v)
        return;
      this.files = v;
      const L = this.maps;
      this.maps = {};
      for (let N = 0; N < this.files.length; N++) {
        const W = this.files[N];
        this.maps[W.id] = W;
      }
      for (const N in this.maps) {
        const W = this.maps[N], ue = L[N];
        W !== ue && this.emitFile(W, ue);
      }
      for (const N in L)
        this.maps[N] || this.emitFile(void 0, L[N]);
    }
  },
  methods: {
    newId() {
      return Math.random().toString(36).substr(2);
    },
    // 清空
    clear() {
      if (this.files.length) {
        const v = this.files;
        this.files = [], this.maps = {}, this.emitInput();
        for (let L = 0; L < v.length; L++)
          this.emitFile(void 0, v[L]);
      }
      return !0;
    },
    // 选择
    get(v) {
      return v ? typeof v == "object" ? this.maps[v.id || ""] || !1 : this.maps[v] || !1 : !1;
    },
    // 添加
    add(v, L) {
      let N;
      v instanceof Array ? N = v : N = [v], L === void 0 && (L = this.addIndex);
      let W = [];
      for (let he = 0; he < N.length; he++) {
        let pe = N[he];
        this.features.html5 && pe instanceof Blob && (pe = {
          id: "",
          file: pe,
          size: pe.size,
          // @ts-ignore
          name: pe.webkitRelativePath || pe.relativePath || pe.name || "unknown",
          type: pe.type
        }), pe = pe;
        let Me = !1;
        if (pe.fileObject === !1 || (pe.fileObject || typeof Element < "u" && pe.el instanceof HTMLInputElement || typeof Blob < "u" && pe.file instanceof Blob) && (Me = !0), Me && (pe = {
          fileObject: !0,
          size: -1,
          name: "Filename",
          type: "",
          active: !1,
          error: "",
          success: !1,
          putAction: this.putAction,
          postAction: this.postAction,
          timeout: this.timeout,
          ...pe,
          response: {},
          progress: "0.00",
          // 只读
          speed: 0
          // 只读
          // file: undefined,
          // xhr: undefined,
          // el: undefined,
          // iframe: undefined,
        }, pe.data = {
          ...this.data,
          ...pe.data ? pe.data : {}
        }, pe.headers = {
          ...this.headers,
          ...pe.headers ? pe.headers : {}
        }), pe.id || (pe.id = this.newId()), !this.emitFilter(pe, void 0) && (this.iMaximum > 1 && W.length + this.files.length >= this.iMaximum || (W.push(pe), this.iMaximum === 1)))
          break;
      }
      if (!W.length)
        return;
      this.iMaximum === 1 && this.clear();
      let ue;
      L === !0 || L === 0 ? ue = W.concat(this.files) : L ? (ue = this.files.concat([]), ue.splice(L, 0, ...W)) : ue = this.files.concat(W), this.files = ue;
      let ce = 0;
      L === !0 || L === 0 ? ce = 0 : L ? L >= 0 ? L + W.length > this.files.length ? ce = this.files.length - W.length : ce = L : (ce = this.files.length - W.length + L, ce < 0 && (ce = 0)) : ce = this.files.length - W.length, W = this.files.slice(ce, ce + W.length);
      for (let he = 0; he < W.length; he++) {
        const pe = W[he];
        this.maps[pe.id] = pe;
      }
      this.emitInput();
      for (let he = 0; he < W.length; he++)
        this.emitFile(W[he], void 0);
      return v instanceof Array ? W : W[0];
    },
    // 添加表单文件
    addInputFile(v) {
      const L = [];
      this.iMaximum;
      const N = v.webkitEntries || v.entries || void 0;
      if (N != null && N.length)
        return this.getFileSystemEntry(N).then((W) => this.add(W));
      if (v.files)
        for (let W = 0; W < v.files.length; W++) {
          const ue = v.files[W];
          L.push({
            id: "",
            size: ue.size,
            // @ts-ignore
            name: ue.webkitRelativePath || ue.relativePath || ue.name,
            type: ue.type,
            file: ue
          });
        }
      else {
        let W = v.value.replace(/\\/g, "/").split("/");
        (!W || !W.length) && (W = [v.value]), delete v.__vuex__, L.push({
          id: "",
          name: W[W.length - 1],
          el: v
        });
      }
      return Promise.resolve(this.add(L));
    },
    // 添加 DataTransfer
    addDataTransfer(v) {
      var W;
      if ((W = v == null ? void 0 : v.items) != null && W.length) {
        const ue = [];
        for (let ce = 0; ce < v.items.length; ce++) {
          const he = v.items[ce];
          let pe;
          he.getAsEntry ? pe = he.getAsEntry() || he.getAsFile() : he.webkitGetAsEntry ? pe = he.webkitGetAsEntry() || he.getAsFile() : pe = he.getAsFile(), pe && ue.push(pe);
        }
        return this.getFileSystemEntry(ue).then((ce) => this.add(ce));
      }
      const L = this.iMaximum, N = [];
      if (v.files.length) {
        for (let ue = 0; ue < v.files.length && (N.push(v.files[ue]), !(L > 0 && N.length >= L)); ue++)
          ;
        return Promise.resolve(this.add(N));
      }
      return Promise.resolve([]);
    },
    // 获得 entrys
    getFileSystemEntry(v, L = "") {
      return new Promise((N) => {
        const W = this.iMaximum;
        if (!v) {
          N([]);
          return;
        }
        if (v instanceof Array) {
          const ue = [], ce = (he) => {
            const pe = v[he];
            if (!pe || W > 0 && ue.length >= W)
              return N(ue);
            this.getFileSystemEntry(pe, L).then(function(Me) {
              ue.push(...Me), ce(he + 1);
            });
          };
          ce(0);
          return;
        }
        if (v instanceof Blob) {
          N([
            {
              id: "",
              size: v.size,
              // @ts-ignore
              name: L + v.name,
              type: v.type,
              file: v
            }
          ]);
          return;
        }
        if (v.isFile) {
          v.file(function(ce) {
            N([
              {
                id: "",
                size: ce.size,
                name: L + ce.name,
                type: ce.type,
                file: ce
              }
            ]);
          });
          return;
        }
        if (v.isDirectory && this.dropDirectory) {
          let ue = v;
          const ce = [];
          this.createDirectory && ce.push({
            id: "",
            name: L + ue.name,
            size: 0,
            type: "text/directory",
            file: new File([], L + ue.name, { type: "text/directory" })
          });
          const he = ue.createReader(), pe = () => {
            he.readEntries((Me) => {
              const Ze = (Ye) => {
                if (!Me[Ye] && Ye === 0 || W > 0 && ce.length >= W)
                  return N(ce);
                if (!Me[Ye])
                  return pe();
                this.getFileSystemEntry(Me[Ye], L + ue.name + "/").then(function(yt) {
                  ce.push(...yt), Ze(Ye + 1);
                });
              };
              Ze(0);
            });
          };
          pe();
          return;
        }
        N([]);
      });
    },
    // 替换
    replace(v, L) {
      const N = this.get(v), W = this.get(L);
      if (!N || !W || N === W)
        return !1;
      const ue = this.files.concat([]), ce = ue.indexOf(N), he = ue.indexOf(W);
      return ce === -1 || he === -1 ? !1 : (ue[ce] = W, ue[he] = N, this.files = ue, this.emitInput(), !0);
    },
    // 移除
    remove(v) {
      const L = this.get(v);
      if (L) {
        if (this.emitFilter(void 0, L))
          return !1;
        const N = this.files.concat([]), W = N.indexOf(L);
        if (W === -1)
          return console.error("remove", L), !1;
        N.splice(W, 1), this.files = N, delete this.maps[L.id], this.emitInput(), this.emitFile(void 0, L);
      }
      return L;
    },
    // 更新
    update(v, L) {
      const N = this.get(v);
      if (N) {
        let W = {
          ...N,
          ...L
        };
        if (N.fileObject && N.active && !W.active && !W.error && !W.success && (W.error = "abort"), this.emitFilter(W, N))
          return !1;
        const ue = this.files.concat([]), ce = ue.indexOf(N);
        return ce === -1 ? (console.error("update", N), !1) : (ue.splice(ce, 1, W), this.files = ue, W = this.files[ce], delete this.maps[N.id], this.maps[W.id] = W, this.emitInput(), this.emitFile(W, N), W);
      }
      return !1;
    },
    // 预处理 事件 过滤器
    emitFilter(v, L) {
      let N = !1;
      return this.$emit("input-filter", v, L, function(W = !0) {
        return N = W, N;
      }), N;
    },
    // 处理后 事件 分发
    emitFile(v, L) {
      this.$emit("input-file", v, L), v != null && v.fileObject && v.active && (!L || !L.active) ? (this.uploading++, this.$nextTick(() => {
        setTimeout(() => {
          v && this.upload(v).then(() => {
            v && (v = this.get(v) || void 0), v != null && v.fileObject && this.update(v, {
              active: !1,
              success: !v.error
            });
          }).catch((N) => {
            v && this.update(v, {
              active: !1,
              success: !1,
              error: N.code || N.error || N.message || N
            });
          });
        }, Math.ceil(Math.random() * 50 + 50));
      })) : (!v || !v.fileObject || !v.active) && L && L.fileObject && L.active && this.uploading--, this.active && (!!v != !!L || v.active !== L.active) && this.watchActive(!0);
    },
    emitInput() {
      this.$emit("update:modelValue", this.files);
    },
    // 上传
    upload(v) {
      const L = this.get(v);
      if (!L)
        return Promise.reject(new Error("not_exists"));
      if (!L.fileObject)
        return Promise.reject(new Error("file_object"));
      if (L.error)
        return L.error instanceof Error ? Promise.reject(L.error) : Promise.reject(new Error(L.error));
      if (L.success)
        return Promise.resolve(L);
      if (L.name && this.iExtensions && L.type !== "text/directory" && L.name.search(this.iExtensions) === -1)
        return Promise.reject(new Error("extension"));
      if (this.size > 0 && L.size !== void 0 && L.size >= 0 && L.size > this.size && L.type !== "text/directory")
        return Promise.reject(new Error("size"));
      if (this.customAction)
        return this.customAction(L, this);
      if (this.features.html5) {
        if (this.shouldUseChunkUpload(L))
          return this.uploadChunk(L);
        if (L.putAction)
          return this.uploadPut(L);
        if (L.postAction)
          return this.uploadHtml5(L);
      }
      return L.postAction ? this.uploadHtml4(L) : Promise.reject(new Error("No action configured"));
    },
    /**
     * Whether this file should be uploaded using chunk upload or not
     *
     * @param Object file
     */
    shouldUseChunkUpload(v) {
      return this.chunkEnabled && !!this.chunkOptions.handler && v.size && v.size > this.chunkOptions.minSize;
    },
    /**
     * Upload a file using Chunk method
     *
     * @param File file
     */
    uploadChunk(v) {
      const L = this.chunkOptions.handler;
      return v.chunk = new L(v, this.chunkOptions), v.chunk.upload().then((N) => v);
    },
    uploadPut(v) {
      const L = [];
      let N;
      for (const he in v.data)
        N = v.data[he], N != null && L.push(encodeURIComponent(he) + "=" + encodeURIComponent(N));
      const W = v.putAction || "", ue = L.length ? (W.indexOf("?") === -1 ? "?" : "&") + L.join("&") : "", ce = new XMLHttpRequest();
      return ce.open("PUT", W + ue), this.uploadXhr(ce, v, v.file);
    },
    uploadHtml5(v) {
      const L = new window.FormData();
      let N;
      for (const ue in v.data)
        N = v.data[ue], N && typeof N == "object" && typeof N.toString != "function" ? N instanceof File ? L.append(ue, N, N.name) : L.append(ue, JSON.stringify(N)) : N != null && L.append(ue, N);
      L.append(this.name, v.file, v.name || v.file.name || v.file.filename);
      const W = new XMLHttpRequest();
      return W.open("POST", v.postAction || ""), this.uploadXhr(W, v, L);
    },
    uploadXhr(v, L, N) {
      let W = L, ue = 0, ce = 0;
      v.upload.onprogress = (pe) => {
        if (!W || (W = this.get(W), !pe.lengthComputable || !W || !W.fileObject || !W.active))
          return;
        const Me = Math.round(Date.now() / 1e3);
        Me !== ue && (ue = Me, W = this.update(W, {
          progress: (pe.loaded / pe.total * 100).toFixed(2),
          speed: pe.loaded - ce
        }), ce = pe.loaded);
      };
      let he = window.setInterval(() => {
        if (!(W && (W = this.get(W)) && W != null && W.fileObject && !W.success && !W.error && W.active)) {
          he && (clearInterval(he), he = void 0);
          try {
            v.abort(), v.timeout = 1;
          } catch {
          }
        }
      }, 100);
      return new Promise((pe, Me) => {
        if (!W) {
          Me(new Error("not_exists"));
          return;
        }
        let Ze;
        const Ye = (yt) => {
          if (Ze)
            return;
          if (Ze = !0, he && (clearInterval(he), he = void 0), !W)
            return Me(new Error("not_exists"));
          if (W = this.get(W), !W)
            return Me(new Error("not_exists"));
          if (!W.fileObject)
            return Me(new Error("file_object"));
          if (W.error)
            return W.error instanceof Error ? Me(W.error) : Me(new Error(W.error));
          if (!W.active)
            return Me(new Error("abort"));
          if (W.success)
            return pe(W);
          const jt = {};
          switch (yt.type) {
            case "timeout":
            case "abort":
              jt.error = yt.type;
              break;
            case "error":
              v.status ? v.status >= 500 ? jt.error = "server" : v.status >= 400 && (jt.error = "denied") : jt.error = "network";
              break;
            default:
              v.status >= 500 ? jt.error = "server" : v.status >= 400 ? jt.error = "denied" : jt.progress = "100.00";
          }
          if (v.responseText) {
            const it = v.getResponseHeader("Content-Type");
            it && it.indexOf("/json") !== -1 ? jt.response = JSON.parse(v.responseText) : jt.response = v.responseText;
          }
          return W = this.update(W, jt), W ? W.error ? W.error instanceof Error ? Me(W.error) : Me(new Error(W.error)) : pe(W) : Me(new Error("abort"));
        };
        v.onload = Ye, v.onerror = Ye, v.onabort = Ye, v.ontimeout = Ye, W.timeout && (v.timeout = W.timeout);
        for (const yt in W.headers)
          v.setRequestHeader(yt, W.headers[yt]);
        W = this.update(W, { xhr: v }), W && v.send(N);
      });
    },
    uploadHtml4(v) {
      let L = v;
      if (!L)
        return Promise.reject(new Error("not_exists"));
      const N = function(he) {
        he.keyCode === 27 && he.preventDefault();
      }, W = document.createElement("iframe");
      W.id = "upload-iframe-" + L.id, W.name = "upload-iframe-" + L.id, W.src = "about:blank", W.setAttribute("style", "width:1px;height:1px;top:-999em;position:absolute; margin-top:-999em;");
      const ue = document.createElement("form");
      ue.setAttribute("action", L.postAction || ""), ue.name = "upload-form-" + L.id, ue.setAttribute("method", "POST"), ue.setAttribute("target", "upload-iframe-" + L.id), ue.setAttribute("enctype", "multipart/form-data");
      for (const he in L.data) {
        let pe = L.data[he];
        if (pe && typeof pe == "object" && typeof pe.toString != "function" && (pe = JSON.stringify(pe)), pe != null) {
          const Me = document.createElement("input");
          Me.type = "hidden", Me.name = he, Me.value = pe, ue.appendChild(Me);
        }
      }
      ue.appendChild(L.el), document.body.appendChild(W).appendChild(ue);
      const ce = function() {
        let he;
        try {
          W.contentWindow && (he = W.contentWindow.document);
        } catch {
        }
        if (!he)
          try {
            he = W.contentDocument ? W.contentDocument : W.document;
          } catch {
            he = W.document;
          }
        return he != null && he.body ? he.body.innerHTML : null;
      };
      return new Promise((he, pe) => {
        setTimeout(() => {
          if (!L) {
            pe(new Error("not_exists"));
            return;
          }
          if (L = this.update(L, { iframe: W }), !L)
            return pe(new Error("not_exists"));
          let Me = window.setInterval(() => {
            L && (L = this.get(L)) && L.fileObject && !L.success && !L.error && L.active || (Me && (clearInterval(Me), Me = void 0), W.onabort({ type: L ? "abort" : "not_exists" }));
          }, 100), Ze;
          const Ye = (yt) => {
            if (Ze)
              return;
            if (Ze = !0, Me && (clearInterval(Me), Me = void 0), document.body.removeEventListener("keydown", N), !L)
              return pe(new Error("not_exists"));
            if (L = this.get(L), !L)
              return pe(new Error("not_exists"));
            if (!L.fileObject)
              return pe(new Error("file_object"));
            if (L.error)
              return L.error instanceof Error ? pe(L.error) : pe(new Error(L.error));
            if (!L.active)
              return pe(new Error("abort"));
            if (L.success)
              return he(L);
            let jt = ce();
            const it = {};
            if (typeof yt == "string")
              return pe(new Error(yt));
            switch (yt.type) {
              case "abort":
                it.error = "abort";
                break;
              case "error":
                L.error ? it.error = L.error : jt === null ? it.error = "network" : it.error = "denied";
                break;
              default:
                L.error ? it.error = L.error : jt === null ? it.error = "network" : it.progress = "100.00";
            }
            if (jt !== null) {
              if (jt && jt.substr(0, 1) === "{" && jt.substr(jt.length - 1, 1) === "}")
                try {
                  jt = JSON.parse(jt);
                } catch {
                }
              it.response = jt;
            }
            return L = this.update(L, it), L ? L != null && L.error ? L.error instanceof Error ? pe(L.error) : pe(new Error(L.error)) : he(L) : pe(new Error("not_exists"));
          };
          W.onload = Ye, W.onerror = Ye, W.onabort = Ye, document.body.addEventListener("keydown", N), ue.submit();
        }, 50);
      }).then(function(he) {
        var pe;
        return (pe = W == null ? void 0 : W.parentNode) == null || pe.removeChild(W), he;
      }).catch(function(he) {
        var pe;
        return (pe = W == null ? void 0 : W.parentNode) == null || pe.removeChild(W), he;
      });
    },
    watchActive(v) {
      let L, N = 0;
      for (; L = this.files[N]; )
        if (N++, L.fileObject)
          if (v && !this.destroy) {
            if (this.uploading >= this.thread || this.uploading && !this.features.html5)
              break;
            !L.active && !L.error && !L.success && this.update(L, { active: !0 });
          } else
            L.active && this.update(L, { active: !1 });
      this.uploading === 0 && (this.active = !1);
    },
    watchDrop(v, L = void 0) {
      if (!this.features.drop || v === L)
        return;
      if (this.dropElement)
        try {
          document.removeEventListener("dragenter", this.onDocumentDragenter, !1), document.removeEventListener("dragleave", this.onDocumentDragleave, !1), document.removeEventListener("dragover", this.onDocumentDragover, !1), document.removeEventListener("drop", this.onDocumentDrop, !1), this.dropElement.removeEventListener("dragover", this.onDragover, !1), this.dropElement.removeEventListener("drop", this.onDrop, !1);
        } catch {
        }
      let N = null;
      v && (typeof v == "string" ? N = document.querySelector(v) || this.$root.$el.querySelector(v) : v === !0 ? (N = this.$parent.$el, (!N || (N == null ? void 0 : N.nodeType) === 8) && (N = this.$root.$el, (!N || (N == null ? void 0 : N.nodeType) === 8) && (N = document.body))) : N = v), this.dropElement = N, this.dropElement && (document.addEventListener("dragenter", this.onDocumentDragenter, !1), document.addEventListener("dragleave", this.onDocumentDragleave, !1), document.addEventListener("dragover", this.onDocumentDragover, !1), document.addEventListener("drop", this.onDocumentDrop, !1), this.dropElement.addEventListener("dragover", this.onDragover, !1), this.dropElement.addEventListener("drop", this.onDrop, !1));
    },
    watchDropActive(v, L) {
      v !== L && (this.dropTimeout && (clearTimeout(this.dropTimeout), this.dropTimeout = null), v && (this.dropTimeout = setTimeout(this.onDocumentDrop, 1e3)));
    },
    onDocumentDragenter(v) {
      var N, W;
      if (this.dropActive || !v.dataTransfer)
        return;
      const L = v.dataTransfer;
      (N = L == null ? void 0 : L.files) != null && N.length ? this.dropActive = !0 : L.types ? L.types.indexOf && L.types.indexOf("Files") !== -1 ? this.dropActive = !0 : (W = L.types) != null && W.contains && L.types.contains("Files") && (this.dropActive = !0) : this.dropActive = !0, this.dropActive && this.watchDropActive(!0);
    },
    onDocumentDragleave(v) {
      this.dropActive && (v.target === v.explicitOriginalTarget || !v.fromElement && (v.clientX <= 0 || v.clientY <= 0 || v.clientX >= window.innerWidth || v.clientY >= window.innerHeight)) && (this.dropActive = !1, this.watchDropActive(!1));
    },
    onDocumentDragover() {
      this.watchDropActive(!0);
    },
    onDocumentDrop() {
      this.dropActive = !1, this.watchDropActive(!1);
    },
    onDragover(v) {
      v.preventDefault();
    },
    onDrop(v) {
      v.preventDefault(), v.dataTransfer && this.addDataTransfer(v.dataTransfer);
    },
    async inputOnChange(v) {
      if (!(v.target instanceof HTMLInputElement))
        return Promise.reject(new Error("not HTMLInputElement"));
      v.target;
      const L = (N) => (this.reload = !0, this.$nextTick(() => {
        this.reload = !1;
      }), N);
      return this.addInputFile(v.target).then(L).catch(L);
    }
  }
});
const ZG = (v, L) => {
  const N = v.__vccOpts || v;
  for (const [W, ue] of L)
    N[W] = ue;
  return N;
}, WG = ["for"], qG = ["name", "id", "accept", "capture", "disabled", "webkitdirectory", "allowdirs", "directory", "multiple"];
function GG(v, L, N, W, ue, ce) {
  return kn(), no("span", {
    class: tc(v.className)
  }, [
    kl(v.$slots, "default"),
    Co("label", { for: v.forId }, null, 8, WG),
    v.reload ? Ks("", !0) : (kn(), no("input", {
      key: 0,
      ref: "input",
      type: "file",
      name: v.name,
      id: v.forId,
      accept: v.accept,
      capture: v.capture,
      disabled: v.disabled,
      webkitdirectory: v.iDirectory,
      allowdirs: v.iDirectory,
      directory: v.iDirectory,
      multiple: v.multiple && v.features.html5,
      onChange: L[0] || (L[0] = (...he) => v.inputOnChange && v.inputOnChange(...he))
    }, null, 40, qG))
  ], 2);
}
const KG = /* @__PURE__ */ ZG(jG, [["render", GG]]);
const YG = {
  key: 0,
  class: "image-preview-container bg-gray-100 relative border rounded mx-auto shadow"
}, XG = {
  key: 0,
  class: "flex flex-col justify-center items-center"
}, JG = {
  key: 0,
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 24 24",
  "stroke-width": "1.5",
  stroke: "currentColor",
  class: "w-1/2 inline-block"
}, QG = {
  key: 1,
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 24 24",
  "stroke-width": "1.5",
  stroke: "currentColor",
  class: "w-1/2 inline-block"
}, eK = {
  key: 2,
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 24 24",
  "stroke-width": "1.5",
  stroke: "currentColor",
  class: "w-1/2 inline-block"
}, tK = {
  key: 3,
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 24 24",
  "stroke-width": "1.5",
  stroke: "currentColor",
  class: "w-1/2 inline-block"
}, nK = {
  key: 4,
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 24 24",
  "stroke-width": "1.5",
  stroke: "currentColor",
  class: "w-1/2 inline-block text-gray-400"
}, oK = {
  key: 5,
  class: "text-sm"
}, rK = ["href"], sK = { key: 1 }, aK = { class: "space-y-1 text-center" }, iK = { class: "flex text-sm text-gray-600 justify-center" }, lK = { class: "text-xs text-gray-500" }, cK = {
  key: 0,
  role: "list",
  class: "divide-y divide-gray-200"
}, uK = ["onClick"], dK = { class: "mx-2" }, IF = {
  __name: "FileUploadInput",
  props: {
    modelValue: null,
    id: {
      default() {
        return Math.random().toString(36).slice(2);
      }
    },
    placeholder: {
      type: String,
      default: "/images/placeholder-image.png"
    },
    acceptableTypes: {
      type: Array,
      default() {
        return ["image"];
      }
    },
    maxSize: {
      type: [Number, String],
      default: "10MB"
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    multiple: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update:modelValue", "preview"],
  setup(v, { emit: L }) {
    const N = L, W = v, ue = Jr(W.placeholder), ce = Jr(null), he = () => {
      I5(() => {
        if (pe.value && an(pe.value, "image"))
          if (W.modelValue.file) {
            let We = new FileReader();
            We.onload = (Cn) => {
              ue.value = Cn.target.result;
            }, We.readAsDataURL(W.modelValue.file);
          } else
            gT.isString(W.modelValue) && (ue.value = W.modelValue);
        else
          ue.value = W.placeholder;
      });
    };
    Od(ue, (We) => {
      N("preview", We === W.placeholder ? null : We);
    });
    const pe = Qo(() => {
      if (!W.modelValue || W.multiple)
        return null;
      let We = W.modelValue.file ? W.modelValue.file.name : gT.isString(W.modelValue) ? W.modelValue : null;
      We = We.split("/").pop();
      const Cn = We.indexOf("?");
      return decodeURI(Cn > -1 ? We.substring(0, Cn) : We);
    }), Me = Qo(() => W.modelValue && pe.value ? gt(pe.value) : "empty"), Ze = Qo(() => Me.value === "image" || Me.value === "empty" && ue.value === W.placeholder ? { "background-image": `url(${ue.value})` } : null), Ye = Qo({
      get() {
        return W.modelValue ?? [];
      },
      set(We) {
        N("update:modelValue", W.multiple ? We : We[0]);
      }
    });
    Ad(() => {
      gT.isString(W.modelValue) && an(W.modelValue, "image") && (ue.value = W.modelValue);
    });
    const yt = Qo(() => {
      let We = Number(W.maxSize), Cn = 1;
      if (Number.isNaN(We)) {
        let ko = W.maxSize.indexOf("GB");
        ko > 0 ? Cn = 1024 * 1024 * 1024 : ko = W.maxSize.indexOf("MB"), ko > 0 ? Cn = 1024 * 1024 : ko = W.maxSize.indexOf("KB"), ko > 0 && (We = Number(W.maxSize.substring(0, ko)));
      }
      return Number.isNaN(We) ? null : We * Cn;
    }), jt = Qo(() => {
      const We = Number(W.maxSize);
      return Number.isNaN(We) ? W.maxSize : We >= 1073741824 ? (We / (1024 * 1024 * 1024)).toFixed(2) + "GB" : We >= 10485760 ? (We / (1024 * 1024)).toFixed(2) + "MB" : (We / 1024).toFixed(2) + "KB";
    }), it = Qo(() => W.acceptableTypes.map((We) => {
      var ko;
      let Cn = (ko = Se[We]) == null ? void 0 : ko.split(",");
      return Cn ? Object.entries(wt).map((jn) => Cn.includes(jn[1]) ? jn[0].toUpperCase() : null).filter((jn) => !!jn).join(", ") : We.replace(".", "").toUpperCase();
    }).join(", ") + " up to " + jt.value), Rt = (We) => We > 1024 * 1024 * 1024 * 1024 ? (We / 1024 / 1024 / 1024 / 1024).toFixed(2) + " TB" : We > 1024 * 1024 * 1024 ? (We / 1024 / 1024 / 1024).toFixed(2) + " GB" : We > 1024 * 1024 ? (We / 1024 / 1024).toFixed(2) + " MB" : We > 1024 ? (We / 1024).toFixed(2) + " KB" : We.toString() + " B";
    function en(We) {
      N("update:modelValue", W.multiple ? W.modelValue.filter((Cn) => Cn !== We) : null), he();
    }
    function Gt(We) {
      let Cn = We.split(".").pop();
      return Cn.indexOf("?") > -1 ? Cn.substring(0, Cn.indexOf("?")) : Cn;
    }
    function gt(We) {
      let Cn = Gt(We).toLowerCase();
      for (let ko in Se)
        if (Se.hasOwnProperty(ko) && Ot(Cn, ko))
          return ko;
      return "other";
    }
    function an(We, Cn) {
      return Ot(Gt(We), Cn);
    }
    function Ot(We, Cn) {
      var Xe;
      let ko = (Xe = Se[Cn]) == null ? void 0 : Xe.split(",");
      return Object.entries(wt).map((un) => ko.includes(un[1]) ? un[0] : null).filter((un) => !!un).indexOf(We) > -1;
    }
    const Ee = Qo(() => W.acceptableTypes.map((We) => (We = We.replace(".", ""), wt[We] || Se[We] || null)).filter((We) => !!We).join(",")), wt = {
      aac: "audio/aac",
      avi: "video/x-msvideo",
      azw: "application/vnd.amazon.ebook",
      bin: "application/octet-stream",
      bmp: "image/bmp",
      css: "text/css",
      csv: "text/csv",
      doc: "application/msword",
      docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      eot: "application/vnd.ms-fontobject",
      epub: "application/epub+zip",
      gz: "application/gzip",
      gif: "image/gif",
      htm: "text/html",
      html: "text/html",
      ico: "image/vnd.microsoft.icon",
      ics: "text/calendar",
      jar: "application/java-archive",
      jpeg: "image/jpeg",
      jpg: "image/jpeg",
      js: "text/javascript,",
      json: "application/json",
      jsonld: "application/ld+json",
      geojson: "application/geo+json",
      mid: "audio/midi,audio/x-midi",
      midi: "audio/midi,audio/x-midi",
      mjs: "text/javascript",
      mp3: "audio/mpeg",
      mpeg: "video/mpeg",
      mpkg: "application/vnd.apple.installer+xml",
      mov: "video/quicktime",
      odp: "application/vnd.oasis.opendocument.presentation",
      ods: "application/vnd.oasis.opendocument.spreadsheet",
      odt: "application/vnd.oasis.opendocument.text",
      oga: "audio/ogg",
      ogv: "video/ogg",
      ogx: "application/ogg",
      opus: "audio/opus",
      otf: "font/otf",
      png: "image/png",
      pdf: "application/pdf",
      php: "application/x-httpd-php",
      ppt: "application/vnd.ms-powerpoint",
      pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
      rar: "application/vnd.rar",
      rtf: "application/rtf",
      sh: "application/x-sh",
      svg: "image/svg+xml",
      swf: "application/x-shockwave-flash",
      tar: "application/x-tar",
      tif: "image/tiff",
      tiff: "image/tiff",
      ts: "video/mp2t",
      ttf: "font/ttf",
      txt: "text/plain",
      vsd: "application/vnd.visio",
      wav: "audio/wav",
      weba: "audio/webm",
      webm: "video/webm",
      webp: "image/webp",
      woff: "font/woff",
      woff2: "font/woff2",
      xhtml: "application/xhtml+xml",
      xls: "application/vnd.ms-excel",
      xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      xml: "application/xml",
      xul: "application/vnd.mozilla.xul+xml",
      zip: "application/zip",
      mp4: "video/mp4"
    }, Se = {
      image: [
        wt.bmp,
        wt.gif,
        wt.ico,
        wt.jpeg,
        wt.jpg,
        wt.png,
        wt.svg,
        wt.tif,
        wt.tiff,
        wt.webp
      ].join(","),
      video: [
        wt.avi,
        wt.mpeg,
        wt.mov,
        wt.ogv,
        wt.ts,
        wt.webm,
        wt.mp4
      ].join(","),
      document: [
        wt.doc,
        wt.docx,
        wt.odp,
        wt.ods,
        wt.odt,
        wt.pdf,
        wt.rtf,
        wt.txt,
        wt.xls,
        wt.xlsx
      ].join(","),
      audio: [
        wt.aac,
        wt.mid,
        wt.midi,
        wt.mp3,
        wt.oga,
        wt.opus,
        wt.wav,
        wt.weba
      ].join(",")
    };
    return (We, Cn) => {
      var ko, jn;
      return kn(), no("div", {
        class: tc({ "blur-sm": v.disabled })
      }, [
        pe.value ? (kn(), no("div", YG, [
          Co("div", {
            class: "bg-contain bg-no-repeat bg-center absolute top-2 left-2 bottom-2 right-2 grid justify-items-center content-center items-center",
            style: Y2(Ze.value)
          }, [
            Ze.value ? Ks("", !0) : (kn(), no("div", XG, [
              Me.value === "document" || Me.value === "other" ? (kn(), no("svg", JG, Cn[4] || (Cn[4] = [
                Co("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
                }, null, -1)
              ]))) : Ks("", !0),
              Me.value === "image" ? (kn(), no("svg", QG, Cn[5] || (Cn[5] = [
                Co("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  d: "M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 001.5-1.5V6a1.5 1.5 0 00-1.5-1.5H3.75A1.5 1.5 0 002.25 6v12a1.5 1.5 0 001.5 1.5zm10.5-11.25h.008v.008h-.008V8.25zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z"
                }, null, -1)
              ]))) : Ks("", !0),
              Me.value === "video" ? (kn(), no("svg", eK, Cn[6] || (Cn[6] = [
                Co("path", {
                  "stroke-linecap": "round",
                  d: "M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z"
                }, null, -1)
              ]))) : Ks("", !0),
              Me.value === "sound" ? (kn(), no("svg", tK, Cn[7] || (Cn[7] = [
                Co("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  d: "M12 18.75a6 6 0 006-6v-1.5m-6 7.5a6 6 0 01-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5M12 15.75a3 3 0 01-3-3V4.5a3 3 0 116 0v8.25a3 3 0 01-3 3z"
                }, null, -1)
              ]))) : Ks("", !0),
              Me.value === "empty" ? (kn(), no("svg", nK, Cn[8] || (Cn[8] = [
                Co("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  d: "M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"
                }, null, -1)
              ]))) : Ks("", !0),
              Me.value !== "image" ? (kn(), no("div", oK, [
                ng(gT.isString)(v.modelValue) ? (kn(), no("a", {
                  key: 0,
                  href: v.modelValue,
                  target: "_blank",
                  class: "hover:underline"
                }, ji(pe.value), 9, rK)) : (kn(), no("span", sK, ji(pe.value), 1))
              ])) : Ks("", !0)
            ]))
          ], 4),
          v.modelValue && v.modelValue != v.placeholder ? (kn(), no("button", {
            key: 0,
            onClick: Cn[0] || (Cn[0] = (Xe) => en()),
            type: "button",
            class: "text-red-500 rounded-full hover:bg-red-200 p-1 shadow border border-red-200 bg-white absolute -top-3 -right-3"
          }, Cn[9] || (Cn[9] = [
            Co("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              class: "h-6 w-6",
              fill: "none",
              viewBox: "0 0 24 24",
              stroke: "currentColor"
            }, [
              Co("path", {
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                d: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
              })
            ], -1)
          ]))) : Ks("", !0)
        ])) : Ks("", !0),
        pe.value ? Ks("", !0) : (kn(), no("div", {
          key: 1,
          class: tc(["mt-1 flex justify-center px-6 pt-5 pb-6 border-2 border-gray-300 border-dashed rounded-md bg-white", (ko = ce.value) != null && ko.dropActive ? "border-blue-500 bg-blue-100" : ""])
        }, [
          Co("div", aK, [
            (kn(), no("svg", {
              class: tc([(jn = ce.value) != null && jn.dropActive ? "text-blue-500" : "", "mx-auto h-12 w-12 text-gray-400"]),
              stroke: "currentColor",
              fill: "none",
              viewBox: "0 0 48 48",
              "aria-hidden": "true"
            }, Cn[10] || (Cn[10] = [
              Co("path", {
                d: "M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02",
                "stroke-width": "2",
                "stroke-linecap": "round",
                "stroke-linejoin": "round"
              }, null, -1)
            ]), 2)),
            Co("div", iK, [
              Qf(KG, {
                class: "relative cursor-pointer rounded-md font-medium text-blue-600 hover:text-blue-500 focus-within:outline-none focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-blue-500",
                "input-id": v.id,
                multiple: v.multiple,
                drop: !0,
                "drop-directory": !0,
                accept: Ee.value,
                size: yt.value,
                modelValue: Ye.value,
                "onUpdate:modelValue": Cn[1] || (Cn[1] = (Xe) => Ye.value = Xe),
                onInputFile: he,
                ref_key: "upload",
                ref: ce
              }, {
                default: bf(() => Cn[11] || (Cn[11] = [
                  Co("span", null, "Upload a file", -1)
                ])),
                _: 1
              }, 8, ["input-id", "multiple", "accept", "size", "modelValue"]),
              Cn[12] || (Cn[12] = Co("div", { class: "pl-1" }, "or drag and drop", -1))
            ]),
            Co("div", lK, ji(it.value), 1),
            v.multiple && Ye.value.length ? (kn(), no("ul", cK, [
              (kn(!0), no(th, null, Oy(Ye.value, (Xe) => (kn(), no("li", {
                key: Xe.id,
                class: "p-2 flex items-center rounded-md"
              }, [
                Co("button", {
                  onClick: (un) => en(Xe),
                  type: "button",
                  class: "text-red-500 rounded-full hover:bg-red-200 p-1"
                }, Cn[13] || (Cn[13] = [
                  Co("svg", {
                    xmlns: "http://www.w3.org/2000/svg",
                    class: "h-6 w-6",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    stroke: "currentColor"
                  }, [
                    Co("path", {
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      "stroke-width": "2",
                      d: "M6 18L18 6M6 6l12 12"
                    })
                  ], -1)
                ]), 8, uK),
                Co("span", dK, ji(Xe.name) + " - " + ji(Rt(Xe.size)), 1)
              ]))), 128))
            ])) : Ks("", !0)
          ])
        ], 2)),
        Ks("", !0)
      ], 2);
    };
  }
};
var fK = { exports: {} };
(function(v) {
  (function() {
    var L = function(e) {
      if (e === null)
        return "null";
      if (e === void 0)
        return "undefined";
      var t = typeof e;
      return t === "object" && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === "Array") ? "array" : t === "object" && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === "String") ? "string" : t;
    }, N = function(e) {
      return [
        "undefined",
        "boolean",
        "number",
        "string",
        "function",
        "xml",
        "null"
      ].indexOf(e) !== -1;
    }, W = function(e, t) {
      var n = Array.prototype.slice.call(e);
      return n.sort(t);
    }, ue = function(e, t) {
      return ce(function(n, r) {
        return e.eq(t(n), t(r));
      });
    }, ce = function(e) {
      return { eq: e };
    }, he = ce(function(e, t) {
      return e === t;
    }), pe = he, Me = function(e) {
      return ce(function(t, n) {
        if (t.length !== n.length)
          return !1;
        for (var r = t.length, a = 0; a < r; a++)
          if (!e.eq(t[a], n[a]))
            return !1;
        return !0;
      });
    }, Ze = function(e, t) {
      return ue(Me(e), function(n) {
        return W(n, t);
      });
    }, Ye = function(e) {
      return ce(function(t, n) {
        var r = Object.keys(t), a = Object.keys(n);
        if (!Ze(pe).eq(r, a))
          return !1;
        for (var c = r.length, d = 0; d < c; d++) {
          var h = r[d];
          if (!e.eq(t[h], n[h]))
            return !1;
        }
        return !0;
      });
    }, yt = ce(function(e, t) {
      if (e === t)
        return !0;
      var n = L(e), r = L(t);
      return n !== r ? !1 : N(n) ? e === t : n === "array" ? Me(yt).eq(e, t) : n === "object" ? Ye(yt).eq(e, t) : !1;
    });
    const jt = Object.getPrototypeOf, it = (e, t, n) => {
      var r;
      return n(e, t.prototype) ? !0 : ((r = e.constructor) === null || r === void 0 ? void 0 : r.name) === t.name;
    }, Rt = (e) => {
      const t = typeof e;
      return e === null ? "null" : t === "object" && Array.isArray(e) ? "array" : t === "object" && it(e, String, (n, r) => r.isPrototypeOf(n)) ? "string" : t;
    }, en = (e) => (t) => Rt(t) === e, Gt = (e) => (t) => typeof t === e, gt = (e) => (t) => e === t, an = (e, t) => Ee(e) && it(e, t, (n, r) => jt(n) === r), Ot = en("string"), Ee = en("object"), wt = (e) => an(e, Object), Se = en("array"), We = gt(null), Cn = Gt("boolean"), ko = gt(void 0), jn = (e) => e == null, Xe = (e) => !jn(e), un = Gt("function"), M = Gt("number"), Et = (e, t) => {
      if (Se(e)) {
        for (let n = 0, r = e.length; n < r; ++n)
          if (!t(e[n]))
            return !1;
        return !0;
      }
      return !1;
    }, ht = () => {
    }, mn = (e, t) => (...n) => e(t.apply(null, n)), lo = (e, t) => (n) => e(t(n)), dt = (e) => () => e, Bn = (e) => e, jr = (e, t) => e === t;
    function Tt(e, ...t) {
      return (...n) => {
        const r = t.concat(n);
        return e.apply(null, r);
      };
    }
    const yo = (e) => (t) => !e(t), Ct = (e) => () => {
      throw new Error(e);
    }, tn = (e) => e(), oa = (e) => {
      e();
    }, Pn = dt(!1), Mo = dt(!0);
    class K {
      constructor(t, n) {
        this.tag = t, this.value = n;
      }
      static some(t) {
        return new K(!0, t);
      }
      static none() {
        return K.singletonNone;
      }
      fold(t, n) {
        return this.tag ? n(this.value) : t();
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(t) {
        return this.tag ? K.some(t(this.value)) : K.none();
      }
      bind(t) {
        return this.tag ? t(this.value) : K.none();
      }
      exists(t) {
        return this.tag && t(this.value);
      }
      forall(t) {
        return !this.tag || t(this.value);
      }
      filter(t) {
        return !this.tag || t(this.value) ? this : K.none();
      }
      getOr(t) {
        return this.tag ? this.value : t;
      }
      or(t) {
        return this.tag ? this : t;
      }
      getOrThunk(t) {
        return this.tag ? this.value : t();
      }
      orThunk(t) {
        return this.tag ? this : t();
      }
      getOrDie(t) {
        if (this.tag)
          return this.value;
        throw new Error(t ?? "Called getOrDie on None");
      }
      static from(t) {
        return Xe(t) ? K.some(t) : K.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(t) {
        this.tag && t(this.value);
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    K.singletonNone = new K(!1);
    const Go = Array.prototype.slice, Zi = Array.prototype.indexOf, er = Array.prototype.push, Qr = (e, t) => Zi.call(e, t), nc = (e, t) => {
      const n = Qr(e, t);
      return n === -1 ? K.none() : K.some(n);
    }, So = (e, t) => Qr(e, t) > -1, cr = (e, t) => {
      for (let n = 0, r = e.length; n < r; n++) {
        const a = e[n];
        if (t(a, n))
          return !0;
      }
      return !1;
    }, oo = (e, t) => {
      const n = e.length, r = new Array(n);
      for (let a = 0; a < n; a++) {
        const c = e[a];
        r[a] = t(c, a);
      }
      return r;
    }, ut = (e, t) => {
      for (let n = 0, r = e.length; n < r; n++) {
        const a = e[n];
        t(a, n);
      }
    }, kt = (e, t) => {
      for (let n = e.length - 1; n >= 0; n--) {
        const r = e[n];
        t(r, n);
      }
    }, It = (e, t) => {
      const n = [], r = [];
      for (let a = 0, c = e.length; a < c; a++) {
        const d = e[a];
        (t(d, a) ? n : r).push(d);
      }
      return {
        pass: n,
        fail: r
      };
    }, ct = (e, t) => {
      const n = [];
      for (let r = 0, a = e.length; r < a; r++) {
        const c = e[r];
        t(c, r) && n.push(c);
      }
      return n;
    }, xn = (e, t, n) => (kt(e, (r, a) => {
      n = t(n, r, a);
    }), n), co = (e, t, n) => (ut(e, (r, a) => {
      n = t(n, r, a);
    }), n), Ko = (e, t, n) => {
      for (let r = 0, a = e.length; r < a; r++) {
        const c = e[r];
        if (t(c, r))
          return K.some(c);
        if (n(c, r))
          break;
      }
      return K.none();
    }, po = (e, t) => Ko(e, t, Pn), Ra = (e, t) => {
      for (let n = 0, r = e.length; n < r; n++) {
        const a = e[n];
        if (t(a, n))
          return K.some(n);
      }
      return K.none();
    }, Mr = (e) => {
      const t = [];
      for (let n = 0, r = e.length; n < r; ++n) {
        if (!Se(e[n]))
          throw new Error("Arr.flatten item " + n + " was not an array, input: " + e);
        er.apply(t, e[n]);
      }
      return t;
    }, ho = (e, t) => Mr(oo(e, t)), Ns = (e, t) => {
      for (let n = 0, r = e.length; n < r; ++n) {
        const a = e[n];
        if (t(a, n) !== !0)
          return !1;
      }
      return !0;
    }, Ca = (e) => {
      const t = Go.call(e, 0);
      return t.reverse(), t;
    }, Zr = (e, t) => ct(e, (n) => !So(t, n)), $r = (e, t) => {
      const n = {};
      for (let r = 0, a = e.length; r < a; r++) {
        const c = e[r];
        n[String(c)] = t(c, r);
      }
      return n;
    }, Po = (e, t) => {
      const n = Go.call(e, 0);
      return n.sort(t), n;
    }, ha = (e, t) => t >= 0 && t < e.length ? K.some(e[t]) : K.none(), ro = (e) => ha(e, 0), cn = (e) => ha(e, e.length - 1), _n = un(Array.from) ? Array.from : (e) => Go.call(e), Ys = (e, t) => {
      for (let n = 0; n < e.length; n++) {
        const r = t(e[n], n);
        if (r.isSome())
          return r;
      }
      return K.none();
    }, Si = (e, t) => {
      const n = [], r = un(t) ? (a) => cr(n, (c) => t(c, a)) : (a) => So(n, a);
      for (let a = 0, c = e.length; a < c; a++) {
        const d = e[a];
        r(d) || n.push(d);
      }
      return n;
    }, Nt = Object.keys, fi = Object.hasOwnProperty, Zo = (e, t) => {
      const n = Nt(e);
      for (let r = 0, a = n.length; r < a; r++) {
        const c = n[r], d = e[c];
        t(d, c);
      }
    }, mi = (e, t) => kr(e, (n, r) => ({
      k: r,
      v: t(n, r)
    })), kr = (e, t) => {
      const n = {};
      return Zo(e, (r, a) => {
        const c = t(r, a);
        n[c.k] = c.v;
      }), n;
    }, Qu = (e) => (t, n) => {
      e[n] = t;
    }, ba = (e, t, n, r) => {
      Zo(e, (a, c) => {
        (t(a, c) ? n : r)(a, c);
      });
    }, xc = (e, t) => {
      const n = {}, r = {};
      return ba(e, t, Qu(n), Qu(r)), {
        t: n,
        f: r
      };
    }, _l = (e, t) => {
      const n = {};
      return ba(e, t, Qu(n), ht), n;
    }, Wi = (e, t) => {
      const n = [];
      return Zo(e, (r, a) => {
        n.push(t(r, a));
      }), n;
    }, oc = (e) => Wi(e, Bn), Hr = (e, t) => Yn(e, t) ? K.from(e[t]) : K.none(), Yn = (e, t) => fi.call(e, t), qi = (e, t) => Yn(e, t) && e[t] !== void 0 && e[t] !== null, Ei = (e, t, n = yt) => Ye(n).eq(e, t), Cl = (e) => {
      const t = {};
      return ut(e, (n) => {
        t[n] = {};
      }), Nt(t);
    }, Xc = (e) => e.length !== void 0, Xt = Array.isArray, Dd = (e) => {
      if (Xt(e))
        return e;
      {
        const t = [];
        for (let n = 0, r = e.length; n < r; n++)
          t[n] = e[n];
        return t;
      }
    }, es = (e, t, n) => {
      if (!e)
        return !1;
      if (n = n || e, Xc(e)) {
        for (let r = 0, a = e.length; r < a; r++)
          if (t.call(n, e[r], r, e) === !1)
            return !1;
      } else
        for (const r in e)
          if (Yn(e, r) && t.call(n, e[r], r, e) === !1)
            return !1;
      return !0;
    }, yf = (e, t) => {
      const n = [];
      return es(e, (r, a) => {
        n.push(t(r, a, e));
      }), n;
    }, Rd = (e, t) => {
      const n = [];
      return es(e, (r, a) => {
        (!t || t(r, a, e)) && n.push(r);
      }), n;
    }, Ti = (e, t) => {
      if (e) {
        for (let n = 0, r = e.length; n < r; n++)
          if (e[n] === t)
            return n;
      }
      return -1;
    }, wc = (e, t, n, r) => {
      let a = ko(n) ? e[0] : n;
      for (let c = 0; c < e.length; c++)
        a = t.call(r, a, e[c], c);
      return a;
    }, pi = (e, t, n) => {
      for (let r = 0, a = e.length; r < a; r++)
        if (t.call(n, e[r], r, e))
          return r;
      return -1;
    }, ra = (e) => e[e.length - 1], Gi = (e) => {
      let t = !1, n;
      return (...r) => (t || (t = !0, n = e.apply(null, r)), n);
    }, vf = (e, t, n, r) => {
      const a = e.isiOS() && /ipad/i.test(n) === !0, c = e.isiOS() && !a, d = e.isiOS() || e.isAndroid(), h = d || r("(pointer:coarse)"), k = a || !c && d && r("(min-device-width:768px)"), D = c || d && !k, H = t.isSafari() && e.isiOS() && /safari/i.test(n) === !1, U = !D && !k && !H;
      return {
        isiPad: dt(a),
        isiPhone: dt(c),
        isTablet: dt(k),
        isPhone: dt(D),
        isTouch: dt(h),
        isAndroid: e.isAndroid,
        isiOS: e.isiOS,
        isWebView: dt(H),
        isDesktop: dt(U)
      };
    }, rc = (e, t) => {
      for (let n = 0; n < e.length; n++) {
        const r = e[n];
        if (r.test(t))
          return r;
      }
    }, tm = (e, t) => {
      const n = rc(e, t);
      if (!n)
        return {
          major: 0,
          minor: 0
        };
      const r = (a) => Number(t.replace(n, "$" + a));
      return tr(r(1), r(2));
    }, Sl = (e, t) => {
      const n = String(t).toLowerCase();
      return e.length === 0 ? Nd() : tm(e, n);
    }, Nd = () => tr(0, 0), tr = (e, t) => ({
      major: e,
      minor: t
    }), Ms = {
      nu: tr,
      detect: Sl,
      unknown: Nd
    }, ni = (e, t) => Ys(t.brands, (n) => {
      const r = n.brand.toLowerCase();
      return po(e, (a) => {
        var c;
        return r === ((c = a.brand) === null || c === void 0 ? void 0 : c.toLowerCase());
      }).map((a) => ({
        current: a.name,
        version: Ms.nu(parseInt(n.version, 10), 0)
      }));
    }), Jc = (e, t) => {
      const n = String(t).toLowerCase();
      return po(e, (r) => r.search(n));
    }, Md = (e, t) => Jc(e, t).map((n) => {
      const r = Ms.detect(n.versionRegexes, t);
      return {
        current: n.name,
        version: r
      };
    }), Bd = (e, t) => Jc(e, t).map((n) => {
      const r = Ms.detect(n.versionRegexes, t);
      return {
        current: n.name,
        version: r
      };
    }), cl = (e, t) => e.substring(t), sa = (e, t, n) => t === "" || e.length >= t.length && e.substr(n, n + t.length) === t, nm = (e, t) => Dr(e, t) ? cl(e, t.length) : e, _r = (e, t, n = 0, r) => {
      const a = e.indexOf(t, n);
      return a !== -1 ? ko(r) ? !0 : a + t.length <= r : !1;
    }, Dr = (e, t) => sa(e, t, 0), El = (e, t) => sa(e, t, e.length - t.length), ul = (e) => (t) => t.replace(e, ""), Lc = ul(/^\s+|\s+$/g), kc = ul(/^\s+/g), gu = ul(/\s+$/g), Na = (e) => e.length > 0, us = (e) => !Na(e), Ma = (e, t) => t <= 0 ? "" : new Array(t + 1).join(e), Us = (e, t = 10) => {
      const n = parseInt(e, t);
      return isNaN(n) ? K.none() : K.some(n);
    }, dl = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, Rr = (e) => (t) => _r(t, e), Wa = [
      {
        name: "Edge",
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: (e) => _r(e, "edge/") && _r(e, "chrome") && _r(e, "safari") && _r(e, "applewebkit")
      },
      {
        name: "Chromium",
        brand: "Chromium",
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          dl
        ],
        search: (e) => _r(e, "chrome") && !_r(e, "chromeframe")
      },
      {
        name: "IE",
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: (e) => _r(e, "msie") || _r(e, "trident")
      },
      {
        name: "Opera",
        versionRegexes: [
          dl,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: Rr("opera")
      },
      {
        name: "Firefox",
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: Rr("firefox")
      },
      {
        name: "Safari",
        versionRegexes: [
          dl,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: (e) => (_r(e, "safari") || _r(e, "mobile/")) && _r(e, "applewebkit")
      }
    ], zi = [
      {
        name: "Windows",
        search: Rr("win"),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "iOS",
        search: (e) => _r(e, "iphone") || _r(e, "ipad"),
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: "Android",
        search: Rr("android"),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "macOS",
        search: Rr("mac os x"),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: "Linux",
        search: Rr("linux"),
        versionRegexes: []
      },
      {
        name: "Solaris",
        search: Rr("sunos"),
        versionRegexes: []
      },
      {
        name: "FreeBSD",
        search: Rr("freebsd"),
        versionRegexes: []
      },
      {
        name: "ChromeOS",
        search: Rr("cros"),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ], qa = {
      browsers: dt(Wa),
      oses: dt(zi)
    }, eo = "Edge", gi = "Chromium", js = "IE", Sa = "Opera", Ki = "Firefox", ts = "Safari", Bs = () => sc({
      current: void 0,
      version: Ms.unknown()
    }), sc = (e) => {
      const t = e.current, n = e.version, r = (a) => () => t === a;
      return {
        current: t,
        version: n,
        isEdge: r(eo),
        isChromium: r(gi),
        isIE: r(js),
        isOpera: r(Sa),
        isFirefox: r(Ki),
        isSafari: r(ts)
      };
    }, qn = {
      unknown: Bs,
      nu: sc,
      edge: dt(eo),
      chromium: dt(gi),
      ie: dt(js),
      opera: dt(Sa),
      firefox: dt(Ki),
      safari: dt(ts)
    }, ac = "Windows", Yi = "iOS", Ts = "Android", fl = "Linux", Xs = "macOS", hu = "Solaris", xf = "FreeBSD", ar = "ChromeOS", te = () => ze({
      current: void 0,
      version: Ms.unknown()
    }), ze = (e) => {
      const t = e.current, n = e.version, r = (a) => () => t === a;
      return {
        current: t,
        version: n,
        isWindows: r(ac),
        isiOS: r(Yi),
        isAndroid: r(Ts),
        isMacOS: r(Xs),
        isLinux: r(fl),
        isSolaris: r(hu),
        isFreeBSD: r(xf),
        isChromeOS: r(ar)
      };
    }, Pe = {
      unknown: te,
      nu: ze,
      windows: dt(ac),
      ios: dt(Yi),
      android: dt(Ts),
      linux: dt(fl),
      macos: dt(Xs),
      solaris: dt(hu),
      freebsd: dt(xf),
      chromeos: dt(ar)
    }, Ft = { detect: (e, t, n) => {
      const r = qa.browsers(), a = qa.oses(), c = t.bind((k) => ni(r, k)).orThunk(() => Md(r, e)).fold(qn.unknown, qn.nu), d = Bd(a, e).fold(Pe.unknown, Pe.nu), h = vf(d, c, e, n);
      return {
        browser: c,
        os: d,
        deviceType: h
      };
    } }, An = (e) => window.matchMedia(e).matches;
    let so = Gi(() => Ft.detect(navigator.userAgent, K.from(navigator.userAgentData), An));
    const Zn = () => so(), $n = navigator.userAgent, ds = Zn(), Cr = ds.browser, Wr = ds.os, Ba = ds.deviceType, ml = $n.indexOf("Windows Phone") !== -1, nr = {
      transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
      documentMode: Cr.isIE() ? document.documentMode || 7 : 10,
      cacheSuffix: null,
      container: null,
      canHaveCSP: !Cr.isIE(),
      windowsPhone: ml,
      browser: {
        current: Cr.current,
        version: Cr.version,
        isChromium: Cr.isChromium,
        isEdge: Cr.isEdge,
        isFirefox: Cr.isFirefox,
        isIE: Cr.isIE,
        isOpera: Cr.isOpera,
        isSafari: Cr.isSafari
      },
      os: {
        current: Wr.current,
        version: Wr.version,
        isAndroid: Wr.isAndroid,
        isChromeOS: Wr.isChromeOS,
        isFreeBSD: Wr.isFreeBSD,
        isiOS: Wr.isiOS,
        isLinux: Wr.isLinux,
        isMacOS: Wr.isMacOS,
        isSolaris: Wr.isSolaris,
        isWindows: Wr.isWindows
      },
      deviceType: {
        isDesktop: Ba.isDesktop,
        isiPad: Ba.isiPad,
        isiPhone: Ba.isiPhone,
        isPhone: Ba.isPhone,
        isTablet: Ba.isTablet,
        isTouch: Ba.isTouch,
        isWebView: Ba.isWebView
      }
    }, wf = /^\s*|\s*$/g, Qc = (e) => jn(e) ? "" : ("" + e).replace(wf, ""), Ga = (e, t) => t ? t === "array" && Xt(e) ? !0 : typeof e === t : e !== void 0, Ld = (e, t, n = {}) => {
      const r = Ot(e) ? e.split(t || ",") : e || [];
      let a = r.length;
      for (; a--; )
        n[r[a]] = {};
      return n;
    }, aa = Yn, sg = (e, ...t) => {
      for (let n = 0; n < t.length; n++) {
        const r = t[n];
        for (const a in r)
          if (Yn(r, a)) {
            const c = r[a];
            c !== void 0 && (e[a] = c);
          }
      }
      return e;
    }, oi = function(e, t, n, r) {
      r = r || this, e && (n && (e = e[n]), es(e, (a, c) => t.call(r, a, c, n) === !1 ? !1 : (oi(a, t, n, r), !0)));
    }, Ht = {
      trim: Qc,
      isArray: Xt,
      is: Ga,
      toArray: Dd,
      makeMap: Ld,
      each: es,
      map: yf,
      grep: Rd,
      inArray: Ti,
      hasOwn: aa,
      extend: sg,
      walk: oi,
      resolve: (e, t = window) => {
        const n = e.split(".");
        for (let r = 0, a = n.length; r < a && (t = t[n[r]], !!t); r++)
          ;
        return t;
      },
      explode: (e, t) => Se(e) ? e : e === "" ? [] : yf(e.split(t || ","), Qc),
      _addCacheSuffix: (e) => {
        const t = nr.cacheSuffix;
        return t && (e += (e.indexOf("?") === -1 ? "?" : "&") + t), e;
      }
    }, Pd = (e, t, n = jr) => e.exists((r) => n(r, t)), _p = (e, t, n = jr) => ns(e, t, n).getOr(e.isNone() && t.isNone()), ed = (e) => {
      const t = [], n = (r) => {
        t.push(r);
      };
      for (let r = 0; r < e.length; r++)
        e[r].each(n);
      return t;
    }, ns = (e, t, n) => e.isSome() && t.isSome() ? K.some(n(e.getOrDie(), t.getOrDie())) : K.none(), ag = (e, t, n, r) => e.isSome() && t.isSome() && n.isSome() ? K.some(r(e.getOrDie(), t.getOrDie(), n.getOrDie())) : K.none(), Xi = (e, t) => e ? K.some(t) : K.none(), Id = typeof window < "u" ? window : Function("return this;")(), Cp = (e, t) => {
      let n = t ?? Id;
      for (let r = 0; r < e.length && n !== void 0 && n !== null; ++r)
        n = n[e[r]];
      return n;
    }, Pc = (e, t) => {
      const n = e.split(".");
      return Cp(n, t);
    }, bu = (e, t) => Pc(e, t), rh = (e, t) => {
      const n = bu(e, t);
      if (n == null)
        throw new Error(e + " not available on this browser");
      return n;
    }, Ea = Object.getPrototypeOf, yu = (e) => rh("HTMLElement", e), ig = (e) => {
      const t = Pc("ownerDocument.defaultView", e);
      return Ee(e) && (yu(t).prototype.isPrototypeOf(e) || /^HTML\w*Element$/.test(Ea(e).constructor.name));
    }, eu = 8, om = 9, kf = 11, _c = 1, Ic = 3, Eo = (e) => e.dom.nodeName.toLowerCase(), Fd = (e) => e.dom.nodeType, ia = (e) => (t) => Fd(t) === e, td = (e) => Fd(e) === eu || Eo(e) === "#comment", $d = (e) => Ji(e) && ig(e.dom), Ji = ia(_c), Zs = ia(Ic), nd = ia(om), rm = ia(kf), ya = (e) => (t) => Ji(t) && Eo(t) === e, Ls = (e, t, n) => {
      if (Ot(n) || Cn(n) || M(n))
        e.setAttribute(t, n + "");
      else
        throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", n, ":: Element ", e), new Error("Attribute value was not simple");
    }, Vr = (e, t, n) => {
      Ls(e.dom, t, n);
    }, zs = (e, t) => {
      const n = e.dom;
      Zo(t, (r, a) => {
        Ls(n, a, r);
      });
    }, Qi = (e, t) => {
      const n = e.dom.getAttribute(t);
      return n === null ? void 0 : n;
    }, Js = (e, t) => K.from(Qi(e, t)), La = (e, t) => {
      const n = e.dom;
      return n && n.hasAttribute ? n.hasAttribute(t) : !1;
    }, xs = (e, t) => {
      e.dom.removeAttribute(t);
    }, Hd = (e) => {
      const t = e.dom.attributes;
      return t == null || t.length === 0;
    }, Ws = (e) => co(e.dom.attributes, (t, n) => (t[n.name] = n.value, t), {}), va = (e, t) => {
      const n = Qi(e, t);
      return n === void 0 || n === "" ? [] : n.split(" ");
    }, la = (e, t, n) => {
      const a = va(e, t).concat([n]);
      return Vr(e, t, a.join(" ")), !0;
    }, od = (e, t, n) => {
      const r = ct(va(e, t), (a) => a !== n);
      return r.length > 0 ? Vr(e, t, r.join(" ")) : xs(e, t), !1;
    }, os = (e) => e.dom.classList !== void 0, sm = (e) => va(e, "class"), vu = (e, t) => la(e, "class", t), Cc = (e, t) => od(e, "class", t), To = (e, t) => So(sm(e), t) ? Cc(e, t) : vu(e, t), ca = (e, t) => {
      os(e) ? e.dom.classList.add(t) : vu(e, t);
    }, rd = (e) => {
      (os(e) ? e.dom.classList : sm(e)).length === 0 && xs(e, "class");
    }, Oi = (e, t) => {
      os(e) ? e.dom.classList.remove(t) : Cc(e, t), rd(e);
    }, Vd = (e, t) => {
      const n = os(e) ? e.dom.classList.toggle(t) : To(e, t);
      return rd(e), n;
    }, Fc = (e, t) => os(e) && e.dom.classList.contains(t), xu = (e, t) => {
      const r = (t || document).createElement("div");
      if (r.innerHTML = e, !r.hasChildNodes() || r.childNodes.length > 1) {
        const a = "HTML does not have a single root node";
        throw console.error(a, e), new Error(a);
      }
      return ri(r.childNodes[0]);
    }, lg = (e, t) => {
      const r = (t || document).createElement(e);
      return ri(r);
    }, wu = (e, t) => {
      const r = (t || document).createTextNode(e);
      return ri(r);
    }, ri = (e) => {
      if (e == null)
        throw new Error("Node cannot be null or undefined");
      return { dom: e };
    }, be = {
      fromHtml: xu,
      fromTag: lg,
      fromText: wu,
      fromDom: ri,
      fromPoint: (e, t, n) => K.from(e.dom.elementFromPoint(t, n)).map(ri)
    }, Sc = (e, t) => {
      const n = [], r = (c) => (n.push(c), t(c));
      let a = t(e);
      do
        a = a.bind(r);
      while (a.isSome());
      return n;
    }, Ai = (e, t) => {
      const n = e.dom;
      if (n.nodeType !== _c)
        return !1;
      {
        const r = n;
        if (r.matches !== void 0)
          return r.matches(t);
        if (r.msMatchesSelector !== void 0)
          return r.msMatchesSelector(t);
        if (r.webkitMatchesSelector !== void 0)
          return r.webkitMatchesSelector(t);
        if (r.mozMatchesSelector !== void 0)
          return r.mozMatchesSelector(t);
        throw new Error("Browser lacks native selectors");
      }
    }, tu = (e) => e.nodeType !== _c && e.nodeType !== om && e.nodeType !== kf || e.childElementCount === 0, _f = (e, t) => {
      const n = t === void 0 ? document : t.dom;
      return tu(n) ? [] : oo(n.querySelectorAll(e), be.fromDom);
    }, sd = (e, t) => {
      const n = t === void 0 ? document : t.dom;
      return tu(n) ? K.none() : K.from(n.querySelector(e)).map(be.fromDom);
    }, Le = (e, t) => e.dom === t.dom, Dt = (e, t) => {
      const n = e.dom, r = t.dom;
      return n === r ? !1 : n.contains(r);
    }, vt = (e) => be.fromDom(e.dom.ownerDocument), Sn = (e) => nd(e) ? e : vt(e), Fo = (e) => be.fromDom(Sn(e).dom.documentElement), ur = (e) => be.fromDom(Sn(e).dom.defaultView), Br = (e) => K.from(e.dom.parentNode).map(be.fromDom), Lr = (e) => K.from(e.dom.parentElement).map(be.fromDom), hi = (e, t) => {
      const n = un(t) ? t : Pn;
      let r = e.dom;
      const a = [];
      for (; r.parentNode !== null && r.parentNode !== void 0; ) {
        const c = r.parentNode, d = be.fromDom(c);
        if (a.push(d), n(d) === !0)
          break;
        r = c;
      }
      return a;
    }, Nn = (e) => {
      const t = (n) => ct(n, (r) => !Le(e, r));
      return Br(e).map(Pr).map(t).getOr([]);
    }, Ps = (e) => K.from(e.dom.previousSibling).map(be.fromDom), Di = (e) => K.from(e.dom.nextSibling).map(be.fromDom), cg = (e) => Ca(Sc(e, Ps)), Ec = (e) => Sc(e, Di), Pr = (e) => oo(e.dom.childNodes, be.fromDom), Tc = (e, t) => {
      const n = e.dom.childNodes;
      return K.from(n[t]).map(be.fromDom);
    }, qr = (e) => Tc(e, 0), xa = (e) => Tc(e, e.dom.childNodes.length - 1), $c = (e) => e.dom.childNodes.length, Ud = (e) => e.dom.hasChildNodes(), am = (e) => {
      const t = e.dom.head;
      if (t == null)
        throw new Error("Head is not available yet");
      return be.fromDom(t);
    }, Ep = (e) => rm(e) && Xe(e.dom.host), ku = un(Element.prototype.attachShadow) && un(Node.prototype.getRootNode), Tl = dt(ku), pl = ku ? (e) => be.fromDom(e.dom.getRootNode()) : Sn, Gr = (e) => Ep(e) ? e : am(Sn(e)), ic = (e) => Ep(e) ? e : be.fromDom(Sn(e).dom.body), Ta = (e) => {
      const t = pl(e);
      return Ep(t) ? K.some(t) : K.none();
    }, nu = (e) => be.fromDom(e.dom.host), bi = (e) => {
      if (Tl() && Xe(e.target)) {
        const t = be.fromDom(e.target);
        if (Ji(t) && ad(t) && e.composed && e.composedPath) {
          const n = e.composedPath();
          if (n)
            return ro(n);
        }
      }
      return K.from(e.target);
    }, ad = (e) => Xe(e.dom.shadowRoot), Qs = (e) => {
      const t = Zs(e) ? e.dom.parentNode : e.dom;
      if (t == null || t.ownerDocument === null)
        return !1;
      const n = t.ownerDocument;
      return Ta(be.fromDom(t)).fold(() => n.body.contains(t), lo(Qs, nu));
    };
    var ua = (e, t, n, r, a) => e(n, r) ? K.some(n) : un(a) && a(n) ? K.none() : t(n, r, a);
    const si = (e, t, n) => {
      let r = e.dom;
      const a = un(n) ? n : Pn;
      for (; r.parentNode; ) {
        r = r.parentNode;
        const c = be.fromDom(r);
        if (t(c))
          return K.some(c);
        if (a(c))
          break;
      }
      return K.none();
    }, st = (e, t, n) => ua((a, c) => c(a), si, e, t, n), zl = (e, t) => {
      const n = e.dom;
      return n.parentNode ? Lm(be.fromDom(n.parentNode), (r) => !Le(e, r) && t(r)) : K.none();
    }, Lm = (e, t) => {
      const n = (a) => t(be.fromDom(a));
      return po(e.dom.childNodes, n).map(be.fromDom);
    }, Is = (e, t) => {
      const n = (r) => {
        for (let a = 0; a < r.childNodes.length; a++) {
          const c = be.fromDom(r.childNodes[a]);
          if (t(c))
            return K.some(c);
          const d = n(r.childNodes[a]);
          if (d.isSome())
            return d;
        }
        return K.none();
      };
      return n(e.dom);
    }, Pa = (e, t, n) => si(e, (r) => Ai(r, t), n), Ia = (e, t) => sd(t, e), el = (e, t, n) => ua((a, c) => Ai(a, c), Pa, e, t, n), jd = (e) => el(e, "[contenteditable]"), Ka = (e, t = !1) => Qs(e) ? e.dom.isContentEditable : jd(e).fold(dt(t), (n) => pr(n) === "true"), pr = (e) => e.dom.contentEditable, Hl = (e) => e.style !== void 0 && un(e.style.getPropertyValue), ea = (e, t, n) => {
      if (!Ot(n))
        throw console.error("Invalid call to CSS.set. Property ", t, ":: Value ", n, ":: Element ", e), new Error("CSS value must be a string: " + n);
      Hl(e) && e.style.setProperty(t, n);
    }, Nr = (e, t) => {
      Hl(e) && e.style.removeProperty(t);
    }, Pm = (e, t, n) => {
      const r = e.dom;
      ea(r, t, n);
    }, Vl = (e, t) => {
      const n = e.dom;
      Zo(t, (r, a) => {
        ea(n, a, r);
      });
    }, Ya = (e, t) => {
      const n = e.dom, a = window.getComputedStyle(n).getPropertyValue(t);
      return a === "" && !Qs(e) ? Ol(n, t) : a;
    }, Ol = (e, t) => Hl(e) ? e.style.getPropertyValue(t) : "", He = (e, t) => {
      const n = e.dom, r = Ol(n, t);
      return K.from(r).filter((a) => a.length > 0);
    }, za = (e) => {
      const t = {}, n = e.dom;
      if (Hl(n))
        for (let r = 0; r < n.style.length; r++) {
          const a = n.style.item(r);
          t[a] = n.style[a];
        }
      return t;
    }, ou = (e, t) => {
      const n = e.dom;
      Nr(n, t), Pd(Js(e, "style").map(Lc), "") && xs(e, "style");
    }, Al = (e) => e.dom.offsetWidth, Fs = (e, t) => {
      Br(e).each((r) => {
        r.dom.insertBefore(t.dom, e.dom);
      });
    }, rs = (e, t) => {
      Di(e).fold(() => {
        Br(e).each((a) => {
          Ir(a, t);
        });
      }, (r) => {
        Fs(r, t);
      });
    }, fs = (e, t) => {
      qr(e).fold(() => {
        Ir(e, t);
      }, (r) => {
        e.dom.insertBefore(t.dom, r.dom);
      });
    }, Ir = (e, t) => {
      e.dom.appendChild(t.dom);
    }, im = (e, t) => {
      Fs(e, t), Ir(t, e);
    }, Ln = (e, t) => {
      ut(t, (n, r) => {
        const a = r === 0 ? e : t[r - 1];
        rs(a, n);
      });
    }, Fa = (e, t) => {
      ut(t, (n) => {
        Ir(e, n);
      });
    }, yi = (e) => {
      e.dom.textContent = "", ut(Pr(e), (t) => {
        dr(t);
      });
    }, dr = (e) => {
      const t = e.dom;
      t.parentNode !== null && t.parentNode.removeChild(t);
    }, wa = (e) => {
      const t = Pr(e);
      t.length > 0 && Ln(e, t), dr(e);
    }, zc = (e, t) => {
      const r = (t || document).createElement("div");
      return r.innerHTML = e, Pr(be.fromDom(r));
    }, lc = (e) => oo(e, be.fromDom), de = (e) => e.dom.innerHTML, Hc = (e, t) => {
      const r = vt(e).dom, a = be.fromDom(r.createDocumentFragment()), c = zc(t, r);
      Fa(a, c), yi(e), Ir(e, a);
    }, Oc = (e) => {
      const t = be.fromTag("div"), n = be.fromDom(e.dom.cloneNode(!0));
      return Ir(t, n), de(t);
    }, ls = (e, t, n, r, a, c, d) => ({
      target: e,
      x: t,
      y: n,
      stop: r,
      prevent: a,
      kill: c,
      raw: d
    }), Yo = (e) => {
      const t = be.fromDom(bi(e).getOr(e.target)), n = () => e.stopPropagation(), r = () => e.preventDefault(), a = mn(r, n);
      return ls(t, e.clientX, e.clientY, n, r, a, e);
    }, id = (e, t) => (n) => {
      e(n) && t(Yo(n));
    }, Ac = (e, t, n, r, a) => {
      const c = id(n, r);
      return e.dom.addEventListener(t, c, a), { unbind: Tt(da, e, t, c, a) };
    }, Cf = (e, t, n, r) => Ac(e, t, n, r, !1), da = (e, t, n, r) => {
      e.dom.removeEventListener(t, n, r);
    }, z = (e, t) => ({
      left: e,
      top: t,
      translate: (r, a) => z(e + r, t + a)
    }), F = z, X = (e) => {
      const t = e.getBoundingClientRect();
      return F(t.left, t.top);
    }, _e = (e, t) => e !== void 0 ? e : t !== void 0 ? t : 0, Oe = (e) => {
      const t = e.dom.ownerDocument, n = t.body, r = t.defaultView, a = t.documentElement;
      if (n === e.dom)
        return F(n.offsetLeft, n.offsetTop);
      const c = _e(r == null ? void 0 : r.pageYOffset, a.scrollTop), d = _e(r == null ? void 0 : r.pageXOffset, a.scrollLeft), h = _e(a.clientTop, n.clientTop), k = _e(a.clientLeft, n.clientLeft);
      return zt(e).translate(d - k, c - h);
    }, zt = (e) => {
      const t = e.dom, r = t.ownerDocument.body;
      return r === t ? F(r.offsetLeft, r.offsetTop) : Qs(e) ? X(t) : F(0, 0);
    }, bn = (e) => {
      const t = e !== void 0 ? e.dom : document, n = t.body.scrollLeft || t.documentElement.scrollLeft, r = t.body.scrollTop || t.documentElement.scrollTop;
      return F(n, r);
    }, ao = (e, t, n) => {
      const a = (n !== void 0 ? n.dom : document).defaultView;
      a && a.scrollTo(e, t);
    }, Hn = (e, t) => {
      Zn().browser.isSafari() && un(e.dom.scrollIntoViewIfNeeded) ? e.dom.scrollIntoViewIfNeeded(!1) : e.dom.scrollIntoView(t);
    }, En = (e) => {
      const t = e === void 0 ? window : e;
      return Zn().browser.isFirefox() ? K.none() : K.from(t.visualViewport);
    }, yr = (e, t, n, r) => ({
      x: e,
      y: t,
      width: n,
      height: r,
      right: e + n,
      bottom: t + r
    }), ws = (e) => {
      const t = e === void 0 ? window : e, n = t.document, r = bn(be.fromDom(n));
      return En(t).fold(() => {
        const a = t.document.documentElement, c = a.clientWidth, d = a.clientHeight;
        return yr(r.left, r.top, c, d);
      }, (a) => yr(Math.max(a.pageLeft, r.left), Math.max(a.pageTop, r.top), a.width, a.height));
    }, Ri = (e, t) => ct(Pr(e), t), _u = (e, t) => {
      let n = [];
      return ut(Pr(e), (r) => {
        t(r) && (n = n.concat([r])), n = n.concat(_u(r, t));
      }), n;
    }, Ni = (e, t) => _f(t, e), ka = (e, t, n) => Pa(e, t, n).isSome();
    class vi {
      constructor(t, n) {
        this.node = t, this.rootNode = n, this.current = this.current.bind(this), this.next = this.next.bind(this), this.prev = this.prev.bind(this), this.prev2 = this.prev2.bind(this);
      }
      current() {
        return this.node;
      }
      next(t) {
        return this.node = this.findSibling(this.node, "firstChild", "nextSibling", t), this.node;
      }
      prev(t) {
        return this.node = this.findSibling(this.node, "lastChild", "previousSibling", t), this.node;
      }
      prev2(t) {
        return this.node = this.findPreviousNode(this.node, t), this.node;
      }
      findSibling(t, n, r, a) {
        if (t) {
          if (!a && t[n])
            return t[n];
          if (t !== this.rootNode) {
            let c = t[r];
            if (c)
              return c;
            for (let d = t.parentNode; d && d !== this.rootNode; d = d.parentNode)
              if (c = d[r], c)
                return c;
          }
        }
      }
      findPreviousNode(t, n) {
        if (t) {
          const r = t.previousSibling;
          if (this.rootNode && r === this.rootNode)
            return;
          if (r) {
            if (!n) {
              for (let c = r.lastChild; c; c = c.lastChild)
                if (!c.lastChild)
                  return c;
            }
            return r;
          }
          const a = t.parentNode;
          if (a && a !== this.rootNode)
            return a;
        }
      }
    }
    const Mi = (e) => (t) => !!t && t.nodeType === e, Im = (e) => !!e && !Object.getPrototypeOf(e), wn = Mi(1), ta = (e) => wn(e) && $d(be.fromDom(e)), gl = (e) => wn(e) && e.namespaceURI === "http://www.w3.org/2000/svg", Vc = (e) => {
      const t = e.toLowerCase();
      return (n) => Xe(n) && n.nodeName.toLowerCase() === t;
    }, Ul = (e) => {
      const t = e.map((n) => n.toLowerCase());
      return (n) => {
        if (n && n.nodeName) {
          const r = n.nodeName.toLowerCase();
          return So(t, r);
        }
        return !1;
      };
    }, Zd = (e, t) => {
      const n = t.toLowerCase().split(" ");
      return (r) => {
        if (wn(r)) {
          const a = r.ownerDocument.defaultView;
          if (a)
            for (let c = 0; c < n.length; c++) {
              const d = a.getComputedStyle(r, null);
              if ((d ? d.getPropertyValue(e) : null) === n[c])
                return !0;
            }
        }
        return !1;
      };
    }, Tp = (e) => (t) => wn(t) && t.hasAttribute(e), ug = (e, t) => (n) => wn(n) && n.getAttribute(e) === t, ru = (e) => wn(e) && e.hasAttribute("data-mce-bogus"), sh = (e) => wn(e) && e.getAttribute("data-mce-bogus") === "all", Cu = (e) => wn(e) && e.tagName === "TABLE", Wd = (e) => (t) => !!(ta(t) && (t.contentEditable === e || t.getAttribute("data-mce-contenteditable") === e)), Uc = Ul([
      "textarea",
      "input"
    ]), At = Mi(3), Fm = Mi(4), qd = Mi(7), Gd = Mi(8), Dl = Mi(9), lm = Mi(11), cs = Vc("br"), Rl = Vc("img"), cc = Wd("true"), Kr = Wd("false"), Sf = Ul([
      "td",
      "th"
    ]), Io = Ul([
      "td",
      "th",
      "caption"
    ]), pn = Ul([
      "video",
      "audio",
      "object",
      "embed"
    ]), Kd = Vc("li"), zp = Vc("details"), Ef = Vc("summary"), uc = "\uFEFF", Bo = " ", $a = (e) => e === uc, $m = (e) => e.replace(/\uFEFF/g, ""), dc = ((e, t) => {
      const n = (c) => {
        if (!e(c))
          throw new Error("Can only get " + t + " value of a " + t + " node");
        return r(c).getOr("");
      }, r = (c) => e(c) ? K.from(c.dom.nodeValue) : K.none();
      return {
        get: n,
        getOption: r,
        set: (c, d) => {
          if (!e(c))
            throw new Error("Can only set raw " + t + " value of a " + t + " node");
          c.dom.nodeValue = d;
        }
      };
    })(Zs, "text"), ld = (e) => dc.get(e), cd = (e) => dc.getOption(e), Yd = (e, t) => dc.set(e, t), Su = [
      "td",
      "th"
    ], jl = [
      "thead",
      "tbody",
      "tfoot"
    ], Xd = [
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "p",
      "div",
      "address",
      "pre",
      "form",
      "blockquote",
      "center",
      "dir",
      "fieldset",
      "header",
      "footer",
      "article",
      "section",
      "hgroup",
      "aside",
      "nav",
      "figure"
    ], ss = [
      "li",
      "dd",
      "dt"
    ], ud = [
      "ul",
      "ol",
      "dl"
    ], eb = [
      "pre",
      "script",
      "textarea",
      "style"
    ], hl = (e) => {
      let t;
      return (n) => (t = t || $r(e, Mo), Yn(t, Eo(n)));
    }, Hm = (e) => Eo(e) === "table", tl = (e) => Ji(e) && Eo(e) === "br", cm = hl(Xd), Eu = hl(ud), Jd = hl(ss), Tu = hl(jl), Tf = hl(Su), um = hl(eb), hn = (e) => {
      const t = [];
      let n = e.dom;
      for (; n; )
        t.push(be.fromDom(n)), n = n.lastChild;
      return t;
    }, Op = (e) => {
      const t = Ni(e, "br"), n = ct(hn(e).slice(-1), tl);
      t.length === n.length && ut(n, dr);
    }, Vm = () => {
      const e = be.fromTag("br");
      return Vr(e, "data-mce-bogus", "1"), e;
    }, zf = (e) => {
      yi(e), Ir(e, Vm());
    }, tb = (e, t) => {
      xa(e).each((n) => {
        Ps(n).each((r) => {
          t.isBlock(Eo(e)) && tl(n) && t.isBlock(Eo(r)) && dr(n);
        });
      });
    }, C = uc, R = $a, q = $m, se = (e) => e.insertContent(C, { preserve_zwsp: !0 }), De = wn, rt = At, Pt = (e) => (rt(e) && (e = e.parentNode), De(e) && e.hasAttribute("data-mce-caret")), on = (e) => rt(e) && R(e.data), Tn = (e) => Pt(e) || on(e), uo = (e) => e.firstChild !== e.lastChild || !cs(e.firstChild), ks = (e, t) => {
      var n;
      const a = ((n = e.ownerDocument) !== null && n !== void 0 ? n : document).createTextNode(C), c = e.parentNode;
      if (t) {
        const d = e.previousSibling;
        if (rt(d)) {
          if (Tn(d))
            return d;
          if (Xa(d))
            return d.splitText(d.data.length - 1);
        }
        c == null || c.insertBefore(a, e);
      } else {
        const d = e.nextSibling;
        if (rt(d)) {
          if (Tn(d))
            return d;
          if (Ha(d))
            return d.splitText(1), d;
        }
        e.nextSibling ? c == null || c.insertBefore(a, e.nextSibling) : c == null || c.appendChild(a);
      }
      return a;
    }, _o = (e) => {
      const t = e.container();
      return At(t) ? t.data.charAt(e.offset()) === C || e.isAtStart() && on(t.previousSibling) : !1;
    }, fr = (e) => {
      const t = e.container();
      return At(t) ? t.data.charAt(e.offset() - 1) === C || e.isAtEnd() && on(t.nextSibling) : !1;
    }, as = (e, t, n) => {
      var r;
      const c = ((r = t.ownerDocument) !== null && r !== void 0 ? r : document).createElement(e);
      c.setAttribute("data-mce-caret", n ? "before" : "after"), c.setAttribute("data-mce-bogus", "all"), c.appendChild(Vm().dom);
      const d = t.parentNode;
      return n ? d == null || d.insertBefore(c, t) : t.nextSibling ? d == null || d.insertBefore(c, t.nextSibling) : d == null || d.appendChild(c), c;
    }, Ha = (e) => rt(e) && e.data[0] === C, Xa = (e) => rt(e) && e.data[e.data.length - 1] === C, su = (e) => {
      var t;
      const n = e.getElementsByTagName("br"), r = n[n.length - 1];
      ru(r) && ((t = r.parentNode) === null || t === void 0 || t.removeChild(r));
    }, Um = (e) => e && e.hasAttribute("data-mce-caret") ? (su(e), e.removeAttribute("data-mce-caret"), e.removeAttribute("data-mce-bogus"), e.removeAttribute("style"), e.removeAttribute("data-mce-style"), e.removeAttribute("_moz_abspos"), e) : null, Of = (e) => Pt(e.startContainer), or = cc, jm = Kr, dd = cs, fd = At, Ap = Ul([
      "script",
      "style",
      "textarea"
    ]), dg = Ul([
      "img",
      "input",
      "textarea",
      "hr",
      "iframe",
      "video",
      "audio",
      "object",
      "embed"
    ]), md = Ul(["table"]), Oo = Tn, Sr = (e) => Oo(e) ? !1 : fd(e) ? !Ap(e.parentNode) : dg(e) || dd(e) || md(e) || vr(e), xi = (e) => wn(e) && e.getAttribute("unselectable") === "true", vr = (e) => !xi(e) && jm(e), fg = (e, t) => {
      for (let n = e.parentNode; n && n !== t; n = n.parentNode) {
        if (vr(n))
          return !1;
        if (or(n))
          return !0;
      }
      return !0;
    }, $s = (e) => vr(e) ? !co(_n(e.getElementsByTagName("*")), (t, n) => t || or(n), !1) : !1, _s = (e) => dg(e) || $s(e), nl = (e, t) => Sr(e) && fg(e, t), jc = /^[ \t\r\n]*$/, pd = (e) => jc.test(e), zu = (e) => {
      for (const t of e)
        if (!$a(t))
          return !1;
      return !0;
    }, dm = (e) => " \f	\v".indexOf(e) !== -1, mg = (e) => e === `
` || e === "\r", fm = (e, t) => t < e.length && t >= 0 ? mg(e[t]) : !1, Af = (e, t = 4, n = !0, r = !0) => {
      const a = Ma(" ", t), c = e.replace(/\t/g, a);
      return co(c, (h, k) => dm(k) || k === Bo ? h.pcIsSpace || h.str === "" && n || h.str.length === c.length - 1 && r || fm(c, h.str.length + 1) ? {
        pcIsSpace: !1,
        str: h.str + Bo
      } : {
        pcIsSpace: !0,
        str: h.str + " "
      } : {
        pcIsSpace: mg(k),
        str: h.str + k
      }, {
        pcIsSpace: !1,
        str: ""
      }).str;
    }, ah = (e, t) => {
      const n = be.fromDom(t), r = be.fromDom(e);
      return ka(r, "pre,code", Tt(Le, n));
    }, Zm = (e, t) => At(e) && pd(e.data) && !ah(e, t), Ry = (e) => wn(e) && e.nodeName === "A" && !e.hasAttribute("href") && (e.hasAttribute("name") || e.hasAttribute("id")), gd = (e, t) => Sr(e) && !Zm(e, t) || Ry(e) || Os(e), Os = Tp("data-mce-bookmark"), nb = Tp("data-mce-bogus"), ob = ug("data-mce-bogus", "all"), rb = (e) => Lr(be.fromDom(e)).exists((t) => !Ka(t)), Nl = (e, t) => {
      let n = 0;
      if (gd(e, e))
        return !1;
      {
        let r = e.firstChild;
        if (!r)
          return !0;
        const a = new vi(r, e);
        do {
          if (t) {
            if (ob(r)) {
              r = a.next(!0);
              continue;
            }
            if (nb(r)) {
              r = a.next();
              continue;
            }
          }
          if (cc(r) && rb(r))
            return !1;
          if (cs(r)) {
            n++, r = a.next();
            continue;
          }
          if (gd(r, e))
            return !1;
          r = a.next();
        } while (r);
        return n <= 1;
      }
    }, Yr = (e, t = !0) => Nl(e.dom, t), Ml = (e) => e.toLowerCase() === "svg", pg = (e) => Ml(e.nodeName), sb = (e) => (e == null ? void 0 : e.nodeName) === "svg" ? "svg" : "html", Ny = ["svg"], ih = () => {
      let e = [];
      const t = () => e[e.length - 1];
      return {
        track: (c) => {
          pg(c) && e.push(c);
          let d = t();
          return d && !d.contains(c) && (e.pop(), d = t()), sb(d);
        },
        current: () => sb(t()),
        reset: () => {
          e = [];
        }
      };
    }, Va = "data-mce-block", hd = (e) => ct(Nt(e), (t) => !/[A-Z]/.test(t)), fa = (e) => oo(hd(e), (t) => `${t}:` + oo(Ny, (n) => `not(${n} ${t})`).join(":")).join(","), Ou = (e, t) => Xe(t.querySelector(e)) ? (t.setAttribute(Va, "true"), t.getAttribute("data-mce-selected") === "inline-boundary" && t.removeAttribute("data-mce-selected"), !0) : (t.removeAttribute(Va), !1), Df = (e, t) => {
      const n = fa(e.getTransparentElements()), r = fa(e.getBlockElements());
      return ct(t.querySelectorAll(n), (a) => Ou(r, a));
    }, Qd = (e, t) => {
      var n;
      const r = t ? "lastChild" : "firstChild";
      for (let a = e[r]; a; a = a[r])
        if (Yr(be.fromDom(a))) {
          (n = a.parentNode) === null || n === void 0 || n.removeChild(a);
          return;
        }
    }, wi = (e, t) => {
      const n = document.createRange(), r = e.parentNode;
      if (r) {
        n.setStartBefore(e), n.setEndBefore(t);
        const a = n.extractContents();
        Qd(a, !0), n.setStartAfter(t), n.setEndAfter(e);
        const c = n.extractContents();
        Qd(c, !1), Yr(be.fromDom(a)) || r.insertBefore(a, e), Yr(be.fromDom(t)) || r.insertBefore(t, e), Yr(be.fromDom(c)) || r.insertBefore(c, e), r.removeChild(e);
      }
    }, Rf = (e, t, n) => {
      const r = e.getBlockElements(), a = be.fromDom(t), c = (h) => Eo(h) in r, d = (h) => Le(h, a);
      ut(lc(n), (h) => {
        si(h, c, d).each((k) => {
          const D = Ri(h, (H) => c(H) && !e.isValidChild(Eo(k), Eo(H)));
          if (D.length > 0) {
            const H = Lr(k);
            ut(D, (U) => {
              si(U, c, d).each((G) => {
                wi(G.dom, U.dom);
              });
            }), H.each((U) => Df(e, U.dom));
          }
        });
      });
    }, lh = (e, t, n) => {
      ut([
        ...n,
        ...ef(e, t) ? [t] : []
      ], (r) => ut(Ni(be.fromDom(r), r.nodeName.toLowerCase()), (a) => {
        hg(e, a.dom) && wa(a);
      }));
    }, ab = (e, t) => {
      const n = Df(e, t);
      Rf(e, t, n), lh(e, t, n);
    }, Wm = (e, t) => {
      if (gg(e, t)) {
        const n = fa(e.getBlockElements());
        Ou(n, t);
      }
    }, ch = (e, t, n) => {
      const r = (c) => Le(c, be.fromDom(t)), a = hi(be.fromDom(n), r);
      ha(a, a.length - 2).filter(Ji).fold(() => ab(e, t), (c) => ab(e, c.dom));
    }, Dp = (e) => e.hasAttribute(Va), qm = (e, t) => Yn(e.getTransparentElements(), t), gg = (e, t) => wn(t) && qm(e, t.nodeName), ef = (e, t) => gg(e, t) && Dp(t), hg = (e, t) => gg(e, t) && !Dp(t), Au = (e, t) => t.type === 1 && qm(e, t.name) && Ot(t.attr(Va)), Rp = Zn().browser, Vo = (e) => po(e, Ji), fc = (e) => Rp.isFirefox() && Eo(e) === "table" ? Vo(Pr(e)).filter((t) => Eo(t) === "caption").bind((t) => Vo(Ec(t)).map((n) => {
      const r = n.dom.offsetTop, a = t.dom.offsetTop, c = t.dom.offsetHeight;
      return r <= a ? -c : 0;
    })).getOr(0) : 0, bd = (e, t) => e.children && So(e.children, t), bg = (e, t, n) => {
      let r = 0, a = 0;
      const c = e.ownerDocument;
      if (n = n || e, t) {
        if (n === e && t.getBoundingClientRect && Ya(be.fromDom(e), "position") === "static") {
          const h = t.getBoundingClientRect();
          return r = h.left + (c.documentElement.scrollLeft || e.scrollLeft) - c.documentElement.clientLeft, a = h.top + (c.documentElement.scrollTop || e.scrollTop) - c.documentElement.clientTop, {
            x: r,
            y: a
          };
        }
        let d = t;
        for (; d && d !== n && d.nodeType && !bd(d, n); ) {
          const h = d;
          r += h.offsetLeft || 0, a += h.offsetTop || 0, d = h.offsetParent;
        }
        for (d = t.parentNode; d && d !== n && d.nodeType && !bd(d, n); )
          r -= d.scrollLeft || 0, a -= d.scrollTop || 0, d = d.parentNode;
        a += fc(be.fromDom(t));
      }
      return {
        x: r,
        y: a
      };
    }, ms = (e, t = {}) => {
      let n = 0;
      const r = {}, a = be.fromDom(e), c = Sn(a), d = (Ne) => {
        t.referrerPolicy = Ne;
      }, h = (Ne) => {
        t.contentCssCors = Ne;
      }, k = (Ne) => {
        Ir(Gr(a), Ne);
      }, D = (Ne) => {
        const Ie = Gr(a);
        Ia(Ie, "#" + Ne).each(dr);
      }, H = (Ne) => Hr(r, Ne).getOrThunk(() => ({
        id: "mce-u" + n++,
        passed: [],
        failed: [],
        count: 0
      })), U = (Ne) => new Promise((Ie, Fe) => {
        let je;
        const _t = Ht._addCacheSuffix(Ne), Zt = H(_t);
        r[_t] = Zt, Zt.count++;
        const fn = (gn, Fn) => {
          ut(gn, oa), Zt.status = Fn, Zt.passed = [], Zt.failed = [], je && (je.onload = null, je.onerror = null, je = null);
        }, at = () => fn(Zt.passed, 2), et = () => fn(Zt.failed, 3);
        if (Ie && Zt.passed.push(Ie), Fe && Zt.failed.push(Fe), Zt.status === 1)
          return;
        if (Zt.status === 2) {
          at();
          return;
        }
        if (Zt.status === 3) {
          et();
          return;
        }
        Zt.status = 1;
        const Mt = be.fromTag("link", c.dom);
        zs(Mt, {
          rel: "stylesheet",
          type: "text/css",
          id: Zt.id
        }), t.contentCssCors && Vr(Mt, "crossOrigin", "anonymous"), t.referrerPolicy && Vr(Mt, "referrerpolicy", t.referrerPolicy), je = Mt.dom, je.onload = at, je.onerror = et, k(Mt), Vr(Mt, "href", _t);
      }), G = (Ne, Ie) => {
        const Fe = H(Ne);
        r[Ne] = Fe, Fe.count++;
        const je = be.fromTag("style", c.dom);
        zs(je, {
          rel: "stylesheet",
          type: "text/css",
          id: Fe.id
        }), je.dom.innerHTML = Ie, k(je);
      }, ie = (Ne) => Promise.allSettled(oo(Ne, (Fe) => U(Fe).then(dt(Fe)))).then((Fe) => {
        const je = It(Fe, (_t) => _t.status === "fulfilled");
        return je.fail.length > 0 ? Promise.reject(oo(je.fail, (_t) => _t.reason)) : oo(je.pass, (_t) => _t.value);
      }), ye = (Ne) => {
        const Ie = Ht._addCacheSuffix(Ne);
        Hr(r, Ie).each((Fe) => {
          --Fe.count === 0 && (delete r[Ie], D(Fe.id));
        });
      };
      return {
        load: U,
        loadRawCss: G,
        loadAll: ie,
        unload: ye,
        unloadRawCss: (Ne) => {
          Hr(r, Ne).each((Ie) => {
            --Ie.count === 0 && (delete r[Ne], D(Ie.id));
          });
        },
        unloadAll: (Ne) => {
          ut(Ne, (Ie) => {
            ye(Ie);
          });
        },
        _setReferrerPolicy: d,
        _setContentCssCors: h
      };
    }, By = (() => {
      const e = /* @__PURE__ */ new WeakMap();
      return { forElement: (n, r) => {
        const c = pl(n).dom;
        return K.from(e.get(c)).getOrThunk(() => {
          const d = ms(c, r);
          return e.set(c, d), d;
        });
      } };
    })(), ol = (e) => e.nodeName.toLowerCase() === "span", mc = (e, t, n) => Xe(e) && (gd(e, t) || n.isInline(e.nodeName.toLowerCase())), uh = (e, t, n) => {
      const r = new vi(e, t).prev(!1), a = new vi(e, t).next(!1), c = ko(r) || mc(r, t, n), d = ko(a) || mc(a, t, n);
      return c && d;
    }, dh = (e) => ol(e) && e.getAttribute("data-mce-type") === "bookmark", Ly = (e, t, n) => At(e) && e.data.length > 0 && uh(e, t, n), ib = (e) => wn(e) ? e.childNodes.length > 0 : !1, K1 = (e) => lm(e) || Dl(e), lb = (e, t, n, r) => {
      var a;
      const c = r || t;
      if (wn(t) && dh(t))
        return t;
      const d = t.childNodes;
      for (let h = d.length - 1; h >= 0; h--)
        lb(e, d[h], n, c);
      if (wn(t)) {
        const h = t.childNodes;
        h.length === 1 && dh(h[0]) && ((a = t.parentNode) === null || a === void 0 || a.insertBefore(h[0], t));
      }
      return !K1(t) && !gd(t, c) && !ib(t) && !Ly(t, c, n) && e.remove(t), t;
    }, Nf = Ht.makeMap, Np = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, tf = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Dc = /[<>&\"\']/g, ki = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi, Du = {
      128: "€",
      130: "‚",
      131: "ƒ",
      132: "„",
      133: "…",
      134: "†",
      135: "‡",
      136: "ˆ",
      137: "‰",
      138: "Š",
      139: "‹",
      140: "Œ",
      142: "Ž",
      145: "‘",
      146: "’",
      147: "“",
      148: "”",
      149: "•",
      150: "–",
      151: "—",
      152: "˜",
      153: "™",
      154: "š",
      155: "›",
      156: "œ",
      158: "ž",
      159: "Ÿ"
    }, Ao = {
      '"': "&quot;",
      "'": "&#39;",
      "<": "&lt;",
      ">": "&gt;",
      "&": "&amp;",
      "`": "&#96;"
    }, fh = {
      "&lt;": "<",
      "&gt;": ">",
      "&amp;": "&",
      "&quot;": '"',
      "&apos;": "'"
    }, cb = (e) => {
      const t = be.fromTag("div").dom;
      return t.innerHTML = e, t.textContent || t.innerText || e;
    }, Mf = (e, t) => {
      const n = {};
      if (e) {
        const r = e.split(",");
        t = t || 10;
        for (let a = 0; a < r.length; a += 2) {
          const c = String.fromCharCode(parseInt(r[a], t));
          if (!Ao[c]) {
            const d = "&" + r[a + 1] + ";";
            n[c] = d, n[d] = c;
          }
        }
        return n;
      } else
        return;
    }, mh = Mf("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32), yg = (e, t) => e.replace(t ? Np : tf, (n) => Ao[n] || n), Bi = (e) => ("" + e).replace(Dc, (t) => Ao[t] || t), Tr = (e, t) => e.replace(t ? Np : tf, (n) => n.length > 1 ? "&#" + ((n.charCodeAt(0) - 55296) * 1024 + (n.charCodeAt(1) - 56320) + 65536) + ";" : Ao[n] || "&#" + n.charCodeAt(0) + ";"), rl = (e, t, n) => {
      const r = n || mh;
      return e.replace(t ? Np : tf, (a) => Ao[a] || r[a] || a);
    }, ma = {
      encodeRaw: yg,
      encodeAllRaw: Bi,
      encodeNumeric: Tr,
      encodeNamed: rl,
      getEncodeFunc: (e, t) => {
        const n = Mf(t) || mh, r = (d, h) => d.replace(h ? Np : tf, (k) => Ao[k] !== void 0 ? Ao[k] : n[k] !== void 0 ? n[k] : k.length > 1 ? "&#" + ((k.charCodeAt(0) - 55296) * 1024 + (k.charCodeAt(1) - 56320) + 65536) + ";" : "&#" + k.charCodeAt(0) + ";"), a = (d, h) => rl(d, h, n), c = Nf(e.replace(/\+/g, ","));
        return c.named && c.numeric ? r : c.named ? t ? a : rl : c.numeric ? Tr : yg;
      },
      decode: (e) => e.replace(ki, (t, n) => n ? (n.charAt(0).toLowerCase() === "x" ? n = parseInt(n.substr(1), 16) : n = parseInt(n, 10), n > 65535 ? (n -= 65536, String.fromCharCode(55296 + (n >> 10), 56320 + (n & 1023))) : Du[n] || String.fromCharCode(n)) : fh[t] || mh[t] || cb(t))
    }, Li = (e, t) => (e = Ht.trim(e), e ? e.split(t || " ") : []), ph = (e) => new RegExp("^" + e.replace(/([?+*])/g, ".$1") + "$"), Py = (e) => {
      const t = /^(~)?(.+)$/;
      return ho(Li(e, ","), (n) => {
        const r = t.exec(n);
        if (r) {
          const a = r[1] === "~", c = a ? "span" : "div", d = r[2];
          return [{
            inline: a,
            cloneName: c,
            name: d
          }];
        } else
          return [];
      });
    }, vg = (e) => {
      let t, n, r;
      if (t = "id accesskey class dir lang style tabindex title role", n = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul", r = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment", e !== "html4") {
        const c = "a ins del canvas map";
        t += " contenteditable contextmenu draggable dropzone hidden spellcheck translate", n += " article aside details dialog figure main header footer hgroup section nav " + c, r += " audio canvas command datalist mark meter output picture progress time wbr video ruby bdi keygen svg";
      }
      e !== "html5-strict" && (t += " xml:lang", r = [
        r,
        "acronym applet basefont big font strike tt"
      ].join(" "), n = [
        n,
        "center dir isindex noframes"
      ].join(" "));
      const a = [
        n,
        r
      ].join(" ");
      return {
        globalAttributes: t,
        blockContent: n,
        phrasingContent: r,
        flowContent: a
      };
    }, nf = (e) => {
      const { globalAttributes: t, phrasingContent: n, flowContent: r } = vg(e), a = {}, c = (k, D, H) => {
        a[k] = {
          attributes: $r(D, dt({})),
          attributesOrder: D,
          children: $r(H, dt({}))
        };
      }, d = (k, D = "", H = "") => {
        const U = Li(H), G = Li(k);
        let ie = G.length;
        const ye = Li([
          t,
          D
        ].join(" "));
        for (; ie--; )
          c(G[ie], ye.slice(), U);
      }, h = (k, D) => {
        const H = Li(k), U = Li(D);
        let G = H.length;
        for (; G--; ) {
          const ie = a[H[G]];
          for (let ye = 0, ae = U.length; ye < ae; ye++)
            ie.attributes[U[ye]] = {}, ie.attributesOrder.push(U[ye]);
        }
      };
      return e !== "html5-strict" && (ut(Li("acronym applet basefont big font strike tt"), (H) => {
        d(H, "", n);
      }), ut(Li("center dir isindex noframes"), (H) => {
        d(H, "", r);
      })), d("html", "manifest", "head body"), d("head", "", "base command link meta noscript script style title"), d("title hr noscript br"), d("base", "href target"), d("link", "href rel media hreflang type sizes hreflang"), d("meta", "name http-equiv content charset"), d("style", "media type scoped"), d("script", "src async defer type charset"), d("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", r), d("dd div", "", r), d("address dt caption", "", e === "html4" ? n : r), d("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", n), d("blockquote", "cite", r), d("ol", "reversed start type", "li"), d("ul", "", "li"), d("li", "value", r), d("dl", "", "dt dd"), d("a", "href target rel media hreflang type", e === "html4" ? n : r), d("q", "cite", n), d("ins del", "cite datetime", r), d("img", "src sizes srcset alt usemap ismap width height"), d("iframe", "src name width height", r), d("embed", "src type width height"), d("object", "data type typemustmatch name usemap form width height", [
        r,
        "param"
      ].join(" ")), d("param", "name value"), d("map", "name", [
        r,
        "area"
      ].join(" ")), d("area", "alt coords shape href target rel media hreflang type"), d("table", "border", "caption colgroup thead tfoot tbody tr" + (e === "html4" ? " col" : "")), d("colgroup", "span", "col"), d("col", "span"), d("tbody thead tfoot", "", "tr"), d("tr", "", "td th"), d("td", "colspan rowspan headers", r), d("th", "colspan rowspan headers scope abbr", r), d("form", "accept-charset action autocomplete enctype method name novalidate target", r), d("fieldset", "disabled form name", [
        r,
        "legend"
      ].join(" ")), d("label", "form for", n), d("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"), d("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", e === "html4" ? r : n), d("select", "disabled form multiple name required size", "option optgroup"), d("optgroup", "disabled label", "option"), d("option", "disabled label selected value"), d("textarea", "cols dirname disabled form maxlength name readonly required rows wrap"), d("menu", "type label", [
        r,
        "li"
      ].join(" ")), d("noscript", "", r), e !== "html4" && (d("wbr"), d("ruby", "", [
        n,
        "rt rp"
      ].join(" ")), d("figcaption", "", r), d("mark rt rp bdi", "", n), d("summary", "", [
        n,
        "h1 h2 h3 h4 h5 h6"
      ].join(" ")), d("canvas", "width height", r), d("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", [
        r,
        "track source"
      ].join(" ")), d("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [
        r,
        "track source"
      ].join(" ")), d("picture", "", "img source"), d("source", "src srcset type media sizes"), d("track", "kind src srclang label default"), d("datalist", "", [
        n,
        "option"
      ].join(" ")), d("article section nav aside main header footer", "", r), d("hgroup", "", "h1 h2 h3 h4 h5 h6"), d("figure", "", [
        r,
        "figcaption"
      ].join(" ")), d("time", "datetime", n), d("dialog", "open", r), d("command", "type label icon disabled checked radiogroup command"), d("output", "for form name", n), d("progress", "value max", n), d("meter", "value min max low high optimum", n), d("details", "open", [
        r,
        "summary"
      ].join(" ")), d("keygen", "autofocus challenge disabled form keytype name"), c("svg", "id tabindex lang xml:space class style x y width height viewBox preserveAspectRatio zoomAndPan transform".split(" "), [])), e !== "html5-strict" && (h("script", "language xml:space"), h("style", "xml:space"), h("object", "declare classid code codebase codetype archive standby align border hspace vspace"), h("embed", "align name hspace vspace"), h("param", "valuetype type"), h("a", "charset name rev shape coords"), h("br", "clear"), h("applet", "codebase archive code object alt name width height align hspace vspace"), h("img", "name longdesc align border hspace vspace"), h("iframe", "longdesc frameborder marginwidth marginheight scrolling align"), h("font basefont", "size color face"), h("input", "usemap align"), h("select"), h("textarea"), h("h1 h2 h3 h4 h5 h6 div p legend caption", "align"), h("ul", "type compact"), h("li", "type"), h("ol dl menu dir", "compact"), h("pre", "width xml:space"), h("hr", "align noshade size width"), h("isindex", "prompt"), h("table", "summary width frame rules cellspacing cellpadding align bgcolor"), h("col", "width align char charoff valign"), h("colgroup", "width align char charoff valign"), h("thead", "align char charoff valign"), h("tr", "align char charoff valign bgcolor"), h("th", "axis align char charoff valign nowrap bgcolor width height"), h("form", "accept"), h("td", "abbr axis scope align char charoff valign nowrap bgcolor width height"), h("tfoot", "align char charoff valign"), h("tbody", "align char charoff valign"), h("area", "nohref"), h("body", "background bgcolor text link vlink alink")), e !== "html4" && (h("input button select textarea", "autofocus"), h("input textarea", "placeholder"), h("a", "download"), h("link script img", "crossorigin"), h("img", "loading"), h("iframe", "sandbox seamless allow allowfullscreen loading")), e !== "html4" && ut([
        a.video,
        a.audio
      ], (k) => {
        delete k.children.audio, delete k.children.video;
      }), ut(Li("a form meter progress dfn"), (k) => {
        a[k] && delete a[k].children[k];
      }), delete a.caption.children.table, delete a.script, a;
    }, Pi = (e) => e === "-" ? "remove" : "add", xg = (e) => {
      const t = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
      return ho(Li(e, ","), (n) => {
        const r = t.exec(n);
        if (r) {
          const a = r[1], c = a ? Pi(a) : "replace", d = r[2], h = Li(r[3], "|");
          return [{
            operation: c,
            name: d,
            validChildren: h
          }];
        } else
          return [];
      });
    }, gh = (e, t) => {
      const n = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/, r = /[*?+]/, { attributes: a, attributesOrder: c } = t;
      return ut(Li(e, "|"), (d) => {
        const h = n.exec(d);
        if (h) {
          const k = {}, D = h[1], H = h[2].replace(/[\\:]:/g, ":"), U = h[3], G = h[4];
          if (D === "!" && (t.attributesRequired = t.attributesRequired || [], t.attributesRequired.push(H), k.required = !0), D === "-") {
            delete a[H], c.splice(Ht.inArray(c, H), 1);
            return;
          }
          if (U && (U === "=" ? (t.attributesDefault = t.attributesDefault || [], t.attributesDefault.push({
            name: H,
            value: G
          }), k.defaultValue = G) : U === "~" ? (t.attributesForced = t.attributesForced || [], t.attributesForced.push({
            name: H,
            value: G
          }), k.forcedValue = G) : U === "<" && (k.validValues = Ht.makeMap(G, "?"))), r.test(H)) {
            const ie = k;
            t.attributePatterns = t.attributePatterns || [], ie.pattern = ph(H), t.attributePatterns.push(ie);
          } else
            a[H] || c.push(H), a[H] = k;
        }
      });
    }, Iy = (e, t) => {
      Zo(e.attributes, (n, r) => {
        t.attributes[r] = n;
      }), t.attributesOrder.push(...e.attributesOrder);
    }, vv = (e, t) => {
      const n = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/;
      return ho(Li(t, ","), (r) => {
        const a = n.exec(r);
        if (a) {
          const c = a[1], d = a[2], h = a[3], k = a[4], D = a[5], H = {
            attributes: {},
            attributesOrder: []
          };
          if (e.each((U) => Iy(U, H)), c === "#" ? H.paddEmpty = !0 : c === "-" && (H.removeEmpty = !0), k === "!" && (H.removeEmptyAttrs = !0), D && gh(D, H), h && (H.outputName = d), d === "@")
            if (e.isNone())
              e = K.some(H);
            else
              return [];
          return [h ? {
            name: d,
            element: H,
            aliasName: h
          } : {
            name: d,
            element: H
          }];
        } else
          return [];
      });
    }, wg = {}, Bf = Ht.makeMap, au = Ht.each, $t = Ht.extend, Fy = Ht.explode, _i = (e, t = {}) => {
      const n = Bf(e, " ", Bf(e.toUpperCase(), " "));
      return $t(n, t);
    }, hh = (e) => _i("td th li dt dd figcaption caption details summary", e.getTextBlockElements()), Gm = (e, t) => {
      if (e) {
        const n = {};
        return Ot(e) && (e = { "*": e }), au(e, (r, a) => {
          n[a] = n[a.toUpperCase()] = t === "map" ? Bf(r, /[, ]/) : Fy(r, /[, ]/);
        }), n;
      } else
        return;
    }, of = (e = {}) => {
      var t;
      const n = {}, r = {};
      let a = [];
      const c = {}, d = {}, h = (vo, br, Es) => {
        const Za = e[vo];
        if (Za)
          return Bf(Za, /[, ]/, Bf(Za.toUpperCase(), /[, ]/));
        {
          let ti = wg[vo];
          return ti || (ti = _i(br, Es), wg[vo] = ti), ti;
        }
      }, k = (t = e.schema) !== null && t !== void 0 ? t : "html5", D = nf(k);
      e.verify_html === !1 && (e.valid_elements = "*[*]");
      const H = Gm(e.valid_styles), U = Gm(e.invalid_styles, "map"), G = Gm(e.valid_classes, "map"), ie = h("whitespace_elements", "pre script noscript style textarea video audio iframe object code"), ye = h("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr"), ae = h("void_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track"), xe = h("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls allowfullscreen"), Ne = "td th iframe video audio object script code", Ie = h("non_empty_elements", Ne + " pre svg", ae), Fe = h("move_caret_before_on_enter_elements", Ne + " table", ae), je = "h1 h2 h3 h4 h5 h6", _t = h("text_block_elements", je + " p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure"), Zt = h("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary html body multicol listing", _t), fn = h("text_inline_elements", "span strong b em i font s strike u var cite dfn code mark q sup sub samp"), at = h("transparent_elements", "a ins del canvas map"), et = h("wrap_block_elements", "pre " + je);
      au("script noscript iframe noframes noembed title style textarea xmp plaintext".split(" "), (vo) => {
        d[vo] = new RegExp("</" + vo + "[^>]*>", "gi");
      });
      const Mt = (vo) => {
        const br = K.from(n["@"]), Es = /[*?+]/;
        ut(vv(br, vo ?? ""), ({ name: Za, element: ti, aliasName: tg }) => {
          if (tg && (n[tg] = ti), Es.test(Za)) {
            const Z2 = ti;
            Z2.pattern = ph(Za), a.push(Z2);
          } else
            n[Za] = ti;
        });
      }, gn = (vo) => {
        a = [], ut(Nt(n), (br) => {
          delete n[br];
        }), Mt(vo);
      }, Fn = (vo) => {
        delete wg.text_block_elements, delete wg.block_elements, ut(Py(vo ?? ""), ({ inline: br, name: Es, cloneName: Za }) => {
          if (r[Es] = r[Za], c[Es] = Za, Ie[Es.toUpperCase()] = {}, Ie[Es] = {}, br || (Zt[Es.toUpperCase()] = {}, Zt[Es] = {}), !n[Es]) {
            let ti = n[Za];
            ti = $t({}, ti), delete ti.removeEmptyAttrs, delete ti.removeEmpty, n[Es] = ti;
          }
          Zo(r, (ti, tg) => {
            ti[Za] && (r[tg] = ti = $t({}, r[tg]), ti[Es] = ti[Za]);
          });
        });
      }, Uo = (vo) => {
        ut(xg(vo ?? ""), ({ operation: br, name: Es, validChildren: Za }) => {
          const ti = br === "replace" ? { "#comment": {} } : r[Es];
          ut(Za, (tg) => {
            br === "remove" ? delete ti[tg] : ti[tg] = {};
          }), r[Es] = ti;
        });
      }, qo = (vo) => {
        const br = n[vo];
        if (br)
          return br;
        let Es = a.length;
        for (; Es--; ) {
          const Za = a[Es];
          if (Za.pattern.test(vo))
            return Za;
        }
      };
      e.valid_elements ? (gn(e.valid_elements), au(D, (vo, br) => {
        r[br] = vo.children;
      })) : (au(D, (vo, br) => {
        n[br] = {
          attributes: vo.attributes,
          attributesOrder: vo.attributesOrder
        }, r[br] = vo.children;
      }), au(Li("strong/b em/i"), (vo) => {
        const br = Li(vo, "/");
        n[br[1]].outputName = br[0];
      }), au(fn, (vo, br) => {
        n[br] && (e.padd_empty_block_inline_children && (n[br].paddInEmptyBlock = !0), n[br].removeEmpty = !0);
      }), au(Li("ol ul blockquote a table tbody"), (vo) => {
        n[vo] && (n[vo].removeEmpty = !0);
      }), au(Li("p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary"), (vo) => {
        n[vo] && (n[vo].paddEmpty = !0);
      }), au(Li("span"), (vo) => {
        n[vo].removeEmptyAttrs = !0;
      })), delete n.svg, Fn(e.custom_elements), Uo(e.valid_children), Mt(e.extended_valid_elements), Uo("+ol[ul|ol],+ul[ul|ol]"), au({
        dd: "dl",
        dt: "dl",
        li: "ul ol",
        td: "tr",
        th: "tr",
        tr: "tbody thead tfoot",
        tbody: "table",
        thead: "table",
        tfoot: "table",
        legend: "fieldset",
        area: "map",
        param: "video audio object"
      }, (vo, br) => {
        n[br] && (n[br].parentsRequired = Li(vo));
      }), e.invalid_elements && au(Fy(e.invalid_elements), (vo) => {
        n[vo] && delete n[vo];
      }), qo("span") || Mt("span[!data-mce-type|*]");
      const vs = dt(H), Vs = dt(U), Ci = dt(G), Yc = dt(xe), Ql = dt(Zt), sn = dt(_t), zn = dt(fn), Ar = dt(Object.seal(ae)), xr = dt(ye), On = dt(Ie), Rn = dt(Fe), qt = dt(ie), bo = dt(at), hr = dt(et), Ss = dt(Object.seal(d)), na = (vo, br) => {
        const Es = r[vo.toLowerCase()];
        return !!(Es && Es[br.toLowerCase()]);
      }, Ed = (vo, br) => {
        const Es = qo(vo);
        if (Es)
          if (br) {
            if (Es.attributes[br])
              return !0;
            const Za = Es.attributePatterns;
            if (Za) {
              let ti = Za.length;
              for (; ti--; )
                if (Za[ti].pattern.test(br))
                  return !0;
            }
          } else
            return !0;
        return !1;
      }, Mm = (vo) => Yn(Ql(), vo), Sy = (vo) => !Dr(vo, "#") && Ed(vo) && !Mm(vo), Td = (vo) => Yn(hr(), vo) || Sy(vo), Qg = dt(c);
      return {
        type: k,
        children: r,
        elements: n,
        getValidStyles: vs,
        getValidClasses: Ci,
        getBlockElements: Ql,
        getInvalidStyles: Vs,
        getVoidElements: Ar,
        getTextBlockElements: sn,
        getTextInlineElements: zn,
        getBoolAttrs: Yc,
        getElementRule: qo,
        getSelfClosingElements: xr,
        getNonEmptyElements: On,
        getMoveCaretBeforeOnEnterElements: Rn,
        getWhitespaceElements: qt,
        getTransparentElements: bo,
        getSpecialElements: Ss,
        isValidChild: na,
        isValid: Ed,
        isBlock: Mm,
        isInline: Sy,
        isWrapper: Td,
        getCustomElements: Qg,
        addValidElements: Mt,
        setValidElements: gn,
        addCustomElements: Fn,
        addValidChildren: Uo
      };
    }, pc = (e) => ({ value: xv(e) }), xv = (e) => nm(e, "#").toUpperCase(), gc = (e) => {
      const t = e.toString(16);
      return (t.length === 1 ? "0" + t : t).toUpperCase();
    }, ub = (e) => {
      const t = gc(e.red) + gc(e.green) + gc(e.blue);
      return pc(t);
    }, mm = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i, Zc = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i, iu = (e, t, n, r) => ({
      red: e,
      green: t,
      blue: n,
      alpha: r
    }), Mp = (e, t, n, r) => {
      const a = parseInt(e, 10), c = parseInt(t, 10), d = parseInt(n, 10), h = parseFloat(r);
      return iu(a, c, d, h);
    }, Wl = (e) => {
      if (e === "transparent")
        return K.some(iu(0, 0, 0, 0));
      const t = mm.exec(e);
      if (t !== null)
        return K.some(Mp(t[1], t[2], t[3], "1"));
      const n = Zc.exec(e);
      return n !== null ? K.some(Mp(n[1], n[2], n[3], n[4])) : K.none();
    }, db = (e) => `rgba(${e.red},${e.green},${e.blue},${e.alpha})`, ql = (e) => Wl(e).map(ub).map((t) => "#" + t.value).getOr(e), rf = (e = {}, t) => {
      const n = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi, r = /\s*([^:]+):\s*([^;]+);?/g, a = /\s+$/, c = {};
      let d, h;
      const k = uc;
      t && (d = t.getValidStyles(), h = t.getInvalidStyles());
      const D = (`\\" \\' \\; \\: ; : ` + k).split(" ");
      for (let U = 0; U < D.length; U++)
        c[D[U]] = k + U, c[k + U] = D[U];
      const H = {
        parse: (U) => {
          const G = {};
          let ie = !1;
          const ye = e.url_converter, ae = e.url_converter_scope || H, xe = (at, et, Mt) => {
            const gn = G[at + "-top" + et];
            if (!gn)
              return;
            const Fn = G[at + "-right" + et];
            if (!Fn)
              return;
            const Uo = G[at + "-bottom" + et];
            if (!Uo)
              return;
            const qo = G[at + "-left" + et];
            if (!qo)
              return;
            const vs = [
              gn,
              Fn,
              Uo,
              qo
            ];
            let Vs = vs.length - 1;
            for (; Vs-- && vs[Vs] === vs[Vs + 1]; )
              ;
            Vs > -1 && Mt || (G[at + et] = Vs === -1 ? vs[0] : vs.join(" "), delete G[at + "-top" + et], delete G[at + "-right" + et], delete G[at + "-bottom" + et], delete G[at + "-left" + et]);
          }, Ne = (at) => {
            const et = G[at];
            if (!et)
              return;
            const Mt = et.indexOf(",") > -1 ? [et] : et.split(" ");
            let gn = Mt.length;
            for (; gn--; )
              if (Mt[gn] !== Mt[0])
                return !1;
            return G[at] = Mt[0], !0;
          }, Ie = (at, et, Mt, gn) => {
            Ne(et) && Ne(Mt) && Ne(gn) && (G[at] = G[et] + " " + G[Mt] + " " + G[gn], delete G[et], delete G[Mt], delete G[gn]);
          }, Fe = (at) => (ie = !0, c[at]), je = (at, et) => (ie && (at = at.replace(/\uFEFF[0-9]/g, (Mt) => c[Mt])), et || (at = at.replace(/\\([\'\";:])/g, "$1")), at), _t = (at) => String.fromCharCode(parseInt(at.slice(1), 16)), Zt = (at) => at.replace(/\\[0-9a-f]+/gi, _t), fn = (at, et, Mt, gn, Fn, Uo) => {
            if (Fn = Fn || Uo, Fn)
              return Fn = je(Fn), "'" + Fn.replace(/\'/g, "\\'") + "'";
            if (et = je(et || Mt || gn || ""), !e.allow_script_urls) {
              const qo = et.replace(/[\s\r\n]+/g, "");
              if (/(java|vb)script:/i.test(qo) || !e.allow_svg_data_urls && /^data:image\/svg/i.test(qo))
                return "";
            }
            return ye && (et = ye.call(ae, et, "style")), "url('" + et.replace(/\'/g, "\\'") + "')";
          };
          if (U) {
            U = U.replace(/[\u0000-\u001F]/g, ""), U = U.replace(/\\[\"\';:\uFEFF]/g, Fe).replace(/\"[^\"]+\"|\'[^\']+\'/g, (et) => et.replace(/[;:]/g, Fe));
            let at;
            for (; at = r.exec(U); ) {
              r.lastIndex = at.index + at[0].length;
              let et = at[1].replace(a, "").toLowerCase(), Mt = at[2].replace(a, "");
              if (et && Mt) {
                if (et = Zt(et), Mt = Zt(Mt), et.indexOf(k) !== -1 || et.indexOf('"') !== -1 || !e.allow_script_urls && (et === "behavior" || /expression\s*\(|\/\*|\*\//.test(Mt)))
                  continue;
                et === "font-weight" && Mt === "700" ? Mt = "bold" : (et === "color" || et === "background-color") && (Mt = Mt.toLowerCase()), Ot(e.force_hex_color) && e.force_hex_color !== "off" && Wl(Mt).each((gn) => {
                  (e.force_hex_color === "always" || gn.alpha === 1) && (Mt = ql(db(gn)));
                }), Mt = Mt.replace(n, fn), G[et] = ie ? je(Mt, !0) : Mt;
              }
            }
            xe("border", "", !0), xe("border", "-width"), xe("border", "-color"), xe("border", "-style"), xe("padding", ""), xe("margin", ""), Ie("border", "border-width", "border-style", "border-color"), G.border === "medium none" && delete G.border, G["border-image"] === "none" && delete G["border-image"];
          }
          return G;
        },
        serialize: (U, G) => {
          let ie = "";
          const ye = (xe, Ne) => {
            const Ie = Ne[xe];
            if (Ie)
              for (let Fe = 0, je = Ie.length; Fe < je; Fe++) {
                const _t = Ie[Fe], Zt = U[_t];
                Zt && (ie += (ie.length > 0 ? " " : "") + _t + ": " + Zt + ";");
              }
          }, ae = (xe, Ne) => {
            if (!h || !Ne)
              return !0;
            let Ie = h["*"];
            return Ie && Ie[xe] ? !1 : (Ie = h[Ne], !(Ie && Ie[xe]));
          };
          return G && d ? (ye("*", d), ye(G, d)) : Zo(U, (xe, Ne) => {
            xe && ae(Ne, G) && (ie += (ie.length > 0 ? " " : "") + Ne + ": " + xe + ";");
          }), ie;
        }
      };
      return H;
    }, $y = {
      keyLocation: !0,
      layerX: !0,
      layerY: !0,
      returnValue: !0,
      webkitMovementX: !0,
      webkitMovementY: !0,
      keyIdentifier: !0,
      mozPressure: !0
    }, bh = (e) => e instanceof Event || un(e.initEvent), wv = (e) => e.isDefaultPrevented === Mo || e.isDefaultPrevented === Pn, Hy = (e) => jn(e.preventDefault) || bh(e), Vy = (e, t) => {
      const n = t ?? {};
      for (const r in e)
        Yn($y, r) || (n[r] = e[r]);
      return Xe(e.composedPath) && (n.composedPath = () => e.composedPath()), Xe(e.getModifierState) && (n.getModifierState = (r) => e.getModifierState(r)), Xe(e.getTargetRanges) && (n.getTargetRanges = () => e.getTargetRanges()), n;
    }, Uy = (e, t, n, r) => {
      var a;
      const c = Vy(t, r);
      return c.type = e, jn(c.target) && (c.target = (a = c.srcElement) !== null && a !== void 0 ? a : n), Hy(t) && (c.preventDefault = () => {
        c.defaultPrevented = !0, c.isDefaultPrevented = Mo, un(t.preventDefault) && t.preventDefault();
      }, c.stopPropagation = () => {
        c.cancelBubble = !0, c.isPropagationStopped = Mo, un(t.stopPropagation) && t.stopPropagation();
      }, c.stopImmediatePropagation = () => {
        c.isImmediatePropagationStopped = Mo, c.stopPropagation();
      }, wv(c) || (c.isDefaultPrevented = c.defaultPrevented === !0 ? Mo : Pn, c.isPropagationStopped = c.cancelBubble === !0 ? Mo : Pn, c.isImmediatePropagationStopped = Pn)), c;
    }, yh = "mce-data-", Y1 = /^(?:mouse|contextmenu)|click/, Km = (e, t, n, r) => {
      e.addEventListener(t, n, r || !1);
    }, bl = (e, t, n, r) => {
      e.removeEventListener(t, n, r || !1);
    }, Ym = (e) => Xe(e) && Y1.test(e.type), Lf = (e, t) => {
      const n = Uy(e.type, e, document, t);
      if (Ym(e) && ko(e.pageX) && !ko(e.clientX)) {
        const r = n.target.ownerDocument || document, a = r.documentElement, c = r.body, d = n;
        d.pageX = e.clientX + (a && a.scrollLeft || c && c.scrollLeft || 0) - (a && a.clientLeft || c && c.clientLeft || 0), d.pageY = e.clientY + (a && a.scrollTop || c && c.scrollTop || 0) - (a && a.clientTop || c && c.clientTop || 0);
      }
      return n;
    }, As = (e, t, n) => {
      const r = e.document, a = { type: "ready" };
      if (n.domLoaded) {
        t(a);
        return;
      }
      const c = () => r.readyState === "complete" || r.readyState === "interactive" && r.body, d = () => {
        bl(e, "DOMContentLoaded", d), bl(e, "load", d), n.domLoaded || (n.domLoaded = !0, t(a)), e = null;
      };
      c() ? d() : Km(e, "DOMContentLoaded", d), n.domLoaded || Km(e, "load", d);
    };
    class pm {
      constructor() {
        this.domLoaded = !1, this.events = {}, this.count = 1, this.expando = yh + (+/* @__PURE__ */ new Date()).toString(32), this.hasFocusIn = "onfocusin" in document.documentElement, this.count = 1;
      }
      bind(t, n, r, a) {
        const c = this;
        let d;
        const h = window, k = (G) => {
          c.executeHandlers(Lf(G || h.event), D);
        };
        if (!t || At(t) || Gd(t))
          return r;
        let D;
        t[c.expando] ? D = t[c.expando] : (D = c.count++, t[c.expando] = D, c.events[D] = {}), a = a || t;
        const H = n.split(" ");
        let U = H.length;
        for (; U--; ) {
          let G = H[U], ie = k, ye = !1, ae = !1;
          if (G === "DOMContentLoaded" && (G = "ready"), c.domLoaded && G === "ready" && t.readyState === "complete") {
            r.call(a, Lf({ type: G }));
            continue;
          }
          !c.hasFocusIn && (G === "focusin" || G === "focusout") && (ye = !0, ae = G === "focusin" ? "focus" : "blur", ie = (xe) => {
            const Ne = Lf(xe || h.event);
            Ne.type = Ne.type === "focus" ? "focusin" : "focusout", c.executeHandlers(Ne, D);
          }), d = c.events[D][G], d ? G === "ready" && c.domLoaded ? r(Lf({ type: G })) : d.push({
            func: r,
            scope: a
          }) : (c.events[D][G] = d = [{
            func: r,
            scope: a
          }], d.fakeName = ae, d.capture = ye, d.nativeHandler = ie, G === "ready" ? As(t, ie, c) : Km(t, ae || G, ie, ye));
        }
        return t = d = null, r;
      }
      unbind(t, n, r) {
        if (!t || At(t) || Gd(t))
          return this;
        const a = t[this.expando];
        if (a) {
          let c = this.events[a];
          if (n) {
            const d = n.split(" ");
            let h = d.length;
            for (; h--; ) {
              const k = d[h], D = c[k];
              if (D) {
                if (r) {
                  let H = D.length;
                  for (; H--; )
                    if (D[H].func === r) {
                      const U = D.nativeHandler, G = D.fakeName, ie = D.capture, ye = D.slice(0, H).concat(D.slice(H + 1));
                      ye.nativeHandler = U, ye.fakeName = G, ye.capture = ie, c[k] = ye;
                    }
                }
                (!r || D.length === 0) && (delete c[k], bl(t, D.fakeName || k, D.nativeHandler, D.capture));
              }
            }
          } else
            Zo(c, (d, h) => {
              bl(t, d.fakeName || h, d.nativeHandler, d.capture);
            }), c = {};
          for (const d in c)
            if (Yn(c, d))
              return this;
          delete this.events[a];
          try {
            delete t[this.expando];
          } catch {
            t[this.expando] = null;
          }
        }
        return this;
      }
      fire(t, n, r) {
        return this.dispatch(t, n, r);
      }
      dispatch(t, n, r) {
        if (!t || At(t) || Gd(t))
          return this;
        const a = Lf({
          type: n,
          target: t
        }, r);
        do {
          const c = t[this.expando];
          c && this.executeHandlers(a, c), t = t.parentNode || t.ownerDocument || t.defaultView || t.parentWindow;
        } while (t && !a.isPropagationStopped());
        return this;
      }
      clean(t) {
        if (!t || At(t) || Gd(t))
          return this;
        if (t[this.expando] && this.unbind(t), t.getElementsByTagName || (t = t.document), t && t.getElementsByTagName) {
          this.unbind(t);
          const n = t.getElementsByTagName("*");
          let r = n.length;
          for (; r--; )
            t = n[r], t[this.expando] && this.unbind(t);
        }
        return this;
      }
      destroy() {
        this.events = {};
      }
      cancel(t) {
        return t && (t.preventDefault(), t.stopImmediatePropagation()), !1;
      }
      executeHandlers(t, n) {
        const r = this.events[n], a = r && r[t.type];
        if (a)
          for (let c = 0, d = a.length; c < d; c++) {
            const h = a[c];
            if (h && h.func.call(h.scope, t) === !1 && t.preventDefault(), t.isImmediatePropagationStopped())
              return;
          }
      }
    }
    pm.Event = new pm();
    const sl = Ht.each, kg = Ht.grep, fb = "data-mce-style", _g = Ht.makeMap("fill-opacity font-weight line-height opacity orphans widows z-index zoom", " "), gm = (e, t, n) => {
      jn(n) || n === "" ? xs(e, t) : Vr(e, t, n);
    }, mb = (e) => e.replace(/[A-Z]/g, (t) => "-" + t.toLowerCase()), hm = (e, t) => {
      let n = 0;
      if (e)
        for (let r = e.nodeType, a = e.previousSibling; a; a = a.previousSibling) {
          const c = a.nodeType;
          t && At(a) && (c === r || !a.data.length) || (n++, r = c);
        }
      return n;
    }, Bp = (e, t) => {
      const n = Qi(t, "style"), r = e.serialize(e.parse(n), Eo(t));
      gm(t, fb, r);
    }, Lp = (e, t) => M(e) ? Yn(_g, t) ? e + "" : e + "px" : e, pb = (e, t, n) => {
      const r = mb(t);
      jn(n) || n === "" ? ou(e, r) : Pm(e, r, Lp(n, r));
    }, gb = (e, t, n) => {
      const r = t.keep_values, a = {
        set: (d, h, k) => {
          const D = be.fromDom(d);
          un(t.url_converter) && Xe(h) && (h = t.url_converter.call(t.url_converter_scope || n(), String(h), k, d));
          const H = "data-mce-" + k;
          gm(D, H, h), gm(D, k, h);
        },
        get: (d, h) => {
          const k = be.fromDom(d);
          return Qi(k, "data-mce-" + h) || Qi(k, h);
        }
      }, c = {
        style: {
          set: (d, h) => {
            const k = be.fromDom(d);
            r && gm(k, fb, h), xs(k, "style"), Ot(h) && Vl(k, e.parse(h));
          },
          get: (d) => {
            const h = be.fromDom(d), k = Qi(h, fb) || Qi(h, "style");
            return e.serialize(e.parse(k), Eo(h));
          }
        }
      };
      return r && (c.href = c.src = a), c;
    }, gs = (e, t = {}) => {
      const n = {}, r = window, a = {};
      let c = 0;
      const d = !0, h = !0, k = By.forElement(be.fromDom(e), {
        contentCssCors: t.contentCssCors,
        referrerPolicy: t.referrerPolicy
      }), D = [], H = t.schema ? t.schema : of({}), U = rf({
        url_converter: t.url_converter,
        url_converter_scope: t.url_converter_scope,
        force_hex_color: t.force_hex_color
      }, t.schema), G = t.ownEvents ? new pm() : pm.Event, ie = H.getBlockElements(), ye = (Ke) => Ot(Ke) ? Yn(ie, Ke) : wn(Ke) && (Yn(ie, Ke.nodeName) || ef(H, Ke)), ae = (Ke) => Ke && e && Ot(Ke) ? e.getElementById(Ke) : Ke, xe = (Ke) => {
        const Je = ae(Ke);
        return Xe(Je) ? be.fromDom(Je) : null;
      }, Ne = (Ke, Je, nn = "") => {
        let Ut;
        const Wn = xe(Ke);
        if (Xe(Wn) && Ji(Wn)) {
          const wr = lT[Je];
          wr && wr.get ? Ut = wr.get(Wn.dom, Je) : Ut = Qi(Wn, Je);
        }
        return Xe(Ut) ? Ut : nn;
      }, Ie = (Ke) => {
        const Je = ae(Ke);
        return jn(Je) ? [] : Je.attributes;
      }, Fe = (Ke, Je, nn) => {
        zn(Ke, (Ut) => {
          if (wn(Ut)) {
            const Wn = be.fromDom(Ut), wr = nn === "" ? null : nn, di = Qi(Wn, Je), yc = lT[Je];
            yc && yc.set ? yc.set(Wn.dom, wr, Je) : gm(Wn, Je, wr), di !== wr && t.onSetAttrib && t.onSetAttrib({
              attrElm: Wn.dom,
              attrName: Je,
              attrValue: wr
            });
          }
        });
      }, je = (Ke, Je) => Ke.cloneNode(Je), _t = () => t.root_element || e.body, Zt = (Ke) => {
        const Je = ws(Ke);
        return {
          x: Je.x,
          y: Je.y,
          w: Je.width,
          h: Je.height
        };
      }, fn = (Ke, Je) => bg(e.body, ae(Ke), Je), at = (Ke, Je, nn) => {
        zn(Ke, (Ut) => {
          const Wn = be.fromDom(Ut);
          pb(Wn, Je, nn), t.update_styles && Bp(U, Wn);
        });
      }, et = (Ke, Je) => {
        zn(Ke, (nn) => {
          const Ut = be.fromDom(nn);
          Zo(Je, (Wn, wr) => {
            pb(Ut, wr, Wn);
          }), t.update_styles && Bp(U, Ut);
        });
      }, Mt = (Ke, Je, nn) => {
        const Ut = ae(Ke);
        if (!(jn(Ut) || !ta(Ut) && !gl(Ut)))
          return nn ? Ya(be.fromDom(Ut), mb(Je)) : (Je = Je.replace(/-(\D)/g, (Wn, wr) => wr.toUpperCase()), Je === "float" && (Je = "cssFloat"), Ut.style ? Ut.style[Je] : void 0);
      }, gn = (Ke) => {
        const Je = ae(Ke);
        if (!Je)
          return {
            w: 0,
            h: 0
          };
        let nn = Mt(Je, "width"), Ut = Mt(Je, "height");
        return (!nn || nn.indexOf("px") === -1) && (nn = "0"), (!Ut || Ut.indexOf("px") === -1) && (Ut = "0"), {
          w: parseInt(nn, 10) || Je.offsetWidth || Je.clientWidth,
          h: parseInt(Ut, 10) || Je.offsetHeight || Je.clientHeight
        };
      }, Fn = (Ke) => {
        const Je = ae(Ke), nn = fn(Je), Ut = gn(Je);
        return {
          x: nn.x,
          y: nn.y,
          w: Ut.w,
          h: Ut.h
        };
      }, Uo = (Ke, Je) => {
        if (!Ke)
          return !1;
        const nn = Se(Ke) ? Ke : [Ke];
        return cr(nn, (Ut) => Ai(be.fromDom(Ut), Je));
      }, qo = (Ke, Je, nn, Ut) => {
        const Wn = [];
        let wr = ae(Ke);
        Ut = Ut === void 0;
        const di = nn || (_t().nodeName !== "BODY" ? _t().parentNode : null);
        if (Ot(Je))
          if (Je === "*")
            Je = wn;
          else {
            const yc = Je;
            Je = (ec) => Uo(ec, yc);
          }
        for (; wr && !(wr === di || jn(wr.nodeType) || Dl(wr) || lm(wr)); ) {
          if (!Je || Je(wr))
            if (Ut)
              Wn.push(wr);
            else
              return [wr];
          wr = wr.parentNode;
        }
        return Ut ? Wn : null;
      }, vs = (Ke, Je, nn) => {
        const Ut = qo(Ke, Je, nn, !1);
        return Ut && Ut.length > 0 ? Ut[0] : null;
      }, Vs = (Ke, Je, nn) => {
        let Ut = Je;
        if (Ke) {
          Ot(Je) && (Ut = (Wn) => Uo(Wn, Je));
          for (let Wn = Ke[nn]; Wn; Wn = Wn[nn])
            if (un(Ut) && Ut(Wn))
              return Wn;
        }
        return null;
      }, Ci = (Ke, Je) => Vs(Ke, Je, "nextSibling"), Yc = (Ke, Je) => Vs(Ke, Je, "previousSibling"), Ql = (Ke) => un(Ke.querySelectorAll), sn = (Ke, Je) => {
        var nn, Ut;
        const Wn = (Ut = (nn = ae(Je)) !== null && nn !== void 0 ? nn : t.root_element) !== null && Ut !== void 0 ? Ut : e;
        return Ql(Wn) ? _n(Wn.querySelectorAll(Ke)) : [];
      }, zn = function(Ke, Je, nn) {
        const Ut = nn ?? this;
        if (Se(Ke)) {
          const Wn = [];
          return sl(Ke, (wr, di) => {
            const yc = ae(wr);
            yc && Wn.push(Je.call(Ut, yc, di));
          }), Wn;
        } else {
          const Wn = ae(Ke);
          return Wn ? Je.call(Ut, Wn) : !1;
        }
      }, Ar = (Ke, Je) => {
        zn(Ke, (nn) => {
          Zo(Je, (Ut, Wn) => {
            Fe(nn, Wn, Ut);
          });
        });
      }, xr = (Ke, Je) => {
        zn(Ke, (nn) => {
          const Ut = be.fromDom(nn);
          Hc(Ut, Je);
        });
      }, On = (Ke, Je, nn, Ut, Wn) => zn(Ke, (wr) => {
        const di = Ot(Je) ? e.createElement(Je) : Je;
        return Xe(nn) && Ar(di, nn), Ut && (!Ot(Ut) && Ut.nodeType ? di.appendChild(Ut) : Ot(Ut) && xr(di, Ut)), Wn ? di : wr.appendChild(di);
      }), Rn = (Ke, Je, nn) => On(e.createElement(Ke), Ke, Je, nn, !0), qt = ma.decode, bo = ma.encodeAllRaw, hr = (Ke, Je, nn = "") => {
        let Ut = "<" + Ke;
        for (const Wn in Je)
          qi(Je, Wn) && (Ut += " " + Wn + '="' + bo(Je[Wn]) + '"');
        return us(nn) && Yn(H.getVoidElements(), Ke) ? Ut + " />" : Ut + ">" + nn + "</" + Ke + ">";
      }, Ss = (Ke) => {
        const Je = e.createElement("div"), nn = e.createDocumentFragment();
        nn.appendChild(Je), Ke && (Je.innerHTML = Ke);
        let Ut;
        for (; Ut = Je.firstChild; )
          nn.appendChild(Ut);
        return nn.removeChild(Je), nn;
      }, na = (Ke, Je) => zn(Ke, (nn) => {
        const Ut = be.fromDom(nn);
        return Je && ut(Pr(Ut), (Wn) => {
          Zs(Wn) && Wn.dom.length === 0 ? dr(Wn) : Fs(Ut, Wn);
        }), dr(Ut), Ut.dom;
      }), Ed = (Ke) => zn(Ke, (Je) => {
        const nn = Je.attributes;
        for (let Ut = nn.length - 1; Ut >= 0; Ut--)
          Je.removeAttributeNode(nn.item(Ut));
      }), Mm = (Ke) => U.parse(Ke), Sy = (Ke, Je) => U.serialize(Ke, Je), Td = (Ke) => {
        if (hv !== gs.DOM && e === document) {
          if (n[Ke])
            return;
          n[Ke] = !0;
        }
        let Je = e.getElementById("mceDefaultStyles");
        if (!Je) {
          Je = e.createElement("style"), Je.id = "mceDefaultStyles", Je.type = "text/css";
          const nn = e.head;
          nn.firstChild ? nn.insertBefore(Je, nn.firstChild) : nn.appendChild(Je);
        }
        Je.styleSheet ? Je.styleSheet.cssText += Ke : Je.appendChild(e.createTextNode(Ke));
      }, Qg = (Ke) => {
        Ke || (Ke = ""), ut(Ke.split(","), (Je) => {
          a[Je] = !0, k.load(Je).catch(ht);
        });
      }, vo = (Ke, Je, nn) => {
        zn(Ke, (Ut) => {
          if (wn(Ut)) {
            const Wn = be.fromDom(Ut), wr = Je.split(" ");
            ut(wr, (di) => {
              Xe(nn) ? (nn ? ca : Oi)(Wn, di) : Vd(Wn, di);
            });
          }
        });
      }, br = (Ke, Je) => {
        vo(Ke, Je, !0);
      }, Es = (Ke, Je) => {
        vo(Ke, Je, !1);
      }, Za = (Ke, Je) => {
        const nn = xe(Ke), Ut = Je.split(" ");
        return Xe(nn) && Ns(Ut, (Wn) => Fc(nn, Wn));
      }, ti = (Ke) => {
        zn(Ke, (Je) => ou(be.fromDom(Je), "display"));
      }, tg = (Ke) => {
        zn(Ke, (Je) => Pm(be.fromDom(Je), "display", "none"));
      }, Z2 = (Ke) => {
        const Je = xe(Ke);
        return Xe(Je) && Pd(He(Je, "display"), "none");
      }, rT = (Ke) => (Ke || "mce_") + c++, hw = (Ke) => {
        const Je = xe(Ke);
        return Xe(Je) ? wn(Je.dom) ? Je.dom.outerHTML : Oc(Je) : "";
      }, mv = (Ke, Je) => {
        zn(Ke, (nn) => {
          wn(nn) && (nn.outerHTML = Je);
        });
      }, pv = (Ke, Je) => {
        const nn = ae(Je);
        return zn(Ke, (Ut) => {
          const Wn = nn == null ? void 0 : nn.parentNode, wr = nn == null ? void 0 : nn.nextSibling;
          return Wn && (wr ? Wn.insertBefore(Ut, wr) : Wn.appendChild(Ut)), Ut;
        });
      }, sT = (Ke, Je, nn) => zn(Je, (Ut) => {
        var Wn;
        const wr = Se(Je) ? Ke.cloneNode(!0) : Ke;
        return nn && sl(kg(Ut.childNodes), (di) => {
          wr.appendChild(di);
        }), (Wn = Ut.parentNode) === null || Wn === void 0 || Wn.replaceChild(wr, Ut), Ut;
      }), A5 = (Ke, Je) => {
        if (Ke.nodeName !== Je.toUpperCase()) {
          const nn = Rn(Je);
          return sl(Ie(Ke), (Ut) => {
            Fe(nn, Ut.nodeName, Ne(Ke, Ut.nodeName));
          }), sT(nn, Ke, !0), nn;
        } else
          return Ke;
      }, D5 = (Ke, Je) => {
        let nn = Ke;
        for (; nn; ) {
          let Ut = Je;
          for (; Ut && nn !== Ut; )
            Ut = Ut.parentNode;
          if (nn === Ut)
            break;
          nn = nn.parentNode;
        }
        return !nn && Ke.ownerDocument ? Ke.ownerDocument.documentElement : nn;
      }, W2 = (Ke) => {
        if (wn(Ke)) {
          const Je = Ke.nodeName.toLowerCase() === "a" && !Ne(Ke, "href") && Ne(Ke, "id");
          if (Ne(Ke, "name") || Ne(Ke, "data-mce-bookmark") || Je)
            return !0;
        }
        return !1;
      }, R5 = (Ke, Je, nn) => {
        let Ut = 0;
        if (W2(Ke))
          return !1;
        const Wn = Ke.firstChild;
        if (Wn) {
          const wr = new vi(Wn, Ke), di = H ? H.getWhitespaceElements() : {}, yc = Je || (H ? H.getNonEmptyElements() : null);
          let ec = Wn;
          do {
            if (wn(ec)) {
              const cT = ec.getAttribute("data-mce-bogus");
              if (cT) {
                ec = wr.next(cT === "all");
                continue;
              }
              const uT = ec.nodeName.toLowerCase();
              if (yc && yc[uT]) {
                if (uT === "br") {
                  Ut++, ec = wr.next();
                  continue;
                }
                return !1;
              }
              if (W2(ec))
                return !1;
            }
            if (Gd(ec) || At(ec) && !pd(ec.data) && (!(nn != null && nn.includeZwsp) || !zu(ec.data)) || At(ec) && ec.parentNode && di[ec.parentNode.nodeName] && pd(ec.data))
              return !1;
            ec = wr.next();
          } while (ec);
        }
        return Ut <= 1;
      }, gv = () => e.createRange(), q2 = (Ke, Je, nn) => {
        let Ut = gv(), Wn, wr;
        if (Ke && Je && Ke.parentNode && Je.parentNode) {
          const di = Ke.parentNode;
          return Ut.setStart(di, hm(Ke)), Ut.setEnd(Je.parentNode, hm(Je)), Wn = Ut.extractContents(), Ut = gv(), Ut.setStart(Je.parentNode, hm(Je) + 1), Ut.setEnd(di, hm(Ke) + 1), wr = Ut.extractContents(), di.insertBefore(lb(hv, Wn, H), Ke), nn ? di.insertBefore(nn, Ke) : di.insertBefore(Je, Ke), di.insertBefore(lb(hv, wr, H), Ke), na(Ke), nn || Je;
        } else
          return;
      }, eh = (Ke, Je, nn, Ut) => {
        if (Se(Ke)) {
          let Wn = Ke.length;
          const wr = [];
          for (; Wn--; )
            wr[Wn] = eh(Ke[Wn], Je, nn, Ut);
          return wr;
        } else
          return t.collect && (Ke === e || Ke === r) && D.push([
            Ke,
            Je,
            nn,
            Ut
          ]), G.bind(Ke, Je, nn, Ut || hv);
      }, W1 = (Ke, Je, nn) => {
        if (Se(Ke)) {
          let Ut = Ke.length;
          const Wn = [];
          for (; Ut--; )
            Wn[Ut] = W1(Ke[Ut], Je, nn);
          return Wn;
        } else {
          if (D.length > 0 && (Ke === e || Ke === r)) {
            let Ut = D.length;
            for (; Ut--; ) {
              const [Wn, wr, di] = D[Ut];
              Ke === Wn && (!Je || Je === wr) && (!nn || nn === di) && G.unbind(Wn, wr, di);
            }
          }
          return G.unbind(Ke, Je, nn);
        }
      }, aT = (Ke, Je, nn) => G.dispatch(Ke, Je, nn), iT = (Ke, Je, nn) => G.dispatch(Ke, Je, nn), N5 = (Ke) => {
        if (Ke && ta(Ke)) {
          const Je = Ke.getAttribute("data-mce-contenteditable");
          return Je && Je !== "inherit" ? Je : Ke.contentEditable !== "inherit" ? Ke.contentEditable : null;
        } else
          return null;
      }, hv = {
        doc: e,
        settings: t,
        win: r,
        files: a,
        stdMode: d,
        boxModel: h,
        styleSheetLoader: k,
        boundEvents: D,
        styles: U,
        schema: H,
        events: G,
        isBlock: ye,
        root: null,
        clone: je,
        getRoot: _t,
        getViewPort: Zt,
        getRect: Fn,
        getSize: gn,
        getParent: vs,
        getParents: qo,
        get: ae,
        getNext: Ci,
        getPrev: Yc,
        select: sn,
        is: Uo,
        add: On,
        create: Rn,
        createHTML: hr,
        createFragment: Ss,
        remove: na,
        setStyle: at,
        getStyle: Mt,
        setStyles: et,
        removeAllAttribs: Ed,
        setAttrib: Fe,
        setAttribs: Ar,
        getAttrib: Ne,
        getPos: fn,
        parseStyle: Mm,
        serializeStyle: Sy,
        addStyle: Td,
        loadCSS: Qg,
        addClass: br,
        removeClass: Es,
        hasClass: Za,
        toggleClass: vo,
        show: ti,
        hide: tg,
        isHidden: Z2,
        uniqueId: rT,
        setHTML: xr,
        getOuterHTML: hw,
        setOuterHTML: mv,
        decode: qt,
        encode: bo,
        insertAfter: pv,
        replace: sT,
        rename: A5,
        findCommonAncestor: D5,
        run: zn,
        getAttribs: Ie,
        isEmpty: R5,
        createRng: gv,
        nodeIndex: hm,
        split: q2,
        bind: eh,
        unbind: W1,
        fire: iT,
        dispatch: aT,
        getContentEditable: N5,
        getContentEditableParent: (Ke) => {
          const Je = _t();
          let nn = null;
          for (let Ut = Ke; Ut && Ut !== Je && (nn = N5(Ut), nn === null); Ut = Ut.parentNode)
            ;
          return nn;
        },
        isEditable: (Ke) => {
          if (Xe(Ke)) {
            const Je = wn(Ke) ? Ke : Ke.parentElement;
            return Xe(Je) && ta(Je) && Ka(be.fromDom(Je));
          } else
            return !1;
        },
        destroy: () => {
          if (D.length > 0) {
            let Ke = D.length;
            for (; Ke--; ) {
              const [Je, nn, Ut] = D[Ke];
              G.unbind(Je, nn, Ut);
            }
          }
          Zo(a, (Ke, Je) => {
            k.unload(Je), delete a[Je];
          });
        },
        isChildOf: (Ke, Je) => Ke === Je || Je.contains(Ke),
        dumpRng: (Ke) => "startContainer: " + Ke.startContainer.nodeName + ", startOffset: " + Ke.startOffset + ", endContainer: " + Ke.endContainer.nodeName + ", endOffset: " + Ke.endOffset
      }, lT = gb(U, t, dt(hv));
      return hv;
    };
    gs.DOM = gs(document), gs.nodeIndex = hm;
    const Ii = gs.DOM, vh = 0, bm = 1, Pf = 2, jy = 3;
    class Gl {
      constructor(t = {}) {
        this.states = {}, this.queue = [], this.scriptLoadedCallbacks = {}, this.queueLoadedCallbacks = [], this.loading = !1, this.settings = t;
      }
      _setReferrerPolicy(t) {
        this.settings.referrerPolicy = t;
      }
      loadScript(t) {
        return new Promise((n, r) => {
          const a = Ii;
          let c;
          const d = () => {
            a.remove(D), c && (c.onerror = c.onload = c = null);
          }, h = () => {
            d(), n();
          }, k = () => {
            d(), r("Failed to load script: " + t);
          }, D = a.uniqueId();
          c = document.createElement("script"), c.id = D, c.type = "text/javascript", c.src = Ht._addCacheSuffix(t), this.settings.referrerPolicy && a.setAttrib(c, "referrerpolicy", this.settings.referrerPolicy), c.onload = h, c.onerror = k, (document.getElementsByTagName("head")[0] || document.body).appendChild(c);
        });
      }
      isDone(t) {
        return this.states[t] === Pf;
      }
      markDone(t) {
        this.states[t] = Pf;
      }
      add(t) {
        const n = this;
        return n.queue.push(t), n.states[t] === void 0 && (n.states[t] = vh), new Promise((a, c) => {
          n.scriptLoadedCallbacks[t] || (n.scriptLoadedCallbacks[t] = []), n.scriptLoadedCallbacks[t].push({
            resolve: a,
            reject: c
          });
        });
      }
      load(t) {
        return this.add(t);
      }
      remove(t) {
        delete this.states[t], delete this.scriptLoadedCallbacks[t];
      }
      loadQueue() {
        const t = this.queue;
        return this.queue = [], this.loadScripts(t);
      }
      loadScripts(t) {
        const n = this, r = (k, D) => {
          Hr(n.scriptLoadedCallbacks, D).each((H) => {
            ut(H, (U) => U[k](D));
          }), delete n.scriptLoadedCallbacks[D];
        }, a = (k) => {
          const D = ct(k, (H) => H.status === "rejected");
          return D.length > 0 ? Promise.reject(ho(D, ({ reason: H }) => Se(H) ? H : [H])) : Promise.resolve();
        }, c = (k) => Promise.allSettled(oo(k, (D) => n.states[D] === Pf ? (r("resolve", D), Promise.resolve()) : n.states[D] === jy ? (r("reject", D), Promise.reject(D)) : (n.states[D] = bm, n.loadScript(D).then(() => {
          n.states[D] = Pf, r("resolve", D);
          const H = n.queue;
          return H.length > 0 ? (n.queue = [], c(H).then(a)) : Promise.resolve();
        }, () => (n.states[D] = jy, r("reject", D), Promise.reject(D)))))), d = (k) => (n.loading = !0, c(k).then((D) => {
          n.loading = !1;
          const H = n.queueLoadedCallbacks.shift();
          return K.from(H).each(oa), a(D);
        })), h = Cl(t);
        return n.loading ? new Promise((k, D) => {
          n.queueLoadedCallbacks.push(() => {
            d(h).then(k, D);
          });
        }) : d(h);
      }
    }
    Gl.ScriptLoader = new Gl();
    const Ja = (e) => {
      let t = e;
      return {
        get: () => t,
        set: (a) => {
          t = a;
        }
      };
    }, X1 = (e, t) => {
      const n = e.indexOf(t);
      return n !== -1 && e.indexOf(t, n + 1) > n;
    }, ym = (e) => Ee(e) && Yn(e, "raw"), Pp = (e) => Se(e) && e.length > 1, Xm = {}, hb = Ja("en"), bb = () => Hr(Xm, hb.get()), Rc = {
      getData: () => mi(Xm, (e) => ({ ...e })),
      setCode: (e) => {
        e && hb.set(e);
      },
      getCode: () => hb.get(),
      add: (e, t) => {
        let n = Xm[e];
        n || (Xm[e] = n = {});
        const r = oo(Nt(t), (a) => a.toLowerCase());
        Zo(t, (a, c) => {
          const d = c.toLowerCase();
          d !== c && X1(r, d) ? (Yn(t, d) || (n[d] = a), n[c] = a) : n[d] = a;
        });
      },
      translate: (e) => {
        const t = bb().getOr({}), n = (d) => un(d) ? Object.prototype.toString.call(d) : r(d) ? "" : "" + d, r = (d) => d === "" || d === null || d === void 0, a = (d) => {
          const h = n(d);
          return Yn(t, h) ? n(t[h]) : Hr(t, h.toLowerCase()).map(n).getOr(h);
        }, c = (d) => d.replace(/{context:\w+}$/, "");
        if (r(e))
          return "";
        if (ym(e))
          return n(e.raw);
        if (Pp(e)) {
          const d = e.slice(1), h = a(e[0]).replace(/\{([0-9]+)\}/g, (k, D) => Yn(d, D) ? n(d[D]) : k);
          return c(h);
        }
        return c(a(e));
      },
      isRtl: () => bb().bind((e) => Hr(e, "_dir")).exists((e) => e === "rtl"),
      hasCode: (e) => Yn(Xm, e)
    }, Bl = () => {
      const e = [], t = {}, n = {}, r = [], a = (ae, xe) => {
        const Ne = ct(r, (Ie) => Ie.name === ae && Ie.state === xe);
        ut(Ne, (Ie) => Ie.resolve());
      }, c = (ae) => Yn(t, ae), d = (ae) => Yn(n, ae), h = (ae) => {
        if (n[ae])
          return n[ae].instance;
      }, k = (ae, xe) => {
        const Ne = Rc.getCode(), Ie = "," + (xe || "") + ",";
        !Ne || xe && Ie.indexOf("," + Ne + ",") === -1 || Gl.ScriptLoader.add(t[ae] + "/langs/" + Ne + ".js");
      }, D = (ae, xe) => {
        Bl.languageLoad !== !1 && (c(ae) ? k(ae, xe) : ye(ae, "loaded").then(() => k(ae, xe)));
      }, H = (ae, xe) => (e.push(xe), n[ae] = { instance: xe }, a(ae, "added"), xe), U = (ae) => {
        delete t[ae], delete n[ae];
      }, G = (ae, xe) => Ot(xe) ? Ot(ae) ? {
        prefix: "",
        resource: xe,
        suffix: ""
      } : {
        prefix: ae.prefix,
        resource: xe,
        suffix: ae.suffix
      } : xe, ie = (ae, xe) => {
        if (t[ae])
          return Promise.resolve();
        let Ne = Ot(xe) ? xe : xe.prefix + xe.resource + xe.suffix;
        Ne.indexOf("/") !== 0 && Ne.indexOf("://") === -1 && (Ne = Bl.baseURL + "/" + Ne), t[ae] = Ne.substring(0, Ne.lastIndexOf("/"));
        const Ie = () => (a(ae, "loaded"), Promise.resolve());
        return n[ae] ? Ie() : Gl.ScriptLoader.add(Ne).then(Ie);
      }, ye = (ae, xe = "added") => xe === "added" && d(ae) || xe === "loaded" && c(ae) ? Promise.resolve() : new Promise((Ne) => {
        r.push({
          name: ae,
          state: xe,
          resolve: Ne
        });
      });
      return {
        items: e,
        urls: t,
        lookup: n,
        get: h,
        requireLangPack: D,
        add: H,
        remove: U,
        createUrl: G,
        load: ie,
        waitFor: ye
      };
    };
    Bl.languageLoad = !0, Bl.baseURL = "", Bl.PluginManager = Bl(), Bl.ThemeManager = Bl(), Bl.ModelManager = Bl();
    const vb = (e) => {
      const t = Ja(K.none()), n = () => t.get().each(e);
      return {
        clear: () => {
          n(), t.set(K.none());
        },
        isSet: () => t.get().isSome(),
        get: () => t.get(),
        set: (h) => {
          n(), t.set(K.some(h));
        }
      };
    }, xb = (e) => {
      const t = Ja(K.none()), n = () => t.get().each((h) => clearInterval(h));
      return {
        clear: () => {
          n(), t.set(K.none());
        },
        isSet: () => t.get().isSome(),
        get: () => t.get(),
        set: (h) => {
          n(), t.set(K.some(setInterval(h, e)));
        }
      };
    }, sf = () => {
      const e = vb(ht);
      return {
        ...e,
        on: (n) => e.get().each(n)
      };
    }, xh = (e, t) => {
      let n = null;
      return {
        cancel: () => {
          We(n) || (clearTimeout(n), n = null);
        },
        throttle: (...c) => {
          We(n) && (n = setTimeout(() => {
            n = null, e.apply(null, c);
          }, t));
        }
      };
    }, Ru = (e, t) => {
      let n = null;
      const r = () => {
        We(n) || (clearTimeout(n), n = null);
      };
      return {
        cancel: r,
        throttle: (...c) => {
          r(), n = setTimeout(() => {
            n = null, e.apply(null, c);
          }, t);
        }
      };
    }, If = dt("mce-annotation"), Jm = dt("data-mce-annotation"), vm = dt("data-mce-annotation-uid"), xm = dt("data-mce-annotation-active"), yd = dt("data-mce-annotation-classes"), Sg = dt("data-mce-annotation-attrs"), wh = (e) => (t) => Le(t, e), wb = (e, t) => {
      const n = e.selection.getRng(), r = be.fromDom(n.startContainer), a = be.fromDom(e.getBody()), c = t.fold(() => "." + If(), (k) => `[${Jm()}="${k}"]`), d = Tc(r, n.startOffset).getOr(r);
      return el(d, c, wh(a)).bind((k) => Js(k, `${vm()}`).bind((D) => Js(k, `${Jm()}`).map((H) => {
        const U = Gy(e, D);
        return {
          uid: D,
          name: H,
          elements: U
        };
      })));
    }, Kl = (e) => Ji(e) && Fc(e, If()), qy = (e, t) => La(e, "data-mce-bogus") || ka(e, '[data-mce-bogus="all"]', wh(t)), Gy = (e, t) => {
      const n = be.fromDom(e.getBody()), r = Ni(n, `[${vm()}="${t}"]`);
      return ct(r, (a) => !qy(a, n));
    }, kb = (e, t) => {
      const n = be.fromDom(e.getBody()), r = Ni(n, `[${Jm()}="${t}"]`), a = {};
      return ut(r, (c) => {
        if (!qy(c, n)) {
          const d = Qi(c, vm()), h = Hr(a, d).getOr([]);
          a[d] = h.concat([c]);
        }
      }), a;
    }, kv = (e, t) => {
      const n = Ja({}), r = () => ({
        listeners: [],
        previous: sf()
      }), a = (U, G) => {
        c(U, (ie) => (G(ie), ie));
      }, c = (U, G) => {
        const ie = n.get(), ye = Hr(ie, U).getOrThunk(r), ae = G(ye);
        ie[U] = ae, n.set(ie);
      }, d = (U, G, ie) => {
        a(U, (ye) => {
          ut(ye.listeners, (ae) => ae(!0, U, {
            uid: G,
            nodes: oo(ie, (xe) => xe.dom)
          }));
        });
      }, h = (U) => {
        a(U, (G) => {
          ut(G.listeners, (ie) => ie(!1, U));
        });
      }, k = (U, G) => {
        ut(Gy(e, U), (ie) => {
          G ? Vr(ie, xm(), "true") : xs(ie, xm());
        });
      }, D = Ru(() => {
        const U = Po(t.getNames());
        ut(U, (G) => {
          c(G, (ie) => {
            const ye = ie.previous.get();
            return wb(e, K.some(G)).fold(() => {
              ye.each((ae) => {
                h(G), ie.previous.clear(), k(ae, !1);
              });
            }, ({ uid: ae, name: xe, elements: Ne }) => {
              Pd(ye, ae) || (ye.each((Ie) => k(Ie, !1)), d(xe, ae, Ne), ie.previous.set(ae), k(ae, !0));
            }), {
              previous: ie.previous,
              listeners: ie.listeners
            };
          });
        });
      }, 30);
      return e.on("remove", () => {
        D.cancel();
      }), e.on("NodeChange", () => {
        D.throttle();
      }), { addListener: (U, G) => {
        c(U, (ie) => ({
          previous: ie.previous,
          listeners: ie.listeners.concat([G])
        }));
      } };
    }, kh = (e, t) => {
      const n = Jm(), r = (c) => K.from(c.attr(n)).bind(t.lookup), a = (c) => {
        var d, h;
        c.attr(vm(), null), c.attr(Jm(), null), c.attr(xm(), null);
        const k = K.from(c.attr(Sg())).map((G) => G.split(",")).getOr([]), D = K.from(c.attr(yd())).map((G) => G.split(",")).getOr([]);
        ut(k, (G) => c.attr(G, null));
        const H = (h = (d = c.attr("class")) === null || d === void 0 ? void 0 : d.split(" ")) !== null && h !== void 0 ? h : [], U = Zr(H, [If()].concat(D));
        c.attr("class", U.length > 0 ? U.join(" ") : null), c.attr(yd(), null), c.attr(Sg(), null);
      };
      e.serializer.addTempAttr(xm()), e.serializer.addAttributeFilter(n, (c) => {
        for (const d of c)
          r(d).each((h) => {
            h.persistent === !1 && (d.name === "span" ? d.unwrap() : a(d));
          });
      });
    }, Ky = () => {
      const e = {};
      return {
        register: (a, c) => {
          e[a] = {
            name: a,
            settings: c
          };
        },
        lookup: (a) => Hr(e, a).map((c) => c.settings),
        getNames: () => Nt(e)
      };
    };
    let wm = 0;
    const km = (e) => {
      const n = (/* @__PURE__ */ new Date()).getTime(), r = Math.floor(Math.random() * 1e9);
      return wm++, e + "_" + r + wm + String(n);
    }, Q1 = (e, t) => {
      ut(t, (n) => {
        ca(e, n);
      });
    }, _b = (e, t) => {
      ut(t, (n) => {
        Oi(e, n);
      });
    }, Cb = (e, t) => be.fromDom(e.dom.cloneNode(t)), _m = (e) => Cb(e, !1), Qm = (e) => Cb(e, !0), Sb = (e, t) => {
      const n = be.fromTag(t), r = Ws(e);
      return zs(n, r), n;
    }, _h = (e, t) => {
      const n = Sb(e, t);
      rs(e, n);
      const r = Pr(e);
      return Fa(n, r), dr(e), n;
    }, ep = (e, t, n = Pn) => {
      const r = new vi(e, t), a = (c) => {
        let d;
        do
          d = r[c]();
        while (d && !At(d) && !n(d));
        return K.from(d).filter(At);
      };
      return {
        current: () => K.from(r.current()).filter(At),
        next: () => a("next"),
        prev: () => a("prev"),
        prev2: () => a("prev2")
      };
    }, tp = (e, t) => {
      const n = t || ((d) => e.isBlock(d) || cs(d) || Kr(d)), r = (d, h, k, D) => {
        if (At(d)) {
          const H = D(d, h, d.data);
          if (H !== -1)
            return K.some({
              container: d,
              offset: H
            });
        }
        return k().bind((H) => r(H.container, H.offset, k, D));
      };
      return {
        backwards: (d, h, k, D) => {
          const H = ep(d, D ?? e.getRoot(), n);
          return r(d, h, () => H.prev().map((U) => ({
            container: U,
            offset: U.length
          })), k).getOrNull();
        },
        forwards: (d, h, k, D) => {
          const H = ep(d, D ?? e.getRoot(), n);
          return r(d, h, () => H.next().map((U) => ({
            container: U,
            offset: 0
          })), k).getOrNull();
        }
      };
    }, Ip = Math.round, af = (e) => e ? {
      left: Ip(e.left),
      top: Ip(e.top),
      bottom: Ip(e.bottom),
      right: Ip(e.right),
      width: Ip(e.width),
      height: Ip(e.height)
    } : {
      left: 0,
      top: 0,
      bottom: 0,
      right: 0,
      width: 0,
      height: 0
    }, np = (e, t) => (e = af(e), t || (e.left = e.left + e.width), e.right = e.left, e.width = 0, e), _v = (e, t) => e.left === t.left && e.top === t.top && e.bottom === t.bottom && e.right === t.right, Ch = (e, t, n) => e >= 0 && e <= Math.min(t.height, n.height) / 2, op = (e, t) => {
      const n = Math.min(t.height / 2, e.height / 2);
      return e.bottom - n < t.top ? !0 : e.top > t.bottom ? !1 : Ch(t.top - e.bottom, e, t);
    }, Fp = (e, t) => e.top > t.bottom ? !0 : e.bottom < t.top ? !1 : Ch(t.bottom - e.top, e, t), Eb = (e, t, n) => t >= e.left && t <= e.right && n >= e.top && n <= e.bottom, Yy = (e) => co(e, (t, n) => t.fold(() => K.some(n), (r) => {
      const a = Math.min(n.left, r.left), c = Math.min(n.top, r.top), d = Math.max(n.right, r.right), h = Math.max(n.bottom, r.bottom);
      return K.some({
        top: c,
        right: d,
        bottom: h,
        left: a,
        width: d - a,
        height: h - c
      });
    }), K.none()), Xy = (e, t, n) => {
      const r = Math.max(Math.min(t, e.left + e.width), e.left), a = Math.max(Math.min(n, e.top + e.height), e.top);
      return Math.sqrt((t - r) * (t - r) + (n - a) * (n - a));
    }, Ll = (e, t) => Math.max(0, Math.min(e.bottom, t.bottom) - Math.max(e.top, t.top)), Tb = (e, t, n) => Math.min(Math.max(e, t), n), lf = (e) => {
      const t = e.startContainer, n = e.startOffset;
      return t === e.endContainer && t.hasChildNodes() && e.endOffset === n + 1 ? t.childNodes[n] : null;
    }, Nu = (e, t) => {
      if (wn(e) && e.hasChildNodes()) {
        const n = e.childNodes, r = Tb(t, 0, n.length - 1);
        return n[r];
      } else
        return e;
    }, Jy = (e, t) => {
      if (!(t < 0 && wn(e) && e.hasChildNodes()))
        return Nu(e, t);
    }, Sh = new RegExp("[̀-ͯ҃-҇҈-҉֑-ֽֿׁ-ׂׄ-ׇׅؐ-ًؚ-ٰٟۖ-ۜ۟-ۤۧ-۪ۨ-ܑۭܰ-݊ަ-ް߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣣ-ंऺ़ु-ै्॑-ॗॢ-ॣঁ়াু-ৄ্ৗৢ-ৣਁ-ਂ਼ੁ-ੂੇ-ੈੋ-੍ੑੰ-ੱੵઁ-ં઼ુ-ૅે-ૈ્ૢ-ૣଁ଼ାିୁ-ୄ୍ୖୗୢ-ୣஂாீ்ௗఀా-ీె-ైొ-్ౕ-ౖౢ-ౣಁ಼ಿೂೆೌ-್ೕ-ೖೢ-ೣഁാു-ൄ്ൗൢ-ൣ්ාි-ුූෟัิ-ฺ็-๎ັິ-ູົ-ຼ່-ໍ༘-ཱ༹༙༵༷-ཾྀ-྄྆-྇ྍ-ྗྙ-ྼ࿆ိ-ူဲ-့္-်ွ-ှၘ-ၙၞ-ၠၱ-ၴႂႅ-ႆႍႝ፝-፟ᜒ-᜔ᜲ-᜴ᝒ-ᝓᝲ-ᝳ឴-឵ិ-ួំ៉-៓៝᠋-᠍ᢩᤠ-ᤢᤧ-ᤨᤲ᤹-᤻ᨗ-ᨘᨛᩖᩘ-ᩞ᩠ᩢᩥ-ᩬᩳ-᩿᩼᪰-᪽᪾ᬀ-ᬃ᬴ᬶ-ᬺᬼᭂ᭫-᭳ᮀ-ᮁᮢ-ᮥᮨ-ᮩ᮫-ᮭ᯦ᯨ-ᯩᯭᯯ-ᯱᰬ-ᰳᰶ-᰷᳐-᳔᳒-᳢᳠-᳨᳭᳴᳸-᳹᷀-᷵᷼-᷿‌-‍⃐-⃜⃝-⃠⃡⃢-⃤⃥-⃰⳯-⵿⳱ⷠ-〪ⷿ-〭〮-゙〯-゚꙯꙰-꙲ꙴ-꙽ꚞ-ꚟ꛰-꛱ꠂ꠆ꠋꠥ-ꠦ꣄꣠-꣱ꤦ-꤭ꥇ-ꥑꦀ-ꦂ꦳ꦶ-ꦹꦼꧥꨩ-ꨮꨱ-ꨲꨵ-ꨶꩃꩌꩼꪰꪲ-ꪴꪷ-ꪸꪾ-꪿꫁ꫬ-ꫭ꫶ꯥꯨ꯭ﬞ︀-️︠-︯ﾞ-ﾟ]"), rp = (e) => Ot(e) && e.charCodeAt(0) >= 768 && Sh.test(e), sp = (...e) => (t) => {
      for (let n = 0; n < e.length; n++)
        if (e[n](t))
          return !0;
      return !1;
    }, zb = (...e) => (t) => {
      for (let n = 0; n < e.length; n++)
        if (!e[n](t))
          return !1;
      return !0;
    }, Ob = wn, Cm = Sr, ap = Zd("display", "block table"), Eh = Zd("float", "left right"), ip = zb(Ob, Cm, yo(Eh)), Th = yo(Zd("white-space", "pre pre-line pre-wrap")), zh = At, Eg = cs, Ab = gs.nodeIndex, $p = Jy, Ff = (e) => e ? e.createRange() : gs.DOM.createRng(), Sm = (e) => Ot(e) && /[\r\n\t ]/.test(e), Tg = (e) => !!e.setStart && !!e.setEnd, Db = (e) => {
      const t = e.startContainer, n = e.startOffset;
      if (Sm(e.toString()) && Th(t.parentNode) && At(t)) {
        const r = t.data;
        if (Sm(r[n - 1]) || Sm(r[n + 1]))
          return !0;
      }
      return !1;
    }, vd = (e) => {
      const t = e.ownerDocument, n = Ff(t), r = t.createTextNode(Bo), a = e.parentNode;
      a.insertBefore(r, e), n.setStart(r, 0), n.setEnd(r, 1);
      const c = af(n.getBoundingClientRect());
      return a.removeChild(r), c;
    }, Hp = (e) => {
      const t = e.startContainer, n = e.endContainer, r = e.startOffset, a = e.endOffset;
      if (t === n && At(n) && r === 0 && a === 1) {
        const c = e.cloneRange();
        return c.setEndAfter(n), zo(c);
      } else
        return null;
    }, zg = (e) => e.left === 0 && e.right === 0 && e.top === 0 && e.bottom === 0, zo = (e) => {
      var t;
      let n;
      const r = e.getClientRects();
      return r.length > 0 ? n = af(r[0]) : n = af(e.getBoundingClientRect()), !Tg(e) && Eg(e) && zg(n) ? vd(e) : zg(n) && Tg(e) && (t = Hp(e)) !== null && t !== void 0 ? t : n;
    }, Pl = (e, t) => {
      const n = np(e, t);
      return n.width = 1, n.right = n.left + 1, n;
    }, Og = (e) => {
      const t = [], n = (d) => {
        d.height !== 0 && (t.length > 0 && _v(d, t[t.length - 1]) || t.push(d));
      }, r = (d, h) => {
        const k = Ff(d.ownerDocument);
        if (h < d.data.length) {
          if (rp(d.data[h]))
            return;
          if (rp(d.data[h - 1]) && (k.setStart(d, h), k.setEnd(d, h + 1), !Db(k))) {
            n(Pl(zo(k), !1));
            return;
          }
        }
        h > 0 && (k.setStart(d, h - 1), k.setEnd(d, h), Db(k) || n(Pl(zo(k), !1))), h < d.data.length && (k.setStart(d, h), k.setEnd(d, h + 1), Db(k) || n(Pl(zo(k), !0)));
      }, a = e.container(), c = e.offset();
      if (zh(a))
        return r(a, c), t;
      if (Ob(a))
        if (e.isAtEnd()) {
          const d = $p(a, c);
          zh(d) && r(d, d.data.length), ip(d) && !Eg(d) && n(Pl(zo(d), !1));
        } else {
          const d = $p(a, c);
          if (zh(d) && r(d, 0), ip(d) && e.isAtEnd())
            return n(Pl(zo(d), !1)), t;
          const h = $p(e.container(), e.offset() - 1);
          ip(h) && !Eg(h) && (ap(h) || ap(d) || !ip(d)) && n(Pl(zo(h), !1)), ip(d) && n(Pl(zo(d), !0));
        }
      return t;
    }, nt = (e, t, n) => {
      const r = () => (zh(e), t === 0), a = () => zh(e) ? t >= e.data.length : t >= e.childNodes.length, c = () => {
        const H = Ff(e.ownerDocument);
        return H.setStart(e, t), H.setEnd(e, t), H;
      }, d = () => (n || (n = Og(nt(e, t))), n), h = () => d().length > 0, k = (H) => H && e === H.container() && t === H.offset(), D = (H) => $p(e, H ? t - 1 : t);
      return {
        container: dt(e),
        offset: dt(t),
        toRange: c,
        getClientRects: d,
        isVisible: h,
        isAtStart: r,
        isAtEnd: a,
        isEqual: k,
        getNode: D
      };
    };
    nt.fromRangeStart = (e) => nt(e.startContainer, e.startOffset), nt.fromRangeEnd = (e) => nt(e.endContainer, e.endOffset), nt.after = (e) => nt(e.parentNode, Ab(e) + 1), nt.before = (e) => nt(e.parentNode, Ab(e)), nt.isAbove = (e, t) => ns(ro(t.getClientRects()), cn(e.getClientRects()), op).getOr(!1), nt.isBelow = (e, t) => ns(cn(t.getClientRects()), ro(e.getClientRects()), Fp).getOr(!1), nt.isAtStart = (e) => e ? e.isAtStart() : !1, nt.isAtEnd = (e) => e ? e.isAtEnd() : !1, nt.isTextPosition = (e) => e ? At(e.container()) : !1, nt.isElementPosition = (e) => !nt.isTextPosition(e);
    const Ag = (e, t) => {
      At(t) && t.data.length === 0 && e.remove(t);
    }, Rb = (e, t, n) => {
      t.insertNode(n), Ag(e, n.previousSibling), Ag(e, n.nextSibling);
    }, e0 = (e, t, n) => {
      const r = K.from(n.firstChild), a = K.from(n.lastChild);
      t.insertNode(n), r.each((c) => Ag(e, c.previousSibling)), a.each((c) => Ag(e, c.nextSibling));
    }, Dg = (e, t, n) => {
      lm(n) ? e0(e, t, n) : Rb(e, t, n);
    }, Mu = At, Rg = ru, Nb = gs.nodeIndex, Qy = (e) => {
      const t = e.parentNode;
      return Rg(t) ? Qy(t) : t;
    }, Oh = (e) => e ? wc(e.childNodes, (t, n) => (Rg(n) && n.nodeName !== "BR" ? t = t.concat(Oh(n)) : t.push(n), t), []) : [], Mb = (e, t) => {
      let n = e;
      for (; (n = n.previousSibling) && Mu(n); )
        t += n.data.length;
      return t;
    }, e1 = (e) => (t) => e === t, t0 = (e) => {
      let t, n;
      t = Oh(Qy(e)), n = pi(t, e1(e), e), t = t.slice(0, n + 1);
      const r = wc(t, (a, c, d) => (Mu(c) && Mu(t[d - 1]) && a++, a), 0);
      return t = Rd(t, Ul([e.nodeName])), n = pi(t, e1(e), e), n - r;
    }, Bb = (e) => (Mu(e) ? "text()" : e.nodeName.toLowerCase()) + "[" + t0(e) + "]", n0 = (e, t, n) => {
      const r = [];
      for (let a = t.parentNode; a && a !== e && !(n && n(a)); a = a.parentNode)
        r.push(a);
      return r;
    }, xd = (e, t) => {
      let n = [], r = t.container(), a = t.offset(), c;
      if (Mu(r))
        c = Mb(r, a);
      else {
        const h = r.childNodes;
        a >= h.length ? (c = "after", a = h.length - 1) : c = "before", r = h[a];
      }
      n.push(Bb(r));
      let d = n0(e, r);
      return d = Rd(d, yo(ru)), n = n.concat(yf(d, (h) => Bb(h))), n.reverse().join("/") + "," + c;
    }, Cv = (e, t, n) => {
      let r = Oh(e);
      return r = Rd(r, (a, c) => !Mu(a) || !Mu(r[c - 1])), r = Rd(r, Ul([t])), r[n];
    }, ln = (e, t) => {
      let n = e, r = 0;
      for (; Mu(n); ) {
        const a = n.data.length;
        if (t >= r && t <= r + a) {
          e = n, t = t - r;
          break;
        }
        if (!Mu(n.nextSibling)) {
          e = n, t = a;
          break;
        }
        r += a, n = n.nextSibling;
      }
      return Mu(e) && t > e.data.length && (t = e.data.length), nt(e, t);
    }, pa = (e, t) => {
      if (!t)
        return null;
      const n = t.split(","), r = n[0].split("/"), a = n.length > 1 ? n[1] : "before", c = wc(r, (d, h) => {
        const k = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(h);
        return k ? (k[1] === "text()" && (k[1] = "#text"), Cv(d, k[1], parseInt(k[2], 10))) : null;
      }, e);
      if (!c)
        return null;
      if (!Mu(c) && c.parentNode) {
        let d;
        return a === "after" ? d = Nb(c) + 1 : d = Nb(c), nt(c.parentNode, d);
      }
      return ln(c, parseInt(a, 10));
    }, ir = Kr, Fi = (e, t, n) => {
      let r = e(t.data.slice(0, n)).length;
      for (let a = t.previousSibling; a && At(a); a = a.previousSibling)
        r += e(a.data).length;
      return r;
    }, $i = (e, t, n, r, a) => {
      const c = a ? r.startContainer : r.endContainer;
      let d = a ? r.startOffset : r.endOffset;
      const h = [], k = e.getRoot();
      if (At(c))
        h.push(n ? Fi(t, c, d) : d);
      else {
        let D = 0;
        const H = c.childNodes;
        d >= H.length && H.length && (D = 1, d = Math.max(0, H.length - 1)), h.push(e.nodeIndex(H[d], n) + D);
      }
      for (let D = c; D && D !== k; D = D.parentNode)
        h.push(e.nodeIndex(D, n));
      return h;
    }, Ua = (e, t, n, r) => {
      const a = t.dom, c = $i(a, e, n, r, !0), d = t.isForward(), h = Of(r) ? { isFakeCaret: !0 } : {};
      if (t.isCollapsed())
        return {
          start: c,
          forward: d,
          ...h
        };
      {
        const k = $i(a, e, n, r, !1);
        return {
          start: c,
          end: k,
          forward: d,
          ...h
        };
      }
    }, Lb = (e, t, n) => {
      let r = 0;
      return Ht.each(e.select(t), (a) => {
        if (a.getAttribute("data-mce-bogus") !== "all") {
          if (a === n)
            return !1;
          r++;
          return;
        }
      }), r;
    }, wd = (e, t) => {
      let n = t ? e.startContainer : e.endContainer, r = t ? e.startOffset : e.endOffset;
      if (wn(n) && n.nodeName === "TR") {
        const a = n.childNodes;
        n = a[Math.min(t ? r : r - 1, a.length - 1)], n && (r = t ? 0 : n.childNodes.length, t ? e.setStart(n, r) : e.setEnd(n, r));
      }
    }, p = (e) => (wd(e, !0), wd(e, !1), e), y = (e, t) => {
      if (wn(e) && (e = Nu(e, t), ir(e)))
        return e;
      if (Tn(e)) {
        At(e) && Pt(e) && (e = e.parentNode);
        let n = e.previousSibling;
        if (ir(n) || (n = e.nextSibling, ir(n)))
          return n;
      }
    }, _ = (e) => y(e.startContainer, e.startOffset) || y(e.endContainer, e.endOffset), T = (e, t, n) => {
      const r = n.getNode(), a = n.getRng();
      if (r.nodeName === "IMG" || ir(r)) {
        const d = r.nodeName;
        return {
          name: d,
          index: Lb(n.dom, d, r)
        };
      }
      const c = _(a);
      if (c) {
        const d = c.tagName;
        return {
          name: d,
          index: Lb(n.dom, d, c)
        };
      }
      return Ua(e, n, t, a);
    }, P = (e) => {
      const t = e.getRng();
      return {
        start: xd(e.dom.getRoot(), nt.fromRangeStart(t)),
        end: xd(e.dom.getRoot(), nt.fromRangeEnd(t)),
        forward: e.isForward()
      };
    }, I = (e) => ({
      rng: e.getRng(),
      forward: e.isForward()
    }), j = (e, t, n) => {
      const r = {
        "data-mce-type": "bookmark",
        id: t,
        style: "overflow:hidden;line-height:0px"
      };
      return n ? e.create("span", r, "&#xFEFF;") : e.create("span", r);
    }, Y = (e, t) => {
      const n = e.dom;
      let r = e.getRng();
      const a = n.uniqueId(), c = e.isCollapsed(), d = e.getNode(), h = d.nodeName, k = e.isForward();
      if (h === "IMG")
        return {
          name: h,
          index: Lb(n, h, d)
        };
      const D = p(r.cloneRange());
      if (!c) {
        D.collapse(!1);
        const U = j(n, a + "_end", t);
        Dg(n, D, U);
      }
      r = p(r), r.collapse(!0);
      const H = j(n, a + "_start", t);
      return Dg(n, r, H), e.moveToBookmark({
        id: a,
        keep: !0,
        forward: k
      }), {
        id: a,
        forward: k
      };
    }, ne = (e, t, n = !1) => t === 2 ? T(q, n, e) : t === 3 ? P(e) : t ? I(e) : Y(e, !1), ve = Tt(T, Bn, !0), Ce = (e) => {
      const t = (c) => c(e), n = dt(e), r = () => a, a = {
        tag: !0,
        inner: e,
        fold: (c, d) => d(e),
        isValue: Mo,
        isError: Pn,
        map: (c) => Ae.value(c(e)),
        mapError: r,
        bind: t,
        exists: t,
        forall: t,
        getOr: n,
        or: r,
        getOrThunk: n,
        orThunk: r,
        getOrDie: n,
        each: (c) => {
          c(e);
        },
        toOptional: () => K.some(e)
      };
      return a;
    }, ge = (e) => {
      const t = () => n, n = {
        tag: !1,
        inner: e,
        fold: (r, a) => r(e),
        isValue: Pn,
        isError: Mo,
        map: t,
        mapError: (r) => Ae.error(r(e)),
        bind: t,
        exists: Pn,
        forall: Mo,
        getOr: Bn,
        or: Bn,
        getOrThunk: tn,
        orThunk: tn,
        getOrDie: Ct(String(e)),
        each: ht,
        toOptional: K.none
      };
      return n;
    }, Ae = {
      value: Ce,
      error: ge,
      fromOption: (e, t) => e.fold(() => ge(t), Ce)
    }, $e = { generate: (e) => {
      if (!Se(e))
        throw new Error("cases must be an array");
      if (e.length === 0)
        throw new Error("there must be at least one case");
      const t = [], n = {};
      return ut(e, (r, a) => {
        const c = Nt(r);
        if (c.length !== 1)
          throw new Error("one and only one name per case");
        const d = c[0], h = r[d];
        if (n[d] !== void 0)
          throw new Error("duplicate key detected:" + d);
        if (d === "cata")
          throw new Error("cannot have a case named cata (sorry)");
        if (!Se(h))
          throw new Error("case arguments must be an array");
        t.push(d), n[d] = (...k) => {
          const D = k.length;
          if (D !== h.length)
            throw new Error("Wrong number of arguments to case " + d + ". Expected " + h.length + " (" + h + "), got " + D);
          return {
            fold: (...U) => {
              if (U.length !== e.length)
                throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + U.length);
              return U[a].apply(null, k);
            },
            match: (U) => {
              const G = Nt(U);
              if (t.length !== G.length)
                throw new Error("Wrong number of arguments to match. Expected: " + t.join(",") + `
Actual: ` + G.join(","));
              if (!Ns(t, (ye) => So(G, ye)))
                throw new Error("Not all branches were specified when using match. Specified: " + G.join(", ") + `
Required: ` + t.join(", "));
              return U[d].apply(null, k);
            },
            log: (U) => {
              console.log(U, {
                constructors: t,
                constructor: d,
                params: k
              });
            }
          };
        };
      }), n;
    } };
    $e.generate([
      {
        bothErrors: [
          "error1",
          "error2"
        ]
      },
      {
        firstError: [
          "error1",
          "value2"
        ]
      },
      {
        secondError: [
          "value1",
          "error2"
        ]
      },
      {
        bothValues: [
          "value1",
          "value2"
        ]
      }
    ]);
    const lt = (e) => {
      const t = [], n = [];
      return ut(e, (r) => {
        r.fold((a) => {
          t.push(a);
        }, (a) => {
          n.push(a);
        });
      }), {
        errors: t,
        values: n
      };
    }, pt = (e) => e.type === "inline-command" || e.type === "inline-format", Bt = (e) => e.type === "block-command" || e.type === "block-format", xt = (e) => {
      const t = (r) => Ae.error({
        message: r,
        pattern: e
      }), n = (r, a, c) => {
        if (e.format !== void 0) {
          let d;
          if (Se(e.format)) {
            if (!Ns(e.format, Ot))
              return t(r + " pattern has non-string items in the `format` array");
            d = e.format;
          } else if (Ot(e.format))
            d = [e.format];
          else
            return t(r + " pattern has non-string `format` parameter");
          return Ae.value(a(d));
        } else
          return e.cmd !== void 0 ? Ot(e.cmd) ? Ae.value(c(e.cmd, e.value)) : t(r + " pattern has non-string `cmd` parameter") : t(r + " pattern is missing both `format` and `cmd` parameters");
      };
      if (!Ee(e))
        return t("Raw pattern is not an object");
      if (!Ot(e.start))
        return t("Raw pattern is missing `start` parameter");
      if (e.end !== void 0) {
        if (!Ot(e.end))
          return t("Inline pattern has non-string `end` parameter");
        if (e.start.length === 0 && e.end.length === 0)
          return t("Inline pattern has empty `start` and `end` parameters");
        let r = e.start, a = e.end;
        return a.length === 0 && (a = r, r = ""), n("Inline", (c) => ({
          type: "inline-format",
          start: r,
          end: a,
          format: c
        }), (c, d) => ({
          type: "inline-command",
          start: r,
          end: a,
          cmd: c,
          value: d
        }));
      } else
        return e.replacement !== void 0 ? Ot(e.replacement) ? e.start.length === 0 ? t("Replacement pattern has empty `start` parameter") : Ae.value({
          type: "inline-command",
          start: "",
          end: e.start,
          cmd: "mceInsertContent",
          value: e.replacement
        }) : t("Replacement pattern has non-string `replacement` parameter") : e.start.length === 0 ? t("Block pattern has empty `start` parameter") : n("Block", (r) => ({
          type: "block-format",
          start: e.start,
          format: r[0]
        }), (r, a) => ({
          type: "block-command",
          start: e.start,
          cmd: r,
          value: a
        }));
    }, Lt = (e) => ct(e, Bt), Vt = (e) => ct(e, pt), rn = (e, t) => ({
      inlinePatterns: Vt(e),
      blockPatterns: Lt(e),
      dynamicPatternsLookup: t
    }), Vn = (e) => {
      const t = lt(oo(e, xt));
      return ut(t.errors, (n) => console.error(n.message, n.pattern)), t.values;
    }, Un = (e) => (t) => {
      const n = e(t);
      return Vn(n);
    }, Do = Zn().deviceType, Gn = Do.isTouch(), Ro = gs.DOM, xo = (e) => {
      const t = e.indexOf("=") > 0 ? e.split(/[;,](?![^=;,]*(?:[;,]|$))/) : e.split(",");
      return co(t, (n, r) => {
        const a = r.split("="), c = a[0], d = a.length > 1 ? a[1] : c;
        return n[Lc(c)] = Lc(d), n;
      }, {});
    }, zr = (e) => an(e, RegExp), Wt = (e) => (t) => t.options.get(e), Hi = (e) => Ot(e) || Ee(e), ja = (e, t = "") => (n) => {
      const r = Ot(n);
      if (r)
        if (n.indexOf("=") !== -1) {
          const a = xo(n);
          return {
            value: Hr(a, e.id).getOr(t),
            valid: r
          };
        } else
          return {
            value: n,
            valid: r
          };
      else
        return {
          valid: !1,
          message: "Must be a string."
        };
    }, ai = (e) => {
      const t = e.options.register;
      t("id", {
        processor: "string",
        default: e.id
      }), t("selector", { processor: "string" }), t("target", { processor: "object" }), t("suffix", { processor: "string" }), t("cache_suffix", { processor: "string" }), t("base_url", { processor: "string" }), t("referrer_policy", {
        processor: "string",
        default: ""
      }), t("language_load", {
        processor: "boolean",
        default: !0
      }), t("inline", {
        processor: "boolean",
        default: !1
      }), t("iframe_attrs", {
        processor: "object",
        default: {}
      }), t("doctype", {
        processor: "string",
        default: "<!DOCTYPE html>"
      }), t("document_base_url", {
        processor: "string",
        default: e.documentBaseUrl
      }), t("body_id", {
        processor: ja(e, "tinymce"),
        default: "tinymce"
      }), t("body_class", {
        processor: ja(e),
        default: ""
      }), t("content_security_policy", {
        processor: "string",
        default: ""
      }), t("br_in_pre", {
        processor: "boolean",
        default: !0
      }), t("forced_root_block", {
        processor: (n) => {
          const r = Ot(n) && Na(n);
          return r ? {
            value: n,
            valid: r
          } : {
            valid: !1,
            message: "Must be a non-empty string."
          };
        },
        default: "p"
      }), t("forced_root_block_attrs", {
        processor: "object",
        default: {}
      }), t("newline_behavior", {
        processor: (n) => {
          const r = So([
            "block",
            "linebreak",
            "invert",
            "default"
          ], n);
          return r ? {
            value: n,
            valid: r
          } : {
            valid: !1,
            message: "Must be one of: block, linebreak, invert or default."
          };
        },
        default: "default"
      }), t("br_newline_selector", {
        processor: "string",
        default: ".mce-toc h2,figcaption,caption"
      }), t("no_newline_selector", {
        processor: "string",
        default: ""
      }), t("keep_styles", {
        processor: "boolean",
        default: !0
      }), t("end_container_on_empty_block", {
        processor: (n) => Cn(n) ? {
          valid: !0,
          value: n
        } : Ot(n) ? {
          valid: !0,
          value: n
        } : {
          valid: !1,
          message: "Must be boolean or a string"
        },
        default: "blockquote"
      }), t("font_size_style_values", {
        processor: "string",
        default: "xx-small,x-small,small,medium,large,x-large,xx-large"
      }), t("font_size_legacy_values", {
        processor: "string",
        default: "xx-small,small,medium,large,x-large,xx-large,300%"
      }), t("font_size_classes", {
        processor: "string",
        default: ""
      }), t("automatic_uploads", {
        processor: "boolean",
        default: !0
      }), t("images_reuse_filename", {
        processor: "boolean",
        default: !1
      }), t("images_replace_blob_uris", {
        processor: "boolean",
        default: !0
      }), t("icons", {
        processor: "string",
        default: ""
      }), t("icons_url", {
        processor: "string",
        default: ""
      }), t("images_upload_url", {
        processor: "string",
        default: ""
      }), t("images_upload_base_path", {
        processor: "string",
        default: ""
      }), t("images_upload_credentials", {
        processor: "boolean",
        default: !1
      }), t("images_upload_handler", { processor: "function" }), t("language", {
        processor: "string",
        default: "en"
      }), t("language_url", {
        processor: "string",
        default: ""
      }), t("entity_encoding", {
        processor: "string",
        default: "named"
      }), t("indent", {
        processor: "boolean",
        default: !0
      }), t("indent_before", {
        processor: "string",
        default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
      }), t("indent_after", {
        processor: "string",
        default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
      }), t("indent_use_margin", {
        processor: "boolean",
        default: !1
      }), t("indentation", {
        processor: "string",
        default: "40px"
      }), t("content_css", {
        processor: (n) => {
          const r = n === !1 || Ot(n) || Et(n, Ot);
          return r ? Ot(n) ? {
            value: oo(n.split(","), Lc),
            valid: r
          } : Se(n) ? {
            value: n,
            valid: r
          } : n === !1 ? {
            value: [],
            valid: r
          } : {
            value: n,
            valid: r
          } : {
            valid: !1,
            message: "Must be false, a string or an array of strings."
          };
        },
        default: Ib(e) ? [] : ["default"]
      }), t("content_style", { processor: "string" }), t("content_css_cors", {
        processor: "boolean",
        default: !1
      }), t("font_css", {
        processor: (n) => {
          const r = Ot(n) || Et(n, Ot);
          return r ? {
            value: Se(n) ? n : oo(n.split(","), Lc),
            valid: r
          } : {
            valid: !1,
            message: "Must be a string or an array of strings."
          };
        },
        default: []
      }), t("inline_boundaries", {
        processor: "boolean",
        default: !0
      }), t("inline_boundaries_selector", {
        processor: "string",
        default: "a[href],code,span.mce-annotation"
      }), t("object_resizing", {
        processor: (n) => {
          const r = Cn(n) || Ot(n);
          return r ? n === !1 || Do.isiPhone() || Do.isiPad() ? {
            value: "",
            valid: r
          } : {
            value: n === !0 ? "table,img,figure.image,div,video,iframe" : n,
            valid: r
          } : {
            valid: !1,
            message: "Must be boolean or a string"
          };
        },
        default: !Gn
      }), t("resize_img_proportional", {
        processor: "boolean",
        default: !0
      }), t("event_root", { processor: "object" }), t("service_message", { processor: "string" }), t("theme", {
        processor: (n) => n === !1 || Ot(n) || un(n),
        default: "silver"
      }), t("theme_url", { processor: "string" }), t("formats", { processor: "object" }), t("format_empty_lines", {
        processor: "boolean",
        default: !1
      }), t("format_noneditable_selector", {
        processor: "string",
        default: ""
      }), t("preview_styles", {
        processor: (n) => {
          const r = n === !1 || Ot(n);
          return r ? {
            value: n === !1 ? "" : n,
            valid: r
          } : {
            valid: !1,
            message: "Must be false or a string"
          };
        },
        default: "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow"
      }), t("custom_ui_selector", {
        processor: "string",
        default: ""
      }), t("hidden_input", {
        processor: "boolean",
        default: !0
      }), t("submit_patch", {
        processor: "boolean",
        default: !0
      }), t("encoding", { processor: "string" }), t("add_form_submit_trigger", {
        processor: "boolean",
        default: !0
      }), t("add_unload_trigger", {
        processor: "boolean",
        default: !0
      }), t("custom_undo_redo_levels", {
        processor: "number",
        default: 0
      }), t("disable_nodechange", {
        processor: "boolean",
        default: !1
      }), t("readonly", {
        processor: "boolean",
        default: !1
      }), t("editable_root", {
        processor: "boolean",
        default: !0
      }), t("plugins", {
        processor: "string[]",
        default: []
      }), t("external_plugins", { processor: "object" }), t("forced_plugins", { processor: "string[]" }), t("model", {
        processor: "string",
        default: e.hasPlugin("rtc") ? "plugin" : "dom"
      }), t("model_url", { processor: "string" }), t("block_unsupported_drop", {
        processor: "boolean",
        default: !0
      }), t("visual", {
        processor: "boolean",
        default: !0
      }), t("visual_table_class", {
        processor: "string",
        default: "mce-item-table"
      }), t("visual_anchor_class", {
        processor: "string",
        default: "mce-item-anchor"
      }), t("iframe_aria_text", {
        processor: "string",
        default: "Rich Text Area. Press ALT-0 for help."
      }), t("setup", { processor: "function" }), t("init_instance_callback", { processor: "function" }), t("url_converter", {
        processor: "function",
        default: e.convertURL
      }), t("url_converter_scope", {
        processor: "object",
        default: e
      }), t("urlconverter_callback", { processor: "function" }), t("allow_conditional_comments", {
        processor: "boolean",
        default: !1
      }), t("allow_html_data_urls", {
        processor: "boolean",
        default: !1
      }), t("allow_svg_data_urls", { processor: "boolean" }), t("allow_html_in_named_anchor", {
        processor: "boolean",
        default: !1
      }), t("allow_script_urls", {
        processor: "boolean",
        default: !1
      }), t("allow_unsafe_link_target", {
        processor: "boolean",
        default: !1
      }), t("convert_fonts_to_spans", {
        processor: "boolean",
        default: !0,
        deprecated: !0
      }), t("fix_list_elements", {
        processor: "boolean",
        default: !1
      }), t("preserve_cdata", {
        processor: "boolean",
        default: !1
      }), t("remove_trailing_brs", {
        processor: "boolean",
        default: !0
      }), t("pad_empty_with_br", {
        processor: "boolean",
        default: !1
      }), t("inline_styles", {
        processor: "boolean",
        default: !0,
        deprecated: !0
      }), t("element_format", {
        processor: "string",
        default: "html"
      }), t("entities", { processor: "string" }), t("schema", {
        processor: "string",
        default: "html5"
      }), t("convert_urls", {
        processor: "boolean",
        default: !0
      }), t("relative_urls", {
        processor: "boolean",
        default: !0
      }), t("remove_script_host", {
        processor: "boolean",
        default: !0
      }), t("custom_elements", { processor: "string" }), t("extended_valid_elements", { processor: "string" }), t("invalid_elements", { processor: "string" }), t("invalid_styles", { processor: Hi }), t("valid_children", { processor: "string" }), t("valid_classes", { processor: Hi }), t("valid_elements", { processor: "string" }), t("valid_styles", { processor: Hi }), t("verify_html", {
        processor: "boolean",
        default: !0
      }), t("auto_focus", { processor: (n) => Ot(n) || n === !0 }), t("browser_spellcheck", {
        processor: "boolean",
        default: !1
      }), t("protect", { processor: "array" }), t("images_file_types", {
        processor: "string",
        default: "jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp"
      }), t("deprecation_warnings", {
        processor: "boolean",
        default: !0
      }), t("a11y_advanced_options", {
        processor: "boolean",
        default: !1
      }), t("api_key", { processor: "string" }), t("paste_block_drop", {
        processor: "boolean",
        default: !1
      }), t("paste_data_images", {
        processor: "boolean",
        default: !0
      }), t("paste_preprocess", { processor: "function" }), t("paste_postprocess", { processor: "function" }), t("paste_webkit_styles", {
        processor: "string",
        default: "none"
      }), t("paste_remove_styles_if_webkit", {
        processor: "boolean",
        default: !0
      }), t("paste_merge_formats", {
        processor: "boolean",
        default: !0
      }), t("smart_paste", {
        processor: "boolean",
        default: !0
      }), t("paste_as_text", {
        processor: "boolean",
        default: !1
      }), t("paste_tab_spaces", {
        processor: "number",
        default: 4
      }), t("text_patterns", {
        processor: (n) => Et(n, Ee) || n === !1 ? {
          value: Vn(n === !1 ? [] : n),
          valid: !0
        } : {
          valid: !1,
          message: "Must be an array of objects or false."
        },
        default: [
          {
            start: "*",
            end: "*",
            format: "italic"
          },
          {
            start: "**",
            end: "**",
            format: "bold"
          },
          {
            start: "#",
            format: "h1"
          },
          {
            start: "##",
            format: "h2"
          },
          {
            start: "###",
            format: "h3"
          },
          {
            start: "####",
            format: "h4"
          },
          {
            start: "#####",
            format: "h5"
          },
          {
            start: "######",
            format: "h6"
          },
          {
            start: "1. ",
            cmd: "InsertOrderedList"
          },
          {
            start: "* ",
            cmd: "InsertUnorderedList"
          },
          {
            start: "- ",
            cmd: "InsertUnorderedList"
          }
        ]
      }), t("text_patterns_lookup", {
        processor: (n) => un(n) ? {
          value: Un(n),
          valid: !0
        } : {
          valid: !1,
          message: "Must be a single function"
        },
        default: (n) => []
      }), t("noneditable_class", {
        processor: "string",
        default: "mceNonEditable"
      }), t("editable_class", {
        processor: "string",
        default: "mceEditable"
      }), t("noneditable_regexp", {
        processor: (n) => Et(n, zr) ? {
          value: n,
          valid: !0
        } : zr(n) ? {
          value: [n],
          valid: !0
        } : {
          valid: !1,
          message: "Must be a RegExp or an array of RegExp."
        },
        default: []
      }), t("table_tab_navigation", {
        processor: "boolean",
        default: !0
      }), t("highlight_on_focus", {
        processor: "boolean",
        default: !1
      }), t("xss_sanitization", {
        processor: "boolean",
        default: !0
      }), t("details_initial_state", {
        processor: (n) => {
          const r = So([
            "inherited",
            "collapsed",
            "expanded"
          ], n);
          return r ? {
            value: n,
            valid: r
          } : {
            valid: !1,
            message: "Must be one of: inherited, collapsed, or expanded."
          };
        },
        default: "inherited"
      }), t("details_serialized_state", {
        processor: (n) => {
          const r = So([
            "inherited",
            "collapsed",
            "expanded"
          ], n);
          return r ? {
            value: n,
            valid: r
          } : {
            valid: !1,
            message: "Must be one of: inherited, collapsed, or expanded."
          };
        },
        default: "inherited"
      }), t("init_content_sync", {
        processor: "boolean",
        default: !1
      }), t("newdocument_content", {
        processor: "string",
        default: ""
      }), t("force_hex_color", {
        processor: (n) => {
          const r = [
            "always",
            "rgb_only",
            "off"
          ], a = So(r, n);
          return a ? {
            value: n,
            valid: a
          } : {
            valid: !1,
            message: `Must be one of: ${r.join(", ")}.`
          };
        },
        default: "off"
      }), t("sandbox_iframes", {
        processor: "boolean",
        default: !1
      }), t("convert_unsafe_embeds", {
        processor: "boolean",
        default: !1
      }), e.on("ScriptsLoaded", () => {
        t("directionality", {
          processor: "string",
          default: Rc.isRtl() ? "rtl" : void 0
        }), t("placeholder", {
          processor: "string",
          default: Ro.getAttrib(e.getElement(), "placeholder")
        });
      });
    }, Dn = Wt("iframe_attrs"), ii = Wt("doctype"), yl = Wt("document_base_url"), Ng = Wt("body_id"), Ah = Wt("body_class"), hs = Wt("content_security_policy"), Dh = Wt("br_in_pre"), li = Wt("forced_root_block"), Mg = Wt("forced_root_block_attrs"), Ew = Wt("newline_behavior"), Sv = Wt("br_newline_selector"), Tw = Wt("no_newline_selector"), J2 = Wt("keep_styles"), Q2 = Wt("end_container_on_empty_block"), Bu = Wt("automatic_uploads"), hc = Wt("images_reuse_filename"), Pb = Wt("images_replace_blob_uris"), zw = Wt("icons"), eC = Wt("icons_url"), rr = Wt("images_upload_url"), tC = Wt("images_upload_base_path"), Ow = Wt("images_upload_credentials"), t1 = Wt("images_upload_handler"), nC = Wt("content_css_cors"), n1 = Wt("referrer_policy"), Aw = Wt("language"), oC = Wt("language_url"), o0 = Wt("indent_use_margin"), Yl = Wt("indentation"), Lu = Wt("content_css"), rC = Wt("content_style"), Dw = Wt("font_css"), sC = Wt("directionality"), Xn = Wt("inline_boundaries_selector"), Ev = Wt("object_resizing"), o1 = Wt("resize_img_proportional"), Tv = Wt("placeholder"), r0 = Wt("event_root"), Rw = Wt("service_message"), Rh = Wt("theme"), Nw = Wt("theme_url"), s0 = Wt("model"), Mw = Wt("model_url"), mr = Wt("inline_boundaries"), aC = Wt("formats"), Vp = Wt("preview_styles"), lp = Wt("format_empty_lines"), Up = Wt("format_noneditable_selector"), Pu = Wt("custom_ui_selector"), Ib = Wt("inline"), r1 = Wt("hidden_input"), a0 = Wt("submit_patch"), Fb = Wt("add_form_submit_trigger"), Bw = Wt("add_unload_trigger"), Lw = Wt("custom_undo_redo_levels"), iC = Wt("disable_nodechange"), Pw = Wt("readonly"), lr = Wt("editable_root"), $f = Wt("content_css_cors"), cp = Wt("plugins"), lC = Wt("external_plugins"), s1 = Wt("block_unsupported_drop"), gr = Wt("visual"), Iw = Wt("visual_table_class"), i0 = Wt("visual_anchor_class"), cC = Wt("iframe_aria_text"), $b = Wt("setup"), Nh = Wt("init_instance_callback"), Fw = Wt("urlconverter_callback"), uC = Wt("auto_focus"), dC = Wt("browser_spellcheck"), a1 = Wt("protect"), Hb = Wt("paste_block_drop"), l0 = Wt("paste_data_images"), $w = Wt("paste_preprocess"), fC = Wt("paste_postprocess"), Hw = Wt("newdocument_content"), mC = Wt("paste_webkit_styles"), Vw = Wt("paste_remove_styles_if_webkit"), zv = Wt("paste_merge_formats"), i1 = Wt("smart_paste"), c0 = Wt("paste_as_text"), Ov = Wt("paste_tab_spaces"), Uw = Wt("allow_html_data_urls"), jw = Wt("text_patterns"), u0 = Wt("text_patterns_lookup"), l1 = Wt("noneditable_class"), Zw = Wt("editable_class"), Ww = Wt("noneditable_regexp"), qw = Wt("preserve_cdata"), Iu = Wt("highlight_on_focus"), Vb = Wt("xss_sanitization"), pC = Wt("init_content_sync"), gC = (e) => e.options.isSet("text_patterns_lookup"), d0 = (e) => Ht.explode(e.options.get("font_size_style_values")), Gw = (e) => Ht.explode(e.options.get("font_size_classes")), f0 = (e) => e.options.get("encoding") === "xml", Av = (e) => Ht.explode(e.options.get("images_file_types")), Dv = Wt("table_tab_navigation"), hC = Wt("details_initial_state"), bC = Wt("details_serialized_state"), yC = Wt("force_hex_color"), Rv = Wt("sandbox_iframes"), Nv = wn, Mv = At, c1 = (e) => {
      const t = e.parentNode;
      t && t.removeChild(e);
    }, Kw = (e) => {
      const t = q(e);
      return {
        count: e.length - t.length,
        text: t
      };
    }, Ub = (e) => {
      let t;
      for (; (t = e.data.lastIndexOf(C)) !== -1; )
        e.deleteData(t, 1);
    }, m0 = (e, t) => (up(e), t), Yw = (e, t) => {
      const n = Kw(e.data.substr(0, t.offset())), r = Kw(e.data.substr(t.offset()));
      return (n.text + r.text).length > 0 ? (Ub(e), nt(e, t.offset() - n.count)) : t;
    }, Xw = (e, t) => {
      const n = t.container(), r = nc(_n(n.childNodes), e).map((a) => a < t.offset() ? nt(n, t.offset() - 1) : t).getOr(t);
      return up(e), r;
    }, Jw = (e, t) => Mv(e) && t.container() === e ? Yw(e, t) : m0(e, t), vC = (e, t) => t.container() === e.parentNode ? Xw(e, t) : m0(e, t), xC = (e, t) => nt.isTextPosition(t) ? Jw(e, t) : vC(e, t), up = (e) => {
      Nv(e) && Tn(e) && (uo(e) ? e.removeAttribute("data-mce-caret") : c1(e)), Mv(e) && (Ub(e), e.data.length === 0 && c1(e));
    }, Qw = Kr, ek = pn, tk = Sf, nk = "*[contentEditable=false],video,audio,embed,object", ok = (e, t, n) => {
      const r = np(t.getBoundingClientRect(), n);
      let a, c;
      if (e.tagName === "BODY") {
        const h = e.ownerDocument.documentElement;
        a = e.scrollLeft || h.scrollLeft, c = e.scrollTop || h.scrollTop;
      } else {
        const h = e.getBoundingClientRect();
        a = e.scrollLeft - h.left, c = e.scrollTop - h.top;
      }
      r.left += a, r.right += a, r.top += c, r.bottom += c, r.width = 1;
      let d = t.offsetWidth - t.clientWidth;
      return d > 0 && (n && (d *= -1), r.left += d, r.right += d), r;
    }, wC = (e) => {
      var t, n;
      const r = Ni(be.fromDom(e), nk);
      for (let a = 0; a < r.length; a++) {
        const c = r[a].dom;
        let d = c.previousSibling;
        if (Xa(d)) {
          const h = d.data;
          h.length === 1 ? (t = d.parentNode) === null || t === void 0 || t.removeChild(d) : d.deleteData(h.length - 1, 1);
        }
        d = c.nextSibling, Ha(d) && (d.data.length === 1 ? (n = d.parentNode) === null || n === void 0 || n.removeChild(d) : d.deleteData(0, 1));
      }
    }, p0 = (e, t, n, r) => {
      const a = sf();
      let c, d;
      const h = li(e), k = e.dom, D = (ae, xe) => {
        let Ne;
        if (H(), tk(xe))
          return null;
        if (n(xe)) {
          const Ie = as(h, xe, ae), Fe = ok(t, xe, ae);
          k.setStyle(Ie, "top", Fe.top), d = Ie;
          const je = k.create("div", {
            class: "mce-visual-caret",
            "data-mce-bogus": "all"
          });
          k.setStyles(je, { ...Fe }), k.add(t, je), a.set({
            caret: je,
            element: xe,
            before: ae
          }), ae && k.addClass(je, "mce-visual-caret-before"), U(), Ne = xe.ownerDocument.createRange(), Ne.setStart(Ie, 0), Ne.setEnd(Ie, 0);
        } else
          return d = ks(xe, ae), Ne = xe.ownerDocument.createRange(), jb(d.nextSibling) ? (Ne.setStart(d, 0), Ne.setEnd(d, 0)) : (Ne.setStart(d, 1), Ne.setEnd(d, 1)), Ne;
        return Ne;
      }, H = () => {
        wC(t), d && (up(d), d = null), a.on((ae) => {
          k.remove(ae.caret), a.clear();
        }), c && (clearInterval(c), c = void 0);
      }, U = () => {
        c = setInterval(() => {
          a.on((ae) => {
            r() ? k.toggleClass(ae.caret, "mce-visual-caret-hidden") : k.addClass(ae.caret, "mce-visual-caret-hidden");
          });
        }, 500);
      };
      return {
        show: D,
        hide: H,
        getCss: () => ".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}",
        reposition: () => {
          a.on((ae) => {
            const xe = ok(t, ae.element, ae.before);
            k.setStyles(ae.caret, { ...xe });
          });
        },
        destroy: () => clearInterval(c)
      };
    }, Bv = () => nr.browser.isFirefox(), jb = (e) => Qw(e) || ek(e), u1 = (e) => (jb(e) || Cu(e) && Bv()) && Lr(be.fromDom(e)).exists(Ka), kC = cc, Lv = Kr, _C = pn, rk = Zd("display", "block table table-cell table-caption list-item"), sk = Tn, u = Pt, g = wn, S = At, V = Sr, Q = (e) => e > 0, we = (e) => e < 0, Be = (e, t) => {
      let n;
      for (; n = e(t); )
        if (!u(n))
          return n;
      return null;
    }, Ve = (e, t, n, r, a) => {
      const c = new vi(e, r), d = Lv(e) || u(e);
      let h;
      if (we(t)) {
        if (d && (h = Be(c.prev.bind(c), !0), n(h)))
          return h;
        for (; h = Be(c.prev.bind(c), a); )
          if (n(h))
            return h;
      }
      if (Q(t)) {
        if (d && (h = Be(c.next.bind(c), !0), n(h)))
          return h;
        for (; h = Be(c.next.bind(c), a); )
          if (n(h))
            return h;
      }
      return null;
    }, ot = (e, t) => {
      const n = (a) => kC(a.dom), r = (a) => a.dom === t;
      return si(be.fromDom(e), n, r).map((a) => a.dom).getOr(t);
    }, Yt = (e, t) => {
      for (; e && e !== t; ) {
        if (rk(e))
          return e;
        e = e.parentNode;
      }
      return null;
    }, Kt = (e, t, n) => Yt(e.container(), n) === Yt(t.container(), n), dn = (e, t) => {
      if (!t)
        return K.none();
      const n = t.container(), r = t.offset();
      return g(n) ? K.from(n.childNodes[r + e]) : K.none();
    }, Kn = (e, t) => {
      var n;
      const a = ((n = t.ownerDocument) !== null && n !== void 0 ? n : document).createRange();
      return e ? (a.setStartBefore(t), a.setEndBefore(t)) : (a.setStartAfter(t), a.setEndAfter(t)), a;
    }, No = (e, t, n) => Yt(t, e) === Yt(n, e), sr = (e, t, n) => {
      const r = e ? "previousSibling" : "nextSibling";
      let a = n;
      for (; a && a !== t; ) {
        let c = a[r];
        if (c && sk(c) && (c = c[r]), Lv(c) || _C(c)) {
          if (No(t, c, a))
            return c;
          break;
        }
        if (V(c))
          break;
        a = a.parentNode;
      }
      return null;
    }, Or = Tt(Kn, !0), Wo = Tt(Kn, !1), Jt = (e, t, n) => {
      let r;
      const a = Tt(sr, !0, t), c = Tt(sr, !1, t), d = n.startContainer, h = n.startOffset;
      if (Pt(d)) {
        const k = S(d) ? d.parentNode : d, D = k.getAttribute("data-mce-caret");
        if (D === "before" && (r = k.nextSibling, u1(r)))
          return Or(r);
        if (D === "after" && (r = k.previousSibling, u1(r)))
          return Wo(r);
      }
      if (!n.collapsed)
        return n;
      if (At(d)) {
        if (sk(d)) {
          if (e === 1) {
            if (r = c(d), r)
              return Or(r);
            if (r = a(d), r)
              return Wo(r);
          }
          if (e === -1) {
            if (r = a(d), r)
              return Wo(r);
            if (r = c(d), r)
              return Or(r);
          }
          return n;
        }
        if (Xa(d) && h >= d.data.length - 1)
          return e === 1 && (r = c(d), r) ? Or(r) : n;
        if (Ha(d) && h <= 1)
          return e === -1 && (r = a(d), r) ? Wo(r) : n;
        if (h === d.data.length)
          return r = c(d), r ? Or(r) : n;
        if (h === 0)
          return r = a(d), r ? Wo(r) : n;
      }
      return n;
    }, bs = (e, t) => dn(e ? 0 : -1, t).filter(Lv), Nc = (e, t, n) => {
      const r = Jt(e, t, n);
      return e === -1 ? nt.fromRangeStart(r) : nt.fromRangeEnd(r);
    }, Mc = (e) => K.from(e.getNode()).map(be.fromDom), Fu = (e) => K.from(e.getNode(!0)).map(be.fromDom), al = (e, t) => {
      let n = t;
      for (; n = e(n); )
        if (n.isVisible())
          return n;
      return n;
    }, Wc = (e, t) => {
      const n = Kt(e, t);
      return !n && cs(e.getNode()) ? !0 : n;
    };
    var _a;
    (function(e) {
      e[e.Backwards = -1] = "Backwards", e[e.Forwards = 1] = "Forwards";
    })(_a || (_a = {}));
    const ak = Kr, Jn = At, wo = wn, ik = cs, g0 = Sr, kT = _s, lk = nl, io = (e, t) => {
      const n = [];
      let r = e;
      for (; r && r !== t; )
        n.push(r), r = r.parentNode;
      return n;
    }, h0 = (e, t) => e.hasChildNodes() && t < e.childNodes.length ? e.childNodes[t] : null, CC = (e, t) => {
      if (Q(e)) {
        if (g0(t.previousSibling) && !Jn(t.previousSibling))
          return nt.before(t);
        if (Jn(t))
          return nt(t, 0);
      }
      if (we(e)) {
        if (g0(t.nextSibling) && !Jn(t.nextSibling))
          return nt.after(t);
        if (Jn(t))
          return nt(t, t.data.length);
      }
      return we(e) ? ik(t) ? nt.before(t) : nt.after(t) : nt.before(t);
    }, _T = (e, t) => {
      const n = t.nextSibling;
      return n && g0(n) ? Jn(n) ? nt(n, 0) : nt.before(n) : SC(_a.Forwards, nt.after(t), e);
    }, SC = (e, t, n) => {
      let r, a, c, d;
      if (!wo(n) || !t)
        return null;
      if (t.isEqual(nt.after(n)) && n.lastChild) {
        if (d = nt.after(n.lastChild), we(e) && g0(n.lastChild) && wo(n.lastChild))
          return ik(n.lastChild) ? nt.before(n.lastChild) : d;
      } else
        d = t;
      const h = d.container();
      let k = d.offset();
      if (Jn(h)) {
        if (we(e) && k > 0)
          return nt(h, --k);
        if (Q(e) && k < h.length)
          return nt(h, ++k);
        r = h;
      } else {
        if (we(e) && k > 0 && (a = h0(h, k - 1), g0(a)))
          return !kT(a) && (c = Ve(a, e, lk, a), c) ? Jn(c) ? nt(c, c.data.length) : nt.after(c) : Jn(a) ? nt(a, a.data.length) : nt.before(a);
        if (Q(e) && k < h.childNodes.length && (a = h0(h, k), g0(a)))
          return ik(a) ? _T(n, a) : !kT(a) && (c = Ve(a, e, lk, a), c) ? Jn(c) ? nt(c, 0) : nt.before(c) : Jn(a) ? nt(a, 0) : nt.after(a);
        r = a || d.getNode();
      }
      if (r && (Q(e) && d.isAtEnd() || we(e) && d.isAtStart()) && (r = Ve(r, e, Mo, n, !0), lk(r, n)))
        return CC(e, r);
      a = r && Ve(r, e, lk, n);
      const D = ra(ct(io(h, n), ak));
      return D && (!a || !D.contains(a)) ? (Q(e) ? d = nt.after(D) : d = nt.before(D), d) : a ? CC(e, a) : null;
    }, Bg = (e) => ({
      next: (t) => SC(_a.Forwards, t, e),
      prev: (t) => SC(_a.Backwards, t, e)
    }), CT = (e, t, n) => {
      const r = e ? nt.before(n) : nt.after(n);
      return Hf(e, t, r);
    }, U5 = (e) => cs(e) ? nt.before(e) : nt.after(e), Lo = (e) => nt.isTextPosition(e) ? e.offset() === 0 : Sr(e.getNode()), EC = (e) => {
      if (nt.isTextPosition(e)) {
        const t = e.container();
        return e.offset() === t.data.length;
      } else
        return Sr(e.getNode(!0));
    }, Pv = (e, t) => !nt.isTextPosition(e) && !nt.isTextPosition(t) && e.getNode() === t.getNode(!0), ST = (e) => !nt.isTextPosition(e) && cs(e.getNode()), ET = (e, t, n) => e ? !Pv(t, n) && !ST(t) && EC(t) && Lo(n) : !Pv(n, t) && Lo(t) && EC(n), Hf = (e, t, n) => {
      const r = Bg(t);
      return K.from(e ? r.next(n) : r.prev(n));
    }, d1 = (e, t, n) => Hf(e, t, n).bind((r) => Kt(n, r, t) && ET(e, n, r) ? Hf(e, t, r) : K.some(r)), TC = (e, t, n, r) => d1(e, t, n).bind((a) => r(a) ? TC(e, t, a, r) : K.some(a)), f1 = (e, t) => {
      const n = e ? t.firstChild : t.lastChild;
      return At(n) ? K.some(nt(n, e ? 0 : n.data.length)) : n ? Sr(n) ? K.some(e ? nt.before(n) : U5(n)) : CT(e, t, n) : K.none();
    }, kd = Tt(Hf, !0), cf = Tt(Hf, !1), lu = Tt(f1, !0), dp = Tt(f1, !1), zC = "_mce_caret", uf = (e) => wn(e) && e.id === zC, Mh = (e, t) => {
      let n = t;
      for (; n && n !== e; ) {
        if (uf(n))
          return n;
        n = n.parentNode;
      }
      return null;
    }, j5 = (e) => Ot(e.start), Z5 = (e) => Yn(e, "rng"), W5 = (e) => Yn(e, "id"), TT = (e) => Yn(e, "name"), OC = (e) => Ht.isArray(e.start), Lg = (e) => !TT(e) && Cn(e.forward) ? e.forward : !0, AC = (e, t) => (wn(t) && e.isBlock(t) && !t.innerHTML && (t.innerHTML = '<br data-mce-bogus="1" />'), t), zT = (e, t) => {
      const n = K.from(pa(e.getRoot(), t.start)), r = K.from(pa(e.getRoot(), t.end));
      return ns(n, r, (a, c) => {
        const d = e.createRng();
        return d.setStart(a.container(), a.offset()), d.setEnd(c.container(), c.offset()), {
          range: d,
          forward: Lg(t)
        };
      });
    }, q5 = (e, t) => {
      var n;
      const a = ((n = e.ownerDocument) !== null && n !== void 0 ? n : document).createTextNode(C);
      e.appendChild(a), t.setStart(a, 0), t.setEnd(a, 0);
    }, G5 = (e) => !e.hasChildNodes(), OT = (e, t) => dp(e).fold(Pn, (n) => (t.setStart(n.container(), n.offset()), t.setEnd(n.container(), n.offset()), !0)), DC = (e, t, n) => G5(t) && Mh(e, t) ? (q5(t, n), !0) : !1, cu = (e, t, n, r) => {
      const a = n[t ? "start" : "end"], c = e.getRoot();
      if (a) {
        let d = c, h = a[0];
        for (let k = a.length - 1; d && k >= 1; k--) {
          const D = d.childNodes;
          if (DC(c, d, r))
            return !0;
          if (a[k] > D.length - 1)
            return DC(c, d, r) ? !0 : OT(d, r);
          d = D[a[k]];
        }
        At(d) && (h = Math.min(a[0], d.data.length)), wn(d) && (h = Math.min(a[0], d.childNodes.length)), t ? r.setStart(d, h) : r.setEnd(d, h);
      }
      return !0;
    }, RC = (e) => At(e) && e.data.length > 0, Zb = (e, t, n) => {
      const r = e.get(n.id + "_" + t), a = r == null ? void 0 : r.parentNode, c = n.keep;
      if (r && a) {
        let d, h;
        if (t === "start" ? c ? r.hasChildNodes() ? (d = r.firstChild, h = 1) : RC(r.nextSibling) ? (d = r.nextSibling, h = 0) : RC(r.previousSibling) ? (d = r.previousSibling, h = r.previousSibling.data.length) : (d = a, h = e.nodeIndex(r) + 1) : (d = a, h = e.nodeIndex(r)) : c ? r.hasChildNodes() ? (d = r.firstChild, h = 1) : RC(r.previousSibling) ? (d = r.previousSibling, h = r.previousSibling.data.length) : (d = a, h = e.nodeIndex(r)) : (d = a, h = e.nodeIndex(r)), !c) {
          const k = r.previousSibling, D = r.nextSibling;
          Ht.each(Ht.grep(r.childNodes), (U) => {
            At(U) && (U.data = U.data.replace(/\uFEFF/g, ""));
          });
          let H;
          for (; H = e.get(n.id + "_" + t); )
            e.remove(H, !0);
          if (At(D) && At(k) && !nr.browser.isOpera()) {
            const U = k.data.length;
            k.appendData(D.data), e.remove(D), d = k, h = U;
          }
        }
        return K.some(nt(d, h));
      } else
        return K.none();
    }, Oa = (e, t) => {
      const n = e.createRng();
      return cu(e, !0, t, n) && cu(e, !1, t, n) ? K.some({
        range: n,
        forward: Lg(t)
      }) : K.none();
    }, ck = (e, t) => {
      const n = Zb(e, "start", t), r = Zb(e, "end", t);
      return ns(n, r.or(n), (a, c) => {
        const d = e.createRng();
        return d.setStart(AC(e, a.container()), a.offset()), d.setEnd(AC(e, c.container()), c.offset()), {
          range: d,
          forward: Lg(t)
        };
      });
    }, bc = (e, t) => K.from(e.select(t.name)[t.index]).map((n) => {
      const r = e.createRng();
      return r.selectNode(n), {
        range: r,
        forward: !0
      };
    }), Bh = (e, t) => {
      const n = e.dom;
      if (t) {
        if (OC(t))
          return Oa(n, t);
        if (j5(t))
          return zT(n, t);
        if (W5(t))
          return ck(n, t);
        if (TT(t))
          return bc(n, t);
        if (Z5(t))
          return K.some({
            range: t.rng,
            forward: Lg(t)
          });
      }
      return K.none();
    }, Ur = (e, t, n) => ne(e, t, n), AT = (e, t) => {
      Bh(e, t).each(({ range: n, forward: r }) => {
        e.setRng(n, r);
      });
    }, Vf = (e) => wn(e) && e.tagName === "SPAN" && e.getAttribute("data-mce-type") === "bookmark", uk = ((e) => (t) => e === t)(Bo), b0 = (e) => e !== "" && ` \f
\r	\v`.indexOf(e) !== -1, $u = (e) => !b0(e) && !uk(e) && !$a(e), Uf = (e) => {
      const t = [];
      if (e)
        for (let n = 0; n < e.rangeCount; n++)
          t.push(e.getRangeAt(n));
      return t;
    }, DT = (e) => ho(e, (t) => {
      const n = lf(t);
      return n ? [be.fromDom(n)] : [];
    }), NC = (e) => Uf(e).length > 1, MC = (e) => ct(DT(e), Tf), dk = (e) => Ni(e, "td[data-mce-selected],th[data-mce-selected]"), BC = (e, t) => {
      const n = dk(t);
      return n.length > 0 ? n : MC(e);
    }, Pg = (e) => BC(Uf(e.selection.getSel()), be.fromDom(e.getBody())), Wb = (e, t) => Pa(e, "table", t), LC = (e) => {
      const t = e.startContainer, n = e.startOffset;
      return At(t) ? n === 0 ? K.some(be.fromDom(t)) : K.none() : K.from(t.childNodes[n]).map(be.fromDom);
    }, RT = (e) => {
      const t = e.endContainer, n = e.endOffset;
      return At(t) ? n === t.data.length ? K.some(be.fromDom(t)) : K.none() : K.from(t.childNodes[n - 1]).map(be.fromDom);
    }, y0 = (e) => qr(e).fold(dt([e]), (t) => [e].concat(y0(t))), PC = (e) => xa(e).fold(dt([e]), (t) => Eo(t) === "br" ? Ps(t).map((n) => [e].concat(PC(n))).getOr([]) : [e].concat(PC(t))), IC = (e, t) => ns(LC(t), RT(t), (n, r) => {
      const a = po(y0(e), Tt(Le, n)), c = po(PC(e), Tt(Le, r));
      return a.isSome() && c.isSome();
    }).getOr(!1), Em = (e, t, n, r) => {
      const a = n, c = new vi(n, a), d = _l(e.schema.getMoveCaretBeforeOnEnterElements(), (k, D) => !So([
        "td",
        "th",
        "table"
      ], D.toLowerCase()));
      let h = n;
      do {
        if (At(h) && Ht.trim(h.data).length !== 0) {
          r ? t.setStart(h, 0) : t.setEnd(h, h.data.length);
          return;
        }
        if (d[h.nodeName]) {
          r ? t.setStartBefore(h) : h.nodeName === "BR" ? t.setEndBefore(h) : t.setEndAfter(h);
          return;
        }
      } while (h = r ? c.next() : c.prev());
      a.nodeName === "BODY" && (r ? t.setStart(a, 0) : t.setEnd(a, a.childNodes.length));
    }, uu = (e) => {
      const t = e.selection.getSel();
      return Xe(t) && t.rangeCount > 0;
    }, m1 = (e, t) => {
      const n = Pg(e);
      n.length > 0 ? ut(n, (r) => {
        const a = r.dom, c = e.dom.createRng();
        c.setStartBefore(a), c.setEndAfter(a), t(c, !0);
      }) : t(e.selection.getRng(), !1);
    }, FC = (e, t, n) => {
      const r = Y(e, t);
      n(r), e.moveToBookmark(r);
    }, Hu = (e) => M(e == null ? void 0 : e.nodeType), ys = (e) => wn(e) && !Vf(e) && !uf(e) && !ru(e), K5 = (e, t) => {
      if (ys(t) && !/^(TD|TH)$/.test(t.nodeName)) {
        const n = e.getAttrib(t, "data-mce-selected"), r = parseInt(n, 10);
        return !isNaN(r) && r > 0;
      } else
        return !1;
    }, qb = (e, t, n) => {
      const { selection: r, dom: a } = e, c = r.getNode(), d = Kr(c);
      FC(r, !0, () => {
        t();
      }), d && Kr(c) && a.isChildOf(c, e.getBody()) ? e.selection.select(c) : n(r.getStart()) && Iv(a, r);
    }, Iv = (e, t) => {
      var n, r;
      const a = t.getRng(), { startContainer: c, startOffset: d } = a, h = t.getNode();
      if (!K5(e, h) && wn(c)) {
        const k = c.childNodes, D = e.getRoot();
        let H;
        if (d < k.length) {
          const U = k[d];
          H = new vi(U, (n = e.getParent(U, e.isBlock)) !== null && n !== void 0 ? n : D);
        } else {
          const U = k[k.length - 1];
          H = new vi(U, (r = e.getParent(U, e.isBlock)) !== null && r !== void 0 ? r : D), H.next(!0);
        }
        for (let U = H.current(); U; U = H.next()) {
          if (e.getContentEditable(U) === "false")
            return;
          if (At(U) && !HC(U)) {
            a.setStart(U, 0), t.setRng(a);
            return;
          }
        }
      }
    }, $C = (e, t, n) => {
      if (e) {
        const r = t ? "nextSibling" : "previousSibling";
        for (e = n ? e : e[r]; e; e = e[r])
          if (wn(e) || !HC(e))
            return e;
      }
    }, Fv = (e, t) => !!e.getTextBlockElements()[t.nodeName.toLowerCase()] || ef(e, t), Gb = (e, t, n) => e.schema.isValidChild(t, n), HC = (e, t = !1) => {
      if (Xe(e) && At(e)) {
        const n = t ? e.data.replace(/ /g, " ") : e.data;
        return pd(n);
      } else
        return !1;
    }, VC = (e) => Xe(e) && At(e) && e.length === 0, Y5 = (e, t) => {
      const n = "[data-mce-cef-wrappable]", r = Up(e), a = us(r) ? n : `${n},${r}`;
      return Ai(be.fromDom(t), a);
    }, UC = (e, t) => {
      const n = e.dom;
      return ys(t) && n.getContentEditable(t) === "false" && Y5(e, t) && n.select('[contenteditable="true"]', t).length === 0;
    }, Lh = (e, t) => un(e) ? e(t) : (Xe(t) && (e = e.replace(/%(\w+)/g, (n, r) => t[r] || n)), e), $v = (e, t) => (e = e || "", t = t || "", e = "" + (e.nodeName || e), t = "" + (t.nodeName || t), e.toLowerCase() === t.toLowerCase()), fk = (e, t) => {
      if (jn(e))
        return null;
      {
        let n = String(e);
        return (t === "color" || t === "backgroundColor") && (n = ql(n)), t === "fontWeight" && e === 700 && (n = "bold"), t === "fontFamily" && (n = n.replace(/[\'\"]/g, "").replace(/,\s+/g, ",")), n;
      }
    }, p1 = (e, t, n) => {
      const r = e.getStyle(t, n);
      return fk(r, n);
    }, NT = (e, t) => {
      let n;
      return e.getParent(t, (r) => wn(r) ? (n = e.getStyle(r, "text-decoration"), !!n && n !== "none") : !1), n;
    }, mk = (e, t, n) => e.getParents(t, n, e.getRoot()), jC = (e, t, n) => {
      const r = e.formatter.get(t);
      return Xe(r) && cr(r, n);
    }, X5 = (e, t) => jC(e, t, (r) => {
      const a = (c) => un(c) || c.length > 1 && c.charAt(0) === "%";
      return cr([
        "styles",
        "attributes"
      ], (c) => Hr(r, c).exists((d) => {
        const h = Se(d) ? d : oc(d);
        return cr(h, a);
      }));
    }), J5 = (e, t, n) => {
      const r = [
        "inline",
        "block",
        "selector",
        "attributes",
        "styles",
        "classes"
      ], a = (c) => _l(c, (d, h) => cr(r, (k) => k === h));
      return jC(e, t, (c) => {
        const d = a(c);
        return jC(e, n, (h) => {
          const k = a(h);
          return Ei(d, k);
        });
      });
    }, jp = (e) => qi(e, "block"), Q5 = (e) => jp(e) && e.wrapper === !0, eM = (e) => jp(e) && e.wrapper !== !0, jf = (e) => qi(e, "selector"), Xl = (e) => qi(e, "inline"), MT = (e) => jf(e) && Xl(e) && Pd(Hr(e, "mixed"), !0), ZC = (e) => jf(e) && e.expand !== !1 && !Xl(e), tM = (e) => {
      const t = [];
      let n = e;
      for (; n; ) {
        if (At(n) && n.data !== C || n.childNodes.length > 1)
          return [];
        wn(n) && t.push(n), n = n.firstChild;
      }
      return t;
    }, WC = (e) => tM(e).length > 0, _d = (e) => uf(e.dom) && WC(e.dom), v0 = Vf, qC = mk, pk = HC, GC = Fv, BT = (e) => cs(e) && e.getAttribute("data-mce-bogus") && !e.nextSibling, KC = (e, t) => {
      let n = t;
      for (; n; ) {
        if (wn(n) && e.getContentEditable(n))
          return e.getContentEditable(n) === "false" ? n : t;
        n = n.parentNode;
      }
      return t;
    }, gk = (e, t, n, r) => {
      const a = t.data;
      if (e) {
        for (let c = n; c > 0; c--)
          if (r(a.charAt(c - 1)))
            return c;
      } else
        for (let c = n; c < a.length; c++)
          if (r(a.charAt(c)))
            return c;
      return -1;
    }, LT = (e, t, n) => gk(e, t, n, (r) => uk(r) || b0(r)), fp = (e, t, n) => gk(e, t, n, $u), PT = (e, t, n, r, a, c) => {
      let d;
      const h = e.getParent(n, e.isBlock) || t, k = (H, U, G) => {
        const ie = tp(e), ye = a ? ie.backwards : ie.forwards;
        return K.from(ye(H, U, (ae, xe) => v0(ae.parentNode) ? -1 : (d = ae, G(a, ae, xe)), h));
      };
      return k(n, r, LT).bind((H) => c ? k(H.container, H.offset + (a ? -1 : 0), fp) : K.some(H)).orThunk(() => d ? K.some({
        container: d,
        offset: a ? 0 : d.length
      }) : K.none());
    }, hk = (e, t, n, r, a) => {
      const c = r[a];
      At(r) && us(r.data) && c && (r = c);
      const d = qC(e, r);
      for (let h = 0; h < d.length; h++)
        for (let k = 0; k < t.length; k++) {
          const D = t[k];
          if (!(Xe(D.collapsed) && D.collapsed !== n.collapsed) && jf(D) && e.is(d[h], D.selector))
            return d[h];
        }
      return r;
    }, Zf = (e, t, n, r) => {
      var a;
      let c = n;
      const d = e.getRoot(), h = t[0];
      if (jp(h) && (c = h.wrapper ? null : e.getParent(n, h.block, d)), !c) {
        const k = (a = e.getParent(n, "LI,TD,TH,SUMMARY")) !== null && a !== void 0 ? a : d;
        c = e.getParent(At(n) ? n.parentNode : n, (D) => D !== d && GC(e.schema, D), k);
      }
      if (c && jp(h) && h.wrapper && (c = qC(e, c, "ul,ol").reverse()[0] || c), !c)
        for (c = n; c && c[r] && !e.isBlock(c[r]) && (c = c[r], !$v(c, "br")); )
          ;
      return c || n;
    }, x0 = (e, t, n, r) => {
      const a = n.parentNode;
      return Xe(n[r]) ? !1 : a === t || jn(a) || e.isBlock(a) ? !0 : x0(e, t, a, r);
    }, Ph = (e, t, n, r, a) => {
      let c = n;
      const d = a ? "previousSibling" : "nextSibling", h = e.getRoot();
      if (At(n) && !pk(n) && (a ? r > 0 : r < n.data.length))
        return n;
      for (; c; ) {
        if (!t[0].block_expand && e.isBlock(c))
          return c;
        for (let k = c[d]; k; k = k[d]) {
          const D = At(k) && !x0(e, h, k, d);
          if (!v0(k) && !BT(k) && !pk(k, D))
            return c;
        }
        if (c === h || c.parentNode === h) {
          n = c;
          break;
        }
        c = c.parentNode;
      }
      return n;
    }, IT = (e) => v0(e.parentNode) || v0(e), mp = (e, t, n, r = !1) => {
      let { startContainer: a, startOffset: c, endContainer: d, endOffset: h } = t;
      const k = n[0];
      return wn(a) && a.hasChildNodes() && (a = Nu(a, c), At(a) && (c = 0)), wn(d) && d.hasChildNodes() && (d = Nu(d, t.collapsed ? h : h - 1), At(d) && (h = d.data.length)), a = KC(e, a), d = KC(e, d), IT(a) && (a = v0(a) ? a : a.parentNode, t.collapsed ? a = a.previousSibling || a : a = a.nextSibling || a, At(a) && (c = t.collapsed ? a.length : 0)), IT(d) && (d = v0(d) ? d : d.parentNode, t.collapsed ? d = d.nextSibling || d : d = d.previousSibling || d, At(d) && (h = t.collapsed ? 0 : d.length)), t.collapsed && (PT(e, e.getRoot(), a, c, !0, r).each(({ container: U, offset: G }) => {
        a = U, c = G;
      }), PT(e, e.getRoot(), d, h, !1, r).each(({ container: U, offset: G }) => {
        d = U, h = G;
      })), (Xl(k) || k.block_expand) && ((!Xl(k) || !At(a) || c === 0) && (a = Ph(e, n, a, c, !0)), (!Xl(k) || !At(d) || h === d.data.length) && (d = Ph(e, n, d, h, !1))), ZC(k) && (a = hk(e, n, t, a, "previousSibling"), d = hk(e, n, t, d, "nextSibling")), (jp(k) || jf(k)) && (a = Zf(e, n, a, "previousSibling"), d = Zf(e, n, d, "nextSibling"), jp(k) && (e.isBlock(a) || (a = Ph(e, n, a, c, !0)), e.isBlock(d) || (d = Ph(e, n, d, h, !1)))), wn(a) && a.parentNode && (c = e.nodeIndex(a), a = a.parentNode), wn(d) && d.parentNode && (h = e.nodeIndex(d) + 1, d = d.parentNode), {
        startContainer: a,
        startOffset: c,
        endContainer: d,
        endOffset: h
      };
    }, Xr = (e, t, n) => {
      var r;
      const a = t.startOffset, c = Nu(t.startContainer, a), d = t.endOffset, h = Nu(t.endContainer, d - 1), k = (xe) => {
        const Ne = xe[0];
        At(Ne) && Ne === c && a >= Ne.data.length && xe.splice(0, 1);
        const Ie = xe[xe.length - 1];
        return d === 0 && xe.length > 0 && Ie === h && At(Ie) && xe.splice(xe.length - 1, 1), xe;
      }, D = (xe, Ne, Ie) => {
        const Fe = [];
        for (; xe && xe !== Ie; xe = xe[Ne])
          Fe.push(xe);
        return Fe;
      }, H = (xe, Ne) => e.getParent(xe, (Ie) => Ie.parentNode === Ne, Ne), U = (xe, Ne, Ie) => {
        const Fe = Ie ? "nextSibling" : "previousSibling";
        for (let je = xe, _t = je.parentNode; je && je !== Ne; je = _t) {
          _t = je.parentNode;
          const Zt = D(je === xe ? je : je[Fe], Fe);
          Zt.length && (Ie || Zt.reverse(), n(k(Zt)));
        }
      };
      if (c === h)
        return n(k([c]));
      const G = (r = e.findCommonAncestor(c, h)) !== null && r !== void 0 ? r : e.getRoot();
      if (e.isChildOf(c, h))
        return U(c, G, !0);
      if (e.isChildOf(h, c))
        return U(h, G);
      const ie = H(c, G) || c, ye = H(h, G) || h;
      U(c, ie, !0);
      const ae = D(ie === c ? ie : ie.nextSibling, "nextSibling", ye === h ? ye.nextSibling : ye);
      ae.length && n(k(ae)), U(h, ye);
    }, Hv = [
      'pre[class*=language-][contenteditable="false"]',
      "figure.image",
      "div[data-ephox-embed-iri]",
      "div.tiny-pageembed",
      "div.mce-toc",
      "div[data-mce-toc]"
    ], FT = (e) => Zs(e) && ld(e) === C, $T = (e, t, n, r) => Br(t).fold(() => "skipping", (a) => r === "br" || FT(t) ? "valid" : Kl(t) ? "existing" : uf(t.dom) ? "caret" : cr(Hv, (c) => Ai(t, c)) ? "valid-block" : !Gb(e, n, r) || !Gb(e, Eo(a), n) ? "invalid-child" : "valid"), YC = (e, t) => {
      const n = mp(e.dom, t, [{ inline: "span" }]);
      t.setStart(n.startContainer, n.startOffset), t.setEnd(n.endContainer, n.endOffset), e.selection.setRng(t);
    }, bk = (e, t, n, r, a, c) => {
      const { uid: d = t, ...h } = n;
      ca(e, If()), Vr(e, `${vm()}`, d), Vr(e, `${Jm()}`, r);
      const { attributes: k = {}, classes: D = [] } = a(d, h);
      if (zs(e, k), Q1(e, D), c) {
        D.length > 0 && Vr(e, `${yd()}`, D.join(","));
        const H = Nt(k);
        H.length > 0 && Vr(e, `${Sg()}`, H.join(","));
      }
    }, XC = (e) => {
      Oi(e, If()), xs(e, `${vm()}`), xs(e, `${Jm()}`), xs(e, `${xm()}`);
      const t = Js(e, `${Sg()}`).map((r) => r.split(",")).getOr([]), n = Js(e, `${yd()}`).map((r) => r.split(",")).getOr([]);
      ut(t, (r) => xs(e, r)), _b(e, n), xs(e, `${yd()}`), xs(e, `${Sg()}`);
    }, yk = (e, t, n, r, a) => {
      const c = be.fromTag("span", e);
      return bk(c, t, n, r, a, !1), c;
    }, vk = (e, t, n, r, a, c) => {
      const d = [], h = yk(e.getDoc(), n, c, r, a), k = sf(), D = () => {
        k.clear();
      }, H = () => k.get().getOrThunk(() => {
        const ye = _m(h);
        return d.push(ye), k.set(ye), ye;
      }), U = (ye) => {
        ut(ye, G);
      }, G = (ye) => {
        switch ($T(e, ye, "span", Eo(ye))) {
          case "invalid-child": {
            D();
            const xe = Pr(ye);
            U(xe), D();
            break;
          }
          case "valid-block": {
            D(), bk(ye, n, c, r, a, !0);
            break;
          }
          case "valid": {
            const xe = H();
            im(ye, xe);
            break;
          }
        }
      }, ie = (ye) => {
        const ae = oo(ye, be.fromDom);
        U(ae);
      };
      return Xr(e.dom, t, (ye) => {
        D(), ie(ye);
      }), d;
    }, JC = (e, t, n, r) => {
      e.undoManager.transact(() => {
        const a = e.selection, c = a.getRng(), d = Pg(e).length > 0, h = km("mce-annotation");
        if (c.collapsed && !d && YC(e, c), a.getRng().collapsed && !d) {
          const k = yk(e.getDoc(), h, r, t, n.decorate);
          Hc(k, Bo), a.getRng().insertNode(k.dom), a.select(k.dom);
        } else
          FC(a, !1, () => {
            m1(e, (k) => {
              vk(e, k, h, t, n.decorate, r);
            });
          });
      });
    }, QC = (e) => {
      const t = Ky();
      kh(e, t);
      const n = kv(e, t), r = ya("span"), a = (c) => {
        ut(c, (d) => {
          r(d) ? wa(d) : XC(d);
        });
      };
      return {
        register: (c, d) => {
          t.register(c, d);
        },
        annotate: (c, d) => {
          t.lookup(c).each((h) => {
            JC(e, c, h, d);
          });
        },
        annotationChanged: (c, d) => {
          n.addListener(c, d);
        },
        remove: (c) => {
          wb(e, K.some(c)).each(({ elements: d }) => {
            const h = e.selection.getBookmark();
            a(d), e.selection.moveToBookmark(h);
          });
        },
        removeAll: (c) => {
          const d = e.selection.getBookmark();
          Zo(kb(e, c), (h, k) => {
            a(h);
          }), e.selection.moveToBookmark(d);
        },
        getAll: (c) => {
          const d = kb(e, c);
          return mi(d, (h) => oo(h, (k) => k.dom));
        }
      };
    }, w0 = (e) => ({
      getBookmark: Tt(Ur, e),
      moveToBookmark: Tt(AT, e)
    });
    w0.isBookmarkNode = Vf;
    const eS = (e, t, n) => n.collapsed ? !1 : cr(n.getClientRects(), (r) => Eb(r, e, t)), HT = (e, t) => e.dispatch("PreProcess", t), VT = (e, t) => e.dispatch("PostProcess", t), k0 = (e) => {
      e.dispatch("remove");
    }, UT = (e) => {
      e.dispatch("detach");
    }, tS = (e, t) => {
      e.dispatch("SwitchMode", { mode: t });
    }, nM = (e, t, n, r, a) => {
      e.dispatch("ObjectResizeStart", {
        target: t,
        width: n,
        height: r,
        origin: a
      });
    }, oM = (e, t, n, r, a) => {
      e.dispatch("ObjectResized", {
        target: t,
        width: n,
        height: r,
        origin: a
      });
    }, jT = (e) => {
      e.dispatch("PreInit");
    }, ZT = (e) => {
      e.dispatch("PostRender");
    }, WT = (e) => {
      e.dispatch("Init");
    }, xk = (e, t) => {
      e.dispatch("PlaceholderToggle", { state: t });
    }, nS = (e, t, n) => {
      e.dispatch(t, n);
    }, oS = (e, t, n, r) => {
      e.dispatch("FormatApply", {
        format: t,
        node: n,
        vars: r
      });
    }, rS = (e, t, n, r) => {
      e.dispatch("FormatRemove", {
        format: t,
        node: n,
        vars: r
      });
    }, qT = (e, t) => e.dispatch("BeforeSetContent", t), sS = (e, t) => e.dispatch("SetContent", t), GT = (e, t) => e.dispatch("BeforeGetContent", t), aS = (e, t) => e.dispatch("GetContent", t), KT = (e, t) => {
      e.dispatch("AutocompleterStart", t);
    }, YT = (e, t) => {
      e.dispatch("AutocompleterUpdate", t);
    }, XT = (e) => {
      e.dispatch("AutocompleterEnd");
    }, iS = (e, t, n) => e.dispatch("PastePreProcess", {
      content: t,
      internal: n
    }), JT = (e, t, n) => e.dispatch("PastePostProcess", {
      node: t,
      internal: n
    }), lS = (e, t) => e.dispatch("PastePlainTextToggle", { state: t }), QT = (e, t) => e.dispatch("EditableRootStateChange", { state: t }), yn = {
      BACKSPACE: 8,
      DELETE: 46,
      DOWN: 40,
      ENTER: 13,
      ESC: 27,
      LEFT: 37,
      RIGHT: 39,
      SPACEBAR: 32,
      TAB: 9,
      UP: 38,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      modifierPressed: (e) => e.shiftKey || e.ctrlKey || e.altKey || yn.metaKeyPressed(e),
      metaKeyPressed: (e) => nr.os.isMacOS() || nr.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey
    }, Kb = "data-mce-selected", ez = "table,img,figure.image,hr,video,span.mce-preview-object,details", wk = Math.abs, g1 = Math.round, _0 = {
      nw: [
        0,
        0,
        -1,
        -1
      ],
      ne: [
        1,
        0,
        1,
        -1
      ],
      se: [
        1,
        1,
        1,
        1
      ],
      sw: [
        0,
        1,
        -1,
        1
      ]
    }, kk = (e) => e.type === "longpress" || e.type.indexOf("touch") === 0, cS = (e, t) => {
      const n = t.dom, r = t.getDoc(), a = document, c = t.getBody();
      let d, h, k, D, H, U, G, ie, ye, ae, xe, Ne, Ie, Fe, je, _t, Zt;
      const fn = (qt) => Xe(qt) && (Rl(qt) || n.is(qt, "figure.image")), at = (qt) => pn(qt) || n.hasClass(qt, "mce-preview-object"), et = (qt, bo) => {
        if (kk(qt)) {
          const hr = qt.touches[0];
          return fn(qt.target) && !eS(hr.clientX, hr.clientY, bo);
        } else
          return fn(qt.target) && !eS(qt.clientX, qt.clientY, bo);
      }, Mt = (qt) => {
        const bo = qt.target;
        et(qt, t.selection.getRng()) && !qt.isDefaultPrevented() && t.selection.select(bo);
      }, gn = (qt) => n.hasClass(qt, "mce-preview-object") && Xe(qt.firstElementChild) ? [
        qt,
        qt.firstElementChild
      ] : n.is(qt, "figure.image") ? [qt.querySelector("img")] : [qt], Fn = (qt) => {
        const bo = Ev(t);
        return !bo || qt.getAttribute("data-mce-resize") === "false" || qt === t.getBody() ? !1 : n.hasClass(qt, "mce-preview-object") && Xe(qt.firstElementChild) ? Ai(be.fromDom(qt.firstElementChild), bo) : Ai(be.fromDom(qt), bo);
      }, Uo = (qt) => at(qt) ? n.create("img", { src: nr.transparentSrc }) : qt.cloneNode(!0), qo = (qt, bo, hr) => {
        if (Xe(hr)) {
          const Ss = gn(qt);
          ut(Ss, (na) => {
            na.style[bo] || !t.schema.isValid(na.nodeName.toLowerCase(), bo) ? n.setStyle(na, bo, hr) : n.setAttrib(na, bo, "" + hr);
          });
        }
      }, vs = (qt, bo, hr) => {
        qo(qt, "width", bo), qo(qt, "height", hr);
      }, Vs = (qt) => {
        let bo, hr, Ss, na, Ed;
        bo = qt.screenX - U, hr = qt.screenY - G, Fe = bo * D[2] + ae, je = hr * D[3] + xe, Fe = Fe < 5 ? 5 : Fe, je = je < 5 ? 5 : je, (fn(d) || at(d)) && o1(t) !== !1 ? Ss = !yn.modifierPressed(qt) : Ss = yn.modifierPressed(qt), Ss && (wk(bo) > wk(hr) ? (je = g1(Fe * Ne), Fe = g1(je / Ne)) : (Fe = g1(je / Ne), je = g1(Fe * Ne))), vs(h, Fe, je), na = D.startPos.x + bo, Ed = D.startPos.y + hr, na = na > 0 ? na : 0, Ed = Ed > 0 ? Ed : 0, n.setStyles(k, {
          left: na,
          top: Ed,
          display: "block"
        }), k.innerHTML = Fe + " &times; " + je, D[2] < 0 && h.clientWidth <= Fe && n.setStyle(h, "left", ie + (ae - Fe)), D[3] < 0 && h.clientHeight <= je && n.setStyle(h, "top", ye + (xe - je)), bo = c.scrollWidth - _t, hr = c.scrollHeight - Zt, bo + hr !== 0 && n.setStyles(k, {
          left: na - bo,
          top: Ed - hr
        }), Ie || (nM(t, d, ae, xe, "corner-" + D.name), Ie = !0);
      }, Ci = () => {
        const qt = Ie;
        Ie = !1, qt && (qo(d, "width", Fe), qo(d, "height", je)), n.unbind(r, "mousemove", Vs), n.unbind(r, "mouseup", Ci), a !== r && (n.unbind(a, "mousemove", Vs), n.unbind(a, "mouseup", Ci)), n.remove(h), n.remove(k), n.remove(H), Yc(d), qt && (oM(t, d, Fe, je, "corner-" + D.name), n.setAttrib(d, "style", n.getAttrib(d, "style"))), t.nodeChanged();
      }, Yc = (qt) => {
        xr();
        const bo = n.getPos(qt, c), hr = bo.x, Ss = bo.y, na = qt.getBoundingClientRect(), Ed = na.width || na.right - na.left, Mm = na.height || na.bottom - na.top;
        d !== qt && (sn(), d = qt, Fe = je = 0);
        const Sy = t.dispatch("ObjectSelected", { target: qt });
        Fn(qt) && !Sy.isDefaultPrevented() ? Zo(_0, (Td, Qg) => {
          const vo = (Es) => {
            const Za = gn(d)[0];
            U = Es.screenX, G = Es.screenY, ae = Za.clientWidth, xe = Za.clientHeight, Ne = xe / ae, D = Td, D.name = Qg, D.startPos = {
              x: Ed * Td[0] + hr,
              y: Mm * Td[1] + Ss
            }, _t = c.scrollWidth, Zt = c.scrollHeight, H = n.add(c, "div", {
              class: "mce-resize-backdrop",
              "data-mce-bogus": "all"
            }), n.setStyles(H, {
              position: "fixed",
              left: "0",
              top: "0",
              width: "100%",
              height: "100%"
            }), h = Uo(d), n.addClass(h, "mce-clonedresizable"), n.setAttrib(h, "data-mce-bogus", "all"), h.contentEditable = "false", n.setStyles(h, {
              left: hr,
              top: Ss,
              margin: 0
            }), vs(h, Ed, Mm), h.removeAttribute(Kb), c.appendChild(h), n.bind(r, "mousemove", Vs), n.bind(r, "mouseup", Ci), a !== r && (n.bind(a, "mousemove", Vs), n.bind(a, "mouseup", Ci)), k = n.add(c, "div", {
              class: "mce-resize-helper",
              "data-mce-bogus": "all"
            }, ae + " &times; " + xe);
          };
          let br = n.get("mceResizeHandle" + Qg);
          br && n.remove(br), br = n.add(c, "div", {
            id: "mceResizeHandle" + Qg,
            "data-mce-bogus": "all",
            class: "mce-resizehandle",
            unselectable: !0,
            style: "cursor:" + Qg + "-resize; margin:0; padding:0"
          }), n.bind(br, "mousedown", (Es) => {
            Es.stopImmediatePropagation(), Es.preventDefault(), vo(Es);
          }), Td.elm = br, n.setStyles(br, {
            left: Ed * Td[0] + hr - br.offsetWidth / 2,
            top: Mm * Td[1] + Ss - br.offsetHeight / 2
          });
        }) : sn(!1);
      }, Ql = xh(Yc, 0), sn = (qt = !0) => {
        Ql.cancel(), xr(), d && qt && d.removeAttribute(Kb), Zo(_0, (bo, hr) => {
          const Ss = n.get("mceResizeHandle" + hr);
          Ss && (n.unbind(Ss), n.remove(Ss));
        });
      }, zn = (qt, bo) => n.isChildOf(qt, bo), Ar = (qt) => {
        if (Ie || t.removed || t.composing)
          return;
        const bo = qt.type === "mousedown" ? qt.target : e.getNode(), hr = el(be.fromDom(bo), ez).map((na) => na.dom).filter((na) => n.isEditable(na.parentElement) || na.nodeName === "IMG" && n.isEditable(na)).getOrUndefined(), Ss = Xe(hr) ? n.getAttrib(hr, Kb, "1") : "1";
        if (ut(n.select(`img[${Kb}],hr[${Kb}]`), (na) => {
          na.removeAttribute(Kb);
        }), Xe(hr) && zn(hr, c) && t.hasFocus()) {
          On();
          const na = e.getStart(!0);
          if (zn(na, hr) && zn(e.getEnd(!0), hr)) {
            n.setAttrib(hr, Kb, Ss), Ql.throttle(hr);
            return;
          }
        }
        sn();
      }, xr = () => {
        Zo(_0, (qt) => {
          qt.elm && (n.unbind(qt.elm), delete qt.elm);
        });
      }, On = () => {
        try {
          t.getDoc().execCommand("enableObjectResizing", !1, "false");
        } catch {
        }
      };
      return t.on("init", () => {
        On(), t.on("NodeChange ResizeEditor ResizeWindow ResizeContent drop", Ar), t.on("keyup compositionend", (qt) => {
          d && d.nodeName === "TABLE" && Ar(qt);
        }), t.on("hide blur", sn), t.on("contextmenu longpress", Mt, !0);
      }), t.on("remove", xr), {
        isResizable: Fn,
        showResizeRect: Yc,
        hideResizeRect: sn,
        updateResizeRect: Ar,
        destroy: () => {
          Ql.cancel(), d = h = H = null;
        }
      };
    }, _k = (e, t) => {
      t.fold((n) => {
        e.setStartBefore(n.dom);
      }, (n, r) => {
        e.setStart(n.dom, r);
      }, (n) => {
        e.setStartAfter(n.dom);
      });
    }, uS = (e, t) => {
      t.fold((n) => {
        e.setEndBefore(n.dom);
      }, (n, r) => {
        e.setEnd(n.dom, r);
      }, (n) => {
        e.setEndAfter(n.dom);
      });
    }, C0 = (e, t, n) => {
      const r = e.document.createRange();
      return _k(r, t), uS(r, n), r;
    }, Vv = (e, t, n, r, a) => {
      const c = e.document.createRange();
      return c.setStart(t.dom, n), c.setEnd(r.dom, a), c;
    }, S0 = $e.generate([
      {
        ltr: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      },
      {
        rtl: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]), h1 = (e, t, n) => t(be.fromDom(n.startContainer), n.startOffset, be.fromDom(n.endContainer), n.endOffset), dS = (e, t) => t.match({
      domRange: (n) => ({
        ltr: dt(n),
        rtl: K.none
      }),
      relative: (n, r) => ({
        ltr: Gi(() => C0(e, n, r)),
        rtl: Gi(() => K.some(C0(e, r, n)))
      }),
      exact: (n, r, a, c) => ({
        ltr: Gi(() => Vv(e, n, r, a, c)),
        rtl: Gi(() => K.some(Vv(e, a, c, n, r)))
      })
    }), fS = (e, t) => {
      const n = t.ltr();
      return n.collapsed ? t.rtl().filter((a) => a.collapsed === !1).map((a) => S0.rtl(be.fromDom(a.endContainer), a.endOffset, be.fromDom(a.startContainer), a.startOffset)).getOrThunk(() => h1(e, S0.ltr, n)) : h1(e, S0.ltr, n);
    }, Uv = (e, t) => {
      const n = dS(e, t);
      return fS(e, n);
    };
    S0.ltr, S0.rtl;
    const mS = { create: (e, t, n, r) => ({
      start: e,
      soffset: t,
      finish: n,
      foffset: r
    }) }, rM = (e, t, n) => {
      var r, a;
      return K.from((a = (r = e.dom).caretPositionFromPoint) === null || a === void 0 ? void 0 : a.call(r, t, n)).bind((c) => {
        if (c.offsetNode === null)
          return K.none();
        const d = e.dom.createRange();
        return d.setStart(c.offsetNode, c.offset), d.collapse(), K.some(d);
      });
    }, tz = (e, t, n) => {
      var r, a;
      return K.from((a = (r = e.dom).caretRangeFromPoint) === null || a === void 0 ? void 0 : a.call(r, t, n));
    }, nz = (() => document.caretPositionFromPoint ? rM : document.caretRangeFromPoint ? tz : K.none)(), pS = (e, t, n) => {
      const r = be.fromDom(e.document);
      return nz(r, t, n).map((a) => mS.create(be.fromDom(a.startContainer), a.startOffset, be.fromDom(a.endContainer), a.endOffset));
    }, Tm = $e.generate([
      { before: ["element"] },
      {
        on: [
          "element",
          "offset"
        ]
      },
      { after: ["element"] }
    ]), gS = (e, t, n, r) => e.fold(t, n, r), Ck = (e) => e.fold(Bn, Bn, Bn), oz = Tm.before, sM = Tm.on, rz = Tm.after, Ig = {
      before: oz,
      on: sM,
      after: rz,
      cata: gS,
      getStart: Ck
    }, E0 = $e.generate([
      { domRange: ["rng"] },
      {
        relative: [
          "startSitu",
          "finishSitu"
        ]
      },
      {
        exact: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]), sz = (e) => E0.exact(e.start, e.soffset, e.finish, e.foffset), jv = (e) => e.match({
      domRange: (t) => be.fromDom(t.startContainer),
      relative: (t, n) => Ig.getStart(t),
      exact: (t, n, r, a) => t
    }), az = E0.domRange, iz = E0.relative, lz = E0.exact, aM = (e) => {
      const t = jv(e);
      return ur(t);
    }, hS = mS.create, pp = {
      domRange: az,
      relative: iz,
      exact: lz,
      exactFromRange: sz,
      getWin: aM,
      range: hS
    }, Sk = (e, t) => {
      const n = Eo(e);
      return n === "input" ? Ig.after(e) : So([
        "br",
        "img"
      ], n) ? t === 0 ? Ig.before(e) : Ig.after(e) : Ig.on(e, t);
    }, iM = (e, t) => {
      const n = e.fold(Ig.before, Sk, Ig.after), r = t.fold(Ig.before, Sk, Ig.after);
      return pp.relative(n, r);
    }, Zv = (e, t, n, r) => {
      const a = Sk(e, t), c = Sk(n, r);
      return pp.relative(a, c);
    }, cz = (e) => e.match({
      domRange: (t) => {
        const n = be.fromDom(t.startContainer), r = be.fromDom(t.endContainer);
        return Zv(n, t.startOffset, r, t.endOffset);
      },
      relative: iM,
      exact: Zv
    }), Ek = (e, t) => {
      const r = (t || document).createDocumentFragment();
      return ut(e, (a) => {
        r.appendChild(a.dom);
      }), be.fromDom(r);
    }, lM = (e) => {
      const t = pp.getWin(e).dom, n = (a, c, d, h) => Vv(t, a, c, d, h), r = cz(e);
      return Uv(t, r).match({
        ltr: n,
        rtl: n
      });
    }, uz = (e, t, n) => pS(e, t, n), Yb = (e, t, n) => {
      const r = ur(be.fromDom(n));
      return uz(r.dom, e, t).map((a) => {
        const c = n.createRange();
        return c.setStart(a.start.dom, a.soffset), c.setEnd(a.finish.dom, a.foffset), c;
      }).getOrUndefined();
    }, Tk = (e, t) => Xe(e) && Xe(t) && e.startContainer === t.startContainer && e.startOffset === t.startOffset && e.endContainer === t.endContainer && e.endOffset === t.endOffset, dz = (e, t, n) => {
      let r = e;
      for (; r && r !== t; ) {
        if (n(r))
          return r;
        r = r.parentNode;
      }
      return null;
    }, bS = (e, t, n) => dz(e, t, n) !== null, zk = (e, t, n) => bS(e, t, (r) => r.nodeName === n), fz = (e, t) => Tn(e) && !bS(e, t, uf), yS = (e, t, n) => {
      const r = t.parentNode;
      if (r) {
        const a = new vi(t, e.getParent(r, e.isBlock) || e.getRoot());
        let c;
        for (; c = a[n ? "prev" : "next"](); )
          if (cs(c))
            return !0;
      }
      return !1;
    }, cM = (e, t) => {
      var n;
      return ((n = e.previousSibling) === null || n === void 0 ? void 0 : n.nodeName) === t;
    }, Ok = (e, t) => {
      let n = t;
      for (; n && n !== e; ) {
        if (Kr(n))
          return !0;
        n = n.parentNode;
      }
      return !1;
    }, Ak = (e, t, n, r, a) => {
      const c = e.getRoot(), d = e.schema.getNonEmptyElements(), h = a.parentNode;
      let k, D;
      if (!h)
        return K.none();
      const H = e.getParent(h, e.isBlock) || c;
      if (r && cs(a) && t && e.isEmpty(H))
        return K.some(nt(h, e.nodeIndex(a)));
      const U = new vi(a, H);
      for (; D = U[r ? "prev" : "next"](); ) {
        if (e.getContentEditableParent(D) === "false" || fz(D, c))
          return K.none();
        if (At(D) && D.data.length > 0)
          return zk(D, c, "A") ? K.none() : K.some(nt(D, r ? D.data.length : 0));
        if (e.isBlock(D) || d[D.nodeName.toLowerCase()])
          return K.none();
        k = D;
      }
      return Gd(k) ? K.none() : n && k ? K.some(nt(k, 0)) : K.none();
    }, Dk = (e, t, n, r) => {
      const a = e.getRoot();
      let c, d = !1, h = n ? r.startContainer : r.endContainer, k = n ? r.startOffset : r.endOffset;
      const D = wn(h) && k === h.childNodes.length, H = e.schema.getNonEmptyElements();
      let U = n;
      if (Tn(h))
        return K.none();
      if (wn(h) && k > h.childNodes.length - 1 && (U = !1), Dl(h) && (h = a, k = 0), h === a) {
        if (U && (c = h.childNodes[k > 0 ? k - 1 : 0], c && (Tn(c) || H[c.nodeName] || Cu(c))))
          return K.none();
        if (h.hasChildNodes()) {
          if (k = Math.min(!U && k > 0 ? k - 1 : k, h.childNodes.length - 1), h = h.childNodes[k], k = At(h) && D ? h.data.length : 0, !t && h === a.lastChild && Cu(h) || Ok(a, h) || Tn(h) || zp(h))
            return K.none();
          if (h.hasChildNodes() && !Cu(h)) {
            c = h;
            const G = new vi(h, a);
            do {
              if (Kr(c) || Tn(c)) {
                d = !1;
                break;
              }
              if (At(c) && c.data.length > 0) {
                k = U ? 0 : c.data.length, h = c, d = !0;
                break;
              }
              if (H[c.nodeName.toLowerCase()] && !Io(c)) {
                k = e.nodeIndex(c), h = c.parentNode, U || k++, d = !0;
                break;
              }
            } while (c = U ? G.next() : G.prev());
          }
        }
      }
      return t && (At(h) && k === 0 && Ak(e, D, t, !0, h).each((G) => {
        h = G.container(), k = G.offset(), d = !0;
      }), wn(h) && (c = h.childNodes[k], c || (c = h.childNodes[k - 1]), c && cs(c) && !cM(c, "A") && !yS(e, c, !1) && !yS(e, c, !0) && Ak(e, D, t, !0, c).each((G) => {
        h = G.container(), k = G.offset(), d = !0;
      }))), U && !t && At(h) && k === h.data.length && Ak(e, D, t, !1, h).each((G) => {
        h = G.container(), k = G.offset(), d = !0;
      }), d && h ? K.some(nt(h, k)) : K.none();
    }, Wv = (e, t) => {
      const n = t.collapsed, r = t.cloneRange(), a = nt.fromRangeStart(t);
      return Dk(e, n, !0, r).each((c) => {
        (!n || !nt.isAbove(a, c)) && r.setStart(c.container(), c.offset());
      }), n || Dk(e, n, !1, r).each((c) => {
        r.setEnd(c.container(), c.offset());
      }), n && r.collapse(!0), Tk(t, r) ? K.none() : K.some(r);
    }, T0 = (e, t) => e.splitText(t), qv = (e) => {
      let t = e.startContainer, n = e.startOffset, r = e.endContainer, a = e.endOffset;
      if (t === r && At(t)) {
        if (n > 0 && n < t.data.length)
          if (r = T0(t, n), t = r.previousSibling, a > n) {
            a = a - n;
            const c = T0(r, a).previousSibling;
            t = r = c, a = c.data.length, n = 0;
          } else
            a = 0;
      } else if (At(t) && n > 0 && n < t.data.length && (t = T0(t, n), n = 0), At(r) && a > 0 && a < r.data.length) {
        const c = T0(r, a).previousSibling;
        r = c, a = c.data.length;
      }
      return {
        startContainer: t,
        startOffset: n,
        endContainer: r,
        endOffset: a
      };
    }, Fg = (e) => ({
      walk: (c, d) => Xr(e, c, d),
      split: qv,
      expand: (c, d = { type: "word" }) => {
        if (d.type === "word") {
          const h = mp(e, c, [{ inline: "span" }]), k = e.createRng();
          return k.setStart(h.startContainer, h.startOffset), k.setEnd(h.endContainer, h.endOffset), k;
        }
        return c;
      },
      normalize: (c) => Wv(e, c).fold(Pn, (d) => (c.setStart(d.startContainer, d.startOffset), c.setEnd(d.endContainer, d.endOffset), !0))
    });
    Fg.compareRanges = Tk, Fg.getCaretRangeFromPoint = Yb, Fg.getSelectedNode = lf, Fg.getNode = Nu;
    const uM = ((e, t) => {
      const n = (h, k) => {
        if (!M(k) && !k.match(/^[0-9]+$/))
          throw new Error(e + ".set accepts only positive integer values. Value was " + k);
        const D = h.dom;
        Hl(D) && (D.style[e] = k + "px");
      }, r = (h) => {
        const k = t(h);
        if (k <= 0 || k === null) {
          const D = Ya(h, e);
          return parseFloat(D) || 0;
        }
        return k;
      }, a = r, c = (h, k) => co(k, (D, H) => {
        const U = Ya(h, H), G = U === void 0 ? 0 : parseInt(U, 10);
        return isNaN(G) ? D : D + G;
      }, 0);
      return {
        set: n,
        get: r,
        getOuter: a,
        aggregate: c,
        max: (h, k, D) => {
          const H = c(h, D);
          return k > H ? k - H : 0;
        }
      };
    })("height", (e) => {
      const t = e.dom;
      return Qs(e) ? t.getBoundingClientRect().height : t.offsetHeight;
    }), vS = (e) => uM.get(e), ci = () => be.fromDom(document), Rk = (e, t) => e.view(t).fold(dt([]), (r) => {
      const a = e.owner(r), c = Rk(e, a);
      return [r].concat(c);
    }), xS = (e, t) => {
      const n = t.owner(e);
      return Rk(t, n);
    };
    var mz = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      view: (e) => {
        var t;
        return (e.dom === document ? K.none() : K.from((t = e.dom.defaultView) === null || t === void 0 ? void 0 : t.frameElement)).map(be.fromDom);
      },
      owner: (e) => Sn(e)
    });
    const Gv = (e) => {
      const t = ci(), n = bn(t), r = xS(e, mz), a = zt(e), c = xn(r, (d, h) => {
        const k = zt(h);
        return {
          left: d.left + k.left,
          top: d.top + k.top
        };
      }, {
        left: 0,
        top: 0
      });
      return F(c.left + a.left + n.left, c.top + a.top + n.top);
    }, wS = (e) => Eo(e) === "textarea", fM = (e, t) => e.dispatch("ScrollIntoView", t).isDefaultPrevented(), z0 = (e, t) => {
      e.dispatch("AfterScrollIntoView", t);
    }, mM = (e, t) => {
      const n = Pr(e);
      if (n.length === 0 || wS(e))
        return {
          element: e,
          offset: t
        };
      if (t < n.length && !wS(n[t]))
        return {
          element: n[t],
          offset: 0
        };
      {
        const r = n[n.length - 1];
        return wS(r) ? {
          element: e,
          offset: t
        } : Eo(r) === "img" ? {
          element: r,
          offset: 1
        } : Zs(r) ? {
          element: r,
          offset: ld(r).length
        } : {
          element: r,
          offset: Pr(r).length
        };
      }
    }, Qb = (e, t) => {
      const n = Oe(e), r = vS(e);
      return {
        element: e,
        bottom: n.top + r,
        height: r,
        pos: n,
        cleanup: t
      };
    }, pM = (e, t) => {
      const n = mM(e, t), r = be.fromHtml('<span data-mce-bogus="all" style="display: inline-block;">' + C + "</span>");
      return Fs(n.element, r), Qb(r, () => dr(r));
    }, ey = (e) => Qb(be.fromDom(e), ht), Wf = (e, t, n, r) => {
      gM(e, (a, c) => kS(e, t, n, r), n);
    }, Kv = (e, t, n, r, a) => {
      const c = {
        elm: r.element.dom,
        alignToTop: a
      };
      if (fM(e, c))
        return;
      const d = bn(t).top;
      n(e, t, d, r, a), z0(e, c);
    }, kS = (e, t, n, r) => {
      const a = be.fromDom(e.getBody()), c = be.fromDom(e.getDoc());
      Al(a);
      const d = pM(be.fromDom(n.startContainer), n.startOffset);
      Kv(e, c, t, d, r), d.cleanup();
    }, pz = (e, t, n, r) => {
      const a = be.fromDom(e.getDoc());
      Kv(e, a, n, ey(t), r);
    }, gM = (e, t, n) => {
      const r = n.startContainer, a = n.startOffset, c = n.endContainer, d = n.endOffset;
      t(be.fromDom(r), be.fromDom(c));
      const h = e.dom.createRng();
      h.setStart(r, a), h.setEnd(c, d), e.selection.setRng(n);
    }, O0 = (e, t, n, r, a) => {
      const c = t.pos;
      if (r)
        ao(c.left, c.top, a);
      else {
        const d = c.top - n + t.height;
        ao(-e.getBody().getBoundingClientRect().left, d, a);
      }
    }, gz = (e, t, n, r, a, c) => {
      const d = r + n, h = a.pos.top, k = a.bottom, D = k - h >= r;
      h < n ? O0(e, a, r, c !== !1, t) : h > d ? O0(e, a, r, D ? c !== !1 : c === !0, t) : k > d && !D && O0(e, a, r, c === !0, t);
    }, zm = (e, t, n, r, a) => {
      const c = ur(t).dom.innerHeight;
      gz(e, t, n, c, r, a);
    }, Yv = (e, t, n, r, a) => {
      const c = ur(t).dom.innerHeight;
      gz(e, t, n, c, r, a);
      const d = Gv(r.element), h = ws(window);
      d.top < h.y ? Hn(r.element, a !== !1) : d.top > h.bottom && Hn(r.element, a === !0);
    }, hz = (e, t, n) => Wf(e, zm, t, n), _S = (e, t, n) => pz(e, t, zm, n), CS = (e, t, n) => Wf(e, Yv, t, n), y1 = (e, t, n) => pz(e, t, Yv, n), SS = (e, t, n) => {
      (e.inline ? _S : y1)(e, t, n);
    }, A0 = (e, t, n) => {
      (e.inline ? hz : CS)(e, t, n);
    }, bz = (e, t = !1) => e.dom.focus({ preventScroll: t }), D0 = (e) => {
      const t = pl(e).dom;
      return e.dom === t.activeElement;
    }, ES = (e = ci()) => K.from(e.dom.activeElement).map(be.fromDom), yz = (e) => ES(pl(e)).filter((t) => e.dom.contains(t.dom)), Nk = (e, t) => {
      const n = Zs(t) ? ld(t).length : Pr(t).length + 1;
      return e > n ? n : e < 0 ? 0 : e;
    }, hM = (e) => pp.range(e.start, Nk(e.soffset, e.start), e.finish, Nk(e.foffset, e.finish)), TS = (e, t) => !Im(t.dom) && (Dt(e, t) || Le(e, t)), zS = (e) => (t) => TS(e, t.start) && TS(e, t.finish), bM = (e) => e.inline || nr.browser.isFirefox(), yM = (e) => pp.range(be.fromDom(e.startContainer), e.startOffset, be.fromDom(e.endContainer), e.endOffset), vM = (e) => {
      const t = e.getSelection();
      return (!t || t.rangeCount === 0 ? K.none() : K.from(t.getRangeAt(0))).map(yM);
    }, xM = (e) => {
      const t = ur(e);
      return vM(t.dom).filter(zS(e));
    }, wM = (e, t) => K.from(t).filter(zS(e)).map(hM), kM = (e) => {
      const t = document.createRange();
      try {
        return t.setStart(e.start.dom, e.soffset), t.setEnd(e.finish.dom, e.foffset), K.some(t);
      } catch {
        return K.none();
      }
    }, OS = (e) => {
      const t = bM(e) ? xM(be.fromDom(e.getBody())) : K.none();
      e.bookmark = t.isSome() ? t : e.bookmark;
    }, AS = (e) => (e.bookmark ? e.bookmark : K.none()).bind((n) => wM(be.fromDom(e.getBody()), n)).bind(kM), _M = (e) => {
      AS(e).each((t) => e.selection.setRng(t));
    }, vz = { isEditorUIElement: (e) => {
      const t = e.className.toString();
      return t.indexOf("tox-") !== -1 || t.indexOf("mce-") !== -1;
    } }, xz = (e, t) => (M(t) || (t = 0), setTimeout(e, t)), CM = (e, t) => (M(t) || (t = 0), setInterval(e, t)), du = {
      setEditorTimeout: (e, t, n) => xz(() => {
        e.removed || t();
      }, n),
      setEditorInterval: (e, t, n) => {
        const r = CM(() => {
          e.removed ? clearInterval(r) : t();
        }, n);
        return r;
      }
    }, SM = (e) => e.type === "nodechange" && e.selectionChange, EM = (e, t) => {
      const n = () => {
        t.throttle();
      };
      gs.DOM.bind(document, "mouseup", n), e.on("remove", () => {
        gs.DOM.unbind(document, "mouseup", n);
      });
    }, wz = (e, t) => {
      e.on("mouseup touchend", (n) => {
        t.throttle();
      });
    }, TM = (e, t) => {
      wz(e, t), e.on("keyup NodeChange AfterSetSelectionRange", (n) => {
        SM(n) || OS(e);
      });
    }, zM = (e) => {
      const t = xh(() => {
        OS(e);
      }, 0);
      e.on("init", () => {
        e.inline && EM(e, t), TM(e, t);
      }), e.on("remove", () => {
        t.cancel();
      });
    };
    let R0;
    const DS = gs.DOM, OM = (e) => wn(e) && vz.isEditorUIElement(e), RS = (e) => {
      const t = e.classList;
      return t !== void 0 ? t.contains("tox-edit-area") || t.contains("tox-edit-area__iframe") || t.contains("mce-content-body") : !1;
    }, N0 = (e, t) => {
      const n = Pu(e);
      return DS.getParent(t, (a) => OM(a) || (n ? e.dom.is(a, n) : !1)) !== null;
    }, v1 = (e) => {
      try {
        const t = pl(be.fromDom(e.getElement()));
        return ES(t).fold(() => document.body, (n) => n.dom);
      } catch {
        return document.body;
      }
    }, kz = (e, t) => {
      const n = t.editor;
      zM(n);
      const r = (a, c) => {
        if (Iu(a) && a.inline !== !0) {
          const d = be.fromDom(a.getContainer());
          c(d, "tox-edit-focus");
        }
      };
      n.on("focusin", () => {
        const a = e.focusedEditor;
        RS(v1(n)) && r(n, ca), a !== n && (a && a.dispatch("blur", { focusedEditor: n }), e.setActive(n), e.focusedEditor = n, n.dispatch("focus", { blurredEditor: a }), n.focus(!0));
      }), n.on("focusout", () => {
        du.setEditorTimeout(n, () => {
          const a = e.focusedEditor;
          (!RS(v1(n)) || a !== n) && r(n, Oi), !N0(n, v1(n)) && a === n && (n.dispatch("blur", { focusedEditor: null }), e.focusedEditor = null);
        });
      }), R0 || (R0 = (a) => {
        const c = e.activeEditor;
        c && bi(a).each((d) => {
          const h = d;
          h.ownerDocument === document && h !== document.body && !N0(c, h) && e.focusedEditor === c && (c.dispatch("blur", { focusedEditor: null }), e.focusedEditor = null);
        });
      }, DS.bind(document, "focusin", R0));
    }, Xv = (e, t) => {
      e.focusedEditor === t.editor && (e.focusedEditor = null), !e.activeEditor && R0 && (DS.unbind(document, "focusin", R0), R0 = null);
    }, Jv = (e) => {
      e.on("AddEditor", Tt(kz, e)), e.on("RemoveEditor", Tt(Xv, e));
    }, _z = (e, t) => e.dom.getParent(t, (n) => e.dom.getContentEditable(n) === "true"), AM = (e) => e.collapsed ? K.from(Nu(e.startContainer, e.startOffset)).map(be.fromDom) : K.none(), DM = (e, t) => AM(t).bind((n) => Tu(n) ? K.some(n) : Dt(e, n) ? K.none() : K.some(e)), Cz = (e, t) => {
      DM(be.fromDom(e.getBody()), t).bind((n) => lu(n.dom)).fold(() => {
        e.selection.normalize();
      }, (n) => e.selection.setRng(n.toRange()));
    }, NS = (e) => {
      if (e.setActive)
        try {
          e.setActive();
        } catch {
          e.focus();
        }
      else
        e.focus();
    }, Sz = (e) => D0(e) || yz(e).isSome(), Ez = (e) => Xe(e.iframeElement) && D0(be.fromDom(e.iframeElement)), RM = (e) => {
      const t = e.getBody();
      return t && Sz(be.fromDom(t));
    }, Mk = (e) => {
      const t = pl(be.fromDom(e.getElement()));
      return ES(t).filter((n) => !RS(n.dom) && N0(e, n.dom)).isSome();
    }, ty = (e) => e.inline ? RM(e) : Ez(e), il = (e) => ty(e) || Mk(e), M0 = (e) => {
      const t = e.selection, n = e.getBody();
      let r = t.getRng();
      e.quirks.refreshContentEditable(), Xe(e.bookmark) && !ty(e) && AS(e).each((c) => {
        e.selection.setRng(c), r = c;
      });
      const a = _z(e, t.getNode());
      if (a && e.dom.isChildOf(a, n)) {
        NS(a), Cz(e, r), Bk(e);
        return;
      }
      e.inline || (nr.browser.isOpera() || NS(n), e.getWin().focus()), (nr.browser.isFirefox() || e.inline) && (NS(n), Cz(e, r)), Bk(e);
    }, Bk = (e) => e.editorManager.setActive(e), MS = (e, t) => {
      e.removed || (t ? Bk(e) : M0(e));
    }, Qv = (e, t) => t.collapsed ? e.isEditable(t.startContainer) : e.isEditable(t.startContainer) && e.isEditable(t.endContainer), Ih = (e, t, n, r, a) => {
      const c = n ? t.startContainer : t.endContainer, d = n ? t.startOffset : t.endOffset;
      return K.from(c).map(be.fromDom).map((h) => !r || !t.collapsed ? Tc(h, a(h, d)).getOr(h) : h).bind((h) => Ji(h) ? K.some(h) : Br(h).filter(Ji)).map((h) => h.dom).getOr(e);
    }, Fh = (e, t, n = !1) => Ih(e, t, !0, n, (r, a) => Math.min($c(r), a)), Tz = (e, t, n = !1) => Ih(e, t, !1, n, (r, a) => a > 0 ? a - 1 : a), zz = (e, t) => {
      const n = e;
      for (; e && At(e) && e.length === 0; )
        e = t ? e.nextSibling : e.previousSibling;
      return e || n;
    }, B0 = (e, t) => {
      if (!t)
        return e;
      let n = t.startContainer, r = t.endContainer;
      const a = t.startOffset, c = t.endOffset;
      let d = t.commonAncestorContainer;
      t.collapsed || (n === r && c - a < 2 && n.hasChildNodes() && (d = n.childNodes[a]), At(n) && At(r) && (n.length === a ? n = zz(n.nextSibling, !0) : n = n.parentNode, c === 0 ? r = zz(r.previousSibling, !1) : r = r.parentNode, n && n === r && (d = n)));
      const h = At(d) ? d.parentNode : d;
      return ta(h) ? h : e;
    }, L0 = (e, t, n, r) => {
      const a = [], c = e.getRoot(), d = e.getParent(n || Fh(c, t, t.collapsed), e.isBlock), h = e.getParent(r || Tz(c, t, t.collapsed), e.isBlock);
      if (d && d !== c && a.push(d), d && h && d !== h) {
        let k;
        const D = new vi(d, c);
        for (; (k = D.next()) && k !== h; )
          e.isBlock(k) && a.push(k);
      }
      return h && d !== h && h !== c && a.push(h), a;
    }, P0 = (e, t, n) => K.from(t).bind((r) => K.from(r.parentNode).map((a) => {
      const c = e.nodeIndex(r), d = e.createRng();
      return d.setStart(a, c), d.setEnd(a, c + 1), n && (Em(e, d, r, !0), Em(e, d, r, !1)), d;
    })), Lk = (e, t) => oo(t, (n) => {
      const r = e.dispatch("GetSelectionRange", { range: n });
      return r.range !== n ? r.range : n;
    }), BS = (e) => Eo(e) === "img" ? 1 : cd(e).fold(() => Pr(e).length, (t) => t.length), Oz = (e) => cd(e).filter((t) => t.trim().length !== 0 || t.indexOf(Bo) > -1).isSome(), Az = (e) => $d(e) && Qi(e, "contenteditable") === "false", NM = [
      "img",
      "br"
    ], Dz = (e) => Oz(e) || So(NM, Eo(e)) || Az(e), Rz = (e) => Is(e, Dz), Nz = (e) => ex(e, Dz), ex = (e, t) => {
      const n = (r) => {
        const a = Pr(r);
        for (let c = a.length - 1; c >= 0; c--) {
          const d = a[c];
          if (t(d))
            return K.some(d);
          const h = n(d);
          if (h.isSome())
            return h;
        }
        return K.none();
      };
      return n(e);
    }, LS = "[data-mce-autocompleter]", Mz = (e, t) => {
      if (PS(be.fromDom(e.getBody())).isNone()) {
        const n = be.fromHtml('<span data-mce-autocompleter="1" data-mce-bogus="1"></span>', e.getDoc());
        Ir(n, be.fromDom(t.extractContents())), t.insertNode(n.dom), Br(n).each((r) => r.dom.normalize()), Nz(n).map((r) => {
          e.selection.setCursorLocation(r.dom, BS(r));
        });
      }
    }, Bz = (e) => el(e, LS), PS = (e) => Ia(e, LS), Lz = (e, t) => PS(t).each((n) => {
      const r = e.selection.getBookmark();
      wa(n), e.selection.moveToBookmark(r);
    }), Pz = {
      "#text": 3,
      "#comment": 8,
      "#cdata": 4,
      "#pi": 7,
      "#doctype": 10,
      "#document-fragment": 11
    }, tx = (e, t, n) => {
      const r = n ? "lastChild" : "firstChild", a = n ? "prev" : "next";
      if (e[r])
        return e[r];
      if (e !== t) {
        let c = e[a];
        if (c)
          return c;
        for (let d = e.parent; d && d !== t; d = d.parent)
          if (c = d[a], c)
            return c;
      }
    }, Iz = (e) => {
      var t;
      const n = (t = e.value) !== null && t !== void 0 ? t : "";
      if (!pd(n))
        return !1;
      const r = e.parent;
      return !(r && (r.name !== "span" || r.attr("style")) && /^[ ]+$/.test(n));
    }, IS = (e) => {
      const t = e.name === "a" && !e.attr("href") && e.attr("id");
      return e.attr("name") || e.attr("id") && !e.firstChild || e.attr("data-mce-bookmark") || t;
    };
    class qc {
      static create(t, n) {
        const r = new qc(t, Pz[t] || 1);
        return n && Zo(n, (a, c) => {
          r.attr(c, a);
        }), r;
      }
      constructor(t, n) {
        this.name = t, this.type = n, n === 1 && (this.attributes = [], this.attributes.map = {});
      }
      replace(t) {
        const n = this;
        return t.parent && t.remove(), n.insert(t, n), n.remove(), n;
      }
      attr(t, n) {
        const r = this;
        if (!Ot(t))
          return Xe(t) && Zo(t, (c, d) => {
            r.attr(d, c);
          }), r;
        const a = r.attributes;
        if (a) {
          if (n !== void 0) {
            if (n === null) {
              if (t in a.map) {
                delete a.map[t];
                let c = a.length;
                for (; c--; )
                  if (a[c].name === t)
                    return a.splice(c, 1), r;
              }
              return r;
            }
            if (t in a.map) {
              let c = a.length;
              for (; c--; )
                if (a[c].name === t) {
                  a[c].value = n;
                  break;
                }
            } else
              a.push({
                name: t,
                value: n
              });
            return a.map[t] = n, r;
          }
          return a.map[t];
        }
      }
      clone() {
        const t = this, n = new qc(t.name, t.type), r = t.attributes;
        if (r) {
          const a = [];
          a.map = {};
          for (let c = 0, d = r.length; c < d; c++) {
            const h = r[c];
            h.name !== "id" && (a[a.length] = {
              name: h.name,
              value: h.value
            }, a.map[h.name] = h.value);
          }
          n.attributes = a;
        }
        return n.value = t.value, n;
      }
      wrap(t) {
        const n = this;
        return n.parent && (n.parent.insert(t, n), t.append(n)), n;
      }
      unwrap() {
        const t = this;
        for (let n = t.firstChild; n; ) {
          const r = n.next;
          t.insert(n, t, !0), n = r;
        }
        t.remove();
      }
      remove() {
        const t = this, n = t.parent, r = t.next, a = t.prev;
        return n && (n.firstChild === t ? (n.firstChild = r, r && (r.prev = null)) : a && (a.next = r), n.lastChild === t ? (n.lastChild = a, a && (a.next = null)) : r && (r.prev = a), t.parent = t.next = t.prev = null), t;
      }
      append(t) {
        const n = this;
        t.parent && t.remove();
        const r = n.lastChild;
        return r ? (r.next = t, t.prev = r, n.lastChild = t) : n.lastChild = n.firstChild = t, t.parent = n, t;
      }
      insert(t, n, r) {
        t.parent && t.remove();
        const a = n.parent || this;
        return r ? (n === a.firstChild ? a.firstChild = t : n.prev && (n.prev.next = t), t.prev = n.prev, t.next = n, n.prev = t) : (n === a.lastChild ? a.lastChild = t : n.next && (n.next.prev = t), t.next = n.next, t.prev = n, n.next = t), t.parent = a, t;
      }
      getAll(t) {
        const n = this, r = [];
        for (let a = n.firstChild; a; a = tx(a, n))
          a.name === t && r.push(a);
        return r;
      }
      children() {
        const t = this, n = [];
        for (let r = t.firstChild; r; r = r.next)
          n.push(r);
        return n;
      }
      empty() {
        const t = this;
        if (t.firstChild) {
          const n = [];
          for (let a = t.firstChild; a; a = tx(a, t))
            n.push(a);
          let r = n.length;
          for (; r--; ) {
            const a = n[r];
            a.parent = a.firstChild = a.lastChild = a.next = a.prev = null;
          }
        }
        return t.firstChild = t.lastChild = null, t;
      }
      isEmpty(t, n = {}, r) {
        var a;
        const c = this;
        let d = c.firstChild;
        if (IS(c))
          return !1;
        if (d)
          do {
            if (d.type === 1) {
              if (d.attr("data-mce-bogus"))
                continue;
              if (t[d.name] || IS(d))
                return !1;
            }
            if (d.type === 8 || d.type === 3 && !Iz(d) || d.type === 3 && d.parent && n[d.parent.name] && pd((a = d.value) !== null && a !== void 0 ? a : "") || r && r(d))
              return !1;
          } while (d = tx(d, c));
        return !0;
      }
      walk(t) {
        return tx(this, null, t);
      }
    }
    const nx = Ht.makeMap("NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT", " "), FS = (e) => Ot(e.nodeValue) && e.nodeValue.includes(C), $S = (e) => `${e.length === 0 ? "" : `${oo(e, (t) => `[${t}]`).join(",")},`}[data-mce-bogus="all"]`, Pk = (e, t) => t.querySelectorAll($S(e)), Fz = (e) => document.createTreeWalker(e, NodeFilter.SHOW_COMMENT, (t) => FS(t) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP), $z = (e) => document.createTreeWalker(e, NodeFilter.SHOW_TEXT, (t) => {
      if (FS(t)) {
        const n = t.parentNode;
        return n && Yn(nx, n.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      } else
        return NodeFilter.FILTER_SKIP;
    }), ny = (e) => Fz(e).nextNode() !== null, HS = (e) => $z(e).nextNode() !== null, Hz = (e, t) => t.querySelector($S(e)) !== null, ox = (e, t) => {
      ut(Pk(e, t), (n) => {
        const r = be.fromDom(n);
        Qi(r, "data-mce-bogus") === "all" ? dr(r) : ut(e, (a) => {
          La(r, a) && xs(r, a);
        });
      });
    }, VS = (e) => {
      let t = e.nextNode();
      for (; t !== null; )
        t.nodeValue = null, t = e.nextNode();
    }, US = mn(VS, Fz), Vz = mn(VS, $z), jS = (e, t) => {
      const n = [
        {
          condition: Tt(Hz, t),
          action: Tt(ox, t)
        },
        {
          condition: ny,
          action: US
        },
        {
          condition: HS,
          action: Vz
        }
      ];
      let r = e, a = !1;
      return ut(n, ({ condition: c, action: d }) => {
        c(r) && (a || (r = e.cloneNode(!0), a = !0), d(r));
      }), r;
    }, Ik = (e) => {
      const t = Ni(e, "[data-mce-bogus]");
      ut(t, (n) => {
        Qi(n, "data-mce-bogus") === "all" ? dr(n) : tl(n) ? (Fs(n, be.fromText(uc)), dr(n)) : wa(n);
      });
    }, ZS = (e) => {
      const t = Ni(e, "input");
      ut(t, (n) => {
        xs(n, "name");
      });
    }, MM = (e, t) => {
      const n = li(e), r = new RegExp(`^(<${n}[^>]*>(&nbsp;|&#160;|\\s| |<br \\/>|)<\\/${n}>[\r
]*|<br \\/>[\r
]*)$`);
      return t.replace(r, "");
    }, Fk = (e, t) => {
      const n = e.getDoc(), r = pl(be.fromDom(e.getBody())), a = be.fromTag("div", n);
      Vr(a, "data-mce-bogus", "all"), Vl(a, {
        position: "fixed",
        left: "-9999999px",
        top: "0"
      }), Hc(a, t.innerHTML), Ik(a), ZS(a);
      const c = ic(r);
      Ir(c, a);
      const d = q(a.dom.innerText);
      return dr(a), d;
    }, fu = (e, t, n) => {
      let r;
      return t.format === "raw" ? r = Ht.trim(q(jS(n, e.serializer.getTempAttrs()).innerHTML)) : t.format === "text" ? r = Fk(e, n) : t.format === "tree" ? r = e.serializer.serialize(n, t) : r = MM(e, e.serializer.serialize(n, t)), t.format !== "text" && !um(be.fromDom(n)) && Ot(r) ? Ht.trim(r) : r;
    }, $k = (e, t) => K.from(e.getBody()).fold(dt(t.format === "tree" ? new qc("body", 11) : ""), (n) => fu(e, t, n)), oy = Ht.makeMap, WS = (e) => {
      const t = [];
      e = e || {};
      const n = e.indent, r = oy(e.indent_before || ""), a = oy(e.indent_after || ""), c = ma.getEncodeFunc(e.entity_encoding || "raw", e.entities), d = e.element_format !== "xhtml";
      return {
        start: (h, k, D) => {
          if (n && r[h] && t.length > 0) {
            const H = t[t.length - 1];
            H.length > 0 && H !== `
` && t.push(`
`);
          }
          if (t.push("<", h), k)
            for (let H = 0, U = k.length; H < U; H++) {
              const G = k[H];
              t.push(" ", G.name, '="', c(G.value, !0), '"');
            }
          if (!D || d ? t[t.length] = ">" : t[t.length] = " />", D && n && a[h] && t.length > 0) {
            const H = t[t.length - 1];
            H.length > 0 && H !== `
` && t.push(`
`);
          }
        },
        end: (h) => {
          let k;
          t.push("</", h, ">"), n && a[h] && t.length > 0 && (k = t[t.length - 1], k.length > 0 && k !== `
` && t.push(`
`));
        },
        text: (h, k) => {
          h.length > 0 && (t[t.length] = k ? h : c(h));
        },
        cdata: (h) => {
          t.push("<![CDATA[", h, "]]>");
        },
        comment: (h) => {
          t.push("<!--", h, "-->");
        },
        pi: (h, k) => {
          k ? t.push("<?", h, " ", c(k), "?>") : t.push("<?", h, "?>"), n && t.push(`
`);
        },
        doctype: (h) => {
          t.push("<!DOCTYPE", h, ">", n ? `
` : "");
        },
        reset: () => {
          t.length = 0;
        },
        getContent: () => t.join("").replace(/\n$/, "")
      };
    }, Jl = (e = {}, t = of()) => {
      const n = WS(e);
      return e.validate = "validate" in e ? e.validate : !0, { serialize: (a) => {
        const c = e.validate, d = {
          3: (k) => {
            var D;
            n.text((D = k.value) !== null && D !== void 0 ? D : "", k.raw);
          },
          8: (k) => {
            var D;
            n.comment((D = k.value) !== null && D !== void 0 ? D : "");
          },
          7: (k) => {
            n.pi(k.name, k.value);
          },
          10: (k) => {
            var D;
            n.doctype((D = k.value) !== null && D !== void 0 ? D : "");
          },
          4: (k) => {
            var D;
            n.cdata((D = k.value) !== null && D !== void 0 ? D : "");
          },
          11: (k) => {
            let D = k;
            if (D = D.firstChild)
              do
                h(D);
              while (D = D.next);
          }
        };
        n.reset();
        const h = (k) => {
          var D;
          const H = d[k.type];
          if (H)
            H(k);
          else {
            const U = k.name, G = U in t.getVoidElements();
            let ie = k.attributes;
            if (c && ie && ie.length > 1) {
              const ye = [];
              ye.map = {};
              const ae = t.getElementRule(k.name);
              if (ae) {
                for (let xe = 0, Ne = ae.attributesOrder.length; xe < Ne; xe++) {
                  const Ie = ae.attributesOrder[xe];
                  if (Ie in ie.map) {
                    const Fe = ie.map[Ie];
                    ye.map[Ie] = Fe, ye.push({
                      name: Ie,
                      value: Fe
                    });
                  }
                }
                for (let xe = 0, Ne = ie.length; xe < Ne; xe++) {
                  const Ie = ie[xe].name;
                  if (!(Ie in ye.map)) {
                    const Fe = ie.map[Ie];
                    ye.map[Ie] = Fe, ye.push({
                      name: Ie,
                      value: Fe
                    });
                  }
                }
                ie = ye;
              }
            }
            if (n.start(U, ie, G), Ml(U))
              Ot(k.value) && n.text(k.value, !0), n.end(U);
            else if (!G) {
              let ye = k.firstChild;
              if (ye) {
                (U === "pre" || U === "textarea") && ye.type === 3 && ((D = ye.value) === null || D === void 0 ? void 0 : D[0]) === `
` && n.text(`
`, !0);
                do
                  h(ye);
                while (ye = ye.next);
              }
              n.end(U);
            }
          }
        };
        return a.type === 1 && !e.inner ? h(a) : a.type === 3 ? d[3](a) : d[11](a), n.getContent();
      } };
    }, ry = /* @__PURE__ */ new Set();
    ut([
      "margin",
      "margin-left",
      "margin-right",
      "margin-top",
      "margin-bottom",
      "padding",
      "padding-left",
      "padding-right",
      "padding-top",
      "padding-bottom",
      "border",
      "border-width",
      "border-style",
      "border-color",
      "background",
      "background-attachment",
      "background-clip",
      "background-color",
      "background-image",
      "background-origin",
      "background-position",
      "background-repeat",
      "background-size",
      "float",
      "position",
      "left",
      "right",
      "top",
      "bottom",
      "z-index",
      "display",
      "transform",
      "width",
      "max-width",
      "min-width",
      "height",
      "max-height",
      "min-height",
      "overflow",
      "overflow-x",
      "overflow-y",
      "text-overflow",
      "vertical-align",
      "transition",
      "transition-delay",
      "transition-duration",
      "transition-property",
      "transition-timing-function"
    ], (t) => {
      ry.add(t);
    });
    const qS = [
      "font",
      "text-decoration",
      "text-emphasis"
    ], Hk = (e, t) => Nt(e.parseStyle(e.getAttrib(t, "style"))), Uz = (e) => ry.has(e), rx = (e, t) => Ns(Hk(e, t), (n) => !Uz(n)), GS = (e) => ct(e, (t) => cr(qS, (n) => Dr(t, n))), jz = (e, t, n) => {
      const r = Hk(e, t), a = Hk(e, n), c = (d) => {
        var h, k;
        const D = (h = e.getStyle(t, d)) !== null && h !== void 0 ? h : "", H = (k = e.getStyle(n, d)) !== null && k !== void 0 ? k : "";
        return Na(D) && Na(H) && D !== H;
      };
      return cr(r, (d) => {
        const h = (k) => cr(k, (D) => D === d);
        if (!h(a) && h(qS)) {
          const k = GS(a);
          return cr(k, c);
        } else
          return c(d);
      });
    }, Zz = (e, t, n) => K.from(n.container()).filter(At).exists((r) => {
      const a = e ? 0 : -1;
      return t(r.data.charAt(n.offset() + a));
    }), sx = Tt(Zz, !0, b0), ax = Tt(Zz, !1, b0), BM = (e) => {
      const t = e.container();
      return At(t) && (t.data.length === 0 || R(t.data) && w0.isBookmarkNode(t.parentNode));
    }, Vu = (e, t) => (n) => dn(e ? 0 : -1, n).filter(t).isSome(), Vk = (e) => Rl(e) && Ya(be.fromDom(e), "display") === "block", ix = (e) => Kr(e) && !sh(e), KS = Vu(!0, Vk), Wz = Vu(!1, Vk), I0 = Vu(!0, pn), F0 = Vu(!1, pn), qz = Vu(!0, Cu), Gz = Vu(!1, Cu), $h = Vu(!0, ix), Hh = Vu(!1, ix), YS = (e) => e.slice(0, -1), XS = (e, t, n) => Dt(t, e) ? YS(hi(e, (r) => n(r) || Le(r, t))) : [], JS = (e, t) => XS(e, t, Pn), Zp = (e, t) => [e].concat(JS(e, t)), Uk = (e, t, n) => TC(e, t, n, BM), Kz = (e) => (t) => e.isBlock(Eo(t)), jk = (e, t, n) => po(Zp(be.fromDom(t.container()), e), Kz(n)), QS = (e, t, n, r) => Uk(e, t.dom, n).forall((a) => jk(t, n, r).fold(() => !Kt(a, n, t.dom), (c) => !Kt(a, n, t.dom) && Dt(c, be.fromDom(a.container())))), eE = (e, t, n, r) => jk(t, n, r).fold(() => Uk(e, t.dom, n).forall((a) => !Kt(a, n, t.dom)), (a) => Uk(e, a.dom, n).isNone()), Zk = Tt(eE, !1), Wk = Tt(eE, !0), LM = Tt(QS, !1), qk = Tt(QS, !0), Yz = (e) => Mc(e).exists(tl), lx = (e, t, n, r) => {
      const a = ct(Zp(be.fromDom(n.container()), t), (d) => r.isBlock(Eo(d))), c = ro(a).getOr(t);
      return Hf(e, c.dom, n).filter(Yz);
    }, tE = (e, t, n) => Mc(t).exists(tl) || lx(!0, e, t, n).isSome(), nE = (e, t, n) => Fu(t).exists(tl) || lx(!1, e, t, n).isSome(), Xz = Tt(lx, !1), PM = Tt(lx, !0), oE = (e) => nt.isTextPosition(e) && !e.isAtStart() && !e.isAtEnd(), Jz = (e, t, n) => {
      const r = ct(Zp(be.fromDom(t.container()), e), (a) => n.isBlock(Eo(a)));
      return ro(r).getOr(e);
    }, Qz = (e, t, n) => oE(t) ? ax(t) : ax(t) || cf(Jz(e, t, n).dom, t).exists(ax), eO = (e, t, n) => oE(t) ? sx(t) : sx(t) || kd(Jz(e, t, n).dom, t).exists(sx), Qa = (e) => So([
      "pre",
      "pre-wrap"
    ], e), cx = (e) => Mc(e).bind((t) => st(t, Ji)).exists((t) => Qa(Ya(t, "white-space"))), IM = (e, t) => cf(e.dom, t).isNone(), FM = (e, t) => kd(e.dom, t).isNone(), $0 = (e, t, n) => IM(e, t) || FM(e, t) || Zk(e, t, n) || Wk(e, t, n) || nE(e, t, n) || tE(e, t, n), sy = (e) => Xe(e) && Kr(e) && rk(e), $g = (e, t) => (n) => sy(new vi(n, e)[t]()), tO = (e, t) => {
      const n = kd(e.dom, t).getOr(t), r = $g(e.dom, "next");
      return t.isAtEnd() && (r(t.container()) || r(n.container()));
    }, nO = (e, t) => {
      const n = cf(e.dom, t).getOr(t), r = $g(e.dom, "prev");
      return t.isAtStart() && (r(t.container()) || r(n.container()));
    }, rE = (e, t, n) => cx(t) ? !1 : $0(e, t, n) || Qz(e, t, n) || eO(e, t, n), ay = (e, t, n) => cx(t) ? !1 : Zk(e, t, n) || LM(e, t, n) || nE(e, t, n) || Qz(e, t, n) || nO(e, t), $M = (e) => {
      const t = e.container(), n = e.offset();
      return At(t) && n < t.data.length ? nt(t, n + 1) : e;
    }, x1 = (e, t, n) => cx(t) ? !1 : Wk(e, t, n) || qk(e, t, n) || tE(e, t, n) || eO(e, t, n) || tO(e, t), Gk = (e, t, n) => ay(e, t, n) || x1(e, $M(t), n), sE = (e, t) => uk(e.charAt(t)), Kk = (e, t) => b0(e.charAt(t)), oO = (e) => {
      const t = e.container();
      return At(t) && _r(t.data, Bo);
    }, aE = (e) => {
      const t = e.split("");
      return oo(t, (n, r) => uk(n) && r > 0 && r < t.length - 1 && $u(t[r - 1]) && $u(t[r + 1]) ? " " : n).join("");
    }, rO = (e, t, n, r) => {
      const a = t.data, c = nt(t, 0);
      return !n && sE(a, 0) && !Gk(e, c, r) ? (t.data = " " + a.slice(1), !0) : n && Kk(a, 0) && ay(e, c, r) ? (t.data = Bo + a.slice(1), !0) : !1;
    }, HM = (e) => {
      const t = e.data, n = aE(t);
      return n !== t ? (e.data = n, !0) : !1;
    }, qf = (e, t, n, r) => {
      const a = t.data, c = nt(t, a.length - 1);
      return !n && sE(a, a.length - 1) && !Gk(e, c, r) ? (t.data = a.slice(0, -1) + " ", !0) : n && Kk(a, a.length - 1) && x1(e, c, r) ? (t.data = a.slice(0, -1) + Bo, !0) : !1;
    }, sO = (e, t, n) => {
      const r = t.container();
      if (!At(r))
        return K.none();
      if (oO(t)) {
        const a = rO(e, r, !1, n) || HM(r) || qf(e, r, !1, n);
        return Xi(a, t);
      } else if (Gk(e, t, n)) {
        const a = rO(e, r, !0, n) || qf(e, r, !0, n);
        return Xi(a, t);
      } else
        return K.none();
    }, VM = (e) => {
      const t = be.fromDom(e.getBody());
      e.selection.isCollapsed() && sO(t, nt.fromRangeStart(e.selection.getRng()), e.schema).each((n) => {
        e.selection.setRng(n.toRange());
      });
    }, aO = (e, t, n, r) => {
      if (n === 0)
        return;
      const a = be.fromDom(e), c = si(a, (D) => r.isBlock(Eo(D))).getOr(a), d = e.data.slice(t, t + n), h = t + n >= e.data.length && x1(c, nt(e, e.data.length), r), k = t === 0 && ay(c, nt(e, 0), r);
      e.replaceData(t, n, Af(d, 4, k, h));
    }, w1 = (e, t, n) => {
      const r = e.data.slice(t), a = r.length - kc(r).length;
      aO(e, t, a, n);
    }, iE = (e, t, n) => {
      const r = e.data.slice(0, t), a = r.length - gu(r).length;
      aO(e, t - a, a, n);
    }, lE = (e, t, n, r, a = !0) => {
      const c = gu(e.data).length, d = a ? e : t, h = a ? t : e;
      return a ? d.appendData(h.data) : d.insertData(0, h.data), dr(be.fromDom(h)), r && w1(d, c, n), d;
    }, iO = (e, t) => {
      const n = e.container(), r = e.offset();
      return !nt.isTextPosition(e) && n === t.parentNode && r > nt.before(t).offset();
    }, cE = (e, t) => iO(t, e) ? nt(t.container(), t.offset() - 1) : t, UM = (e) => At(e) ? nt(e, 0) : nt.before(e), jM = (e) => At(e) ? nt(e, e.data.length) : nt.after(e), uE = (e) => Sr(e.previousSibling) ? K.some(jM(e.previousSibling)) : e.previousSibling ? dp(e.previousSibling) : K.none(), dE = (e) => Sr(e.nextSibling) ? K.some(UM(e.nextSibling)) : e.nextSibling ? lu(e.nextSibling) : K.none(), k1 = (e, t) => K.from(t.previousSibling ? t.previousSibling : t.parentNode).bind((n) => cf(e, nt.before(n))).orThunk(() => kd(e, nt.after(t))), H0 = (e, t) => kd(e, nt.after(t)).orThunk(() => cf(e, nt.before(t))), ux = (e, t) => uE(t).orThunk(() => dE(t)).orThunk(() => k1(e, t)), lO = (e, t) => dE(t).orThunk(() => uE(t)).orThunk(() => H0(e, t)), cO = (e, t, n) => e ? lO(t, n) : ux(t, n), ZM = (e, t, n) => cO(e, t, n).map(Tt(cE, n)), fE = (e, t, n) => {
      n.fold(() => {
        e.focus();
      }, (r) => {
        e.selection.setRng(r.toRange(), t);
      });
    }, dx = (e) => (t) => t.dom === e, uO = (e, t) => t && Yn(e.schema.getBlockElements(), Eo(t)), dO = (e, t) => {
      if (Yr(e)) {
        const n = be.fromHtml('<br data-mce-bogus="1">');
        return t ? ut(Pr(e), (r) => {
          _d(r) || dr(r);
        }) : yi(e), Ir(e, n), K.some(nt.before(n.dom));
      } else
        return K.none();
    }, fO = (e, t, n, r) => {
      const a = Ps(e).filter(Zs), c = Di(e).filter(Zs);
      return dr(e), ag(a, c, t, (d, h, k) => {
        const D = d.dom, H = h.dom, U = D.data.length;
        return lE(D, H, n, r), k.container() === H ? nt(D, U) : k;
      }).orThunk(() => (r && (a.each((d) => iE(d.dom, d.dom.length, n)), c.each((d) => w1(d.dom, 0, n))), t));
    }, WM = (e, t) => Yn(e.schema.getTextInlineElements(), Eo(t)), Uu = (e, t, n, r = !0, a = !1) => {
      const c = ZM(t, e.getBody(), n.dom), d = si(n, Tt(uO, e), dx(e.getBody())), h = fO(n, c, e.schema, WM(e, n));
      e.dom.isEmpty(e.getBody()) ? (e.setContent(""), e.selection.setCursorLocation()) : d.bind((k) => dO(k, a)).fold(() => {
        r && fE(e, t, h);
      }, (k) => {
        r && fE(e, t, K.some(k));
      });
    }, mE = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/, qM = (e) => mE.test(e), _1 = (e, t) => Ai(be.fromDom(t), Xn(e)) && !ef(e.schema, t) && e.dom.isEditable(t), Fr = (e) => {
      var t;
      return gs.DOM.getStyle(e, "direction", !0) === "rtl" || qM((t = e.textContent) !== null && t !== void 0 ? t : "");
    }, GM = (e, t, n) => ct(gs.DOM.getParents(n.container(), "*", t), e), iy = (e, t, n) => {
      const r = GM(e, t, n);
      return K.from(r[r.length - 1]);
    }, Aa = (e, t, n) => {
      const r = Yt(t, e), a = Yt(n, e);
      return Xe(r) && r === a;
    }, KM = (e) => _o(e) || fr(e), ju = (e, t) => {
      const n = t.container(), r = t.offset();
      return e ? on(n) ? At(n.nextSibling) ? nt(n.nextSibling, 0) : nt.after(n) : _o(t) ? nt(n, r + 1) : t : on(n) ? At(n.previousSibling) ? nt(n.previousSibling, n.previousSibling.data.length) : nt.before(n) : fr(t) ? nt(n, r - 1) : t;
    }, mO = Tt(ju, !0), pE = Tt(ju, !1), Vh = (e, t) => {
      const n = (r) => r.stopImmediatePropagation();
      e.on("beforeinput input", n, !0), e.getDoc().execCommand(t), e.off("beforeinput input", n);
    }, df = (e) => {
      e.execCommand("delete");
    }, C1 = (e) => Vh(e, "Delete"), ly = (e) => Vh(e, "ForwardDelete"), Hg = (e) => (t) => Pd(Br(t), e, Le), fx = (e) => cm(e) || Jd(e), V0 = (e, t) => Dt(e, t) ? st(t, fx, Hg(e)) : K.none(), mx = (e, t = !0) => {
      e.dom.isEmpty(e.getBody()) && e.setContent("", { no_selection: !t });
    }, gE = (e, t, n) => ns(lu(n), dp(n), (r, a) => {
      const c = ju(!0, r), d = ju(!1, a), h = ju(!1, t);
      return e ? kd(n, h).exists((k) => k.isEqual(d) && t.isEqual(c)) : cf(n, h).exists((k) => k.isEqual(c) && t.isEqual(d));
    }).getOr(!0), hE = (e) => (td(e) ? Ps(e) : xa(e)).bind(hE).orThunk(() => K.some(e)), pO = (e, t, n, r = !0) => {
      var a;
      t.deleteContents();
      const c = hE(n).getOr(n), d = be.fromDom((a = e.dom.getParent(c.dom, e.dom.isBlock)) !== null && a !== void 0 ? a : n.dom);
      if (d.dom === e.getBody() ? mx(e, r) : Yr(d) && (zf(d), r && e.selection.setCursorLocation(d.dom, 0)), !Le(n, d)) {
        const h = Pd(Br(d), n) ? [] : Nn(d);
        ut(h.concat(Pr(n)), (k) => {
          !Le(k, d) && !Dt(k, d) && Yr(k) && dr(k);
        });
      }
    }, YM = (e, t, n) => si(e, t, n).isSome(), gO = (e, t) => zl(e, t).isSome(), bE = (e, t) => Is(e, t).isSome(), hO = (e) => (t) => Le(e, t), Yk = (e) => Ni(e, "td,th"), Xk = (e, t) => Wb(be.fromDom(e), t), XM = (e) => ns(e.startTable, e.endTable, (t, n) => {
      const r = bE(t, (c) => Le(c, n)), a = bE(n, (c) => Le(c, t));
      return !r && !a ? e : {
        ...e,
        startTable: r ? K.none() : e.startTable,
        endTable: a ? K.none() : e.endTable,
        isSameTable: !1,
        isMultiTable: !1
      };
    }).getOr(e), JM = (e) => XM(e), QM = (e, t) => {
      const n = Xk(e.startContainer, t), r = Xk(e.endContainer, t), a = n.isSome(), c = r.isSome(), d = ns(n, r, Le).getOr(!1);
      return JM({
        startTable: n,
        endTable: r,
        isStartInTable: a,
        isEndInTable: c,
        isSameTable: d,
        isMultiTable: !d && a && c
      });
    }, gp = (e, t) => ({
      start: e,
      end: t
    }), px = (e, t, n) => ({
      rng: e,
      table: t,
      cells: n
    }), U0 = $e.generate([
      {
        singleCellTable: [
          "rng",
          "cell"
        ]
      },
      { fullTable: ["table"] },
      {
        partialTable: [
          "cells",
          "outsideDetails"
        ]
      },
      {
        multiTable: [
          "startTableCells",
          "endTableCells",
          "betweenRng"
        ]
      }
    ]), gx = (e, t) => el(be.fromDom(e), "td,th", t), yE = (e) => !Le(e.start, e.end), bO = (e, t) => Wb(e.start, t).bind((n) => Wb(e.end, t).bind((r) => Xi(Le(n, r), n))), cy = (e, t) => !yE(e) && bO(e, t).exists((n) => {
      const r = n.dom.rows;
      return r.length === 1 && r[0].cells.length === 1;
    }), eB = (e, t) => {
      const n = gx(e.startContainer, t), r = gx(e.endContainer, t);
      return ns(n, r, gp);
    }, tB = (e) => (t) => Wb(t, e).bind((n) => cn(Yk(n)).map((r) => gp(t, r))), nB = (e) => (t) => Wb(t, e).bind((n) => ro(Yk(n)).map((r) => gp(r, t))), vE = (e) => (t) => bO(t, e).map((n) => px(t, n, Yk(n))), yO = (e, t, n, r) => {
      if (n.collapsed || !e.forall(yE))
        return K.none();
      if (t.isSameTable) {
        const a = e.bind(vE(r));
        return K.some({
          start: a,
          end: a
        });
      } else {
        const a = gx(n.startContainer, r), c = gx(n.endContainer, r), d = a.bind(tB(r)).bind(vE(r)), h = c.bind(nB(r)).bind(vE(r));
        return K.some({
          start: d,
          end: h
        });
      }
    }, vO = (e, t) => Ra(e, (n) => Le(n, t)), xE = (e) => ns(vO(e.cells, e.rng.start), vO(e.cells, e.rng.end), (t, n) => e.cells.slice(t, n + 1)), oB = (e, t, n) => e.exists((r) => cy(r, n) && IC(r.start, t)), xO = (e, t) => {
      const { startTable: n, endTable: r } = t, a = e.cloneRange();
      return n.each((c) => a.setStartAfter(c.dom)), r.each((c) => a.setEndBefore(c.dom)), a;
    }, Jk = (e, t, n, r) => yO(e, t, n, r).bind(({ start: a, end: c }) => a.or(c)).bind((a) => {
      const { isSameTable: c } = t, d = xE(a).getOr([]);
      if (c && a.cells.length === d.length)
        return K.some(U0.fullTable(a.table));
      if (d.length > 0) {
        if (c)
          return K.some(U0.partialTable(d, K.none()));
        {
          const h = xO(n, t);
          return K.some(U0.partialTable(d, K.some({
            ...t,
            rng: h
          })));
        }
      } else
        return K.none();
    }), rB = (e, t, n, r) => yO(e, t, n, r).bind(({ start: a, end: c }) => {
      const d = a.bind(xE).getOr([]), h = c.bind(xE).getOr([]);
      if (d.length > 0 && h.length > 0) {
        const k = xO(n, t);
        return K.some(U0.multiTable(d, h, k));
      } else
        return K.none();
    }), hx = (e, t) => {
      const n = hO(e), r = eB(t, n), a = QM(t, n);
      return oB(r, t, n) ? r.map((c) => U0.singleCellTable(t, c.start)) : a.isMultiTable ? rB(r, a, t, n) : Jk(r, a, t, n);
    }, Qk = (e) => ut(e, (t) => {
      xs(t, "contenteditable"), zf(t);
    }), S1 = (e, t) => K.from(e.dom.getParent(t, e.dom.isBlock)).map(be.fromDom), E1 = (e, t, n) => {
      n.each((r) => {
        t ? dr(r) : (zf(r), e.selection.setCursorLocation(r.dom, 0));
      });
    }, j0 = (e, t, n, r) => {
      const a = n.cloneRange();
      r ? (a.setStart(n.startContainer, n.startOffset), a.setEndAfter(t.dom.lastChild)) : (a.setStartBefore(t.dom.firstChild), a.setEnd(n.endContainer, n.endOffset)), Z0(e, a, t, !1).each((c) => c());
    }, bx = (e) => {
      const t = Pg(e), n = be.fromDom(e.selection.getNode());
      Sf(n.dom) && Yr(n) ? e.selection.setCursorLocation(n.dom, 0) : e.selection.collapse(!0), t.length > 1 && cr(t, (r) => Le(r, n)) && Vr(n, "data-mce-selected", "1");
    }, uy = (e, t, n) => K.some(() => {
      const r = e.selection.getRng(), a = n.bind(({ rng: c, isStartInTable: d }) => {
        const h = S1(e, d ? c.endContainer : c.startContainer);
        c.deleteContents(), E1(e, d, h.filter(Yr));
        const k = d ? t[0] : t[t.length - 1];
        return j0(e, k, r, d), Yr(k) ? K.none() : K.some(d ? t.slice(1) : t.slice(0, -1));
      }).getOr(t);
      Qk(a), bx(e);
    }), T1 = (e, t, n, r) => K.some(() => {
      const a = e.selection.getRng(), c = t[0], d = n[n.length - 1];
      j0(e, c, a, !0), j0(e, d, a, !1);
      const h = Yr(c) ? t : t.slice(1), k = Yr(d) ? n : n.slice(0, -1);
      Qk(h.concat(k)), r.deleteContents(), bx(e);
    }), Z0 = (e, t, n, r = !0) => K.some(() => {
      pO(e, t, n, r);
    }), e_ = (e, t) => K.some(() => Uu(e, !1, t)), wO = (e, t, n) => hx(t, n).bind((r) => r.fold(Tt(Z0, e), Tt(e_, e), Tt(uy, e), Tt(T1, e))), wE = (e, t) => yx(e, t), kE = (e, t, n, r) => dy(t, r).fold(() => wO(e, t, n), (a) => wE(e, a)), kO = (e, t, n) => {
      const r = be.fromDom(e.getBody()), a = e.selection.getRng();
      return n.length !== 0 ? uy(e, n, K.none()) : kE(e, r, a, t);
    }, _E = (e, t) => po(Zp(t, e), Tf), dy = (e, t) => po(Zp(t, e), ya("caption")), _O = (e, t, n, r, a) => d1(n, e.getBody(), a).bind((c) => _E(t, be.fromDom(c.getNode())).bind((d) => Le(d, r) ? K.none() : K.some(ht))), yx = (e, t) => K.some(() => {
      zf(t), e.selection.setCursorLocation(t.dom, 0);
    }), CO = (e, t, n, r) => lu(e.dom).bind((a) => dp(e.dom).map((c) => t ? n.isEqual(a) && r.isEqual(c) : n.isEqual(c) && r.isEqual(a))).getOr(!0), t_ = (e, t) => yx(e, t), SO = (e, t, n) => dy(e, be.fromDom(n.getNode())).fold(() => K.some(ht), (r) => Xi(!Le(r, t), ht)), EO = (e, t, n, r, a) => d1(n, e.getBody(), a).fold(() => K.some(ht), (c) => CO(r, n, a, c) ? t_(e, r) : SO(t, r, c)), TO = (e, t, n, r) => {
      const a = nt.fromRangeStart(e.selection.getRng());
      return _E(n, r).bind((c) => Yr(c) ? yx(e, c) : _O(e, n, t, c, a));
    }, zO = (e, t, n, r) => {
      const a = nt.fromRangeStart(e.selection.getRng());
      return Yr(r) ? yx(e, r) : EO(e, n, t, r, a);
    }, Vg = (e, t) => e ? qz(t) : Gz(t), fy = (e, t) => {
      const n = nt.fromRangeStart(e.selection.getRng());
      return Vg(t, n) || Hf(t, e.getBody(), n).exists((r) => Vg(t, r));
    }, hp = (e, t, n) => {
      const r = be.fromDom(e.getBody());
      return dy(r, n).fold(() => TO(e, t, r, n).orThunk(() => Xi(fy(e, t), ht)), (a) => zO(e, t, r, a));
    }, vx = (e, t) => {
      const n = be.fromDom(e.selection.getStart(!0)), r = Pg(e);
      return e.selection.isCollapsed() && r.length === 0 ? hp(e, t, n) : kO(e, n, r);
    }, Uh = (e, t) => {
      let n = t;
      for (; n && n !== e; ) {
        if (cc(n) || Kr(n))
          return n;
        n = n.parentNode;
      }
      return null;
    }, OO = [
      "data-ephox-",
      "data-mce-",
      "data-alloy-",
      "data-snooker-",
      "_"
    ], AO = Ht.each, n_ = (e) => {
      const t = e.dom, n = new Set(e.serializer.getTempAttrs()), r = (c, d) => {
        if (c.nodeName !== d.nodeName || c.nodeType !== d.nodeType)
          return !1;
        const h = (D) => {
          const H = {};
          return AO(t.getAttribs(D), (U) => {
            const G = U.nodeName.toLowerCase();
            G !== "style" && !a(G) && (H[G] = t.getAttrib(D, G));
          }), H;
        }, k = (D, H) => {
          for (const U in D)
            if (Yn(D, U)) {
              const G = H[U];
              if (ko(G) || D[U] !== G)
                return !1;
              delete H[U];
            }
          for (const U in H)
            if (Yn(H, U))
              return !1;
          return !0;
        };
        return wn(c) && wn(d) && (!k(h(c), h(d)) || !k(t.parseStyle(t.getAttrib(c, "style")), t.parseStyle(t.getAttrib(d, "style")))) ? !1 : !Vf(c) && !Vf(d);
      }, a = (c) => cr(OO, (d) => Dr(c, d)) || n.has(c);
      return {
        compare: r,
        isAttributeInternal: a
      };
    }, o_ = (e) => [
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6"
    ].includes(e.name), DO = (e) => e.name === "summary", RO = (e, t) => {
      let n = e;
      for (; n = n.walk(); )
        t(n);
    }, r_ = (e, t, n, r) => {
      const a = n.name;
      for (let c = 0, d = e.length; c < d; c++) {
        const h = e[c];
        if (h.name === a) {
          const k = r.nodes[a];
          k ? k.nodes.push(n) : r.nodes[a] = {
            filter: h,
            nodes: [n]
          };
        }
      }
      if (n.attributes)
        for (let c = 0, d = t.length; c < d; c++) {
          const h = t[c], k = h.name;
          if (k in n.attributes.map) {
            const D = r.attributes[k];
            D ? D.nodes.push(n) : r.attributes[k] = {
              filter: h,
              nodes: [n]
            };
          }
        }
    }, Ug = (e, t, n) => {
      const r = {
        nodes: {},
        attributes: {}
      };
      return n.firstChild && RO(n, (a) => {
        r_(e, t, a, r);
      }), r;
    }, Om = (e, t) => {
      const n = (r, a) => {
        Zo(r, (c) => {
          const d = _n(c.nodes);
          ut(c.filter.callbacks, (h) => {
            for (let k = d.length - 1; k >= 0; k--) {
              const D = d[k];
              (!(a ? D.attr(c.filter.name) !== void 0 : D.name === c.filter.name) || jn(D.parent)) && d.splice(k, 1);
            }
            d.length > 0 && h(d, c.filter.name, t);
          });
        });
      };
      n(e.nodes, !1), n(e.attributes, !0);
    }, xx = (e, t, n, r = {}) => {
      const a = Ug(e, t, n);
      Om(a, r);
    }, s_ = (e, t, n, r) => {
      if ((e.pad_empty_with_br || t.insert) && n(r)) {
        const c = new qc("br", 1);
        t.insert && c.attr("data-mce-bogus", "1"), r.empty().append(c);
      } else
        r.empty().append(new qc("#text", 3)).value = Bo;
    }, a_ = (e) => {
      var t;
      return CE(e, "#text") && ((t = e == null ? void 0 : e.firstChild) === null || t === void 0 ? void 0 : t.value) === Bo;
    }, CE = (e, t) => {
      const n = e == null ? void 0 : e.firstChild;
      return Xe(n) && n === e.lastChild && n.name === t;
    }, NO = (e, t) => {
      const n = e.getElementRule(t.name);
      return (n == null ? void 0 : n.paddEmpty) === !0;
    }, W0 = (e, t, n, r) => r.isEmpty(t, n, (a) => NO(e, a)), MO = (e, t) => Xe(e) && (t(e) || e.name === "br"), BO = (e) => {
      let t;
      for (let n = e; n; n = n.parent) {
        const r = n.attr("contenteditable");
        if (r === "false")
          break;
        r === "true" && (t = n);
      }
      return K.from(t);
    }, i_ = (e, t, n = e.parent) => {
      if (t.getSpecialElements()[e.name])
        e.empty().remove();
      else {
        const r = e.children();
        for (const a of r)
          n && !t.isValidChild(n.name, a.name) && i_(a, t, n);
        e.unwrap();
      }
    }, q0 = (e, t, n, r = ht) => {
      const a = t.getTextBlockElements(), c = t.getNonEmptyElements(), d = t.getWhitespaceElements(), h = Ht.makeMap("tr,td,th,tbody,thead,tfoot,table,summary"), k = /* @__PURE__ */ new Set(), D = (H) => H !== n && !h[H.name];
      for (let H = 0; H < e.length; H++) {
        const U = e[H];
        let G, ie, ye;
        if (!U.parent || k.has(U))
          continue;
        if (a[U.name] && U.parent.name === "li") {
          let xe = U.next;
          for (; xe && a[xe.name]; ) {
            xe.name = "li", k.add(xe), U.parent.insert(xe, U.parent);
            xe = xe.next;
          }
          U.unwrap();
          continue;
        }
        const ae = [U];
        for (G = U.parent; G && !t.isValidChild(G.name, U.name) && D(G); G = G.parent)
          ae.push(G);
        if (G && ae.length > 1)
          if (l_(t, U, G))
            i_(U, t);
          else {
            ae.reverse(), ie = ae[0].clone(), r(ie);
            let xe = ie;
            for (let Ne = 0; Ne < ae.length - 1; Ne++) {
              t.isValidChild(xe.name, ae[Ne].name) && Ne > 0 ? (ye = ae[Ne].clone(), r(ye), xe.append(ye)) : ye = xe;
              for (let Ie = ae[Ne].firstChild; Ie && Ie !== ae[Ne + 1]; ) {
                const Fe = Ie.next;
                ye.append(Ie), Ie = Fe;
              }
              xe = ye;
            }
            W0(t, c, d, ie) ? G.insert(U, ae[0], !0) : (G.insert(ie, ae[0], !0), G.insert(U, ie)), G = ae[0], (W0(t, c, d, G) || CE(G, "br")) && G.empty().remove();
          }
        else if (U.parent) {
          if (U.name === "li") {
            let xe = U.prev;
            if (xe && (xe.name === "ul" || xe.name === "ol")) {
              xe.append(U);
              continue;
            }
            if (xe = U.next, xe && (xe.name === "ul" || xe.name === "ol") && xe.firstChild) {
              xe.insert(U, xe.firstChild, !0);
              continue;
            }
            const Ne = new qc("ul", 1);
            r(Ne), U.wrap(Ne);
            continue;
          }
          if (t.isValidChild(U.parent.name, "div") && t.isValidChild("div", U.name)) {
            const xe = new qc("div", 1);
            r(xe), U.wrap(xe);
          } else
            i_(U, t);
        }
      }
    }, SE = (e, t) => {
      let n = e;
      for (; n; ) {
        if (n.name === t)
          return !0;
        n = n.parent;
      }
      return !1;
    }, l_ = (e, t, n = t.parent) => n ? e.children[t.name] && !e.isValidChild(n.name, t.name) || t.name === "a" && SE(n, "a") ? !0 : DO(n) && o_(t) ? !((n == null ? void 0 : n.firstChild) === t && (n == null ? void 0 : n.lastChild) === t) : !1 : !1, EE = (e, t, n, r) => {
      const a = document.createRange();
      return a.setStart(e, t), a.setEnd(n, r), a;
    }, sB = (e) => {
      const t = nt.fromRangeStart(e), n = nt.fromRangeEnd(e), r = e.commonAncestorContainer;
      return Hf(!1, r, n).map((a) => !Kt(t, n, r) && Kt(t, a, r) ? EE(t.container(), t.offset(), a.container(), a.offset()) : e).getOr(e);
    }, TE = (e) => e.collapsed ? e : sB(e), aB = (e) => Xe(e.firstChild) && e.firstChild === e.lastChild, iB = (e) => e.name === "br" || e.value === Bo, lB = (e, t) => e.getBlockElements()[t.name] && aB(t) && iB(t.firstChild), cB = (e, t) => {
      const n = e.getNonEmptyElements();
      return Xe(t) && (t.isEmpty(n) || lB(e, t));
    }, c_ = (e, t) => {
      let n = t.firstChild, r = t.lastChild;
      return n && n.name === "meta" && (n = n.next), r && r.attr("id") === "mce_marker" && (r = r.prev), cB(e, r) && (r = r == null ? void 0 : r.prev), !n || n !== r ? !1 : n.name === "ul" || n.name === "ol";
    }, zE = (e) => {
      var t, n;
      const r = e.firstChild, a = e.lastChild;
      return r && r.nodeName === "META" && ((t = r.parentNode) === null || t === void 0 || t.removeChild(r)), a && a.id === "mce_marker" && ((n = a.parentNode) === null || n === void 0 || n.removeChild(a)), e;
    }, LO = (e, t, n) => {
      const r = t.serialize(n), a = e.createFragment(r);
      return zE(a);
    }, OE = (e) => {
      var t;
      return ct((t = e == null ? void 0 : e.childNodes) !== null && t !== void 0 ? t : [], (n) => n.nodeName === "LI");
    }, uB = (e) => e.data === Bo || cs(e), dB = (e) => Xe(e == null ? void 0 : e.firstChild) && e.firstChild === e.lastChild && uB(e.firstChild), fB = (e) => !e.firstChild || dB(e), mB = (e) => e.length > 0 && fB(e[e.length - 1]) ? e.slice(0, -1) : e, AE = (e, t) => {
      const n = e.getParent(t, e.isBlock);
      return n && n.nodeName === "LI" ? n : null;
    }, pB = (e, t) => !!AE(e, t), u_ = (e, t) => {
      const n = t.cloneRange(), r = t.cloneRange();
      return n.setStartBefore(e), r.setEndAfter(e), [
        n.cloneContents(),
        r.cloneContents()
      ];
    }, d_ = (e, t) => {
      const n = nt.before(e), a = Bg(t).next(n);
      return a ? a.toRange() : null;
    }, wx = (e, t) => {
      const n = nt.after(e), a = Bg(t).prev(n);
      return a ? a.toRange() : null;
    }, gB = (e, t, n, r) => {
      const a = u_(e, r), c = e.parentNode;
      return c && (c.insertBefore(a[0], e), Ht.each(t, (d) => {
        c.insertBefore(d, e);
      }), c.insertBefore(a[1], e), c.removeChild(e)), wx(t[t.length - 1], n);
    }, hB = (e, t, n) => {
      const r = e.parentNode;
      return r && Ht.each(t, (a) => {
        r.insertBefore(a, e);
      }), d_(e, n);
    }, bB = (e, t, n, r) => (r.insertAfter(t.reverse(), e), wx(t[0], n)), yB = (e, t, n, r) => {
      const a = LO(t, e, r), c = AE(t, n.startContainer), d = mB(OE(a.firstChild)), h = 1, k = 2, D = t.getRoot(), H = (U) => {
        const G = nt.fromRangeStart(n), ie = Bg(t.getRoot()), ye = U === h ? ie.prev(G) : ie.next(G), ae = ye == null ? void 0 : ye.getNode();
        return ae ? AE(t, ae) !== c : !0;
      };
      return c ? H(h) ? hB(c, d, D) : H(k) ? bB(c, d, D, t) : gB(c, d, D, n) : null;
    }, vB = ["pre"], xB = (e, t, n, r) => {
      var a;
      const c = t.firstChild, d = t.lastChild, h = d.attr("data-mce-type") === "bookmark" ? d.prev : d, k = c === h, D = So(vB, c.name);
      if (k && D) {
        const H = c.attr("contenteditable") !== "false", U = ((a = e.getParent(n, e.isBlock)) === null || a === void 0 ? void 0 : a.nodeName.toLowerCase()) === c.name, G = K.from(Uh(r, n)).forall(cc);
        return H && U && G;
      } else
        return !1;
    }, Gf = Sf, DE = (e, t, n) => {
      if (Xe(n)) {
        const r = e.getParent(t.endContainer, Gf);
        return n === r && IC(be.fromDom(n), t);
      } else
        return !1;
    }, PO = (e, t, n) => {
      var r;
      if (n.getAttribute("data-mce-bogus") === "all")
        (r = n.parentNode) === null || r === void 0 || r.insertBefore(e.dom.createFragment(t), n);
      else {
        const a = n.firstChild, c = n.lastChild;
        !a || a === c && a.nodeName === "BR" ? e.dom.setHTML(n, t) : e.selection.setContent(t, { no_events: !0 });
      }
    }, IO = (e, t, n) => {
      K.from(e.getParent(t, "td,th")).map(be.fromDom).each((r) => tb(r, n));
    }, FO = (e, t) => {
      const n = e.schema.getTextInlineElements(), r = e.dom;
      if (t) {
        const a = e.getBody(), c = n_(e);
        Ht.each(r.select("*[data-mce-fragment]"), (d) => {
          if (Xe(n[d.nodeName.toLowerCase()]) && rx(r, d)) {
            for (let k = d.parentElement; Xe(k) && k !== a && !jz(r, d, k); k = k.parentElement)
              if (c.compare(k, d)) {
                r.remove(d, !0);
                break;
              }
          }
        });
      }
    }, wB = (e) => {
      let t = e;
      for (; t = t.walk(); )
        t.type === 1 && t.attr("data-mce-fragment", "1");
    }, $O = (e) => {
      Ht.each(e.getElementsByTagName("*"), (t) => {
        t.removeAttribute("data-mce-fragment");
      });
    }, kB = (e) => !!e.getAttribute("data-mce-fragment"), G0 = (e, t) => Xe(t) && !e.schema.getVoidElements()[t.nodeName], HO = (e, t) => {
      var n, r, a;
      let c;
      const d = e.dom, h = e.selection;
      if (!t)
        return;
      h.scrollIntoView(t);
      const k = Uh(e.getBody(), t);
      if (k && d.getContentEditable(k) === "false") {
        d.remove(t), h.select(k);
        return;
      }
      let D = d.createRng();
      const H = t.previousSibling;
      if (At(H)) {
        D.setStart(H, (r = (n = H.nodeValue) === null || n === void 0 ? void 0 : n.length) !== null && r !== void 0 ? r : 0);
        const ie = t.nextSibling;
        At(ie) && (H.appendData(ie.data), (a = ie.parentNode) === null || a === void 0 || a.removeChild(ie));
      } else
        D.setStartBefore(t), D.setEndBefore(t);
      const U = (ie) => {
        let ye = nt.fromRangeStart(ie);
        return ye = Bg(e.getBody()).next(ye), ye == null ? void 0 : ye.toRange();
      }, G = d.getParent(t, d.isBlock);
      if (d.remove(t), G && d.isEmpty(G)) {
        const ie = Gf(G);
        yi(be.fromDom(G)), D.setStart(G, 0), D.setEnd(G, 0), !ie && !kB(G) && (c = U(D)) ? (D = c, d.remove(G)) : d.add(G, d.create("br", ie ? {} : { "data-mce-bogus": "1" }));
      }
      h.setRng(D);
    }, VO = (e) => {
      const t = e.dom, n = TE(e.selection.getRng());
      e.selection.setRng(n);
      const r = t.getParent(n.startContainer, Gf);
      DE(t, n, r) ? Z0(e, n, be.fromDom(r)) : n.startContainer === n.endContainer && n.endOffset - n.startOffset === 1 && At(n.startContainer.childNodes[n.startOffset]) ? n.deleteContents() : e.getDoc().execCommand("Delete", !1);
    }, UO = (e) => {
      for (let t = e; t; t = t.walk())
        if (t.attr("id") === "mce_marker")
          return K.some(t);
      return K.none();
    }, RE = (e, t, n) => {
      var r;
      return cr(n.children(), o_) && ((r = e.getParent(t, e.isBlock)) === null || r === void 0 ? void 0 : r.nodeName) === "SUMMARY";
    }, _B = (e, t, n) => {
      var r, a;
      const c = e.selection, d = e.dom, h = e.parser, k = n.merge, D = Jl({ validate: !0 }, e.schema), H = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
      n.preserve_zwsp || (t = q(t)), t.indexOf("{$caret}") === -1 && (t += "{$caret}"), t = t.replace(/\{\$caret\}/, H);
      let U = c.getRng();
      const G = U.startContainer, ie = e.getBody();
      G === ie && c.isCollapsed() && d.isBlock(ie.firstChild) && G0(e, ie.firstChild) && d.isEmpty(ie.firstChild) && (U = d.createRng(), U.setStart(ie.firstChild, 0), U.setEnd(ie.firstChild, 0), c.setRng(U)), c.isCollapsed() || VO(e);
      const ye = c.getNode(), ae = {
        context: ye.nodeName.toLowerCase(),
        data: n.data,
        insert: !0
      }, xe = h.parse(t, ae);
      if (n.paste === !0 && c_(e.schema, xe) && pB(d, ye))
        return U = yB(D, d, c.getRng(), xe), U && c.setRng(U), t;
      n.paste === !0 && xB(d, xe, ye, e.getBody()) && ((r = xe.firstChild) === null || r === void 0 || r.unwrap()), wB(xe);
      let Ne = xe.lastChild;
      if (Ne && Ne.attr("id") === "mce_marker") {
        const Ie = Ne;
        for (Ne = Ne.prev; Ne; Ne = Ne.walk(!0))
          if (Ne.type === 3 || !d.isBlock(Ne.name)) {
            Ne.parent && e.schema.isValidChild(Ne.parent.name, "span") && Ne.parent.insert(Ie, Ne, Ne.name === "br");
            break;
          }
      }
      if (e._selectionOverrides.showBlockCaretContainer(ye), !ae.invalid && !RE(d, ye, xe))
        t = D.serialize(xe), PO(e, t, ye);
      else {
        e.selection.setContent(H);
        let Ie = c.getNode(), Fe;
        const je = e.getBody();
        for (Dl(Ie) ? Ie = Fe = je : Fe = Ie; Fe && Fe !== je; )
          Ie = Fe, Fe = Fe.parentNode;
        t = Ie === je ? je.innerHTML : d.getOuterHTML(Ie);
        const _t = h.parse(t), Zt = UO(_t), fn = Zt.bind(BO).getOr(_t);
        Zt.each((gn) => gn.replace(xe));
        const at = xe.children(), et = (a = xe.parent) !== null && a !== void 0 ? a : _t;
        xe.unwrap();
        const Mt = ct(at, (gn) => l_(e.schema, gn, et));
        q0(Mt, e.schema, fn), xx(h.getNodeFilters(), h.getAttributeFilters(), _t), t = D.serialize(_t), Ie === je ? d.setHTML(je, t) : d.setOuterHTML(Ie, t);
      }
      return FO(e, k), HO(e, d.get("mce_marker")), $O(e.getBody()), IO(d, c.getStart(), e.schema), ch(e.schema, e.getBody(), c.getStart()), t;
    }, f_ = (e) => e instanceof qc, my = (e) => {
      ty(e) && lu(e.getBody()).each((t) => {
        const n = t.getNode(), r = Cu(n) ? lu(n).getOr(t) : t;
        e.selection.setRng(r.toRange());
      });
    }, kx = (e, t, n) => {
      e.dom.setHTML(e.getBody(), t), n !== !0 && my(e);
    }, CB = (e, t, n, r) => {
      if (n = q(n), n.length === 0 || /^\s+$/.test(n)) {
        const a = '<br data-mce-bogus="1">';
        t.nodeName === "TABLE" ? n = "<tr><td>" + a + "</td></tr>" : /^(UL|OL)$/.test(t.nodeName) && (n = "<li>" + a + "</li>");
        const c = li(e);
        return e.schema.isValidChild(t.nodeName.toLowerCase(), c.toLowerCase()) ? (n = a, n = e.dom.createHTML(c, Mg(e), n)) : n || (n = a), kx(e, n, r.no_selection), {
          content: n,
          html: n
        };
      } else {
        r.format !== "raw" && (n = Jl({ validate: !1 }, e.schema).serialize(e.parser.parse(n, {
          isRootContent: !0,
          insert: !0
        })));
        const a = um(be.fromDom(t)) ? n : Ht.trim(n);
        return kx(e, a, r.no_selection), {
          content: a,
          html: a
        };
      }
    }, SB = (e, t, n, r) => {
      xx(e.parser.getNodeFilters(), e.parser.getAttributeFilters(), n);
      const a = Jl({ validate: !1 }, e.schema).serialize(n), c = q(um(be.fromDom(t)) ? a : Ht.trim(a));
      return kx(e, c, r.no_selection), {
        content: n,
        html: c
      };
    }, z1 = (e, t, n) => K.from(e.getBody()).map((r) => f_(t) ? SB(e, r, t, n) : CB(e, r, t, n)).getOr({
      content: t,
      html: f_(n.content) ? "" : n.content
    }), NE = (e) => un(e) ? e : Pn, m_ = (e, t, n) => {
      let r = e.dom;
      const a = NE(n);
      for (; r.parentNode; ) {
        r = r.parentNode;
        const c = be.fromDom(r), d = t(c);
        if (d.isSome())
          return d;
        if (a(c))
          break;
      }
      return K.none();
    }, ME = (e, t, n) => {
      const r = t(e), a = NE(n);
      return r.orThunk(() => a(e) ? K.none() : m_(e, t, a));
    }, BE = $v, jg = (e, t, n) => {
      const r = e.formatter.get(n);
      if (r)
        for (let a = 0; a < r.length; a++) {
          const c = r[a];
          if (jf(c) && c.inherit === !1 && e.dom.is(t, c.selector))
            return !0;
        }
      return !1;
    }, _x = (e, t, n, r, a) => {
      const c = e.dom.getRoot();
      if (t === c)
        return !1;
      const d = e.dom.getParent(t, (h) => jg(e, h, n) ? !0 : h.parentNode === c || !!Wp(e, h, n, r, !0));
      return !!Wp(e, d, n, r, a);
    }, K0 = (e, t, n) => Xl(n) && BE(t, n.inline) || jp(n) && BE(t, n.block) ? !0 : jf(n) ? wn(t) && e.is(t, n.selector) : !1, p_ = (e, t, n, r, a, c) => {
      const d = n[r], h = r === "attributes";
      if (un(n.onmatch))
        return n.onmatch(t, n, r);
      if (d) {
        if (Xc(d)) {
          for (let k = 0; k < d.length; k++)
            if (h ? e.getAttrib(t, d[k]) : p1(e, t, d[k]))
              return !0;
        } else
          for (const k in d)
            if (Yn(d, k)) {
              const D = h ? e.getAttrib(t, k) : p1(e, t, k), H = Lh(d[k], c), U = jn(D) || us(D);
              if (U && jn(H))
                continue;
              if (a && U && !n.exact || (!a || n.exact) && !BE(D, fk(H, k)))
                return !1;
            }
      }
      return !0;
    }, Wp = (e, t, n, r, a) => {
      const c = e.formatter.get(n), d = e.dom;
      if (c && wn(t))
        for (let h = 0; h < c.length; h++) {
          const k = c[h];
          if (K0(e.dom, t, k) && p_(d, t, k, "attributes", a, r) && p_(d, t, k, "styles", a, r)) {
            const D = k.classes;
            if (D) {
              for (let H = 0; H < D.length; H++)
                if (!e.dom.hasClass(t, Lh(D[H], r)))
                  return;
            }
            return k;
          }
        }
    }, g_ = (e, t, n, r, a) => {
      if (r)
        return _x(e, r, t, n, a);
      if (r = e.selection.getNode(), _x(e, r, t, n, a))
        return !0;
      const c = e.selection.getStart();
      return !!(c !== r && _x(e, c, t, n, a));
    }, jO = (e, t, n) => {
      const r = [], a = {}, c = e.selection.getStart();
      return e.dom.getParent(c, (d) => {
        for (let h = 0; h < t.length; h++) {
          const k = t[h];
          !a[k] && Wp(e, d, k, n) && (a[k] = !0, r.push(k));
        }
      }, e.dom.getRoot()), r;
    }, EB = (e, t) => {
      const n = (a) => Le(a, be.fromDom(e.getBody())), r = (a, c) => Wp(e, a.dom, c) ? K.some(c) : K.none();
      return K.from(e.selection.getStart(!0)).bind((a) => ME(be.fromDom(a), (c) => Ys(t, (d) => r(c, d)), n)).getOrNull();
    }, Cx = (e, t) => {
      const n = e.formatter.get(t), r = e.dom;
      if (n && e.selection.isEditable()) {
        const a = e.selection.getStart(), c = mk(r, a);
        for (let d = n.length - 1; d >= 0; d--) {
          const h = n[d];
          if (!jf(h))
            return !0;
          for (let k = c.length - 1; k >= 0; k--)
            if (r.is(c[k], h.selector))
              return !0;
        }
      }
      return !1;
    }, h_ = (e, t, n) => co(n, (r, a) => {
      const c = X5(e, a);
      return e.formatter.matchNode(t, a, {}, c) ? r.concat([a]) : r;
    }, []), Y0 = C, ZO = (e, t) => e.importNode(t, !0), LE = (e) => {
      if (e) {
        const t = new vi(e, e);
        for (let n = t.current(); n; n = t.next())
          if (At(n))
            return n;
      }
      return null;
    }, b_ = (e) => {
      const t = be.fromTag("span");
      return zs(t, {
        id: zC,
        "data-mce-bogus": "1",
        "data-mce-type": "format-caret"
      }), e && Ir(t, be.fromText(Y0)), t;
    }, y_ = (e) => {
      const t = LE(e);
      return t && t.data.charAt(0) === Y0 && t.deleteData(0, 1), t;
    }, Sx = (e, t, n) => {
      const r = e.dom, a = e.selection;
      if (WC(t))
        Uu(e, !1, be.fromDom(t), n, !0);
      else {
        const c = a.getRng(), d = r.getParent(t, r.isBlock), h = c.startContainer, k = c.startOffset, D = c.endContainer, H = c.endOffset, U = y_(t);
        r.remove(t, !0), h === U && k > 0 && c.setStart(U, k - 1), D === U && H > 0 && c.setEnd(U, H - 1), d && r.isEmpty(d) && zf(be.fromDom(d)), a.setRng(c);
      }
    }, O1 = (e, t, n) => {
      const r = e.dom, a = e.selection;
      if (t)
        Sx(e, t, n);
      else if (t = Mh(e.getBody(), a.getStart()), !t)
        for (; t = r.get(zC); )
          Sx(e, t, n);
    }, TB = (e, t, n) => {
      var r, a;
      const c = e.dom, d = c.getParent(n, Tt(Fv, e.schema));
      d && c.isEmpty(d) ? (r = n.parentNode) === null || r === void 0 || r.replaceChild(t, n) : (Op(be.fromDom(n)), c.isEmpty(n) ? (a = n.parentNode) === null || a === void 0 || a.replaceChild(t, n) : c.insertAfter(t, n));
    }, PE = (e, t) => (e.appendChild(t), t), WO = (e, t) => {
      var n;
      const r = xn(e, (c, d) => PE(c, d.cloneNode(!1)), t), a = (n = r.ownerDocument) !== null && n !== void 0 ? n : document;
      return PE(r, a.createTextNode(Y0));
    }, zB = (e, t, n, r, a, c) => {
      const d = e.formatter, h = e.dom, k = ct(Nt(d.get()), (U) => U !== r && !_r(U, "removeformat")), D = h_(e, n, k);
      if (ct(D, (U) => !J5(e, U, r)).length > 0) {
        const U = n.cloneNode(!1);
        return h.add(t, U), d.remove(r, a, U, c), h.remove(U), K.some(U);
      } else
        return K.none();
    }, qO = (e, t, n) => {
      let r;
      const a = e.selection, c = e.formatter.get(t);
      if (!c)
        return;
      const d = a.getRng();
      let h = d.startOffset;
      const D = d.startContainer.nodeValue;
      r = Mh(e.getBody(), a.getStart());
      const H = /[^\s\u00a0\u00ad\u200b\ufeff]/;
      if (D && h > 0 && h < D.length && H.test(D.charAt(h)) && H.test(D.charAt(h - 1))) {
        const U = a.getBookmark();
        d.collapse(!0);
        let G = mp(e.dom, d, c);
        G = qv(G), e.formatter.apply(t, n, G), a.moveToBookmark(U);
      } else {
        let U = r ? LE(r) : null;
        (!r || (U == null ? void 0 : U.data) !== Y0) && (r = ZO(e.getDoc(), b_(!0).dom), U = r.firstChild, d.insertNode(r), h = 1), e.formatter.apply(t, n, r), a.setCursorLocation(U, h);
      }
    }, GO = (e, t, n, r) => {
      const a = e.dom, c = e.selection;
      let d = !1;
      const h = e.formatter.get(t);
      if (!h)
        return;
      const k = c.getRng(), D = k.startContainer, H = k.startOffset;
      let U = D;
      At(D) && (H !== D.data.length && (d = !0), U = U.parentNode);
      const G = [];
      let ie;
      for (; U; ) {
        if (Wp(e, U, t, n, r)) {
          ie = U;
          break;
        }
        U.nextSibling && (d = !0), G.push(U), U = U.parentNode;
      }
      if (ie)
        if (d) {
          const ye = c.getBookmark();
          k.collapse(!0);
          let ae = mp(a, k, h, !0);
          ae = qv(ae), e.formatter.remove(t, n, ae, r), c.moveToBookmark(ye);
        } else {
          const ye = Mh(e.getBody(), ie), ae = Xe(ye) ? a.getParents(ie.parentNode, Mo, ye) : [], xe = b_(!1).dom;
          TB(e, xe, ye ?? ie);
          const Ne = zB(e, xe, ie, t, n, r), Ie = WO([
            ...G,
            ...Ne.toArray(),
            ...ae
          ], xe);
          ye && Sx(e, ye, Xe(ye)), c.setCursorLocation(Ie, 1), a.isEmpty(ie) && a.remove(ie);
        }
    }, OB = (e, t, n) => {
      const r = e.selection, a = e.getBody();
      O1(e, null, n), (t === 8 || t === 46) && r.isCollapsed() && r.getStart().innerHTML === Y0 && O1(e, Mh(a, r.getStart()), !0), (t === 37 || t === 39) && O1(e, Mh(a, r.getStart()), !0);
    }, KO = (e) => At(e) && El(e.data, Bo), A1 = (e) => {
      e.on("mouseup keydown", (t) => {
        OB(e, t.keyCode, KO(e.selection.getRng().endContainer));
      });
    }, IE = (e) => {
      const t = b_(!1), n = WO(e, t.dom);
      return {
        caretContainer: t,
        caretPosition: nt(n, 0)
      };
    }, v_ = (e, t) => {
      const { caretContainer: n, caretPosition: r } = IE(t);
      return Fs(be.fromDom(e), n), dr(be.fromDom(e)), r;
    }, YO = (e, t) => {
      const { caretContainer: n, caretPosition: r } = IE(t);
      return e.insertNode(n.dom), r;
    }, x_ = (e, t) => {
      if (uf(t.dom))
        return !1;
      const n = e.schema.getTextInlineElements();
      return Yn(n, Eo(t)) && !uf(t.dom) && !ru(t.dom);
    }, bp = {}, FE = Ul(["pre"]), Am = (e, t) => {
      bp[e] || (bp[e] = []), bp[e].push(t);
    }, D1 = (e, t) => {
      Yn(bp, e) && ut(bp[e], (n) => {
        n(t);
      });
    };
    Am("pre", (e) => {
      const t = e.selection.getRng(), n = (a) => (c) => {
        const d = c.previousSibling;
        return FE(d) && So(a, d);
      }, r = (a, c) => {
        const d = be.fromDom(c), h = Sn(d).dom;
        dr(d), Fa(be.fromDom(a), [
          be.fromTag("br", h),
          be.fromTag("br", h),
          ...Pr(d)
        ]);
      };
      if (!t.collapsed) {
        const a = e.selection.getSelectedBlocks(), c = ct(ct(a, FE), n(a));
        ut(c, (d) => {
          r(d.previousSibling, d);
        });
      }
    });
    const w_ = [
      "fontWeight",
      "fontStyle",
      "color",
      "fontSize",
      "fontFamily"
    ], XO = (e) => Ee(e.styles) && cr(Nt(e.styles), (t) => So(w_, t)), AB = (e) => po(e, (t) => Xl(t) && t.inline === "span" && XO(t)), $E = (e, t) => {
      const n = e.get(t);
      return Se(n) ? AB(n) : K.none();
    }, R1 = (e, t) => cf(t, nt.fromRangeStart(e)).isNone(), k_ = (e, t) => kd(t, nt.fromRangeEnd(e)).exists((n) => !cs(n.getNode()) || kd(t, n).isSome()) === !1, HE = (e) => (t) => Kd(t) && e.isEditable(t), JO = (e) => {
      const t = e.getSelectedBlocks(), n = e.getRng();
      if (e.isCollapsed())
        return [];
      if (t.length === 1)
        return R1(n, t[0]) && k_(n, t[0]) ? t : [];
      {
        const r = ro(t).filter((d) => R1(n, d)).toArray(), a = cn(t).filter((d) => k_(n, d)).toArray(), c = t.slice(1, -1);
        return r.concat(c).concat(a);
      }
    }, VE = (e) => ct(JO(e), HE(e.dom)), QO = (e) => ct(e.getSelectedBlocks(), HE(e.dom)), UE = Ht.each, __ = (e) => wn(e) && !Vf(e) && !uf(e) && !ru(e), eA = (e, t) => {
      for (let n = e; n; n = n[t]) {
        if (At(n) && Na(n.data))
          return e;
        if (wn(n) && !Vf(n))
          return n;
      }
      return e;
    }, ff = (e, t, n) => {
      const r = n_(e), a = ta(t) && e.dom.isEditable(t), c = ta(n) && e.dom.isEditable(n);
      if (a && c) {
        const d = eA(t, "previousSibling"), h = eA(n, "nextSibling");
        if (r.compare(d, h)) {
          for (let k = d.nextSibling; k && k !== h; ) {
            const D = k;
            k = k.nextSibling, d.appendChild(D);
          }
          return e.dom.remove(h), Ht.each(Ht.grep(h.childNodes), (k) => {
            d.appendChild(k);
          }), d;
        }
      }
      return n;
    }, C_ = (e, t, n, r) => {
      var a;
      if (r && t.merge_siblings !== !1) {
        const c = (a = ff(e, $C(r), r)) !== null && a !== void 0 ? a : r;
        ff(e, c, $C(c, !0));
      }
    }, tA = (e, t, n) => {
      if (t.clear_child_styles) {
        const r = t.links ? "*:not(a)" : "*";
        UE(e.select(r, n), (a) => {
          __(a) && e.isEditable(a) && UE(t.styles, (c, d) => {
            e.setStyle(a, d, "");
          });
        });
      }
    }, Ex = (e, t, n) => {
      UE(e.childNodes, (r) => {
        __(r) && (t(r) && n(r), r.hasChildNodes() && Ex(r, t, n));
      });
    }, nA = (e, t) => {
      t.nodeName === "SPAN" && e.getAttribs(t).length === 0 && e.remove(t, !0);
    }, X0 = (e, t) => (n) => !!(n && p1(e, n, t)), Zg = (e, t, n) => (r) => {
      e.setStyle(r, t, n), r.getAttribute("style") === "" && r.removeAttribute("style"), nA(e, r);
    }, Dm = $e.generate([
      { keep: [] },
      { rename: ["name"] },
      { removed: [] }
    ]), S_ = /^(src|href|style)$/, Tx = Ht.each, J0 = $v, oA = (e) => /^(TR|TH|TD)$/.test(e.nodeName), rA = (e, t, n) => e.isChildOf(t, n) && t !== n && !e.isBlock(n), jE = (e, t, n) => {
      let r = t[n ? "startContainer" : "endContainer"], a = t[n ? "startOffset" : "endOffset"];
      if (wn(r)) {
        const c = r.childNodes.length - 1;
        !n && a && a--, r = r.childNodes[a > c ? c : a];
      }
      return At(r) && n && a >= r.data.length && (r = new vi(r, e.getBody()).next() || r), At(r) && !n && a === 0 && (r = new vi(r, e.getBody()).prev() || r), r;
    }, ZE = (e, t) => {
      const n = t ? "firstChild" : "lastChild", r = e[n];
      return oA(e) && r ? e.nodeName === "TR" && r[n] || r : e;
    }, E_ = (e, t, n, r) => {
      var a;
      const c = e.create(n, r);
      return (a = t.parentNode) === null || a === void 0 || a.insertBefore(c, t), c.appendChild(t), c;
    }, WE = (e, t, n, r, a) => {
      const c = be.fromDom(t), d = be.fromDom(e.create(r, a)), h = n ? Ec(c) : cg(c);
      return Fa(d, h), n ? (Fs(c, d), fs(d, c)) : (rs(c, d), Ir(d, c)), d.dom;
    }, DB = (e, t) => t.links && e.nodeName === "A", sA = (e, t, n) => {
      const r = t.parentNode;
      let a;
      const c = e.dom, d = li(e);
      jp(n) && r === c.getRoot() && (!n.list_block || !J0(t, n.list_block)) && ut(_n(t.childNodes), (h) => {
        Gb(e, d, h.nodeName.toLowerCase()) ? a ? a.appendChild(h) : (a = E_(c, h, d), c.setAttribs(a, Mg(e))) : a = null;
      }), !(MT(n) && !J0(n.inline, t)) && c.remove(t, !0);
    }, aA = (e, t, n) => M(e) ? {
      name: t,
      value: null
    } : {
      name: e,
      value: Lh(t, n)
    }, Cd = (e, t) => {
      e.getAttrib(t, "style") === "" && (t.removeAttribute("style"), t.removeAttribute("data-mce-style"));
    }, qE = (e, t, n, r, a) => {
      let c = !1;
      Tx(n.styles, (d, h) => {
        const {
          name: k,
          value: D
        } = aA(h, d, r), H = fk(D, k);
        (n.remove_similar || We(D) || !wn(a) || J0(p1(e, a, k), H)) && e.setStyle(t, k, ""), c = !0;
      }), c && Cd(e, t);
    }, zx = (e, t, n) => {
      t === "removeformat" ? ut(QO(e.selection), (r) => {
        ut(w_, (a) => e.dom.setStyle(r, a, "")), Cd(e.dom, r);
      }) : $E(e.formatter, t).each((r) => {
        ut(QO(e.selection), (a) => qE(e.dom, a, r, n, null));
      });
    }, iA = (e, t, n, r, a) => {
      const c = e.dom, d = n_(e), h = e.schema;
      if (Xl(t) && qm(h, t.inline) && ef(h, r) && r.parentElement === e.getBody())
        return sA(e, r, t), Dm.removed();
      if (!t.ceFalseOverride && r && c.getContentEditableParent(r) === "false" || r && !K0(c, r, t) && !DB(r, t))
        return Dm.keep();
      const k = r, D = t.preserve_attributes;
      if (Xl(t) && t.remove === "all" && Se(D)) {
        const H = ct(c.getAttribs(k), (U) => So(D, U.name.toLowerCase()));
        if (c.removeAllAttribs(k), ut(H, (U) => c.setAttrib(k, U.name, U.value)), H.length > 0)
          return Dm.rename("span");
      }
      if (t.remove !== "all") {
        qE(c, k, t, n, a), Tx(t.attributes, (U, G) => {
          const {
            name: ie,
            value: ye
          } = aA(G, U, n);
          if (t.remove_similar || We(ye) || !wn(a) || J0(c.getAttrib(a, ie), ye)) {
            if (ie === "class") {
              const ae = c.getAttrib(k, ie);
              if (ae) {
                let xe = "";
                if (ut(ae.split(/\s+/), (Ne) => {
                  /mce\-\w+/.test(Ne) && (xe += (xe ? " " : "") + Ne);
                }), xe) {
                  c.setAttrib(k, ie, xe);
                  return;
                }
              }
            }
            if (S_.test(ie) && k.removeAttribute("data-mce-" + ie), ie === "style" && Ul(["li"])(k) && c.getStyle(k, "list-style-type") === "none") {
              k.removeAttribute(ie), c.setStyle(k, "list-style-type", "none");
              return;
            }
            ie === "class" && k.removeAttribute("className"), k.removeAttribute(ie);
          }
        }), Tx(t.classes, (U) => {
          U = Lh(U, n), (!wn(a) || c.hasClass(a, U)) && c.removeClass(k, U);
        });
        const H = c.getAttribs(k);
        for (let U = 0; U < H.length; U++) {
          const G = H[U].nodeName;
          if (!d.isAttributeInternal(G))
            return Dm.keep();
        }
      }
      return t.remove !== "none" ? (sA(e, k, t), Dm.removed()) : Dm.keep();
    }, lA = (e, t, n, r, a) => {
      let c;
      return t.parentNode && ut(mk(e.dom, t.parentNode).reverse(), (d) => {
        if (!c && wn(d) && d.id !== "_start" && d.id !== "_end") {
          const h = Wp(e, d, n, r, a);
          h && h.split !== !1 && (c = d);
        }
      }), c;
    }, cA = (e, t, n, r) => iA(e, t, n, r, r).fold(dt(r), (a) => (e.dom.createFragment().appendChild(r), e.dom.rename(r, a)), dt(null)), GE = (e, t, n, r, a, c, d, h) => {
      var k, D;
      let H, U;
      const G = e.dom;
      if (n) {
        const ie = n.parentNode;
        for (let ye = r.parentNode; ye && ye !== ie; ye = ye.parentNode) {
          let ae = G.clone(ye, !1);
          for (let xe = 0; xe < t.length && (ae = cA(e, t[xe], h, ae), ae !== null); xe++)
            ;
          ae && (H && ae.appendChild(H), U || (U = ae), H = ae);
        }
        c && (!d.mixed || !G.isBlock(n)) && (r = (k = G.split(n, r)) !== null && k !== void 0 ? k : r), H && U && ((D = a.parentNode) === null || D === void 0 || D.insertBefore(H, a), U.appendChild(a), Xl(d) && C_(e, d, h, H));
      }
      return r;
    }, uA = (e, t, n, r, a) => {
      const c = e.formatter.get(t), d = c[0], h = e.dom, k = e.selection, D = (ae) => {
        const xe = lA(e, ae, t, n, a);
        return GE(e, c, xe, ae, ae, !0, d, n);
      }, H = (ae) => Vf(ae) && wn(ae) && (ae.id === "_start" || ae.id === "_end"), U = (ae) => cr(c, (xe) => Ox(e, xe, n, ae, ae)), G = (ae) => {
        const xe = _n(ae.childNodes), Ie = U(ae) || cr(c, (_t) => K0(h, ae, _t)), Fe = ae.parentNode;
        if (!Ie && Xe(Fe) && ZC(d) && U(Fe), d.deep && xe.length)
          for (let _t = 0; _t < xe.length; _t++)
            G(xe[_t]);
        ut([
          "underline",
          "line-through",
          "overline"
        ], (_t) => {
          wn(ae) && e.dom.getStyle(ae, "text-decoration") === _t && ae.parentNode && NT(h, ae.parentNode) === _t && Ox(e, {
            deep: !1,
            exact: !0,
            inline: "span",
            styles: { textDecoration: _t }
          }, void 0, ae);
        });
      }, ie = (ae) => {
        const xe = h.get(ae ? "_start" : "_end");
        if (xe) {
          let Ne = xe[ae ? "firstChild" : "lastChild"];
          return H(Ne) && (Ne = Ne[ae ? "firstChild" : "lastChild"]), At(Ne) && Ne.data.length === 0 && (Ne = ae ? xe.previousSibling || xe.nextSibling : xe.nextSibling || xe.previousSibling), h.remove(xe, !0), Ne;
        } else
          return null;
      }, ye = (ae) => {
        let xe, Ne, Ie = mp(h, ae, c, ae.collapsed);
        if (d.split) {
          if (Ie = qv(Ie), xe = jE(e, Ie, !0), Ne = jE(e, Ie), xe !== Ne) {
            if (xe = ZE(xe, !0), Ne = ZE(Ne, !1), rA(h, xe, Ne)) {
              const je = K.from(xe.firstChild).getOr(xe);
              D(WE(h, je, !0, "span", {
                id: "_start",
                "data-mce-type": "bookmark"
              })), ie(!0);
              return;
            }
            if (rA(h, Ne, xe)) {
              const je = K.from(Ne.lastChild).getOr(Ne);
              D(WE(h, je, !1, "span", {
                id: "_end",
                "data-mce-type": "bookmark"
              })), ie(!1);
              return;
            }
            xe = E_(h, xe, "span", {
              id: "_start",
              "data-mce-type": "bookmark"
            }), Ne = E_(h, Ne, "span", {
              id: "_end",
              "data-mce-type": "bookmark"
            });
            const Fe = h.createRng();
            Fe.setStartAfter(xe), Fe.setEndBefore(Ne), Xr(h, Fe, (je) => {
              ut(je, (_t) => {
                !Vf(_t) && !Vf(_t.parentNode) && D(_t);
              });
            }), D(xe), D(Ne), xe = ie(!0), Ne = ie();
          } else
            xe = Ne = D(xe);
          Ie.startContainer = xe.parentNode ? xe.parentNode : xe, Ie.startOffset = h.nodeIndex(xe), Ie.endContainer = Ne.parentNode ? Ne.parentNode : Ne, Ie.endOffset = h.nodeIndex(Ne) + 1;
        }
        Xr(h, Ie, (Fe) => {
          ut(Fe, G);
        });
      };
      if (r) {
        if (Hu(r)) {
          const ae = h.createRng();
          ae.setStartBefore(r), ae.setEndAfter(r), ye(ae);
        } else
          ye(r);
        rS(e, t, r, n);
        return;
      }
      !k.isCollapsed() || !Xl(d) || Pg(e).length ? (qb(e, () => m1(e, ye), (ae) => Xl(d) && g_(e, t, n, ae)), e.nodeChanged()) : GO(e, t, n, a), zx(e, t, n), rS(e, t, r, n);
    }, dA = (e, t, n, r, a) => {
      (r || e.selection.isEditable()) && uA(e, t, n, r, a);
    }, Ox = (e, t, n, r, a) => iA(e, t, n, r, a).fold(Pn, (c) => (e.dom.rename(r, c), !0), Mo), fA = Ht.each, KE = (e, t, n, r) => {
      const a = (c) => {
        if (ta(c) && wn(c.parentNode) && e.isEditable(c)) {
          const d = NT(e, c.parentNode);
          e.getStyle(c, "color") && d ? e.setStyle(c, "text-decoration", d) : e.getStyle(c, "text-decoration") === d && e.setStyle(c, "text-decoration", null);
        }
      };
      t.styles && (t.styles.color || t.styles.textDecoration) && (Ht.walk(r, a, "childNodes"), a(r));
    }, RB = (e, t, n, r) => {
      if (t.styles && t.styles.backgroundColor) {
        const a = X0(e, "fontSize");
        Ex(r, (c) => a(c) && e.isEditable(c), Zg(e, "backgroundColor", Lh(t.styles.backgroundColor, n)));
      }
    }, NB = (e, t, n, r) => {
      if (Xl(t) && (t.inline === "sub" || t.inline === "sup")) {
        const a = X0(e, "fontSize");
        Ex(r, (d) => a(d) && e.isEditable(d), Zg(e, "fontSize", ""));
        const c = ct(e.select(t.inline === "sup" ? "sub" : "sup", r), e.isEditable);
        e.remove(c, !0);
      }
    }, mA = (e, t, n, r) => {
      fA(t, (a) => {
        Xl(a) && fA(e.dom.select(a.inline, r), (c) => {
          __(c) && Ox(e, a, n, c, a.exact ? c : null);
        }), tA(e.dom, a, r);
      });
    }, MB = (e, t, n, r, a) => {
      const c = a.parentNode;
      Wp(e, c, n, r) && Ox(e, t, r, a) || t.merge_with_parents && c && e.dom.getParent(c, (d) => Wp(e, d, n, r) ? (Ox(e, t, r, a), !0) : !1);
    }, T_ = Ht.each, YE = (e, t, n, r) => {
      if (lp(e) && Xl(t) && n.parentNode) {
        const a = hh(e.schema), c = gO(be.fromDom(n), (d) => uf(d.dom));
        return qi(a, r) && Yr(be.fromDom(n.parentNode), !1) && !c;
      } else
        return !1;
    }, Ax = (e, t, n, r) => {
      if (T_(n.styles, (a, c) => {
        e.setStyle(t, c, Lh(a, r));
      }), n.styles) {
        const a = e.getAttrib(t, "style");
        a && e.setAttrib(t, "data-mce-style", a);
      }
    }, pA = (e, t, n, r) => {
      const a = e.formatter.get(t), c = a[0], d = !r && e.selection.isCollapsed(), h = e.dom, k = e.selection, D = (ye, ae = c) => {
        un(ae.onformat) && ae.onformat(ye, ae, n, r), Ax(h, ye, ae, n), T_(ae.attributes, (xe, Ne) => {
          h.setAttrib(ye, Ne, Lh(xe, n));
        }), T_(ae.classes, (xe) => {
          const Ne = Lh(xe, n);
          h.hasClass(ye, Ne) || h.addClass(ye, Ne);
        });
      }, H = (ye, ae) => {
        let xe = !1;
        return T_(ye, (Ne) => jf(Ne) ? h.getContentEditable(ae) === "false" && !Ne.ceFalseOverride || Xe(Ne.collapsed) && Ne.collapsed !== d ? !0 : h.is(ae, Ne.selector) && !uf(ae) ? (D(ae, Ne), xe = !0, !1) : !0 : !1), xe;
      }, U = (ye) => {
        if (Ot(ye)) {
          const ae = h.create(ye);
          return D(ae), ae;
        } else
          return null;
      }, G = (ye, ae, xe) => {
        const Ne = [];
        let Ie = !0;
        const Fe = c.inline || c.block, je = U(Fe), _t = (at) => Q5(c) && Wp(e, at, t, n), Zt = (at, et, Mt) => {
          const gn = eM(c) && Fv(e.schema, at) && Gb(e, et, Fe);
          return Mt && gn;
        }, fn = (at, et, Mt, gn) => {
          const Fn = at.nodeName.toLowerCase(), Uo = Gb(e, Fe, Fn) && Gb(e, et, Fe), qo = !xe && At(at) && R(at.data), vs = uf(at), Vs = !Xl(c) || !ye.isBlock(at);
          return (Mt || gn) && Uo && !qo && !vs && Vs;
        };
        Xr(ye, ae, (at) => {
          let et;
          const Mt = (gn) => {
            let Fn = !1, Uo = Ie, qo = !1;
            const vs = gn.parentNode, Vs = vs.nodeName.toLowerCase(), Ci = ye.getContentEditable(gn);
            Xe(Ci) && (Uo = Ie, Ie = Ci === "true", Fn = !0, qo = UC(e, gn));
            const Yc = Ie && !Fn;
            if (cs(gn) && !YE(e, c, gn, Vs)) {
              et = null, jp(c) && ye.remove(gn);
              return;
            }
            if (_t(gn)) {
              et = null;
              return;
            }
            if (Zt(gn, Vs, Yc)) {
              const Ql = ye.rename(gn, Fe);
              D(Ql), Ne.push(Ql), et = null;
              return;
            }
            if (jf(c)) {
              let Ql = H(a, gn);
              if (!Ql && Xe(vs) && ZC(c) && (Ql = H(a, vs)), !Xl(c) || Ql) {
                et = null;
                return;
              }
            }
            Xe(je) && fn(gn, Vs, Yc, qo) ? (et || (et = ye.clone(je, !1), vs.insertBefore(et, gn), Ne.push(et)), qo && Fn && (Ie = Uo), et.appendChild(gn)) : (et = null, ut(_n(gn.childNodes), Mt), Fn && (Ie = Uo), et = null);
          };
          ut(at, Mt);
        }), c.links === !0 && ut(Ne, (at) => {
          const et = (Mt) => {
            Mt.nodeName === "A" && D(Mt, c), ut(_n(Mt.childNodes), et);
          };
          et(at);
        }), ut(Ne, (at) => {
          const et = (Fn) => {
            let Uo = 0;
            return ut(Fn.childNodes, (qo) => {
              !VC(qo) && !Vf(qo) && Uo++;
            }), Uo;
          }, Mt = (Fn) => po(Fn.childNodes, ys).filter((qo) => ye.getContentEditable(qo) !== "false" && K0(ye, qo, c)).map((qo) => {
            const vs = ye.clone(qo, !1);
            return D(vs), ye.replace(vs, Fn, !0), ye.remove(qo, !0), vs;
          }).getOr(Fn), gn = et(at);
          if ((Ne.length > 1 || !ye.isBlock(at)) && gn === 0) {
            ye.remove(at, !0);
            return;
          }
          (Xl(c) || jp(c) && c.wrapper) && (!c.exact && gn === 1 && (at = Mt(at)), mA(e, a, n, at), MB(e, c, t, n, at), RB(ye, c, n, at), KE(ye, c, n, at), NB(ye, c, n, at), C_(e, c, n, at));
        });
      }, ie = Hu(r) ? r : k.getNode();
      if (h.getContentEditable(ie) === "false" && !UC(e, ie)) {
        r = ie, H(a, r), oS(e, t, r, n);
        return;
      }
      if (c) {
        if (r)
          if (Hu(r)) {
            if (!H(a, r)) {
              const ye = h.createRng();
              ye.setStartBefore(r), ye.setEndAfter(r), G(h, mp(h, ye, a), !0);
            }
          } else
            G(h, r, !0);
        else
          !d || !Xl(c) || Pg(e).length ? (k.setRng(TE(k.getRng())), qb(e, () => {
            m1(e, (ye, ae) => {
              const xe = ae ? ye : mp(h, ye, a);
              G(h, xe, !1);
            });
          }, Mo), e.nodeChanged()) : qO(e, t, n), $E(e.formatter, t).each((ye) => {
            ut(VE(e.selection), (ae) => Ax(h, ae, ye, n));
          });
        D1(t, e);
      }
      oS(e, t, r, n);
    }, XE = (e, t, n, r) => {
      (r || e.selection.isEditable()) && pA(e, t, n, r);
    }, z_ = (e) => Yn(e, "vars"), BB = (e, t) => {
      e.set({}), t.on("NodeChange", (n) => {
        bA(t, n.element, e.get());
      }), t.on("FormatApply FormatRemove", (n) => {
        const r = K.from(n.node).map((a) => Hu(a) ? a : a.startContainer).bind((a) => wn(a) ? K.some(a) : K.from(a.parentElement)).getOrThunk(() => gA(t));
        bA(t, r, e.get());
      });
    }, gA = (e) => e.selection.getStart(), hA = (e, t, n, r, a) => Ko(t, (h) => {
      const k = e.formatter.matchNode(h, n, a ?? {}, r);
      return !ko(k);
    }, (h) => jg(e, h, n) ? !0 : r ? !1 : Xe(e.formatter.matchNode(h, n, a, !0))), py = (e, t) => {
      const n = t ?? gA(e);
      return ct(mk(e.dom, n), (r) => wn(r) && !ru(r));
    }, bA = (e, t, n) => {
      const r = py(e, t);
      Zo(n, (a, c) => {
        const d = (h) => {
          const k = hA(e, r, c, h.similar, z_(h) ? h.vars : void 0), D = k.isSome();
          if (h.state.get() !== D) {
            h.state.set(D);
            const H = k.getOr(t);
            z_(h) ? h.callback(D, {
              node: H,
              format: c,
              parents: r
            }) : ut(h.callbacks, (U) => U(D, {
              node: H,
              format: c,
              parents: r
            }));
          }
        };
        ut([
          a.withSimilar,
          a.withoutSimilar
        ], d), ut(a.withVars, d);
      });
    }, O_ = (e, t, n, r, a, c) => {
      const d = t.get();
      ut(n.split(","), (h) => {
        const k = Hr(d, h).getOrThunk(() => {
          const H = {
            withSimilar: {
              state: Ja(!1),
              similar: !0,
              callbacks: []
            },
            withoutSimilar: {
              state: Ja(!1),
              similar: !1,
              callbacks: []
            },
            withVars: []
          };
          return d[h] = H, H;
        }), D = () => {
          const H = py(e);
          return hA(e, H, h, a, c).isSome();
        };
        if (ko(c)) {
          const H = a ? k.withSimilar : k.withoutSimilar;
          H.callbacks.push(r), H.callbacks.length === 1 && H.state.set(D());
        } else
          k.withVars.push({
            state: Ja(D()),
            similar: a,
            vars: c,
            callback: r
          });
      }), t.set(d);
    }, LB = (e, t, n) => {
      const r = e.get();
      ut(t.split(","), (a) => Hr(r, a).each((c) => {
        r[a] = {
          withSimilar: {
            ...c.withSimilar,
            callbacks: ct(c.withSimilar.callbacks, (d) => d !== n)
          },
          withoutSimilar: {
            ...c.withoutSimilar,
            callbacks: ct(c.withoutSimilar.callbacks, (d) => d !== n)
          },
          withVars: ct(c.withVars, (d) => d.callback !== n)
        };
      })), e.set(r);
    }, JE = (e, t, n, r, a, c) => (O_(e, t, n, r, a, c), { unbind: () => LB(t, n, r) }), yA = (e, t, n, r) => {
      const a = e.formatter.get(t);
      a && (g_(e, t, n, r) && (!("toggle" in a[0]) || a[0].toggle) ? dA(e, t, n, r) : XE(e, t, n, r));
    }, QE = Ht.explode, e4 = () => {
      const e = {};
      return {
        addFilter: (a, c) => {
          ut(QE(a), (d) => {
            Yn(e, d) || (e[d] = {
              name: d,
              callbacks: []
            }), e[d].callbacks.push(c);
          });
        },
        getFilters: () => oc(e),
        removeFilter: (a, c) => {
          ut(QE(a), (d) => {
            if (Yn(e, d))
              if (Xe(c)) {
                const h = e[d], k = ct(h.callbacks, (D) => D !== c);
                k.length > 0 ? h.callbacks = k : delete e[d];
              } else
                delete e[d];
          });
        }
      };
    }, A_ = (e, t) => {
      ut(t, (n) => {
        e.attr(n, null);
      });
    }, PB = (e, t, n) => {
      e.addNodeFilter("font", (r) => {
        ut(r, (a) => {
          const c = t.parse(a.attr("style")), d = a.attr("color"), h = a.attr("face"), k = a.attr("size");
          d && (c.color = d), h && (c["font-family"] = h), k && Us(k).each((D) => {
            c["font-size"] = n[D - 1];
          }), a.name = "span", a.attr("style", t.serialize(c)), A_(a, [
            "color",
            "face",
            "size"
          ]);
        });
      });
    }, IB = (e, t, n) => {
      e.addNodeFilter("strike", (r) => {
        const a = t.type !== "html4";
        ut(r, (c) => {
          if (a)
            c.name = "s";
          else {
            const d = n.parse(c.attr("style"));
            d["text-decoration"] = "line-through", c.name = "span", c.attr("style", n.serialize(d));
          }
        });
      });
    }, t4 = (e, t, n) => {
      var r;
      const a = rf();
      t.convert_fonts_to_spans && PB(e, a, Ht.explode((r = t.font_size_legacy_values) !== null && r !== void 0 ? r : "")), IB(e, n, a);
    }, vA = (e, t, n) => {
      t.inline_styles && t4(e, t, n);
    }, xA = (e, t, n) => {
      t.addNodeFilter("br", (r, a, c) => {
        const d = Ht.extend({}, n.getBlockElements()), h = n.getNonEmptyElements(), k = n.getWhitespaceElements();
        d.body = 1;
        const D = (H) => H.name in d || Au(n, H);
        for (let H = 0, U = r.length; H < U; H++) {
          let G = r[H], ie = G.parent;
          if (ie && D(ie) && G === ie.lastChild) {
            let ye = G.prev;
            for (; ye; ) {
              const ae = ye.name;
              if (ae !== "span" || ye.attr("data-mce-type") !== "bookmark") {
                ae === "br" && (G = null);
                break;
              }
              ye = ye.prev;
            }
            if (G && (G.remove(), W0(n, h, k, ie))) {
              const ae = n.getElementRule(ie.name);
              ae && (ae.removeEmpty ? ie.remove() : ae.paddEmpty && s_(e, c, D, ie));
            }
          } else {
            let ye = G;
            for (; ie && ie.firstChild === ye && ie.lastChild === ye && (ye = ie, !d[ie.name]); )
              ie = ie.parent;
            if (ye === ie) {
              const ae = new qc("#text", 3);
              ae.value = Bo, G.replace(ae);
            }
          }
        }
      });
    }, FB = (e) => fetch(e).then((t) => t.ok ? t.blob() : Promise.reject()).catch(() => Promise.reject({
      message: `Cannot convert ${e} to Blob. Resource might not exist or is inaccessible.`,
      uriType: "blob"
    })), $B = (e) => {
      const t = /([a-z0-9+\/=\s]+)/i.exec(e);
      return t ? t[1] : "";
    }, n4 = (e) => {
      const [t, ...n] = e.split(","), r = n.join(","), a = /data:([^/]+\/[^;]+)(;.+)?/.exec(t);
      if (a) {
        const c = a[2] === ";base64", d = c ? $B(r) : decodeURIComponent(r);
        return K.some({
          type: a[1],
          data: d,
          base64Encoded: c
        });
      } else
        return K.none();
    }, D_ = (e, t, n = !0) => {
      let r = t;
      if (n)
        try {
          r = atob(t);
        } catch {
          return K.none();
        }
      const a = new Uint8Array(r.length);
      for (let c = 0; c < a.length; c++)
        a[c] = r.charCodeAt(c);
      return K.some(new Blob([a], { type: e }));
    }, wA = (e) => new Promise((t, n) => {
      n4(e).bind(({ type: r, data: a, base64Encoded: c }) => D_(r, a, c)).fold(() => n("Invalid data URI"), t);
    }), HB = (e) => Dr(e, "blob:") ? FB(e) : Dr(e, "data:") ? wA(e) : Promise.reject("Unknown URI format"), kA = (e) => new Promise((t, n) => {
      const r = new FileReader();
      r.onloadend = () => {
        t(r.result);
      }, r.onerror = () => {
        var a;
        n((a = r.error) === null || a === void 0 ? void 0 : a.message);
      }, r.readAsDataURL(e);
    });
    let vl = 0;
    const VB = (e) => (e || "blobid") + vl++, _A = (e, t, n) => n4(e).bind(({ data: r, type: a, base64Encoded: c }) => {
      if (t && !c)
        return K.none();
      {
        const d = c ? r : btoa(r);
        return n(d, a);
      }
    }), o4 = (e, t, n) => {
      const r = e.create(VB(), t, n);
      return e.add(r), r;
    }, R_ = (e, t, n = !1) => _A(t, n, (r, a) => K.from(e.getByData(r, a)).orThunk(() => D_(a, r).map((c) => o4(e, c, r)))), CA = (e, t) => {
      const n = () => Promise.reject("Invalid data URI");
      if (Dr(t, "blob:")) {
        const r = e.getByUri(t);
        return Xe(r) ? Promise.resolve(r) : HB(t).then((a) => kA(a).then((c) => _A(c, !1, (d) => K.some(o4(e, a, d))).getOrThunk(n)));
      } else
        return Dr(t, "data:") ? R_(e, t).fold(n, (r) => Promise.resolve(r)) : Promise.reject("Unknown image data format");
    }, gy = (e) => Xe(e.attr("data-mce-bogus")), r4 = (e) => e.attr("src") === nr.transparentSrc || Xe(e.attr("data-mce-placeholder")), SA = (e, t) => {
      const { blob_cache: n } = t;
      if (n) {
        const r = (a) => {
          const c = a.attr("src");
          r4(a) || gy(a) || jn(c) || R_(n, c, !0).each((d) => {
            a.attr("src", d.blobUri());
          });
        };
        e.addAttributeFilter("src", (a) => ut(a, r));
      }
    }, Dx = (e, t) => Dr(e, `${t}/`), s4 = (e, t, n, r, a) => {
      let c;
      ko(e) ? c = "iframe" : Dx(e, "image") ? c = "img" : Dx(e, "video") ? c = "video" : Dx(e, "audio") ? c = "audio" : c = "iframe";
      const d = new qc(c, 1);
      return d.attr(c === "audio" ? { src: t } : {
        src: t,
        width: n,
        height: r
      }), (c === "audio" || c === "video") && d.attr("controls", ""), c === "iframe" && a && d.attr("sandbox", ""), d;
    }, a4 = (e, t) => {
      const n = e.schema;
      t.remove_trailing_brs && xA(t, e, n), e.addAttributeFilter("href", (a) => {
        let c = a.length;
        const d = (k) => k.split(" ").filter((H) => H.length > 0).concat(["noopener"]).sort().join(" "), h = (k) => {
          const D = k ? Ht.trim(k) : "";
          return /\b(noopener)\b/g.test(D) ? D : d(D);
        };
        if (!t.allow_unsafe_link_target)
          for (; c--; ) {
            const k = a[c];
            k.name === "a" && k.attr("target") === "_blank" && k.attr("rel", h(k.attr("rel")));
          }
      }), t.allow_html_in_named_anchor || e.addAttributeFilter("id,name", (a) => {
        let c = a.length, d, h, k, D;
        for (; c--; )
          if (D = a[c], D.name === "a" && D.firstChild && !D.attr("href"))
            for (k = D.parent, d = D.lastChild; d && k; )
              h = d.prev, k.insert(d, D), d = h;
      }), t.fix_list_elements && e.addNodeFilter("ul,ol", (a) => {
        let c = a.length, d, h;
        for (; c--; )
          if (d = a[c], h = d.parent, h && (h.name === "ul" || h.name === "ol"))
            if (d.prev && d.prev.name === "li")
              d.prev.append(d);
            else {
              const k = new qc("li", 1);
              k.attr("style", "list-style-type: none"), d.wrap(k);
            }
      });
      const r = n.getValidClasses();
      t.validate && r && e.addAttributeFilter("class", (a) => {
        var c;
        let d = a.length;
        for (; d--; ) {
          const h = a[d], k = (c = h.attr("class")) !== null && c !== void 0 ? c : "", D = Ht.explode(k, " ");
          let H = "";
          for (let U = 0; U < D.length; U++) {
            const G = D[U];
            let ie = !1, ye = r["*"];
            ye && ye[G] && (ie = !0), ye = r[h.name], !ie && ye && ye[G] && (ie = !0), ie && (H && (H += " "), H += G);
          }
          H.length || (H = null), h.attr("class", H);
        }
      }), SA(e, t), t.convert_unsafe_embeds && e.addNodeFilter("object,embed", (a) => ut(a, (c) => {
        c.replace(s4(c.attr("type"), c.name === "object" ? c.attr("data") : c.attr("src"), c.attr("width"), c.attr("height"), t.sandbox_iframes));
      })), t.sandbox_iframes && e.addNodeFilter("iframe", (a) => ut(a, (c) => c.attr("sandbox", "")));
    };
    /*! @license DOMPurify 3.1.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.7/LICENSE */
    const {
      entries: i4,
      setPrototypeOf: Rx,
      isFrozen: N_,
      getPrototypeOf: Nx,
      getOwnPropertyDescriptor: Mx
    } = Object;
    let {
      freeze: Vi,
      seal: Sd,
      create: l4
    } = Object, {
      apply: M_,
      construct: c4
    } = typeof Reflect < "u" && Reflect;
    Vi || (Vi = function(t) {
      return t;
    }), Sd || (Sd = function(t) {
      return t;
    }), M_ || (M_ = function(t, n, r) {
      return t.apply(n, r);
    }), c4 || (c4 = function(t, n) {
      return new t(...n);
    });
    const Bx = Rm(Array.prototype.forEach), EA = Rm(Array.prototype.pop), Lx = Rm(Array.prototype.push), hy = Rm(String.prototype.toLowerCase), u4 = Rm(String.prototype.toString), TA = Rm(String.prototype.match), Px = Rm(String.prototype.replace), UB = Rm(String.prototype.indexOf), jB = Rm(String.prototype.trim), qp = Rm(Object.prototype.hasOwnProperty), mf = Rm(RegExp.prototype.test), Ix = ZB(TypeError);
    function Rm(e) {
      return function(t) {
        for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)
          r[a - 1] = arguments[a];
        return M_(e, t, r);
      };
    }
    function ZB(e) {
      return function() {
        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
          n[r] = arguments[r];
        return c4(e, n);
      };
    }
    function Ds(e, t) {
      let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : hy;
      Rx && Rx(e, null);
      let r = t.length;
      for (; r--; ) {
        let a = t[r];
        if (typeof a == "string") {
          const c = n(a);
          c !== a && (N_(t) || (t[r] = c), a = c);
        }
        e[a] = !0;
      }
      return e;
    }
    function zA(e) {
      for (let t = 0; t < e.length; t++)
        qp(e, t) || (e[t] = null);
      return e;
    }
    function by(e) {
      const t = l4(null);
      for (const [n, r] of i4(e))
        qp(e, n) && (Array.isArray(r) ? t[n] = zA(r) : r && typeof r == "object" && r.constructor === Object ? t[n] = by(r) : t[n] = r);
      return t;
    }
    function Q0(e, t) {
      for (; e !== null; ) {
        const r = Mx(e, t);
        if (r) {
          if (r.get)
            return Rm(r.get);
          if (typeof r.value == "function")
            return Rm(r.value);
        }
        e = Nx(e);
      }
      function n() {
        return null;
      }
      return n;
    }
    const d4 = Vi(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), B_ = Vi(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), L_ = Vi(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), OA = Vi(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), f4 = Vi(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), AA = Vi(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), DA = Vi(["#text"]), RA = Vi(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), P_ = Vi(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), m4 = Vi(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), I_ = Vi(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), NA = Sd(/\{\{[\w\W]*|[\w\W]*\}\}/gm), MA = Sd(/<%[\w\W]*|[\w\W]*%>/gm), WB = Sd(/\${[\w\W]*}/gm), qB = Sd(/^data-[\-\w.\u00B7-\uFFFF]/), GB = Sd(/^aria-[\-\w]+$/), BA = Sd(
      /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
      // eslint-disable-line no-useless-escape
    ), KB = Sd(/^(?:\w+script|data):/i), F_ = Sd(
      /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
      // eslint-disable-line no-control-regex
    ), p4 = Sd(/^html$/i), LA = Sd(/^[a-z][.\w]*(-[.\w]+)+$/i);
    var g4 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      MUSTACHE_EXPR: NA,
      ERB_EXPR: MA,
      TMPLIT_EXPR: WB,
      DATA_ATTR: qB,
      ARIA_ATTR: GB,
      IS_ALLOWED_URI: BA,
      IS_SCRIPT_OR_DATA: KB,
      ATTR_WHITESPACE: F_,
      DOCTYPE_NAME: p4,
      CUSTOM_ELEMENT: LA
    });
    const Fx = {
      element: 1,
      attribute: 2,
      text: 3,
      cdataSection: 4,
      entityReference: 5,
      // Deprecated
      entityNode: 6,
      // Deprecated
      progressingInstruction: 7,
      comment: 8,
      document: 9,
      documentType: 10,
      documentFragment: 11,
      notation: 12
      // Deprecated
    }, YB = function() {
      return typeof window > "u" ? null : window;
    }, PA = function(t, n) {
      if (typeof t != "object" || typeof t.createPolicy != "function")
        return null;
      let r = null;
      const a = "data-tt-policy-suffix";
      n && n.hasAttribute(a) && (r = n.getAttribute(a));
      const c = "dompurify" + (r ? "#" + r : "");
      try {
        return t.createPolicy(c, {
          createHTML(d) {
            return d;
          },
          createScriptURL(d) {
            return d;
          }
        });
      } catch {
        return console.warn("TrustedTypes policy " + c + " could not be created."), null;
      }
    };
    function IA() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : YB();
      const t = (Jo) => IA(Jo);
      if (t.version = "3.1.7", t.removed = [], !e || !e.document || e.document.nodeType !== Fx.document)
        return t.isSupported = !1, t;
      let {
        document: n
      } = e;
      const r = n, a = r.currentScript, {
        DocumentFragment: c,
        HTMLTemplateElement: d,
        Node: h,
        Element: k,
        NodeFilter: D,
        NamedNodeMap: H = e.NamedNodeMap || e.MozNamedAttrMap,
        HTMLFormElement: U,
        DOMParser: G,
        trustedTypes: ie
      } = e, ye = k.prototype, ae = Q0(ye, "cloneNode"), xe = Q0(ye, "remove"), Ne = Q0(ye, "nextSibling"), Ie = Q0(ye, "childNodes"), Fe = Q0(ye, "parentNode");
      if (typeof d == "function") {
        const Jo = n.createElement("template");
        Jo.content && Jo.content.ownerDocument && (n = Jo.content.ownerDocument);
      }
      let je, _t = "";
      const {
        implementation: Zt,
        createNodeIterator: fn,
        createDocumentFragment: at,
        getElementsByTagName: et
      } = n, {
        importNode: Mt
      } = r;
      let gn = {};
      t.isSupported = typeof i4 == "function" && typeof Fe == "function" && Zt && Zt.createHTMLDocument !== void 0;
      const {
        MUSTACHE_EXPR: Fn,
        ERB_EXPR: Uo,
        TMPLIT_EXPR: qo,
        DATA_ATTR: vs,
        ARIA_ATTR: Vs,
        IS_SCRIPT_OR_DATA: Ci,
        ATTR_WHITESPACE: Yc,
        CUSTOM_ELEMENT: Ql
      } = g4;
      let {
        IS_ALLOWED_URI: sn
      } = g4, zn = null;
      const Ar = Ds({}, [...d4, ...B_, ...L_, ...f4, ...DA]);
      let xr = null;
      const On = Ds({}, [...RA, ...P_, ...m4, ...I_]);
      let Rn = Object.seal(l4(null, {
        tagNameCheck: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: null
        },
        attributeNameCheck: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: null
        },
        allowCustomizedBuiltInElements: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: !1
        }
      })), qt = null, bo = null, hr = !0, Ss = !0, na = !1, Ed = !0, Mm = !1, Sy = !0, Td = !1, Qg = !1, vo = !1, br = !1, Es = !1, Za = !1, ti = !0, tg = !1;
      const Z2 = "user-content-";
      let rT = !0, hw = !1, mv = {}, pv = null;
      const sT = Ds({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
      let A5 = null;
      const D5 = Ds({}, ["audio", "video", "img", "source", "image", "track"]);
      let W2 = null;
      const R5 = Ds({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), gv = "http://www.w3.org/1998/Math/MathML", q2 = "http://www.w3.org/2000/svg", eh = "http://www.w3.org/1999/xhtml";
      let W1 = eh, aT = !1, iT = null;
      const N5 = Ds({}, [gv, q2, eh], u4);
      let G2 = null;
      const _F = ["application/xhtml+xml", "text/html"], CF = "text/html";
      let Yu = null, bw = null;
      const hv = n.createElement("form"), lT = function(tt) {
        return tt instanceof RegExp || tt instanceof Function;
      }, Ke = function() {
        let tt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!(bw && bw === tt)) {
          if ((!tt || typeof tt != "object") && (tt = {}), tt = by(tt), G2 = // eslint-disable-next-line unicorn/prefer-includes
          _F.indexOf(tt.PARSER_MEDIA_TYPE) === -1 ? CF : tt.PARSER_MEDIA_TYPE, Yu = G2 === "application/xhtml+xml" ? u4 : hy, zn = qp(tt, "ALLOWED_TAGS") ? Ds({}, tt.ALLOWED_TAGS, Yu) : Ar, xr = qp(tt, "ALLOWED_ATTR") ? Ds({}, tt.ALLOWED_ATTR, Yu) : On, iT = qp(tt, "ALLOWED_NAMESPACES") ? Ds({}, tt.ALLOWED_NAMESPACES, u4) : N5, W2 = qp(tt, "ADD_URI_SAFE_ATTR") ? Ds(
            by(R5),
            // eslint-disable-line indent
            tt.ADD_URI_SAFE_ATTR,
            // eslint-disable-line indent
            Yu
            // eslint-disable-line indent
          ) : R5, A5 = qp(tt, "ADD_DATA_URI_TAGS") ? Ds(
            by(D5),
            // eslint-disable-line indent
            tt.ADD_DATA_URI_TAGS,
            // eslint-disable-line indent
            Yu
            // eslint-disable-line indent
          ) : D5, pv = qp(tt, "FORBID_CONTENTS") ? Ds({}, tt.FORBID_CONTENTS, Yu) : sT, qt = qp(tt, "FORBID_TAGS") ? Ds({}, tt.FORBID_TAGS, Yu) : {}, bo = qp(tt, "FORBID_ATTR") ? Ds({}, tt.FORBID_ATTR, Yu) : {}, mv = qp(tt, "USE_PROFILES") ? tt.USE_PROFILES : !1, hr = tt.ALLOW_ARIA_ATTR !== !1, Ss = tt.ALLOW_DATA_ATTR !== !1, na = tt.ALLOW_UNKNOWN_PROTOCOLS || !1, Ed = tt.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Mm = tt.SAFE_FOR_TEMPLATES || !1, Sy = tt.SAFE_FOR_XML !== !1, Td = tt.WHOLE_DOCUMENT || !1, br = tt.RETURN_DOM || !1, Es = tt.RETURN_DOM_FRAGMENT || !1, Za = tt.RETURN_TRUSTED_TYPE || !1, vo = tt.FORCE_BODY || !1, ti = tt.SANITIZE_DOM !== !1, tg = tt.SANITIZE_NAMED_PROPS || !1, rT = tt.KEEP_CONTENT !== !1, hw = tt.IN_PLACE || !1, sn = tt.ALLOWED_URI_REGEXP || BA, W1 = tt.NAMESPACE || eh, Rn = tt.CUSTOM_ELEMENT_HANDLING || {}, tt.CUSTOM_ELEMENT_HANDLING && lT(tt.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Rn.tagNameCheck = tt.CUSTOM_ELEMENT_HANDLING.tagNameCheck), tt.CUSTOM_ELEMENT_HANDLING && lT(tt.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Rn.attributeNameCheck = tt.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), tt.CUSTOM_ELEMENT_HANDLING && typeof tt.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Rn.allowCustomizedBuiltInElements = tt.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Mm && (Ss = !1), Es && (br = !0), mv && (zn = Ds({}, DA), xr = [], mv.html === !0 && (Ds(zn, d4), Ds(xr, RA)), mv.svg === !0 && (Ds(zn, B_), Ds(xr, P_), Ds(xr, I_)), mv.svgFilters === !0 && (Ds(zn, L_), Ds(xr, P_), Ds(xr, I_)), mv.mathMl === !0 && (Ds(zn, f4), Ds(xr, m4), Ds(xr, I_))), tt.ADD_TAGS && (zn === Ar && (zn = by(zn)), Ds(zn, tt.ADD_TAGS, Yu)), tt.ADD_ATTR && (xr === On && (xr = by(xr)), Ds(xr, tt.ADD_ATTR, Yu)), tt.ADD_URI_SAFE_ATTR && Ds(W2, tt.ADD_URI_SAFE_ATTR, Yu), tt.FORBID_CONTENTS && (pv === sT && (pv = by(pv)), Ds(pv, tt.FORBID_CONTENTS, Yu)), rT && (zn["#text"] = !0), Td && Ds(zn, ["html", "head", "body"]), zn.table && (Ds(zn, ["tbody"]), delete qt.tbody), tt.TRUSTED_TYPES_POLICY) {
            if (typeof tt.TRUSTED_TYPES_POLICY.createHTML != "function")
              throw Ix('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
            if (typeof tt.TRUSTED_TYPES_POLICY.createScriptURL != "function")
              throw Ix('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
            je = tt.TRUSTED_TYPES_POLICY, _t = je.createHTML("");
          } else
            je === void 0 && (je = PA(ie, a)), je !== null && typeof _t == "string" && (_t = je.createHTML(""));
          Vi && Vi(tt), bw = tt;
        }
      }, Je = Ds({}, ["mi", "mo", "mn", "ms", "mtext"]), nn = Ds({}, ["annotation-xml"]), Ut = Ds({}, ["title", "style", "font", "a", "script"]), Wn = Ds({}, [...B_, ...L_, ...OA]), wr = Ds({}, [...f4, ...AA]), di = function(tt) {
        let In = Fe(tt);
        (!In || !In.tagName) && (In = {
          namespaceURI: W1,
          tagName: "template"
        });
        const jo = hy(tt.tagName), wl = hy(In.tagName);
        return iT[tt.namespaceURI] ? tt.namespaceURI === q2 ? In.namespaceURI === eh ? jo === "svg" : In.namespaceURI === gv ? jo === "svg" && (wl === "annotation-xml" || Je[wl]) : !!Wn[jo] : tt.namespaceURI === gv ? In.namespaceURI === eh ? jo === "math" : In.namespaceURI === q2 ? jo === "math" && nn[wl] : !!wr[jo] : tt.namespaceURI === eh ? In.namespaceURI === q2 && !nn[wl] || In.namespaceURI === gv && !Je[wl] ? !1 : !wr[jo] && (Ut[jo] || !Wn[jo]) : !!(G2 === "application/xhtml+xml" && iT[tt.namespaceURI]) : !1;
      }, yc = function(tt) {
        Lx(t.removed, {
          element: tt
        });
        try {
          Fe(tt).removeChild(tt);
        } catch {
          xe(tt);
        }
      }, ec = function(tt, In) {
        try {
          Lx(t.removed, {
            attribute: In.getAttributeNode(tt),
            from: In
          });
        } catch {
          Lx(t.removed, {
            attribute: null,
            from: In
          });
        }
        if (In.removeAttribute(tt), tt === "is" && !xr[tt])
          if (br || Es)
            try {
              yc(In);
            } catch {
            }
          else
            try {
              In.setAttribute(tt, "");
            } catch {
            }
      }, cT = function(tt) {
        let In = null, jo = null;
        if (vo)
          tt = "<remove></remove>" + tt;
        else {
          const zd = TA(tt, /^[\r\n\t ]+/);
          jo = zd && zd[0];
        }
        G2 === "application/xhtml+xml" && W1 === eh && (tt = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + tt + "</body></html>");
        const wl = je ? je.createHTML(tt) : tt;
        if (W1 === eh)
          try {
            In = new G().parseFromString(wl, G2);
          } catch {
          }
        if (!In || !In.documentElement) {
          In = Zt.createDocument(W1, "template", null);
          try {
            In.documentElement.innerHTML = aT ? _t : wl;
          } catch {
          }
        }
        const Jf = In.body || In.documentElement;
        return tt && jo && Jf.insertBefore(n.createTextNode(jo), Jf.childNodes[0] || null), W1 === eh ? et.call(In, Td ? "html" : "body")[0] : Td ? In.documentElement : Jf;
      }, uT = function(tt) {
        return fn.call(
          tt.ownerDocument || tt,
          tt,
          // eslint-disable-next-line no-bitwise
          D.SHOW_ELEMENT | D.SHOW_COMMENT | D.SHOW_TEXT | D.SHOW_PROCESSING_INSTRUCTION | D.SHOW_CDATA_SECTION,
          null
        );
      }, SF = function(tt) {
        return tt instanceof U && (typeof tt.nodeName != "string" || typeof tt.textContent != "string" || typeof tt.removeChild != "function" || !(tt.attributes instanceof H) || typeof tt.removeAttribute != "function" || typeof tt.setAttribute != "function" || typeof tt.namespaceURI != "string" || typeof tt.insertBefore != "function" || typeof tt.hasChildNodes != "function");
      }, EF = function(tt) {
        return typeof h == "function" && tt instanceof h;
      }, q1 = function(tt, In, jo) {
        gn[tt] && Bx(gn[tt], (wl) => {
          wl.call(t, In, jo, bw);
        });
      }, TF = function(tt) {
        let In = null;
        if (q1("beforeSanitizeElements", tt, null), SF(tt))
          return yc(tt), !0;
        const jo = Yu(tt.nodeName);
        if (q1("uponSanitizeElement", tt, {
          tagName: jo,
          allowedTags: zn
        }), tt.hasChildNodes() && !EF(tt.firstElementChild) && mf(/<[/\w]/g, tt.innerHTML) && mf(/<[/\w]/g, tt.textContent) || tt.nodeType === Fx.progressingInstruction || Sy && tt.nodeType === Fx.comment && mf(/<[/\w]/g, tt.data))
          return yc(tt), !0;
        if (!zn[jo] || qt[jo]) {
          if (!qt[jo] && OF(jo) && (Rn.tagNameCheck instanceof RegExp && mf(Rn.tagNameCheck, jo) || Rn.tagNameCheck instanceof Function && Rn.tagNameCheck(jo)))
            return !1;
          if (rT && !pv[jo]) {
            const wl = Fe(tt) || tt.parentNode, Jf = Ie(tt) || tt.childNodes;
            if (Jf && wl) {
              const zd = Jf.length;
              for (let wp = zd - 1; wp >= 0; --wp) {
                const Ey = ae(Jf[wp], !0);
                Ey.__removalCount = (tt.__removalCount || 0) + 1, wl.insertBefore(Ey, Ne(tt));
              }
            }
          }
          return yc(tt), !0;
        }
        return tt instanceof k && !di(tt) || (jo === "noscript" || jo === "noembed" || jo === "noframes") && mf(/<\/no(script|embed|frames)/i, tt.innerHTML) ? (yc(tt), !0) : (Mm && tt.nodeType === Fx.text && (In = tt.textContent, Bx([Fn, Uo, qo], (wl) => {
          In = Px(In, wl, " ");
        }), tt.textContent !== In && (Lx(t.removed, {
          element: tt.cloneNode()
        }), tt.textContent = In)), q1("afterSanitizeElements", tt, null), !1);
      }, zF = function(tt, In, jo) {
        if (ti && (In === "id" || In === "name") && (jo in n || jo in hv))
          return !1;
        if (!(Ss && !bo[In] && mf(vs, In))) {
          if (!(hr && mf(Vs, In))) {
            if (!xr[In] || bo[In]) {
              if (
                // First condition does a very basic check if a) it's basically a valid custom element tagname AND
                // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
                !(OF(tt) && (Rn.tagNameCheck instanceof RegExp && mf(Rn.tagNameCheck, tt) || Rn.tagNameCheck instanceof Function && Rn.tagNameCheck(tt)) && (Rn.attributeNameCheck instanceof RegExp && mf(Rn.attributeNameCheck, In) || Rn.attributeNameCheck instanceof Function && Rn.attributeNameCheck(In)) || // Alternative, second condition checks if it's an `is`-attribute, AND
                // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                In === "is" && Rn.allowCustomizedBuiltInElements && (Rn.tagNameCheck instanceof RegExp && mf(Rn.tagNameCheck, jo) || Rn.tagNameCheck instanceof Function && Rn.tagNameCheck(jo)))
              )
                return !1;
            } else if (!W2[In]) {
              if (!mf(sn, Px(jo, Yc, ""))) {
                if (!((In === "src" || In === "xlink:href" || In === "href") && tt !== "script" && UB(jo, "data:") === 0 && A5[tt])) {
                  if (!(na && !mf(Ci, Px(jo, Yc, "")))) {
                    if (jo)
                      return !1;
                  }
                }
              }
            }
          }
        }
        return !0;
      }, OF = function(tt) {
        return tt !== "annotation-xml" && TA(tt, Ql);
      }, AF = function(tt) {
        q1("beforeSanitizeAttributes", tt, null);
        const {
          attributes: In
        } = tt;
        if (!In)
          return;
        const jo = {
          attrName: "",
          attrValue: "",
          keepAttr: !0,
          allowedAttributes: xr
        };
        let wl = In.length;
        for (; wl--; ) {
          const Jf = In[wl], {
            name: zd,
            namespaceURI: wp,
            value: Ey
          } = Jf, dT = Yu(zd);
          let hf = zd === "value" ? Ey : jB(Ey);
          const Nq = hf;
          if (jo.attrName = dT, jo.attrValue = hf, jo.keepAttr = !0, jo.forceKeepAttr = void 0, q1("uponSanitizeAttribute", tt, jo), hf = jo.attrValue, jo.forceKeepAttr)
            continue;
          if (!jo.keepAttr) {
            ec(zd, tt);
            continue;
          }
          if (!Ed && mf(/\/>/i, hf)) {
            ec(zd, tt);
            continue;
          }
          Mm && Bx([Fn, Uo, qo], (RF) => {
            hf = Px(hf, RF, " ");
          });
          const DF = Yu(tt.nodeName);
          if (!zF(DF, dT, hf)) {
            ec(zd, tt);
            continue;
          }
          if (tg && (dT === "id" || dT === "name") && (ec(zd, tt), hf = Z2 + hf), Sy && mf(/((--!?|])>)|<\/(style|title)/i, hf)) {
            ec(zd, tt);
            continue;
          }
          if (je && typeof ie == "object" && typeof ie.getAttributeType == "function" && !wp)
            switch (ie.getAttributeType(DF, dT)) {
              case "TrustedHTML": {
                hf = je.createHTML(hf);
                break;
              }
              case "TrustedScriptURL": {
                hf = je.createScriptURL(hf);
                break;
              }
            }
          if (hf !== Nq)
            try {
              wp ? tt.setAttributeNS(wp, zd, hf) : tt.setAttribute(zd, hf), SF(tt) ? yc(tt) : EA(t.removed);
            } catch {
            }
        }
        q1("afterSanitizeAttributes", tt, null);
      }, Rq = function Jo(tt) {
        let In = null;
        const jo = uT(tt);
        for (q1("beforeSanitizeShadowDOM", tt, null); In = jo.nextNode(); )
          q1("uponSanitizeShadowNode", In, null), !TF(In) && (In.content instanceof c && Jo(In.content), AF(In));
        q1("afterSanitizeShadowDOM", tt, null);
      };
      return t.sanitize = function(Jo) {
        let tt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, In = null, jo = null, wl = null, Jf = null;
        if (aT = !Jo, aT && (Jo = "<!-->"), typeof Jo != "string" && !EF(Jo))
          if (typeof Jo.toString == "function") {
            if (Jo = Jo.toString(), typeof Jo != "string")
              throw Ix("dirty is not a string, aborting");
          } else
            throw Ix("toString is not a function");
        if (!t.isSupported)
          return Jo;
        if (Qg || Ke(tt), t.removed = [], typeof Jo == "string" && (hw = !1), hw) {
          if (Jo.nodeName) {
            const Ey = Yu(Jo.nodeName);
            if (!zn[Ey] || qt[Ey])
              throw Ix("root node is forbidden and cannot be sanitized in-place");
          }
        } else if (Jo instanceof h)
          In = cT("<!---->"), jo = In.ownerDocument.importNode(Jo, !0), jo.nodeType === Fx.element && jo.nodeName === "BODY" || jo.nodeName === "HTML" ? In = jo : In.appendChild(jo);
        else {
          if (!br && !Mm && !Td && // eslint-disable-next-line unicorn/prefer-includes
          Jo.indexOf("<") === -1)
            return je && Za ? je.createHTML(Jo) : Jo;
          if (In = cT(Jo), !In)
            return br ? null : Za ? _t : "";
        }
        In && vo && yc(In.firstChild);
        const zd = uT(hw ? Jo : In);
        for (; wl = zd.nextNode(); )
          TF(wl) || (wl.content instanceof c && Rq(wl.content), AF(wl));
        if (hw)
          return Jo;
        if (br) {
          if (Es)
            for (Jf = at.call(In.ownerDocument); In.firstChild; )
              Jf.appendChild(In.firstChild);
          else
            Jf = In;
          return (xr.shadowroot || xr.shadowrootmode) && (Jf = Mt.call(r, Jf, !0)), Jf;
        }
        let wp = Td ? In.outerHTML : In.innerHTML;
        return Td && zn["!doctype"] && In.ownerDocument && In.ownerDocument.doctype && In.ownerDocument.doctype.name && mf(p4, In.ownerDocument.doctype.name) && (wp = "<!DOCTYPE " + In.ownerDocument.doctype.name + `>
` + wp), Mm && Bx([Fn, Uo, qo], (Ey) => {
          wp = Px(wp, Ey, " ");
        }), je && Za ? je.createHTML(wp) : wp;
      }, t.setConfig = function() {
        let Jo = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        Ke(Jo), Qg = !0;
      }, t.clearConfig = function() {
        bw = null, Qg = !1;
      }, t.isValidAttribute = function(Jo, tt, In) {
        bw || Ke({});
        const jo = Yu(Jo), wl = Yu(tt);
        return zF(jo, wl, In);
      }, t.addHook = function(Jo, tt) {
        typeof tt == "function" && (gn[Jo] = gn[Jo] || [], Lx(gn[Jo], tt));
      }, t.removeHook = function(Jo) {
        if (gn[Jo])
          return EA(gn[Jo]);
      }, t.removeHooks = function(Jo) {
        gn[Jo] && (gn[Jo] = []);
      }, t.removeAllHooks = function() {
        gn = {};
      }, t;
    }
    var $_ = IA();
    const h4 = Ht.each, XB = Ht.trim, Il = [
      "source",
      "protocol",
      "authority",
      "userInfo",
      "user",
      "password",
      "host",
      "port",
      "relative",
      "path",
      "directory",
      "file",
      "query",
      "anchor"
    ], Wg = {
      ftp: 21,
      http: 80,
      https: 443,
      mailto: 25
    }, JB = [
      "img",
      "video"
    ], QB = (e, t) => Xe(e) ? !e : Xe(t) ? !So(JB, t) : !0, e6 = (e) => {
      try {
        return decodeURIComponent(e);
      } catch {
        return unescape(e);
      }
    }, b4 = (e, t, n) => {
      const r = e6(t).replace(/\s/g, "");
      return e.allow_script_urls ? !1 : /((java|vb)script|mhtml):/i.test(r) ? !0 : e.allow_html_data_urls ? !1 : /^data:image\//i.test(r) ? QB(e.allow_svg_data_urls, n) && /^data:image\/svg\+xml/i.test(r) : /^data:/i.test(r);
    };
    class Zu {
      static parseDataUri(t) {
        let n;
        const r = decodeURIComponent(t).split(","), a = /data:([^;]+)/.exec(r[0]);
        return a && (n = a[1]), {
          type: n,
          data: r[1]
        };
      }
      static isDomSafe(t, n, r = {}) {
        if (r.allow_script_urls)
          return !0;
        {
          const a = ma.decode(t).replace(/[\s\u0000-\u001F]+/g, "");
          return !b4(r, a, n);
        }
      }
      static getDocumentBaseUrl(t) {
        var n;
        let r;
        return t.protocol.indexOf("http") !== 0 && t.protocol !== "file:" ? r = (n = t.href) !== null && n !== void 0 ? n : "" : r = t.protocol + "//" + t.host + t.pathname, /^[^:]+:\/\/\/?[^\/]+\//.test(r) && (r = r.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(r) || (r += "/")), r;
      }
      constructor(t, n = {}) {
        this.path = "", this.directory = "", t = XB(t), this.settings = n;
        const r = n.base_uri, a = this;
        if (/^([\w\-]+):([^\/]{2})/i.test(t) || /^\s*#/.test(t)) {
          a.source = t;
          return;
        }
        const c = t.indexOf("//") === 0;
        if (t.indexOf("/") === 0 && !c && (t = (r && r.protocol || "http") + "://mce_host" + t), !/^[\w\-]*:?\/\//.test(t)) {
          const h = r ? r.path : new Zu(document.location.href).directory;
          if ((r == null ? void 0 : r.protocol) === "")
            t = "//mce_host" + a.toAbsPath(h, t);
          else {
            const k = /([^#?]*)([#?]?.*)/.exec(t);
            k && (t = (r && r.protocol || "http") + "://mce_host" + a.toAbsPath(h, k[1]) + k[2]);
          }
        }
        t = t.replace(/@@/g, "(mce_at)");
        const d = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(t);
        d && h4(Il, (h, k) => {
          let D = d[k];
          D && (D = D.replace(/\(mce_at\)/g, "@@")), a[h] = D;
        }), r && (a.protocol || (a.protocol = r.protocol), a.userInfo || (a.userInfo = r.userInfo), !a.port && a.host === "mce_host" && (a.port = r.port), (!a.host || a.host === "mce_host") && (a.host = r.host), a.source = ""), c && (a.protocol = "");
      }
      setPath(t) {
        const n = /^(.*?)\/?(\w+)?$/.exec(t);
        n && (this.path = n[0], this.directory = n[1], this.file = n[2]), this.source = "", this.getURI();
      }
      toRelative(t) {
        if (t === "./")
          return t;
        const n = new Zu(t, { base_uri: this });
        if (n.host !== "mce_host" && this.host !== n.host && n.host || this.port !== n.port || this.protocol !== n.protocol && n.protocol !== "")
          return n.getURI();
        const r = this.getURI(), a = n.getURI();
        if (r === a || r.charAt(r.length - 1) === "/" && r.substr(0, r.length - 1) === a)
          return r;
        let c = this.toRelPath(this.path, n.path);
        return n.query && (c += "?" + n.query), n.anchor && (c += "#" + n.anchor), c;
      }
      toAbsolute(t, n) {
        const r = new Zu(t, { base_uri: this });
        return r.getURI(n && this.isSameOrigin(r));
      }
      isSameOrigin(t) {
        if (this.host == t.host && this.protocol == t.protocol) {
          if (this.port == t.port)
            return !0;
          const n = this.protocol ? Wg[this.protocol] : null;
          if (n && (this.port || n) == (t.port || n))
            return !0;
        }
        return !1;
      }
      toRelPath(t, n) {
        let r = 0, a = "", c, d;
        const h = t.substring(0, t.lastIndexOf("/")).split("/"), k = n.split("/");
        if (h.length >= k.length) {
          for (c = 0, d = h.length; c < d; c++)
            if (c >= k.length || h[c] !== k[c]) {
              r = c + 1;
              break;
            }
        }
        if (h.length < k.length) {
          for (c = 0, d = k.length; c < d; c++)
            if (c >= h.length || h[c] !== k[c]) {
              r = c + 1;
              break;
            }
        }
        if (r === 1)
          return n;
        for (c = 0, d = h.length - (r - 1); c < d; c++)
          a += "../";
        for (c = r - 1, d = k.length; c < d; c++)
          c !== r - 1 ? a += "/" + k[c] : a += k[c];
        return a;
      }
      toAbsPath(t, n) {
        let r = 0;
        const a = /\/$/.test(n) ? "/" : "", c = t.split("/"), d = n.split("/"), h = [];
        h4(c, (U) => {
          U && h.push(U);
        });
        const k = [];
        for (let U = d.length - 1; U >= 0; U--)
          if (!(d[U].length === 0 || d[U] === ".")) {
            if (d[U] === "..") {
              r++;
              continue;
            }
            if (r > 0) {
              r--;
              continue;
            }
            k.push(d[U]);
          }
        const D = h.length - r;
        let H;
        return D <= 0 ? H = Ca(k).join("/") : H = h.slice(0, D).join("/") + "/" + Ca(k).join("/"), H.indexOf("/") !== 0 && (H = "/" + H), a && H.lastIndexOf("/") !== H.length - 1 && (H += a), H;
      }
      getURI(t = !1) {
        let n;
        return (!this.source || t) && (n = "", t || (this.protocol ? n += this.protocol + "://" : n += "//", this.userInfo && (n += this.userInfo + "@"), this.host && (n += this.host), this.port && (n += ":" + this.port)), this.path && (n += this.path), this.query && (n += "?" + this.query), this.anchor && (n += "#" + this.anchor), this.source = n), this.source;
      }
    }
    const t6 = Ht.makeMap("src,href,data,background,action,formaction,poster,xlink:href"), Nm = "data-mce-type";
    let FA = 0;
    const $A = (e, t, n, r, a) => {
      var c, d, h, k;
      const D = t.validate, H = n.getSpecialElements();
      e.nodeType === eu && !t.allow_conditional_comments && /^\[if/i.test((c = e.nodeValue) !== null && c !== void 0 ? c : "") && (e.nodeValue = " " + e.nodeValue);
      const U = (d = a == null ? void 0 : a.tagName) !== null && d !== void 0 ? d : e.nodeName.toLowerCase();
      if (r !== "html" && n.isValid(r)) {
        Xe(a) && (a.allowedTags[U] = !0);
        return;
      }
      if (e.nodeType !== _c || U === "body")
        return;
      const G = be.fromDom(e), ie = La(G, Nm), ye = Qi(G, "data-mce-bogus");
      if (!ie && Ot(ye)) {
        ye === "all" ? dr(G) : wa(G);
        return;
      }
      const ae = n.getElementRule(U);
      if (D && !ae) {
        Yn(H, U) ? dr(G) : wa(G);
        return;
      } else
        Xe(a) && (a.allowedTags[U] = !0);
      if (D && ae && !ie) {
        if (ut((h = ae.attributesForced) !== null && h !== void 0 ? h : [], (xe) => {
          Vr(G, xe.name, xe.value === "{$uid}" ? `mce_${FA++}` : xe.value);
        }), ut((k = ae.attributesDefault) !== null && k !== void 0 ? k : [], (xe) => {
          La(G, xe.name) || Vr(G, xe.name, xe.value === "{$uid}" ? `mce_${FA++}` : xe.value);
        }), ae.attributesRequired && !cr(ae.attributesRequired, (xe) => La(G, xe))) {
          wa(G);
          return;
        }
        if (ae.removeEmptyAttrs && Hd(G)) {
          wa(G);
          return;
        }
        ae.outputName && ae.outputName !== U && _h(G, ae.outputName);
      }
    }, HA = (e, t, n, r, a) => {
      const c = e.tagName.toLowerCase(), { attrName: d, attrValue: h } = a;
      a.keepAttr = y4(t, n, r, c, d, h), a.keepAttr ? (a.allowedAttributes[d] = !0, H_(d, n) && (a.attrValue = d), t.allow_svg_data_urls && Dr(h, "data:image/svg+xml") && (a.forceKeepAttr = !0)) : VA(e, d) && (a.forceKeepAttr = !0);
    }, y4 = (e, t, n, r, a, c) => n !== "html" && !Ml(r) ? !0 : !(a in t6 && b4(e, c, r)) && (!e.validate || t.isValid(r, a) || Dr(a, "data-") || Dr(a, "aria-")), VA = (e, t) => e.hasAttribute(Nm) && (t === "id" || t === "class" || t === "style"), H_ = (e, t) => e in t.getBoolAttrs(), UA = (e, t, n, r) => {
      const { attributes: a } = e;
      for (let c = a.length - 1; c >= 0; c--) {
        const d = a[c], h = d.name, k = d.value;
        !y4(t, n, r, e.tagName.toLowerCase(), h, k) && !VA(e, h) ? e.removeAttribute(h) : H_(h, n) && e.setAttribute(h, h);
      }
    }, n6 = (e, t, n) => {
      const r = $_();
      return r.addHook("uponSanitizeElement", (a, c) => {
        $A(a, e, t, n.track(a), c);
      }), r.addHook("uponSanitizeAttribute", (a, c) => {
        HA(a, e, t, n.current(), c);
      }), r;
    }, o6 = (e, t) => {
      const r = { ...{
        IN_PLACE: !0,
        ALLOW_UNKNOWN_PROTOCOLS: !0,
        ALLOWED_TAGS: [
          "#comment",
          "#cdata-section",
          "body"
        ],
        ALLOWED_ATTR: [],
        SAFE_FOR_XML: !1
      } };
      return r.PARSER_MEDIA_TYPE = t, e.allow_script_urls ? r.ALLOWED_URI_REGEXP = /.*/ : e.allow_html_data_urls && (r.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i), r;
    }, jA = (e) => {
      const t = [
        "type",
        "href",
        "role",
        "arcrole",
        "title",
        "show",
        "actuate",
        "label",
        "from",
        "to"
      ].map((r) => `xlink:${r}`), n = {
        IN_PLACE: !0,
        USE_PROFILES: {
          html: !0,
          svg: !0,
          svgFilters: !0
        },
        ALLOWED_ATTR: t
      };
      return $_().sanitize(e, n), e.innerHTML;
    }, ZA = (e, t) => {
      const n = ih();
      if (e.sanitize) {
        const r = n6(e, t, n);
        return {
          sanitizeHtmlElement: (c, d) => {
            r.sanitize(c, o6(e, d)), r.removed = [], n.reset();
          },
          sanitizeNamespaceElement: jA
        };
      } else
        return {
          sanitizeHtmlElement: (c, d) => {
            const h = document.createNodeIterator(c, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);
            let k;
            for (; k = h.nextNode(); ) {
              const D = n.track(k);
              $A(k, e, t, D), wn(k) && UA(k, e, t, D);
            }
            n.reset();
          },
          sanitizeNamespaceElement: ht
        };
    }, V_ = Ht.makeMap, U_ = Ht.extend, j_ = (e, t, n, r) => {
      const a = e.name, c = a in n && a !== "title" && a !== "textarea" && a !== "noscript", d = t.childNodes;
      for (let h = 0, k = d.length; h < k; h++) {
        const D = d[h], H = new qc(D.nodeName.toLowerCase(), D.nodeType);
        if (wn(D)) {
          const U = D.attributes;
          for (let G = 0, ie = U.length; G < ie; G++) {
            const ye = U[G];
            H.attr(ye.name, ye.value);
          }
          Ml(H.name) && (r(D), H.value = D.innerHTML);
        } else
          At(D) ? (H.value = D.data, c && (H.raw = !0)) : (Gd(D) || Fm(D) || qd(D)) && (H.value = D.data);
        Ml(H.name) || j_(H, D, n, r), e.append(H);
      }
    }, v4 = (e, t, n) => {
      const r = [];
      for (let a = e, c = a; a; c = a, a = a.walk()) {
        const d = a;
        ut(t, (h) => h(d)), jn(d.parent) && d !== e ? a = c : r.push(d);
      }
      for (let a = r.length - 1; a >= 0; a--) {
        const c = r[a];
        ut(n, (d) => d(c));
      }
    }, WA = (e, t, n, r) => {
      const a = n.validate, c = t.getNonEmptyElements(), d = t.getWhitespaceElements(), h = U_(V_("script,style,head,html,body,title,meta,param"), t.getBlockElements()), k = hh(t), D = /[ \t\r\n]+/g, H = /^[ \t\r\n]+/, U = /[ \t\r\n]+$/, G = (Ie) => {
        let Fe = Ie.parent;
        for (; Xe(Fe); ) {
          if (Fe.name in d)
            return !0;
          Fe = Fe.parent;
        }
        return !1;
      }, ie = (Ie) => {
        let Fe = Ie;
        for (; Xe(Fe); ) {
          if (Fe.name in k)
            return W0(t, c, d, Fe);
          Fe = Fe.parent;
        }
        return !1;
      }, ye = (Ie) => Ie.name in h || Au(t, Ie) || Ml(Ie.name) && Ie.parent === e, ae = (Ie, Fe) => {
        const je = Fe ? Ie.prev : Ie.next;
        return Xe(je) || jn(Ie.parent) ? !1 : ye(Ie.parent) && (Ie.parent !== e || r.isRootContent === !0);
      };
      return [
        (Ie) => {
          var Fe;
          if (Ie.type === 3 && !G(Ie)) {
            let je = (Fe = Ie.value) !== null && Fe !== void 0 ? Fe : "";
            je = je.replace(D, " "), (MO(Ie.prev, ye) || ae(Ie, !0)) && (je = je.replace(H, "")), je.length === 0 ? Ie.remove() : Ie.value = je;
          }
        },
        (Ie) => {
          var Fe;
          if (Ie.type === 1) {
            const je = t.getElementRule(Ie.name);
            if (a && je) {
              const _t = W0(t, c, d, Ie);
              je.paddInEmptyBlock && _t && ie(Ie) ? s_(n, r, ye, Ie) : je.removeEmpty && _t ? ye(Ie) ? Ie.remove() : Ie.unwrap() : je.paddEmpty && (_t || a_(Ie)) && s_(n, r, ye, Ie);
            }
          } else if (Ie.type === 3 && !G(Ie)) {
            let je = (Fe = Ie.value) !== null && Fe !== void 0 ? Fe : "";
            (Ie.next && ye(Ie.next) || ae(Ie, !1)) && (je = je.replace(U, "")), je.length === 0 ? Ie.remove() : Ie.value = je;
          }
        }
      ];
    }, qA = (e, t) => {
      var n;
      const r = (n = t.forced_root_block) !== null && n !== void 0 ? n : e.forced_root_block;
      return r === !1 ? "" : r === !0 ? "p" : r;
    }, yy = (e = {}, t = of()) => {
      const n = e4(), r = e4(), a = {
        validate: !0,
        root_name: "body",
        sanitize: !0,
        ...e
      }, c = new DOMParser(), d = ZA(a, t), h = (Fe, je, _t = "html") => {
        const Zt = _t === "xhtml" ? "application/xhtml+xml" : "text/html", fn = Yn(t.getSpecialElements(), je.toLowerCase()), at = fn ? `<${je}>${Fe}</${je}>` : Fe, et = _t === "xhtml" ? `<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>${at}</body></html>` : `<body>${at}</body>`, Mt = c.parseFromString(et, Zt).body;
        return d.sanitizeHtmlElement(Mt, Zt), fn ? Mt.firstChild : Mt;
      }, k = n.addFilter, D = n.getFilters, H = n.removeFilter, U = r.addFilter, G = r.getFilters, ie = r.removeFilter, ye = (Fe, je) => {
        l_(t, Fe) && je.push(Fe);
      }, ae = (Fe, je) => {
        const _t = Ot(je.attr(Nm)), Zt = je.type === 1 && !Yn(Fe, je.name) && !Au(t, je) && !Ml(je.name);
        return je.type === 3 || Zt && !_t;
      }, xe = (Fe, je) => {
        const _t = U_(V_("script,style,head,html,body,title,meta,param"), t.getBlockElements()), Zt = /^[ \t\r\n]+/, fn = /[ \t\r\n]+$/;
        let at = Fe.firstChild, et = null;
        const Mt = (gn) => {
          var Fn, Uo;
          gn && (at = gn.firstChild, at && at.type === 3 && (at.value = (Fn = at.value) === null || Fn === void 0 ? void 0 : Fn.replace(Zt, "")), at = gn.lastChild, at && at.type === 3 && (at.value = (Uo = at.value) === null || Uo === void 0 ? void 0 : Uo.replace(fn, "")));
        };
        if (t.isValidChild(Fe.name, je.toLowerCase())) {
          for (; at; ) {
            const gn = at.next;
            ae(_t, at) ? (et || (et = new qc(je, 1), et.attr(a.forced_root_block_attrs), Fe.insert(et, at)), et.append(at)) : (Mt(et), et = null), at = gn;
          }
          Mt(et);
        }
      }, Ie = {
        schema: t,
        addAttributeFilter: U,
        getAttributeFilters: G,
        removeAttributeFilter: ie,
        addNodeFilter: k,
        getNodeFilters: D,
        removeNodeFilter: H,
        parse: (Fe, je = {}) => {
          var _t;
          const Zt = a.validate, fn = (_t = je.context) !== null && _t !== void 0 ? _t : a.root_name, at = h(Fe, fn, je.format);
          ab(t, at);
          const et = new qc(fn, 11);
          j_(et, at, t.getSpecialElements(), d.sanitizeNamespaceElement), at.innerHTML = "";
          const [Mt, gn] = WA(et, t, a, je), Fn = [], Uo = Zt ? (Ci) => ye(Ci, Fn) : ht, qo = {
            nodes: {},
            attributes: {}
          }, vs = (Ci) => r_(D(), G(), Ci, qo);
          if (v4(et, [
            Mt,
            vs
          ], [
            gn,
            Uo
          ]), Fn.reverse(), Zt && Fn.length > 0)
            if (je.context) {
              const {
                pass: Ci,
                fail: Yc
              } = It(Fn, (Ql) => Ql.parent === et);
              q0(Yc, t, et, vs), je.invalid = Ci.length > 0;
            } else
              q0(Fn, t, et, vs);
          const Vs = qA(a, je);
          return Vs && (et.name === "body" || je.isRootContent) && xe(et, Vs), je.invalid || Om(qo, je), et;
        }
      };
      return a4(Ie, a), vA(Ie, a, t), Ie;
    }, r6 = (e) => f_(e) ? Jl({ validate: !1 }).serialize(e) : e, x4 = (e, t, n) => {
      const r = r6(e), a = t(r);
      if (a.isDefaultPrevented())
        return a;
      if (f_(e))
        if (a.content !== r) {
          const c = yy({
            validate: !1,
            forced_root_block: !1,
            ...n
          }).parse(a.content, { context: e.name });
          return {
            ...a,
            content: c
          };
        } else
          return {
            ...a,
            content: e
          };
      else
        return a;
    }, Z_ = (e, t) => {
      if (t.no_events)
        return Ae.value(t);
      {
        const n = GT(e, t);
        return n.isDefaultPrevented() ? Ae.error(aS(e, {
          content: "",
          ...n
        }).content) : Ae.value(n);
      }
    }, w4 = (e, t, n) => n.no_events ? t : x4(t, (a) => aS(e, {
      ...n,
      content: a
    }), {
      sanitize: Vb(e),
      sandbox_iframes: Rv(e)
    }).content, W_ = (e, t) => {
      if (t.no_events)
        return Ae.value(t);
      {
        const n = x4(t.content, (r) => qT(e, {
          ...t,
          content: r
        }), {
          sanitize: Vb(e),
          sandbox_iframes: Rv(e)
        });
        return n.isDefaultPrevented() ? (sS(e, n), Ae.error(void 0)) : Ae.value(n);
      }
    }, ev = (e, t, n) => {
      n.no_events || sS(e, {
        ...n,
        content: t
      });
    }, q_ = (e, t, n) => ({
      element: e,
      width: t,
      rows: n
    }), k4 = (e, t) => ({
      element: e,
      cells: t
    }), s6 = (e, t) => ({
      x: e,
      y: t
    }), GA = (e, t) => Js(e, t).bind(Us).getOr(1), a6 = (e, t, n, r, a) => {
      const c = GA(a, "rowspan"), d = GA(a, "colspan"), h = e.rows;
      for (let k = n; k < n + c; k++) {
        h[k] || (h[k] = k4(Qm(r), []));
        for (let D = t; D < t + d; D++) {
          const H = h[k].cells;
          H[D] = k === n && D === t ? a : _m(a);
        }
      }
    }, i6 = (e, t, n) => {
      const r = e.rows;
      return !!(r[n] ? r[n].cells : [])[t];
    }, l6 = (e, t, n) => {
      for (; i6(e, t, n); )
        t++;
      return t;
    }, ei = (e) => co(e, (t, n) => n.cells.length > t ? n.cells.length : t, 0), G_ = (e, t) => {
      const n = e.rows;
      for (let r = 0; r < n.length; r++) {
        const a = n[r].cells;
        for (let c = 0; c < a.length; c++)
          if (Le(a[c], t))
            return K.some(s6(c, r));
      }
      return K.none();
    }, Gp = (e, t, n, r, a) => {
      const c = [], d = e.rows;
      for (let h = n; h <= a; h++) {
        const k = d[h].cells, D = t < r ? k.slice(t, r + 1) : k.slice(r, t + 1);
        c.push(k4(d[h].element, D));
      }
      return c;
    }, KA = (e, t, n) => {
      const r = t.x, a = t.y, c = n.x, d = n.y, h = a < d ? Gp(e, r, a, c, d) : Gp(e, r, d, c, a);
      return q_(e.element, ei(h), h);
    }, YA = (e, t) => {
      const n = _m(e.element), r = be.fromTag("tbody");
      return Fa(r, t), Ir(n, r), n;
    }, K_ = (e) => oo(e.rows, (t) => {
      const n = oo(t.cells, (a) => {
        const c = Qm(a);
        return xs(c, "colspan"), xs(c, "rowspan"), c;
      }), r = _m(t.element);
      return Fa(r, n), r;
    }), _4 = (e) => {
      const t = q_(_m(e), 0, []);
      return ut(Ni(e, "tr"), (n, r) => {
        ut(Ni(n, "td,th"), (a, c) => {
          a6(t, l6(t, c, r), r, n, a);
        });
      }), q_(t.element, ei(t.rows), t.rows);
    }, XA = (e) => YA(e, K_(e)), JA = (e, t, n) => G_(e, t).bind((r) => G_(e, n).map((a) => KA(e, r, a))), QA = (e) => po(e, (t) => Eo(t) === "ul" || Eo(t) === "ol"), c6 = (e, t) => po(e, (n) => Eo(n) === "li" && IC(n, t)).fold(dt([]), (n) => QA(e).map((r) => {
      const a = be.fromTag(Eo(r)), c = _l(za(r), (d, h) => Dr(h, "list-style"));
      return Vl(a, c), [
        be.fromTag("li"),
        a
      ];
    }).getOr([])), u6 = (e, t) => {
      const n = co(t, (r, a) => (Ir(a, r), a), e);
      return t.length > 0 ? Ek([n]) : n;
    }, d6 = (e) => Jd(e) ? Br(e).filter(Eu).fold(dt([]), (t) => [
      e,
      t
    ]) : Eu(e) ? [e] : [], eD = (e, t, n) => {
      const r = be.fromDom(t.commonAncestorContainer), a = Zp(r, e), c = ct(a, (k) => n.isWrapper(Eo(k))), d = c6(a, t), h = c.concat(d.length ? d : d6(r));
      return oo(h, _m);
    }, C4 = () => Ek([]), f6 = (e, t, n) => u6(be.fromDom(t.cloneContents()), eD(e, t, n)), S4 = (e, t) => Pa(t, "table", Tt(Le, e)), tD = (e, t) => S4(e, t[0]).bind((n) => {
      const r = t[0], a = t[t.length - 1], c = _4(n);
      return JA(c, r, a).map((d) => Ek([XA(d)]));
    }).getOrThunk(C4), m6 = (e, t, n) => t.length > 0 && t[0].collapsed ? C4() : f6(e, t[0], n), nD = (e, t, n) => {
      const r = BC(t, e);
      return r.length > 0 ? tD(e, r) : m6(e, t, n);
    }, Y_ = (e, t) => t >= 0 && t < e.length && b0(e.charAt(t)), oD = (e) => q(e.innerText), Gc = (e) => e.map((t) => t.nodeName).getOr("div").toLowerCase(), p6 = (e) => K.from(e.selection.getRng()).map((t) => {
      var n;
      const r = K.from(e.dom.getParent(t.commonAncestorContainer, e.dom.isBlock)), a = e.getBody(), c = Gc(r), d = be.fromDom(t.cloneContents());
      Ik(d), ZS(d);
      const h = e.dom.add(a, c, {
        "data-mce-bogus": "all",
        style: "overflow: hidden; opacity: 0;"
      }, d.dom), k = oD(h), D = q((n = h.textContent) !== null && n !== void 0 ? n : "");
      if (e.dom.remove(h), Y_(D, 0) || Y_(D, D.length - 1)) {
        const H = r.getOr(a), U = oD(H), G = U.indexOf(k);
        if (G === -1)
          return k;
        {
          const ie = Y_(U, G - 1), ye = Y_(U, G + k.length);
          return (ie ? " " : "") + k + (ye ? " " : "");
        }
      } else
        return k;
    }).getOr(""), g6 = (e, t) => {
      const n = e.selection.getRng(), r = e.dom.create("body"), a = e.selection.getSel(), c = Lk(e, Uf(a)), d = t.contextual ? nD(be.fromDom(e.getBody()), c, e.schema).dom : n.cloneContents();
      return d && r.appendChild(d), e.selection.serializer.serialize(r, t);
    }, h6 = (e, t) => {
      if (t.format === "text")
        return p6(e);
      {
        const n = g6(e, t);
        return t.format === "tree" ? n : e.selection.isCollapsed() ? "" : n;
      }
    }, b6 = (e, t) => ({
      ...e,
      format: t,
      get: !0,
      selection: !0,
      getInner: !0
    }), X_ = (e, t, n = {}) => {
      const r = b6(n, t);
      return Z_(e, r).fold(Bn, (a) => {
        const c = h6(e, a);
        return w4(e, c, a);
      });
    }, E4 = 0, J_ = 1, Q_ = 2, y6 = (e, t) => {
      const n = e.length + t.length + 2, r = new Array(n), a = new Array(n), c = (H, U, G) => ({
        start: H,
        end: U,
        diag: G
      }), d = (H, U, G, ie, ye) => {
        const ae = k(H, U, G, ie);
        if (ae === null || ae.start === U && ae.diag === U - ie || ae.end === H && ae.diag === H - G) {
          let xe = H, Ne = G;
          for (; xe < U || Ne < ie; )
            xe < U && Ne < ie && e[xe] === t[Ne] ? (ye.push([
              E4,
              e[xe]
            ]), ++xe, ++Ne) : U - H > ie - G ? (ye.push([
              Q_,
              e[xe]
            ]), ++xe) : (ye.push([
              J_,
              t[Ne]
            ]), ++Ne);
        } else {
          d(H, ae.start, G, ae.start - ae.diag, ye);
          for (let xe = ae.start; xe < ae.end; ++xe)
            ye.push([
              E4,
              e[xe]
            ]);
          d(ae.end, U, ae.end - ae.diag, ie, ye);
        }
      }, h = (H, U, G, ie) => {
        let ye = H;
        for (; ye - U < ie && ye < G && e[ye] === t[ye - U]; )
          ++ye;
        return c(H, ye, U);
      }, k = (H, U, G, ie) => {
        const ye = U - H, ae = ie - G;
        if (ye === 0 || ae === 0)
          return null;
        const xe = ye - ae, Ne = ae + ye, Ie = (Ne % 2 === 0 ? Ne : Ne + 1) / 2;
        r[1 + Ie] = H, a[1 + Ie] = U + 1;
        let Fe, je, _t, Zt, fn;
        for (Fe = 0; Fe <= Ie; ++Fe) {
          for (je = -Fe; je <= Fe; je += 2) {
            for (_t = je + Ie, je === -Fe || je !== Fe && r[_t - 1] < r[_t + 1] ? r[_t] = r[_t + 1] : r[_t] = r[_t - 1] + 1, Zt = r[_t], fn = Zt - H + G - je; Zt < U && fn < ie && e[Zt] === t[fn]; )
              r[_t] = ++Zt, ++fn;
            if (xe % 2 !== 0 && xe - Fe <= je && je <= xe + Fe && a[_t - xe] <= r[_t])
              return h(a[_t - xe], je + H - G, U, ie);
          }
          for (je = xe - Fe; je <= xe + Fe; je += 2) {
            for (_t = je + Ie - xe, je === xe - Fe || je !== xe + Fe && a[_t + 1] <= a[_t - 1] ? a[_t] = a[_t + 1] - 1 : a[_t] = a[_t - 1], Zt = a[_t] - 1, fn = Zt - H + G - je; Zt >= H && fn >= G && e[Zt] === t[fn]; )
              a[_t] = Zt--, fn--;
            if (xe % 2 === 0 && -Fe <= je && je <= Fe && a[_t] <= r[_t + xe])
              return h(a[_t], je + H - G, U, ie);
          }
        }
        return null;
      }, D = [];
      return d(0, e.length, 0, t.length, D), D;
    }, T4 = (e) => wn(e) ? e.outerHTML : At(e) ? ma.encodeRaw(e.data, !1) : Gd(e) ? "<!--" + e.data + "-->" : "", Kp = (e) => {
      let t;
      const n = document.createElement("div"), r = document.createDocumentFragment();
      for (e && (n.innerHTML = e); t = n.firstChild; )
        r.appendChild(t);
      return r;
    }, rD = (e, t, n) => {
      const r = Kp(t);
      if (e.hasChildNodes() && n < e.childNodes.length) {
        const a = e.childNodes[n];
        e.insertBefore(r, a);
      } else
        e.appendChild(r);
    }, v6 = (e, t) => {
      if (e.hasChildNodes() && t < e.childNodes.length) {
        const n = e.childNodes[t];
        e.removeChild(n);
      }
    }, z4 = (e, t) => {
      let n = 0;
      ut(e, (r) => {
        r[0] === E4 ? n++ : r[0] === J_ ? (rD(t, r[1], n), n++) : r[0] === Q_ && v6(t, n);
      });
    }, sD = (e, t) => ct(oo(_n(e.childNodes), t ? mn(q, T4) : T4), (n) => n.length > 0), e2 = (e, t) => {
      const n = oo(_n(t.childNodes), T4);
      return z4(y6(n, e), t), t;
    }, aD = Gi(() => document.implementation.createHTMLDocument("undo")), iD = (e) => e.querySelector("iframe") !== null, lD = (e) => ({
      type: "fragmented",
      fragments: e,
      content: "",
      bookmark: null,
      beforeBookmark: null
    }), x6 = (e) => ({
      type: "complete",
      fragments: null,
      content: e,
      bookmark: null,
      beforeBookmark: null
    }), t2 = (e) => {
      const t = e.serializer.getTempAttrs(), n = jS(e.getBody(), t);
      return iD(n) ? lD(sD(n, !0)) : x6(q(n.innerHTML));
    }, $x = (e, t, n) => {
      const r = n ? t.beforeBookmark : t.bookmark;
      t.type === "fragmented" ? e2(t.fragments, e.getBody()) : e.setContent(t.content, {
        format: "raw",
        no_selection: Xe(r) && OC(r) ? !r.isFakeCaret : !0
      }), r && (e.selection.moveToBookmark(r), e.selection.scrollIntoView());
    }, O4 = (e) => e.type === "fragmented" ? e.fragments.join("") : e.content, cD = (e) => {
      const t = be.fromTag("body", aD());
      return Hc(t, O4(e)), ut(Ni(t, "*[data-mce-bogus]"), wa), de(t);
    }, n2 = (e, t) => O4(e) === O4(t), A4 = (e, t) => cD(e) === cD(t), Hx = (e, t) => !e || !t ? !1 : n2(e, t) ? !0 : A4(e, t), o2 = (e) => e.get() === 0, Yp = (e, t, n) => {
      o2(n) && (e.typing = t);
    }, uD = (e, t) => {
      e.typing && (Yp(e, !1, t), e.add());
    }, w6 = (e) => {
      e.typing && (e.typing = !1, e.add());
    }, r2 = (e, t, n) => {
      o2(t) && n.set(ve(e.selection));
    }, dD = (e, t, n, r, a, c, d) => {
      const h = t2(e), k = Ht.extend(c || {}, h);
      if (!o2(r) || e.removed)
        return null;
      const D = t.data[n.get()];
      if (e.dispatch("BeforeAddUndo", {
        level: k,
        lastLevel: D,
        originalEvent: d
      }).isDefaultPrevented() || D && Hx(D, k))
        return null;
      t.data[n.get()] && a.get().each((G) => {
        t.data[n.get()].beforeBookmark = G;
      });
      const H = Lw(e);
      if (H && t.data.length > H) {
        for (let G = 0; G < t.data.length - 1; G++)
          t.data[G] = t.data[G + 1];
        t.data.length--, n.set(t.data.length);
      }
      k.bookmark = ve(e.selection), n.get() < t.data.length - 1 && (t.data.length = n.get() + 1), t.data.push(k), n.set(t.data.length - 1);
      const U = {
        level: k,
        lastLevel: D,
        originalEvent: d
      };
      return n.get() > 0 ? (e.setDirty(!0), e.dispatch("AddUndo", U), e.dispatch("change", U)) : e.dispatch("AddUndo", U), k;
    }, fD = (e, t, n) => {
      t.data = [], n.set(0), t.typing = !1, e.dispatch("ClearUndos");
    }, mD = (e, t, n, r, a) => {
      if (t.transact(r)) {
        const c = t.data[n.get()].bookmark, d = t.data[n.get() - 1];
        $x(e, d, !0), t.transact(a) && (t.data[n.get() - 1].beforeBookmark = c);
      }
    }, k6 = (e, t, n) => {
      let r;
      return t.get() < n.length - 1 && (t.set(t.get() + 1), r = n[t.get()], $x(e, r, !1), e.setDirty(!0), e.dispatch("Redo", { level: r })), r;
    }, _6 = (e, t, n, r) => {
      let a;
      return t.typing && (t.add(), t.typing = !1, Yp(t, !1, n)), r.get() > 0 && (r.set(r.get() - 1), a = t.data[r.get()], $x(e, a, !0), e.setDirty(!0), e.dispatch("Undo", { level: a })), a;
    }, pD = (e) => {
      e.clear(), e.add();
    }, D4 = (e, t, n) => n.get() > 0 || t.typing && t.data[0] && !Hx(t2(e), t.data[0]), R4 = (e, t) => t.get() < e.data.length - 1 && !e.typing, gD = (e, t, n) => (uD(e, t), e.beforeChange(), e.ignore(n), e.add()), s2 = (e, t) => {
      try {
        e.set(e.get() + 1), t();
      } finally {
        e.set(e.get() - 1);
      }
    }, hD = (e, t) => {
      const n = e.dom, r = Xe(t) ? t : e.getBody();
      ut(n.select("table,a", r), (a) => {
        switch (a.nodeName) {
          case "TABLE":
            const c = Iw(e), d = n.getAttrib(a, "border");
            (!d || d === "0") && e.hasVisual ? n.addClass(a, c) : n.removeClass(a, c);
            break;
          case "A":
            if (!n.getAttrib(a, "href")) {
              const h = n.getAttrib(a, "name") || a.id, k = i0(e);
              h && e.hasVisual ? n.addClass(a, k) : n.removeClass(a, k);
            }
            break;
        }
      }), e.dispatch("VisualAid", {
        element: t,
        hasVisual: e.hasVisual
      });
    }, N4 = (e) => ({
      init: { bindEvents: ht },
      undoManager: {
        beforeChange: (t, n) => r2(e, t, n),
        add: (t, n, r, a, c, d) => dD(e, t, n, r, a, c, d),
        undo: (t, n, r) => _6(e, t, n, r),
        redo: (t, n) => k6(e, t, n),
        clear: (t, n) => fD(e, t, n),
        reset: (t) => pD(t),
        hasUndo: (t, n) => D4(e, t, n),
        hasRedo: (t, n) => R4(t, n),
        transact: (t, n, r) => gD(t, n, r),
        ignore: (t, n) => s2(t, n),
        extra: (t, n, r, a) => mD(e, t, n, r, a)
      },
      formatter: {
        match: (t, n, r, a) => g_(e, t, n, r, a),
        matchAll: (t, n) => jO(e, t, n),
        matchNode: (t, n, r, a) => Wp(e, t, n, r, a),
        canApply: (t) => Cx(e, t),
        closest: (t) => EB(e, t),
        apply: (t, n, r) => XE(e, t, n, r),
        remove: (t, n, r, a) => dA(e, t, n, r, a),
        toggle: (t, n, r) => yA(e, t, n, r),
        formatChanged: (t, n, r, a, c) => JE(e, t, n, r, a, c)
      },
      editor: {
        getContent: (t) => $k(e, t),
        setContent: (t, n) => z1(e, t, n),
        insertContent: (t, n) => _B(e, t, n),
        addVisual: (t) => hD(e, t)
      },
      selection: { getContent: (t, n) => X_(e, t, n) },
      autocompleter: {
        addDecoration: (t) => Mz(e, t),
        removeDecoration: () => Lz(e, be.fromDom(e.getBody()))
      },
      raw: { getModel: () => K.none() }
    }), C6 = (e) => {
      const t = (D) => Ee(D) ? D : {}, { init: n, undoManager: r, formatter: a, editor: c, selection: d, autocompleter: h, raw: k } = e;
      return {
        init: { bindEvents: n.bindEvents },
        undoManager: {
          beforeChange: r.beforeChange,
          add: r.add,
          undo: r.undo,
          redo: r.redo,
          clear: r.clear,
          reset: r.reset,
          hasUndo: r.hasUndo,
          hasRedo: r.hasRedo,
          transact: (D, H, U) => r.transact(U),
          ignore: (D, H) => r.ignore(H),
          extra: (D, H, U, G) => r.extra(U, G)
        },
        formatter: {
          match: (D, H, U, G) => a.match(D, t(H), G),
          matchAll: a.matchAll,
          matchNode: a.matchNode,
          canApply: (D) => a.canApply(D),
          closest: (D) => a.closest(D),
          apply: (D, H, U) => a.apply(D, t(H)),
          remove: (D, H, U, G) => a.remove(D, t(H)),
          toggle: (D, H, U) => a.toggle(D, t(H)),
          formatChanged: (D, H, U, G, ie) => a.formatChanged(H, U, G, ie)
        },
        editor: {
          getContent: (D) => c.getContent(D),
          setContent: (D, H) => ({
            content: c.setContent(D, H),
            html: ""
          }),
          insertContent: (D, H) => (c.insertContent(D), ""),
          addVisual: c.addVisual
        },
        selection: { getContent: (D, H) => d.getContent(H) },
        autocompleter: {
          addDecoration: h.addDecoration,
          removeDecoration: h.removeDecoration
        },
        raw: { getModel: () => K.some(k.getRawModel()) }
      };
    }, S6 = () => {
      const e = dt(null), t = dt("");
      return {
        init: { bindEvents: ht },
        undoManager: {
          beforeChange: ht,
          add: e,
          undo: e,
          redo: e,
          clear: ht,
          reset: ht,
          hasUndo: Pn,
          hasRedo: Pn,
          transact: e,
          ignore: ht,
          extra: ht
        },
        formatter: {
          match: Pn,
          matchAll: dt([]),
          matchNode: dt(void 0),
          canApply: Pn,
          closest: t,
          apply: ht,
          remove: ht,
          toggle: ht,
          formatChanged: dt({ unbind: ht })
        },
        editor: {
          getContent: t,
          setContent: dt({
            content: "",
            html: ""
          }),
          insertContent: dt(""),
          addVisual: ht
        },
        selection: { getContent: t },
        autocompleter: {
          addDecoration: ht,
          removeDecoration: ht
        },
        raw: { getModel: dt(K.none()) }
      };
    }, yp = (e) => Yn(e.plugins, "rtc"), bD = (e) => Hr(e.plugins, "rtc").bind((t) => K.from(t.setup)), yD = (e) => {
      const t = e;
      return bD(e).fold(() => (t.rtcInstance = N4(e), K.none()), (n) => (t.rtcInstance = S6(), K.some(() => n().then((r) => (t.rtcInstance = C6(r), r.rtc.isRemote)))));
    }, M4 = (e) => e.rtcInstance ? e.rtcInstance : N4(e), ll = (e) => {
      const t = e.rtcInstance;
      if (t)
        return t;
      throw new Error("Failed to get RTC instance not yet initialized.");
    }, E6 = (e, t, n) => {
      ll(e).undoManager.beforeChange(t, n);
    }, vD = (e, t, n, r, a, c, d) => ll(e).undoManager.add(t, n, r, a, c, d), xD = (e, t, n, r) => ll(e).undoManager.undo(t, n, r), T6 = (e, t, n) => ll(e).undoManager.redo(t, n), z6 = (e, t, n) => {
      ll(e).undoManager.clear(t, n);
    }, tv = (e, t) => {
      ll(e).undoManager.reset(t);
    }, O6 = (e, t, n) => ll(e).undoManager.hasUndo(t, n), A6 = (e, t, n) => ll(e).undoManager.hasRedo(t, n), wD = (e, t, n, r) => ll(e).undoManager.transact(t, n, r), kD = (e, t, n) => {
      ll(e).undoManager.ignore(t, n);
    }, a2 = (e, t, n, r, a) => {
      ll(e).undoManager.extra(t, n, r, a);
    }, D6 = (e, t, n, r, a) => ll(e).formatter.match(t, n, r, a), R6 = (e, t, n) => ll(e).formatter.matchAll(t, n), N6 = (e, t, n, r, a) => ll(e).formatter.matchNode(t, n, r, a), M6 = (e, t) => ll(e).formatter.canApply(t), B6 = (e, t) => ll(e).formatter.closest(t), L6 = (e, t, n, r) => {
      ll(e).formatter.apply(t, n, r);
    }, P6 = (e, t, n, r, a) => {
      ll(e).formatter.remove(t, n, r, a);
    }, I6 = (e, t, n, r) => {
      ll(e).formatter.toggle(t, n, r);
    }, F6 = (e, t, n, r, a, c) => ll(e).formatter.formatChanged(t, n, r, a, c), $6 = (e, t) => M4(e).editor.getContent(t), Rs = (e, t, n) => M4(e).editor.setContent(t, n), _D = (e, t, n) => M4(e).editor.insertContent(t, n), B4 = (e, t, n) => ll(e).selection.getContent(t, n), CD = (e, t) => ll(e).editor.addVisual(t), L4 = (e) => ll(e).init.bindEvents(), P4 = (e, t) => ll(e).autocompleter.addDecoration(t), H6 = (e) => ll(e).autocompleter.removeDecoration(), V6 = (e, t = {}) => {
      const n = t.format ? t.format : "html";
      return B4(e, n, t);
    }, I4 = (e) => e.dom.length === 0 ? (dr(e), K.none()) : K.some(e), U6 = (e, t) => e.filter((n) => w0.isBookmarkNode(n.dom)).bind(t ? Di : Ps), j6 = (e, t, n, r, a) => {
      const c = e.dom, d = t.dom, h = r ? c.length : d.length;
      r ? (lE(c, d, a, !1, !r), n.setStart(d, h)) : (lE(d, c, a, !1, !r), n.setEnd(d, h));
    }, nv = (e, t, n) => {
      Br(e).each((r) => {
        const a = e.dom;
        t && ay(r, nt(a, 0), n) ? w1(a, 0, n) : !t && x1(r, nt(a, a.length), n) && iE(a, a.length, n);
      });
    }, SD = (e, t, n, r, a) => {
      e.bind((c) => ((r ? iE : w1)(c.dom, r ? c.dom.length : 0, a), t.filter(Zs).map((h) => j6(c, h, n, r, a)))).orThunk(() => U6(t, r).or(t).filter(Zs).map((d) => nv(d, r, a)));
    }, ov = (e, t, n) => {
      const r = K.from(t.firstChild).map(be.fromDom), a = K.from(t.lastChild).map(be.fromDom);
      e.deleteContents(), e.insertNode(t);
      const c = r.bind(Ps).filter(Zs).bind(I4), d = a.bind(Di).filter(Zs).bind(I4);
      SD(c, r, e, !0, n), SD(d, a, e, !1, n), e.collapse(!1);
    }, Vx = (e, t) => ({
      format: "html",
      ...e,
      set: !0,
      selection: !0,
      content: t
    }), rv = (e, t) => {
      if (t.format !== "raw") {
        const n = e.selection.getRng(), r = e.dom.getParent(n.commonAncestorContainer, e.dom.isBlock), a = r ? { context: r.nodeName.toLowerCase() } : {}, c = e.parser.parse(t.content, {
          forced_root_block: !1,
          ...a,
          ...t
        });
        return Jl({ validate: !1 }, e.schema).serialize(c);
      } else
        return t.content;
    }, F4 = (e, t, n = {}) => {
      const r = Vx(n, t);
      W_(e, r).each((a) => {
        const c = rv(e, a), d = e.selection.getRng();
        ov(d, d.createContextualFragment(c), e.schema), e.selection.setRng(d), A0(e, d), ev(e, c, a);
      });
    }, $4 = (e, t, n) => {
      if (Yn(e, t)) {
        const r = ct(e[t], (a) => a !== n);
        r.length === 0 ? delete e[t] : e[t] = r;
      }
    };
    var ED = (e, t) => {
      let n, r;
      const a = (h, k) => po(k, (D) => e.is(D, h)), c = (h) => e.getParents(h, void 0, e.getRoot()), d = () => {
        n = {}, r = {}, t.on("NodeChange", (h) => {
          const k = h.element, D = c(k), H = {};
          Zo(n, (U, G) => {
            a(G, D).each((ie) => {
              r[G] || (ut(U, (ye) => {
                ye(!0, {
                  node: ie,
                  selector: G,
                  parents: D
                });
              }), r[G] = U), H[G] = U;
            });
          }), Zo(r, (U, G) => {
            H[G] || (delete r[G], ut(U, (ie) => {
              ie(!1, {
                node: k,
                selector: G,
                parents: D
              });
            }));
          });
        });
      };
      return {
        selectorChangedWithUnbind: (h, k) => (n || d(), n[h] || (n[h] = []), n[h].push(k), a(h, c(t.selection.getStart())).each(() => {
          r[h] = n[h];
        }), {
          unbind: () => {
            $4(n, h, k), $4(r, h, k);
          }
        })
      };
    };
    const i2 = (e) => !!(e && e.ownerDocument) && Dt(be.fromDom(e.ownerDocument), be.fromDom(e)), TD = (e) => e ? i2(e.startContainer) && i2(e.endContainer) : !1, H4 = (e, t, n, r) => {
      let a, c;
      const { selectorChangedWithUnbind: d } = ED(e, r), h = (sn, zn) => {
        const Ar = e.createRng();
        Xe(sn) && Xe(zn) ? (Ar.setStart(sn, zn), Ar.setEnd(sn, zn), je(Ar), Ne(!1)) : (Em(e, Ar, r.getBody(), !0), je(Ar));
      }, k = (sn) => V6(r, sn), D = (sn, zn) => F4(r, sn, zn), H = (sn) => Fh(r.getBody(), Fe(), sn), U = (sn) => Tz(r.getBody(), Fe(), sn), G = (sn, zn) => Yc.getBookmark(sn, zn), ie = (sn) => Yc.moveToBookmark(sn), ye = (sn, zn) => (P0(e, sn, zn).each(je), sn), ae = () => {
        const sn = Fe(), zn = Ie();
        return !sn || sn.item ? !1 : sn.compareEndPoints ? sn.compareEndPoints("StartToEnd", sn) === 0 : !zn || sn.collapsed;
      }, xe = () => {
        const sn = Fe(), zn = r.getBody().querySelectorAll('[data-mce-selected="1"]');
        return zn.length > 0 ? Ns(zn, (Ar) => e.isEditable(Ar.parentElement)) : Qv(e, sn);
      }, Ne = (sn) => {
        const zn = Fe();
        zn.collapse(!!sn), je(zn);
      }, Ie = () => t.getSelection ? t.getSelection() : t.document.selection, Fe = () => {
        let sn;
        const zn = (xr, On, Rn) => {
          try {
            return On.compareBoundaryPoints(xr, Rn);
          } catch {
            return -1;
          }
        }, Ar = t.document;
        if (Xe(r.bookmark) && !ty(r)) {
          const xr = AS(r);
          if (xr.isSome())
            return xr.map((On) => Lk(r, [On])[0]).getOr(Ar.createRange());
        }
        try {
          const xr = Ie();
          xr && !Im(xr.anchorNode) && (xr.rangeCount > 0 ? sn = xr.getRangeAt(0) : sn = Ar.createRange(), sn = Lk(r, [sn])[0]);
        } catch {
        }
        if (sn || (sn = Ar.createRange()), Dl(sn.startContainer) && sn.collapsed) {
          const xr = e.getRoot();
          sn.setStart(xr, 0), sn.setEnd(xr, 0);
        }
        return a && c && (zn(sn.START_TO_START, sn, a) === 0 && zn(sn.END_TO_END, sn, a) === 0 ? sn = c : (a = null, c = null)), sn;
      }, je = (sn, zn) => {
        if (!TD(sn))
          return;
        const Ar = Ie();
        if (sn = r.dispatch("SetSelectionRange", {
          range: sn,
          forward: zn
        }).range, Ar) {
          c = sn;
          try {
            Ar.removeAllRanges(), Ar.addRange(sn);
          } catch {
          }
          zn === !1 && Ar.extend && (Ar.collapse(sn.endContainer, sn.endOffset), Ar.extend(sn.startContainer, sn.startOffset)), a = Ar.rangeCount > 0 ? Ar.getRangeAt(0) : null;
        }
        if (!sn.collapsed && sn.startContainer === sn.endContainer && (Ar != null && Ar.setBaseAndExtent) && sn.endOffset - sn.startOffset < 2 && sn.startContainer.hasChildNodes()) {
          const On = sn.startContainer.childNodes[sn.startOffset];
          On && On.nodeName === "IMG" && (Ar.setBaseAndExtent(sn.startContainer, sn.startOffset, sn.endContainer, sn.endOffset), (Ar.anchorNode !== sn.startContainer || Ar.focusNode !== sn.endContainer) && Ar.setBaseAndExtent(On, 0, On, 1));
        }
        r.dispatch("AfterSetSelectionRange", {
          range: sn,
          forward: zn
        });
      }, _t = (sn) => (D(e.getOuterHTML(sn)), sn), Zt = () => B0(r.getBody(), Fe()), fn = (sn, zn) => L0(e, Fe(), sn, zn), at = () => {
        const sn = Ie(), zn = sn == null ? void 0 : sn.anchorNode, Ar = sn == null ? void 0 : sn.focusNode;
        if (!sn || !zn || !Ar || Im(zn) || Im(Ar))
          return !0;
        const xr = e.createRng(), On = e.createRng();
        try {
          xr.setStart(zn, sn.anchorOffset), xr.collapse(!0), On.setStart(Ar, sn.focusOffset), On.collapse(!0);
        } catch {
          return !0;
        }
        return xr.compareBoundaryPoints(xr.START_TO_START, On) <= 0;
      }, Ci = {
        dom: e,
        win: t,
        serializer: n,
        editor: r,
        expand: (sn = { type: "word" }) => je(Fg(e).expand(Fe(), sn)),
        collapse: Ne,
        setCursorLocation: h,
        getContent: k,
        setContent: D,
        getBookmark: G,
        moveToBookmark: ie,
        select: ye,
        isCollapsed: ae,
        isEditable: xe,
        isForward: at,
        setNode: _t,
        getNode: Zt,
        getSel: Ie,
        setRng: je,
        getRng: Fe,
        getStart: H,
        getEnd: U,
        getSelectedBlocks: fn,
        normalize: () => {
          const sn = Fe(), zn = Ie();
          if (!NC(zn) && uu(r)) {
            const Ar = Wv(e, sn);
            return Ar.each((xr) => {
              je(xr, at());
            }), Ar.getOr(sn);
          }
          return sn;
        },
        selectorChanged: (sn, zn) => (d(sn, zn), Ci),
        selectorChangedWithUnbind: d,
        getScrollContainer: () => {
          let sn, zn = e.getRoot();
          for (; zn && zn.nodeName !== "BODY"; ) {
            if (zn.scrollHeight > zn.clientHeight) {
              sn = zn;
              break;
            }
            zn = zn.parentNode;
          }
          return sn;
        },
        scrollIntoView: (sn, zn) => {
          Xe(sn) ? SS(r, sn, zn) : A0(r, Fe(), zn);
        },
        placeCaretAt: (sn, zn) => je(Yb(sn, zn, r.getDoc())),
        getBoundingClientRect: () => {
          const sn = Fe();
          return sn.collapsed ? nt.fromRangeStart(sn).getClientRects()[0] : sn.getBoundingClientRect();
        },
        destroy: () => {
          t = a = c = null, Ql.destroy();
        }
      }, Yc = w0(Ci), Ql = cS(Ci, r);
      return Ci.bookmarkManager = Yc, Ci.controlSelection = Ql, Ci;
    }, zD = (e, t, n) => {
      e.addAttributeFilter("data-mce-tabindex", (r, a) => {
        let c = r.length;
        for (; c--; ) {
          const d = r[c];
          d.attr("tabindex", d.attr("data-mce-tabindex")), d.attr(a, null);
        }
      }), e.addAttributeFilter("src,href,style", (r, a) => {
        const c = "data-mce-" + a, d = t.url_converter, h = t.url_converter_scope;
        let k = r.length;
        for (; k--; ) {
          const D = r[k];
          let H = D.attr(c);
          H !== void 0 ? (D.attr(a, H.length > 0 ? H : null), D.attr(c, null)) : (H = D.attr(a), a === "style" ? H = n.serializeStyle(n.parseStyle(H), D.name) : d && (H = d.call(h, H, a, D.name)), D.attr(a, H.length > 0 ? H : null));
        }
      }), e.addAttributeFilter("class", (r) => {
        let a = r.length;
        for (; a--; ) {
          const c = r[a];
          let d = c.attr("class");
          d && (d = d.replace(/(?:^|\s)mce-item-\w+(?!\S)/g, ""), c.attr("class", d.length > 0 ? d : null));
        }
      }), e.addAttributeFilter("data-mce-type", (r, a, c) => {
        let d = r.length;
        for (; d--; ) {
          const h = r[d];
          h.attr("data-mce-type") === "bookmark" && !c.cleanup && (K.from(h.firstChild).exists((D) => {
            var H;
            return !R((H = D.value) !== null && H !== void 0 ? H : "");
          }) ? h.unwrap() : h.remove());
        }
      }), e.addNodeFilter("script,style", (r, a) => {
        var c;
        const d = (k) => k.replace(/(<!--\[CDATA\[|\]\]-->)/g, `
`).replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
        let h = r.length;
        for (; h--; ) {
          const k = r[h], D = k.firstChild, H = (c = D == null ? void 0 : D.value) !== null && c !== void 0 ? c : "";
          if (a === "script") {
            const U = k.attr("type");
            U && k.attr("type", U === "mce-no/type" ? null : U.replace(/^mce\-/, "")), t.element_format === "xhtml" && D && H.length > 0 && (D.value = `// <![CDATA[
` + d(H) + `
// ]]>`);
          } else
            t.element_format === "xhtml" && D && H.length > 0 && (D.value = `<!--
` + d(H) + `
-->`);
        }
      }), e.addNodeFilter("#comment", (r) => {
        let a = r.length;
        for (; a--; ) {
          const c = r[a], d = c.value;
          t.preserve_cdata && (d == null ? void 0 : d.indexOf("[CDATA[")) === 0 ? (c.name = "#cdata", c.type = 4, c.value = n.decode(d.replace(/^\[CDATA\[|\]\]$/g, ""))) : (d == null ? void 0 : d.indexOf("mce:protected ")) === 0 && (c.name = "#text", c.type = 3, c.raw = !0, c.value = unescape(d).substr(14));
        }
      }), e.addNodeFilter("xml:namespace,input", (r, a) => {
        let c = r.length;
        for (; c--; ) {
          const d = r[c];
          d.type === 7 ? d.remove() : d.type === 1 && a === "input" && !d.attr("type") && d.attr("type", "text");
        }
      }), e.addAttributeFilter("data-mce-type", (r) => {
        ut(r, (a) => {
          a.attr("data-mce-type") === "format-caret" && (a.isEmpty(e.schema.getNonEmptyElements()) ? a.remove() : a.unwrap());
        });
      }), e.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-block,data-mce-type,data-mce-resize,data-mce-placeholder", (r, a) => {
        let c = r.length;
        for (; c--; )
          r[c].attr(a, null);
      }), t.remove_trailing_brs && xA(t, e, e.schema);
    }, V4 = (e) => {
      const t = (r) => (r == null ? void 0 : r.name) === "br", n = e.lastChild;
      if (t(n)) {
        const r = n.prev;
        t(r) && (n.remove(), r.remove());
      }
    }, OD = (e, t, n) => {
      let r;
      const a = e.dom;
      let c = t.cloneNode(!0);
      const d = document.implementation;
      if (d.createHTMLDocument) {
        const h = d.createHTMLDocument("");
        Ht.each(c.nodeName === "BODY" ? c.childNodes : [c], (k) => {
          h.body.appendChild(h.importNode(k, !0));
        }), c.nodeName !== "BODY" ? c = h.body.firstChild : c = h.body, r = a.doc, a.doc = h;
      }
      return HT(e, {
        ...n,
        node: c
      }), r && (a.doc = r), c;
    }, AD = (e, t) => Xe(e) && e.hasEventListeners("PreProcess") && !t.no_events, U4 = (e, t, n) => AD(e, n) ? OD(e, t, n) : t, Z6 = (e, t, n) => {
      Ht.inArray(t, n) === -1 && (e.addAttributeFilter(n, (r, a) => {
        let c = r.length;
        for (; c--; )
          r[c].attr(a, null);
      }), t.push(n));
    }, DD = (e, t, n) => !t.no_events && e ? VT(e, {
      ...t,
      content: n
    }).content : n, RD = (e, t, n) => {
      const r = q(n.getInner ? t.innerHTML : e.getOuterHTML(t));
      return n.selection || um(be.fromDom(t)) ? r : Ht.trim(r);
    }, ND = (e, t, n) => {
      const r = n.selection ? {
        forced_root_block: !1,
        ...n
      } : n, a = e.parse(t, r);
      return V4(a), a;
    }, W6 = (e, t, n) => Jl(e, t).serialize(n), q6 = (e, t, n, r, a) => {
      const c = W6(t, n, r);
      return DD(e, a, c);
    }, l2 = (e, t) => {
      const n = ["data-mce-selected"], r = {
        entity_encoding: "named",
        remove_trailing_brs: !0,
        pad_empty_with_br: !1,
        ...e
      }, a = t && t.dom ? t.dom : gs.DOM, c = t && t.schema ? t.schema : of(r), d = yy(r, c);
      zD(d, r, a);
      const h = (k, D = {}) => {
        const H = {
          format: "html",
          ...D
        }, U = U4(t, k, H), G = RD(a, U, H), ie = ND(d, G, H);
        return H.format === "tree" ? ie : q6(t, r, c, ie, H);
      };
      return {
        schema: c,
        addNodeFilter: d.addNodeFilter,
        addAttributeFilter: d.addAttributeFilter,
        serialize: h,
        addRules: c.addValidElements,
        setRules: c.setValidElements,
        addTempAttr: Tt(Z6, d, n),
        getTempAttrs: dt(n),
        getNodeFilters: d.getNodeFilters,
        getAttributeFilters: d.getAttributeFilters,
        removeNodeFilter: d.removeNodeFilter,
        removeAttributeFilter: d.removeAttributeFilter
      };
    }, j4 = (e, t) => {
      const n = l2(e, t);
      return {
        schema: n.schema,
        addNodeFilter: n.addNodeFilter,
        addAttributeFilter: n.addAttributeFilter,
        serialize: n.serialize,
        addRules: n.addRules,
        setRules: n.setRules,
        addTempAttr: n.addTempAttr,
        getTempAttrs: n.getTempAttrs,
        getNodeFilters: n.getNodeFilters,
        getAttributeFilters: n.getAttributeFilters,
        removeNodeFilter: n.removeNodeFilter,
        removeAttributeFilter: n.removeAttributeFilter
      };
    }, MD = "html", BD = (e, t) => ({
      ...e,
      format: t,
      get: !0,
      getInner: !0
    }), G6 = (e, t = {}) => {
      const n = t.format ? t.format : MD, r = BD(t, n);
      return Z_(e, r).fold(Bn, (a) => {
        const c = $6(e, a);
        return w4(e, c, a);
      });
    }, K6 = "html", Y6 = (e, t) => ({
      format: K6,
      ...e,
      set: !0,
      content: t
    }), Z4 = (e, t, n = {}) => {
      const r = Y6(n, t);
      return W_(e, r).map((a) => {
        const c = Rs(e, a.content, a);
        return ev(e, c.html, a), c.content;
      }).getOr(t);
    }, LD = "autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists".split(","), PD = "template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format".split(","), ID = "bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor".split(","), FD = [
      {
        name: "template",
        replacedWith: "Advanced Template"
      },
      { name: "rtc" }
    ], $D = (e, t) => {
      const n = ct(t, (r) => Yn(e, r));
      return Po(n);
    }, X6 = (e) => {
      const t = $D(e, LD), n = e.forced_root_block;
      return (n === !1 || n === "") && t.push("forced_root_block (false only)"), Po(t);
    }, J6 = (e) => $D(e, PD), Ux = (e, t) => {
      const n = Ht.makeMap(e.plugins, " "), a = ct(t, (c) => Yn(n, c));
      return Po(a);
    }, HD = (e) => Ux(e, ID), Q6 = (e) => Ux(e, FD.map((t) => t.name)), VD = (e, t) => {
      const n = X6(e), r = HD(t), a = r.length > 0, c = n.length > 0, d = t.theme === "mobile";
      if (a || c || d) {
        const h = `
- `, k = d ? `

Themes:${h}mobile` : "", D = a ? `

Plugins:${h}${r.join(h)}` : "", H = c ? `

Options:${h}${n.join(h)}` : "";
        console.warn("The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information." + k + D + H);
      }
    }, UD = (e) => po(FD, (t) => t.name === e).fold(() => e, (t) => t.replacedWith ? `${e}, replaced by ${t.replacedWith}` : e), W4 = (e, t) => {
      const n = J6(e), r = Q6(t), a = r.length > 0, c = n.length > 0;
      if (a || c) {
        const d = `
- `, h = a ? `

Plugins:${d}${r.map(UD).join(d)}` : "", k = c ? `

Options:${d}${n.join(d)}` : "";
        console.warn("The following deprecated features are currently enabled but will be removed soon." + h + k);
      }
    }, jD = (e, t) => {
      VD(e, t), W4(e, t);
    }, jx = gs.DOM, ZD = (e) => {
      jx.setStyle(e.id, "display", e.orgDisplay);
    }, c2 = (e) => K.from(e).each((t) => t.destroy()), eL = (e) => {
      const t = e;
      t.contentAreaContainer = t.formElement = t.container = t.editorContainer = null, t.bodyElement = t.contentDocument = t.contentWindow = null, t.iframeElement = t.targetElm = null;
      const n = e.selection;
      if (n) {
        const r = n.dom;
        t.selection = n.win = n.dom = r.doc = null;
      }
    }, Zx = (e) => {
      const t = e.formElement;
      t && (t._mceOldSubmit && (t.submit = t._mceOldSubmit, delete t._mceOldSubmit), jx.unbind(t, "submit reset", e.formEventDelegate));
    }, tL = (e) => {
      if (!e.removed) {
        const { _selectionOverrides: t, editorUpload: n } = e, r = e.getBody(), a = e.getElement();
        r && e.save({ is_removing: !0 }), e.removed = !0, e.unbindAllNativeEvents(), e.hasHiddenInput && Xe(a == null ? void 0 : a.nextSibling) && jx.remove(a.nextSibling), k0(e), e.editorManager.remove(e), !e.inline && r && ZD(e), UT(e), jx.remove(e.getContainer()), c2(t), c2(n), e.destroy();
      }
    }, WD = (e, t) => {
      const { selection: n, dom: r } = e;
      if (!e.destroyed) {
        if (!t && !e.removed) {
          e.remove();
          return;
        }
        t || (e.editorManager.off("beforeunload", e._beforeUnload), e.theme && e.theme.destroy && e.theme.destroy(), c2(n), c2(r)), Zx(e), eL(e), e.destroyed = !0;
      }
    }, Wx = (() => {
      const e = {};
      return {
        add: (a, c) => {
          e[a] = c;
        },
        get: (a) => e[a] ? e[a] : { icons: {} },
        has: (a) => Yn(e, a)
      };
    })(), N1 = Bl.ModelManager, qD = (e, t) => t.dom[e], GD = (e, t) => parseInt(Ya(t, e), 10), G4 = Tt(qD, "clientWidth"), K4 = Tt(qD, "clientHeight"), u2 = Tt(GD, "margin-top"), KD = Tt(GD, "margin-left"), Y4 = (e) => e.dom.getBoundingClientRect(), YD = (e, t, n) => {
      const r = G4(e), a = K4(e);
      return t >= 0 && n >= 0 && t <= r && n <= a;
    }, nL = (e, t, n, r) => {
      const a = Y4(t), c = e ? a.left + t.dom.clientLeft + KD(t) : 0, d = e ? a.top + t.dom.clientTop + u2(t) : 0, h = n - c, k = r - d;
      return {
        x: h,
        y: k
      };
    }, XD = (e, t, n) => {
      const r = be.fromDom(e.getBody()), a = e.inline ? r : Fo(r), c = nL(e.inline, a, t, n);
      return YD(a, c.x, c.y);
    }, oL = (e) => K.from(e).map(be.fromDom), JD = (e) => {
      const t = e.inline ? e.getBody() : e.getContentAreaContainer();
      return oL(t).map(Qs).getOr(!1);
    };
    var QD = () => {
      const e = () => {
        throw new Error("Theme did not provide a NotificationManager implementation.");
      };
      return {
        open: e,
        close: e,
        getArgs: e
      };
    };
    const eR = (e) => {
      const t = [], n = () => {
        const G = e.theme;
        return G && G.getNotificationManagerImpl ? G.getNotificationManagerImpl() : QD();
      }, r = () => K.from(t[0]), a = (G, ie) => G.type === ie.type && G.text === ie.text && !G.progressBar && !G.timeout && !ie.progressBar && !ie.timeout, c = () => {
        ut(t, (G) => {
          G.reposition();
        });
      }, d = (G) => {
        t.push(G);
      }, h = (G) => {
        Ra(t, (ie) => ie === G).each((ie) => {
          t.splice(ie, 1);
        });
      }, k = (G, ie = !0) => e.removed || !JD(e) ? {} : (ie && e.dispatch("BeforeOpenNotification", { notification: G }), po(t, (ye) => a(n().getArgs(ye), G)).getOrThunk(() => {
        e.editorManager.setActive(e);
        const ye = n().open(G, () => {
          h(ye), c(), il(e) && r().fold(() => e.focus(), (ae) => bz(be.fromDom(ae.getEl())));
        });
        return d(ye), c(), e.dispatch("OpenNotification", { notification: { ...ye } }), ye;
      })), D = () => {
        r().each((G) => {
          n().close(G), h(G), c();
        });
      }, H = dt(t);
      return ((G) => {
        G.on("SkinLoaded", () => {
          const ie = Rw(G);
          ie && k({
            text: ie,
            type: "warning",
            timeout: 0
          }, !1), c();
        }), G.on("show ResizeEditor ResizeWindow NodeChange", () => {
          requestAnimationFrame(c);
        }), G.on("remove", () => {
          ut(t.slice(), (ie) => {
            n().close(ie);
          });
        });
      })(e), {
        open: k,
        close: D,
        getNotifications: H
      };
    }, M1 = Bl.PluginManager, jh = Bl.ThemeManager;
    var tR = () => {
      const e = () => {
        throw new Error("Theme did not provide a WindowManager implementation.");
      };
      return {
        open: e,
        openUrl: e,
        alert: e,
        confirm: e,
        close: e
      };
    };
    const X4 = (e) => {
      let t = [];
      const n = () => {
        const ae = e.theme;
        return ae && ae.getWindowManagerImpl ? ae.getWindowManagerImpl() : tR();
      }, r = (ae, xe) => (...Ne) => xe ? xe.apply(ae, Ne) : void 0, a = (ae) => {
        e.dispatch("OpenWindow", { dialog: ae });
      }, c = (ae) => {
        e.dispatch("CloseWindow", { dialog: ae });
      }, d = (ae) => {
        t.push(ae), a(ae);
      }, h = (ae) => {
        c(ae), t = ct(t, (xe) => xe !== ae), t.length === 0 && e.focus();
      }, k = () => K.from(t[t.length - 1]), D = (ae) => {
        e.editorManager.setActive(e), OS(e), e.ui.show();
        const xe = ae();
        return d(xe), xe;
      }, H = (ae, xe) => D(() => n().open(ae, xe, h)), U = (ae) => D(() => n().openUrl(ae, h)), G = (ae, xe, Ne) => {
        const Ie = n();
        Ie.alert(ae, r(Ne || Ie, xe));
      }, ie = (ae, xe, Ne) => {
        const Ie = n();
        Ie.confirm(ae, r(Ne || Ie, xe));
      }, ye = () => {
        k().each((ae) => {
          n().close(ae), h(ae);
        });
      };
      return e.on("remove", () => {
        ut(t, (ae) => {
          n().close(ae);
        });
      }), {
        open: H,
        openUrl: U,
        alert: G,
        confirm: ie,
        close: ye
      };
    }, J4 = (e, t) => {
      e.notificationManager.open({
        type: "error",
        text: t
      });
    }, qx = (e, t) => {
      e._skinLoaded ? J4(e, t) : e.on("SkinLoaded", () => {
        J4(e, t);
      });
    }, rL = (e, t) => {
      qx(e, Rc.translate([
        "Failed to upload image: {0}",
        t
      ]));
    }, Gx = (e, t, n) => {
      nS(e, t, { message: n }), console.error(n);
    }, B1 = (e, t, n) => n ? `Failed to load ${e}: ${n} from url ${t}` : `Failed to load ${e} url: ${t}`, sL = (e, t, n) => {
      Gx(e, "PluginLoadError", B1("plugin", t, n));
    }, nR = (e, t, n) => {
      Gx(e, "IconsLoadError", B1("icons", t, n));
    }, oR = (e, t, n) => {
      Gx(e, "LanguageLoadError", B1("language", t, n));
    }, Q4 = (e, t, n) => {
      Gx(e, "ThemeLoadError", B1("theme", t, n));
    }, e3 = (e, t, n) => {
      Gx(e, "ModelLoadError", B1("model", t, n));
    }, t3 = (e, t, n) => {
      const r = Rc.translate([
        "Failed to initialize plugin: {0}",
        t
      ]);
      nS(e, "PluginLoadError", { message: r }), d2(r, n), qx(e, r);
    }, d2 = (e, ...t) => {
      const n = window.console;
      n && (n.error ? n.error(e, ...t) : n.log(e, ...t));
    }, rR = (e) => /^[a-z0-9\-]+$/i.test(e), n3 = (e) => "content/" + e + "/content.css", aL = (e) => tinymce.Resource.has(n3(e)), sR = (e) => aR(e, Lu(e)), o3 = (e) => aR(e, Dw(e)), aR = (e, t) => {
      const n = e.editorManager.baseURL + "/skins/content", a = `content${e.editorManager.suffix}.css`;
      return oo(t, (c) => aL(c) ? c : rR(c) && !e.inline ? `${n}/${c}/${a}` : e.documentBaseURI.toAbsolute(c));
    }, f2 = (e) => {
      e.contentCSS = e.contentCSS.concat(sR(e), o3(e));
    }, iL = (e) => e ? _n(e.getElementsByTagName("img")) : [], lL = (e, t) => {
      const n = {};
      return { findAll: (a, c = Mo) => {
        const d = ct(iL(a), (k) => {
          const D = k.src;
          return k.hasAttribute("data-mce-bogus") || k.hasAttribute("data-mce-placeholder") || !D || D === nr.transparentSrc ? !1 : Dr(D, "blob:") ? !e.isUploaded(D) && c(k) : Dr(D, "data:") ? c(k) : !1;
        }), h = oo(d, (k) => {
          const D = k.src;
          if (Yn(n, D))
            return n[D].then((H) => Ot(H) ? H : {
              image: k,
              blobInfo: H.blobInfo
            });
          {
            const H = CA(t, D).then((U) => (delete n[D], {
              image: k,
              blobInfo: U
            })).catch((U) => (delete n[D], U));
            return n[D] = H, H;
          }
        });
        return Promise.all(h);
      } };
    }, iR = () => {
      let n = {};
      const r = (G, ie) => ({
        status: G,
        resultUri: ie
      }), a = (G) => G in n;
      return {
        hasBlobUri: a,
        getResultUri: (G) => {
          const ie = n[G];
          return ie ? ie.resultUri : null;
        },
        isPending: (G) => a(G) ? n[G].status === 1 : !1,
        isUploaded: (G) => a(G) ? n[G].status === 2 : !1,
        markPending: (G) => {
          n[G] = r(1, null);
        },
        markUploaded: (G, ie) => {
          n[G] = r(2, ie);
        },
        removeFailed: (G) => {
          delete n[G];
        },
        destroy: () => {
          n = {};
        }
      };
    };
    let lR = 0;
    const cR = () => {
      const e = () => Math.round(Math.random() * 4294967295).toString(36);
      return "s" + (/* @__PURE__ */ new Date()).getTime().toString(36) + e() + e() + e();
    }, cL = (e) => e + lR++ + cR(), uR = () => {
      let e = [];
      const t = (U) => ({
        "image/jpeg": "jpg",
        "image/jpg": "jpg",
        "image/gif": "gif",
        "image/png": "png",
        "image/apng": "apng",
        "image/avif": "avif",
        "image/svg+xml": "svg",
        "image/webp": "webp",
        "image/bmp": "bmp",
        "image/tiff": "tiff"
      })[U.toLowerCase()] || "dat", n = (U, G, ie, ye, ae) => {
        if (Ot(U))
          return r({
            id: U,
            name: ye,
            filename: ae,
            blob: G,
            base64: ie
          });
        if (Ee(U))
          return r(U);
        throw new Error("Unknown input type");
      }, r = (U) => {
        if (!U.blob || !U.base64)
          throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
        const G = U.id || cL("blobid"), ie = U.name || G, ye = U.blob;
        return {
          id: dt(G),
          name: dt(ie),
          filename: dt(U.filename || ie + "." + t(ye.type)),
          blob: dt(ye),
          base64: dt(U.base64),
          blobUri: dt(U.blobUri || URL.createObjectURL(ye)),
          uri: dt(U.uri)
        };
      }, a = (U) => {
        d(U.id()) || e.push(U);
      }, c = (U) => po(e, U).getOrUndefined(), d = (U) => c((G) => G.id() === U);
      return {
        create: n,
        add: a,
        get: d,
        getByUri: (U) => c((G) => G.blobUri() === U),
        getByData: (U, G) => c((ie) => ie.base64() === U && ie.blob().type === G),
        findFirst: c,
        removeByUri: (U) => {
          e = ct(e, (G) => G.blobUri() === U ? (URL.revokeObjectURL(G.blobUri()), !1) : !0);
        },
        destroy: () => {
          ut(e, (U) => {
            URL.revokeObjectURL(U.blobUri());
          }), e = [];
        }
      };
    }, Kx = (e, t) => {
      const n = {}, r = (ae, xe) => ae ? ae.replace(/\/$/, "") + "/" + xe.replace(/^\//, "") : xe, a = (ae, xe) => new Promise((Ne, Ie) => {
        const Fe = new XMLHttpRequest();
        Fe.open("POST", t.url), Fe.withCredentials = t.credentials, Fe.upload.onprogress = (_t) => {
          xe(_t.loaded / _t.total * 100);
        }, Fe.onerror = () => {
          Ie("Image upload failed due to a XHR Transport error. Code: " + Fe.status);
        }, Fe.onload = () => {
          if (Fe.status < 200 || Fe.status >= 300) {
            Ie("HTTP Error: " + Fe.status);
            return;
          }
          const _t = JSON.parse(Fe.responseText);
          if (!_t || !Ot(_t.location)) {
            Ie("Invalid JSON: " + Fe.responseText);
            return;
          }
          Ne(r(t.basePath, _t.location));
        };
        const je = new FormData();
        je.append("file", ae.blob(), ae.filename()), Fe.send(je);
      }), c = un(t.handler) ? t.handler : a, d = () => new Promise((ae) => {
        ae([]);
      }), h = (ae, xe) => ({
        url: xe,
        blobInfo: ae,
        status: !0
      }), k = (ae, xe) => ({
        url: "",
        blobInfo: ae,
        status: !1,
        error: xe
      }), D = (ae, xe) => {
        Ht.each(n[ae], (Ne) => {
          Ne(xe);
        }), delete n[ae];
      }, H = (ae, xe, Ne) => (e.markPending(ae.blobUri()), new Promise((Ie) => {
        let Fe, je;
        try {
          const _t = () => {
            Fe && (Fe.close(), je = ht);
          }, Zt = (at) => {
            _t(), e.markUploaded(ae.blobUri(), at), D(ae.blobUri(), h(ae, at)), Ie(h(ae, at));
          }, fn = (at) => {
            _t(), e.removeFailed(ae.blobUri()), D(ae.blobUri(), k(ae, at)), Ie(k(ae, at));
          };
          je = (at) => {
            at < 0 || at > 100 || K.from(Fe).orThunk(() => K.from(Ne).map(tn)).each((et) => {
              Fe = et, et.progressBar.value(at);
            });
          }, xe(ae, je).then(Zt, (at) => {
            fn(Ot(at) ? { message: at } : at);
          });
        } catch (_t) {
          Ie(k(ae, _t));
        }
      })), U = (ae) => ae === a, G = (ae) => {
        const xe = ae.blobUri();
        return new Promise((Ne) => {
          n[xe] = n[xe] || [], n[xe].push(Ne);
        });
      }, ie = (ae, xe) => (ae = Ht.grep(ae, (Ne) => !e.isUploaded(Ne.blobUri())), Promise.all(Ht.map(ae, (Ne) => e.isPending(Ne.blobUri()) ? G(Ne) : H(Ne, c, xe))));
      return { upload: (ae, xe) => !t.url && U(c) ? d() : ie(ae, xe) };
    }, r3 = (e) => () => e.notificationManager.open({
      text: e.translate("Image uploading..."),
      type: "info",
      timeout: -1,
      progressBar: !0
    }), dR = (e, t) => Kx(t, {
      url: rr(e),
      basePath: tC(e),
      credentials: Ow(e),
      handler: t1(e)
    }), fR = (e) => {
      const t = iR(), n = dR(e, t);
      return { upload: (r, a = !0) => n.upload(r, a ? r3(e) : void 0) };
    }, mR = (e, t) => e.dom.isEmpty(t.dom) && Xe(e.schema.getTextBlockElements()[Eo(t)]), uL = (e) => (t) => {
      mR(e, t) && Ir(t, be.fromHtml('<br data-mce-bogus="1" />'));
    }, dL = (e) => {
      const t = uR();
      let n, r;
      const a = iR(), c = [], d = (Fe) => (je) => e.selection ? Fe(je) : [], h = (Fe) => Fe + (Fe.indexOf("?") === -1 ? "?" : "&") + (/* @__PURE__ */ new Date()).getTime(), k = (Fe, je, _t) => {
        let Zt = 0;
        do
          Zt = Fe.indexOf(je, Zt), Zt !== -1 && (Fe = Fe.substring(0, Zt) + _t + Fe.substr(Zt + je.length), Zt += _t.length - je.length + 1);
        while (Zt !== -1);
        return Fe;
      }, D = (Fe, je, _t) => {
        const Zt = `src="${_t}"${_t === nr.transparentSrc ? ' data-mce-placeholder="1"' : ""}`;
        return Fe = k(Fe, `src="${je}"`, Zt), Fe = k(Fe, 'data-mce-src="' + je + '"', 'data-mce-src="' + _t + '"'), Fe;
      }, H = (Fe, je) => {
        ut(e.undoManager.data, (_t) => {
          _t.type === "fragmented" ? _t.fragments = oo(_t.fragments, (Zt) => D(Zt, Fe, je)) : _t.content = D(_t.content, Fe, je);
        });
      }, U = (Fe, je) => {
        const _t = e.convertURL(je, "src");
        H(Fe.src, je), zs(be.fromDom(Fe), {
          src: hc(e) ? h(je) : je,
          "data-mce-src": _t
        });
      }, G = () => (n || (n = dR(e, a)), xe().then(d((Fe) => {
        const je = oo(Fe, (_t) => _t.blobInfo);
        return n.upload(je, r3(e)).then(d((_t) => {
          const Zt = [];
          let fn = !1;
          const at = oo(_t, (et, Mt) => {
            const { blobInfo: gn, image: Fn } = Fe[Mt];
            let Uo = !1;
            return et.status && Pb(e) ? (et.url && !_r(Fn.src, et.url) && (fn = !0), t.removeByUri(Fn.src), yp(e) || U(Fn, et.url)) : et.error && (et.error.remove && (H(Fn.src, nr.transparentSrc), Zt.push(Fn), Uo = !0), rL(e, et.error.message)), {
              element: Fn,
              status: et.status,
              uploadUri: et.url,
              blobInfo: gn,
              removed: Uo
            };
          });
          return Zt.length > 0 && !yp(e) ? e.undoManager.transact(() => {
            ut(lc(Zt), (et) => {
              const Mt = Br(et);
              dr(et), Mt.each(uL(e)), t.removeByUri(et.dom.src);
            });
          }) : fn && e.undoManager.dispatchChange(), at;
        }));
      }))), ie = () => Bu(e) ? G() : Promise.resolve([]), ye = (Fe) => Ns(c, (je) => je(Fe)), ae = (Fe) => {
        c.push(Fe);
      }, xe = () => (r || (r = lL(a, t)), r.findAll(e.getBody(), ye).then(d((Fe) => {
        const je = ct(Fe, (_t) => Ot(_t) ? (qx(e, _t), !1) : _t.uriType !== "blob");
        return yp(e) || ut(je, (_t) => {
          H(_t.image.src, _t.blobInfo.blobUri()), _t.image.src = _t.blobInfo.blobUri(), _t.image.removeAttribute("data-mce-src");
        }), je;
      }))), Ne = () => {
        t.destroy(), a.destroy(), r = n = null;
      }, Ie = (Fe) => Fe.replace(/src="(blob:[^"]+)"/g, (je, _t) => {
        const Zt = a.getResultUri(_t);
        if (Zt)
          return 'src="' + Zt + '"';
        let fn = t.getByUri(_t);
        return fn || (fn = co(e.editorManager.get(), (at, et) => at || et.editorUpload && et.editorUpload.blobCache.getByUri(_t), void 0)), fn ? 'src="data:' + fn.blob().type + ";base64," + fn.base64() + '"' : je;
      });
      return e.on("SetContent", () => {
        Bu(e) ? ie() : xe();
      }), e.on("RawSaveContent", (Fe) => {
        Fe.content = Ie(Fe.content);
      }), e.on("GetContent", (Fe) => {
        Fe.source_view || Fe.format === "raw" || Fe.format === "tree" || (Fe.content = Ie(Fe.content));
      }), e.on("PostRender", () => {
        e.parser.addNodeFilter("img", (Fe) => {
          ut(Fe, (je) => {
            const _t = je.attr("src");
            if (!_t || t.getByUri(_t))
              return;
            const Zt = a.getResultUri(_t);
            Zt && je.attr("src", Zt);
          });
        });
      }), {
        blobCache: t,
        addFilter: ae,
        uploadImages: G,
        uploadImagesAuto: ie,
        scanForImages: xe,
        destroy: Ne
      };
    }, fL = (e) => {
      const t = e.dom, n = e.schema.type, r = {
        valigntop: [{
          selector: "td,th",
          styles: { verticalAlign: "top" }
        }],
        valignmiddle: [{
          selector: "td,th",
          styles: { verticalAlign: "middle" }
        }],
        valignbottom: [{
          selector: "td,th",
          styles: { verticalAlign: "bottom" }
        }],
        alignleft: [
          {
            selector: "figure.image",
            collapsed: !1,
            classes: "align-left",
            ceFalseOverride: !0,
            preview: "font-family font-size"
          },
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "left" },
            inherit: !1,
            preview: !1
          },
          {
            selector: "img,audio,video",
            collapsed: !1,
            styles: { float: "left" },
            preview: "font-family font-size"
          },
          {
            selector: "table",
            collapsed: !1,
            styles: {
              marginLeft: "0px",
              marginRight: "auto"
            },
            onformat: (a) => {
              t.setStyle(a, "float", null);
            },
            preview: "font-family font-size"
          },
          {
            selector: ".mce-preview-object,[data-ephox-embed-iri]",
            ceFalseOverride: !0,
            styles: { float: "left" }
          }
        ],
        aligncenter: [
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "center" },
            inherit: !1,
            preview: "font-family font-size"
          },
          {
            selector: "figure.image",
            collapsed: !1,
            classes: "align-center",
            ceFalseOverride: !0,
            preview: "font-family font-size"
          },
          {
            selector: "img,audio,video",
            collapsed: !1,
            styles: {
              display: "block",
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: !1
          },
          {
            selector: "table",
            collapsed: !1,
            styles: {
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: "font-family font-size"
          },
          {
            selector: ".mce-preview-object",
            ceFalseOverride: !0,
            styles: {
              display: "table",
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: !1
          },
          {
            selector: "[data-ephox-embed-iri]",
            ceFalseOverride: !0,
            styles: {
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: !1
          }
        ],
        alignright: [
          {
            selector: "figure.image",
            collapsed: !1,
            classes: "align-right",
            ceFalseOverride: !0,
            preview: "font-family font-size"
          },
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "right" },
            inherit: !1,
            preview: "font-family font-size"
          },
          {
            selector: "img,audio,video",
            collapsed: !1,
            styles: { float: "right" },
            preview: "font-family font-size"
          },
          {
            selector: "table",
            collapsed: !1,
            styles: {
              marginRight: "0px",
              marginLeft: "auto"
            },
            onformat: (a) => {
              t.setStyle(a, "float", null);
            },
            preview: "font-family font-size"
          },
          {
            selector: ".mce-preview-object,[data-ephox-embed-iri]",
            ceFalseOverride: !0,
            styles: { float: "right" },
            preview: !1
          }
        ],
        alignjustify: [{
          selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
          styles: { textAlign: "justify" },
          inherit: !1,
          preview: "font-family font-size"
        }],
        bold: [
          {
            inline: "strong",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          },
          {
            inline: "span",
            styles: { fontWeight: "bold" }
          },
          {
            inline: "b",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        italic: [
          {
            inline: "em",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          },
          {
            inline: "span",
            styles: { fontStyle: "italic" }
          },
          {
            inline: "i",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        underline: [
          {
            inline: "span",
            styles: { textDecoration: "underline" },
            exact: !0
          },
          {
            inline: "u",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        strikethrough: (() => {
          const a = {
            inline: "span",
            styles: { textDecoration: "line-through" },
            exact: !0
          }, c = {
            inline: "strike",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }, d = {
            inline: "s",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          };
          return n !== "html4" ? [
            d,
            a,
            c
          ] : [
            a,
            d,
            c
          ];
        })(),
        forecolor: {
          inline: "span",
          styles: { color: "%value" },
          links: !0,
          remove_similar: !0,
          clear_child_styles: !0
        },
        hilitecolor: {
          inline: "span",
          styles: { backgroundColor: "%value" },
          links: !0,
          remove_similar: !0,
          clear_child_styles: !0
        },
        fontname: {
          inline: "span",
          toggle: !1,
          styles: { fontFamily: "%value" },
          clear_child_styles: !0
        },
        fontsize: {
          inline: "span",
          toggle: !1,
          styles: { fontSize: "%value" },
          clear_child_styles: !0
        },
        lineheight: {
          selector: "h1,h2,h3,h4,h5,h6,p,li,td,th,div",
          styles: { lineHeight: "%value" }
        },
        fontsize_class: {
          inline: "span",
          attributes: { class: "%value" }
        },
        blockquote: {
          block: "blockquote",
          wrapper: !0,
          remove: "all"
        },
        subscript: { inline: "sub" },
        superscript: { inline: "sup" },
        code: { inline: "code" },
        link: {
          inline: "a",
          selector: "a",
          remove: "all",
          split: !0,
          deep: !0,
          onmatch: (a, c, d) => wn(a) && a.hasAttribute("href"),
          onformat: (a, c, d) => {
            Ht.each(d, (h, k) => {
              t.setAttrib(a, k, h);
            });
          }
        },
        lang: {
          inline: "span",
          clear_child_styles: !0,
          remove_similar: !0,
          attributes: {
            lang: "%value",
            "data-mce-lang": (a) => {
              var c;
              return (c = a == null ? void 0 : a.customValue) !== null && c !== void 0 ? c : null;
            }
          }
        },
        removeformat: [
          {
            selector: "b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small",
            remove: "all",
            split: !0,
            expand: !1,
            block_expand: !0,
            deep: !0
          },
          {
            selector: "span",
            attributes: [
              "style",
              "class"
            ],
            remove: "empty",
            split: !0,
            expand: !1,
            deep: !0
          },
          {
            selector: "*",
            attributes: [
              "style",
              "class"
            ],
            split: !1,
            expand: !1,
            deep: !0
          }
        ]
      };
      return Ht.each("p h1 h2 h3 h4 h5 h6 div address pre dt dd samp".split(/\s/), (a) => {
        r[a] = {
          block: a,
          remove: "all"
        };
      }), r;
    }, pR = {
      remove_similar: !0,
      inherit: !1
    }, L1 = {
      selector: "td,th",
      ...pR
    }, s3 = {
      tablecellbackgroundcolor: {
        styles: { backgroundColor: "%value" },
        ...L1
      },
      tablecellverticalalign: {
        styles: { "vertical-align": "%value" },
        ...L1
      },
      tablecellbordercolor: {
        styles: { borderColor: "%value" },
        ...L1
      },
      tablecellclass: {
        classes: ["%value"],
        ...L1
      },
      tableclass: {
        selector: "table",
        classes: ["%value"],
        ...pR
      },
      tablecellborderstyle: {
        styles: { borderStyle: "%value" },
        ...L1
      },
      tablecellborderwidth: {
        styles: { borderWidth: "%value" },
        ...L1
      }
    }, gR = dt(s3), hR = (e) => {
      const t = {}, n = (d) => Xe(d) ? t[d] : t, r = (d) => Yn(t, d), a = (d, h) => {
        d && (Ot(d) ? (Se(h) || (h = [h]), ut(h, (k) => {
          ko(k.deep) && (k.deep = !jf(k)), ko(k.split) && (k.split = !jf(k) || Xl(k)), ko(k.remove) && jf(k) && !Xl(k) && (k.remove = "none"), jf(k) && Xl(k) && (k.mixed = !0, k.block_expand = !0), Ot(k.classes) && (k.classes = k.classes.split(/\s+/));
        }), t[d] = h) : Zo(d, (k, D) => {
          a(D, k);
        }));
      }, c = (d) => (d && t[d] && delete t[d], t);
      return a(fL(e)), a(gR()), a(aC(e)), {
        get: n,
        has: r,
        register: a,
        unregister: c
      };
    }, Yx = Ht.each, Kf = gs.DOM, a3 = (e) => Xe(e) && Ee(e), m2 = (e, t) => {
      const n = t && t.schema || of({}), r = (k, D) => {
        D.classes.length > 0 && Kf.addClass(k, D.classes.join(" ")), Kf.setAttribs(k, D.attrs);
      }, a = (k) => {
        const D = Ot(k) ? {
          name: k,
          classes: [],
          attrs: {}
        } : k, H = Kf.create(D.name);
        return r(H, D), H;
      }, c = (k, D) => {
        const H = n.getElementRule(k.nodeName.toLowerCase()), U = H == null ? void 0 : H.parentsRequired;
        return U && U.length ? D && So(U, D) ? D : U[0] : !1;
      }, d = (k, D, H) => {
        let U;
        const G = D[0], ie = a3(G) ? G.name : void 0, ye = c(k, ie);
        if (ye)
          ie === ye ? (U = G, D = D.slice(1)) : U = ye;
        else if (G)
          U = G, D = D.slice(1);
        else if (!H)
          return k;
        const ae = U ? a(U) : Kf.create("div");
        ae.appendChild(k), H && Ht.each(H, (Ne) => {
          const Ie = a(Ne);
          ae.insertBefore(Ie, k);
        });
        const xe = a3(U) ? U.siblings : void 0;
        return d(ae, D, xe);
      }, h = Kf.create("div");
      if (e.length > 0) {
        const k = e[0], D = a(k), H = a3(k) ? k.siblings : void 0;
        h.appendChild(d(D, e.slice(1), H));
      }
      return h;
    }, p2 = (e) => {
      e = Ht.trim(e);
      let t = "div";
      const n = {
        name: t,
        classes: [],
        attrs: {},
        selector: e
      };
      return e !== "*" && (t = e.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, (r, a, c, d, h) => {
        switch (a) {
          case "#":
            n.attrs.id = c;
            break;
          case ".":
            n.classes.push(c);
            break;
          case ":":
            Ht.inArray("checked disabled enabled read-only required".split(" "), c) !== -1 && (n.attrs[c] = c);
            break;
        }
        if (d === "[") {
          const k = h.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
          k && (n.attrs[k[1]] = k[2]);
        }
        return "";
      })), n.name = t || "div", n;
    }, g2 = (e) => Ot(e) ? (e = e.split(/\s*,\s*/)[0], e = e.replace(/\s*(~\+|~|\+|>)\s*/g, "$1"), Ht.map(e.split(/(?:>|\s+(?![^\[\]]+\]))/), (t) => {
      const n = Ht.map(t.split(/(?:~\+|~|\+)/), p2), r = n.pop();
      return n.length && (r.siblings = n), r;
    }).reverse()) : [], Zh = (e, t) => {
      let n = "", r = Vp(e);
      if (r === "")
        return "";
      const a = (G) => Ot(G) ? G.replace(/%(\w+)/g, "") : "", c = (G, ie) => Kf.getStyle(ie ?? e.getBody(), G, !0);
      if (Ot(t)) {
        const G = e.formatter.get(t);
        if (!G)
          return "";
        t = G[0];
      }
      if ("preview" in t) {
        const G = t.preview;
        if (G === !1)
          return "";
        r = G || r;
      }
      let d = t.block || t.inline || "span", h;
      const k = g2(t.selector);
      k.length > 0 ? (k[0].name || (k[0].name = d), d = t.selector, h = m2(k, e)) : h = m2([d], e);
      const D = Kf.select(d, h)[0] || h.firstChild;
      Yx(t.styles, (G, ie) => {
        const ye = a(G);
        ye && Kf.setStyle(D, ie, ye);
      }), Yx(t.attributes, (G, ie) => {
        const ye = a(G);
        ye && Kf.setAttrib(D, ie, ye);
      }), Yx(t.classes, (G) => {
        const ie = a(G);
        Kf.hasClass(D, ie) || Kf.addClass(D, ie);
      }), e.dispatch("PreviewFormats"), Kf.setStyles(h, {
        position: "absolute",
        left: -65535
      }), e.getBody().appendChild(h);
      const H = c("fontSize"), U = /px$/.test(H) ? parseInt(H, 10) : 0;
      return Yx(r.split(" "), (G) => {
        let ie = c(G, D);
        if (!(G === "background-color" && /transparent|rgba\s*\([^)]+,\s*0\)/.test(ie) && (ie = c(G), ql(ie).toLowerCase() === "#ffffff")) && !(G === "color" && ql(ie).toLowerCase() === "#000000")) {
          if (G === "font-size" && /em|%$/.test(ie)) {
            if (U === 0)
              return;
            ie = parseFloat(ie) / (/%$/.test(ie) ? 100 : 1) * U + "px";
          }
          G === "border" && ie && (n += "padding:0 2px;"), n += G + ":" + ie + ";";
        }
      }), e.dispatch("AfterPreviewFormats"), Kf.remove(h), n;
    }, h2 = (e) => {
      e.addShortcut("meta+b", "", "Bold"), e.addShortcut("meta+i", "", "Italic"), e.addShortcut("meta+u", "", "Underline");
      for (let t = 1; t <= 6; t++)
        e.addShortcut("access+" + t, "", [
          "FormatBlock",
          !1,
          "h" + t
        ]);
      e.addShortcut("access+7", "", [
        "FormatBlock",
        !1,
        "p"
      ]), e.addShortcut("access+8", "", [
        "FormatBlock",
        !1,
        "div"
      ]), e.addShortcut("access+9", "", [
        "FormatBlock",
        !1,
        "address"
      ]);
    }, P1 = (e) => {
      const t = hR(e), n = Ja({});
      return h2(e), A1(e), yp(e) || BB(n, e), {
        get: t.get,
        has: t.has,
        register: t.register,
        unregister: t.unregister,
        apply: (r, a, c) => {
          L6(e, r, a, c);
        },
        remove: (r, a, c, d) => {
          P6(e, r, a, c, d);
        },
        toggle: (r, a, c) => {
          I6(e, r, a, c);
        },
        match: (r, a, c, d) => D6(e, r, a, c, d),
        closest: (r) => B6(e, r),
        matchAll: (r, a) => R6(e, r, a),
        matchNode: (r, a, c, d) => N6(e, r, a, c, d),
        canApply: (r) => M6(e, r),
        formatChanged: (r, a, c, d) => F6(e, n, r, a, c, d),
        getCssText: Tt(Zh, e)
      };
    }, i3 = (e) => {
      switch (e.toLowerCase()) {
        case "undo":
        case "redo":
        case "mcefocus":
          return !0;
        default:
          return !1;
      }
    }, bR = (e, t, n) => {
      const r = Ja(!1), a = (k) => {
        Yp(t, !1, n), t.add({}, k);
      };
      e.on("init", () => {
        t.add();
      }), e.on("BeforeExecCommand", (k) => {
        const D = k.command;
        i3(D) || (uD(t, n), t.beforeChange());
      }), e.on("ExecCommand", (k) => {
        const D = k.command;
        i3(D) || a(k);
      }), e.on("ObjectResizeStart cut", () => {
        t.beforeChange();
      }), e.on("SaveContent ObjectResized blur", a), e.on("dragend", a), e.on("keyup", (k) => {
        const D = k.keyCode;
        if (k.isDefaultPrevented())
          return;
        const H = nr.os.isMacOS() && k.key === "Meta";
        (D >= 33 && D <= 36 || D >= 37 && D <= 40 || D === 45 || k.ctrlKey || H) && (a(), e.nodeChanged()), (D === 46 || D === 8) && e.nodeChanged(), r.get() && t.typing && !Hx(t2(e), t.data[0]) && (e.isDirty() || e.setDirty(!0), e.dispatch("TypingUndo"), r.set(!1), e.nodeChanged());
      }), e.on("keydown", (k) => {
        const D = k.keyCode;
        if (k.isDefaultPrevented())
          return;
        if (D >= 33 && D <= 36 || D >= 37 && D <= 40 || D === 45) {
          t.typing && a(k);
          return;
        }
        const H = k.ctrlKey && !k.altKey || k.metaKey;
        if ((D < 16 || D > 20) && D !== 224 && D !== 91 && !t.typing && !H) {
          t.beforeChange(), Yp(t, !0, n), t.add({}, k), r.set(!0);
          return;
        }
        (nr.os.isMacOS() ? k.metaKey : k.ctrlKey && !k.altKey) && t.beforeChange();
      }), e.on("mousedown", (k) => {
        t.typing && a(k);
      });
      const c = (k) => k.inputType === "insertReplacementText", d = (k) => k.inputType === "insertText" && k.data === null, h = (k) => k.inputType === "insertFromPaste" || k.inputType === "insertFromDrop";
      e.on("input", (k) => {
        k.inputType && (c(k) || d(k) || h(k)) && a(k);
      }), e.on("AddUndo Undo Redo ClearUndos", (k) => {
        k.isDefaultPrevented() || e.nodeChanged();
      });
    }, l3 = (e) => {
      e.addShortcut("meta+z", "", "Undo"), e.addShortcut("meta+y,meta+shift+z", "", "Redo");
    }, Xx = (e) => {
      const t = sf(), n = Ja(0), r = Ja(0), a = {
        data: [],
        typing: !1,
        beforeChange: () => {
          E6(e, n, t);
        },
        add: (c, d) => vD(e, a, r, n, t, c, d),
        dispatchChange: () => {
          e.setDirty(!0);
          const c = t2(e);
          c.bookmark = ve(e.selection), e.dispatch("change", {
            level: c,
            lastLevel: ha(a.data, r.get()).getOrUndefined()
          });
        },
        undo: () => xD(e, a, n, r),
        redo: () => T6(e, r, a.data),
        clear: () => {
          z6(e, a, r);
        },
        reset: () => {
          tv(e, a);
        },
        hasUndo: () => O6(e, a, r),
        hasRedo: () => A6(e, a, r),
        transact: (c) => wD(e, a, n, c),
        ignore: (c) => {
          kD(e, n, c);
        },
        extra: (c, d) => {
          a2(e, a, r, c, d);
        }
      };
      return yp(e) || bR(e, a, n), l3(e), a;
    }, vy = [
      9,
      27,
      yn.HOME,
      yn.END,
      19,
      20,
      44,
      144,
      145,
      33,
      34,
      45,
      16,
      17,
      18,
      91,
      92,
      93,
      yn.DOWN,
      yn.UP,
      yn.LEFT,
      yn.RIGHT
    ].concat(nr.browser.isFirefox() ? [224] : []), xy = "data-mce-placeholder", c3 = (e) => e.type === "keydown" || e.type === "keyup", yR = (e) => {
      const t = e.keyCode;
      return t === yn.BACKSPACE || t === yn.DELETE;
    }, vR = (e) => {
      if (c3(e)) {
        const t = e.keyCode;
        return !yR(e) && (yn.metaKeyPressed(e) || e.altKey || t >= 112 && t <= 123 || So(vy, t));
      } else
        return !1;
    }, mL = (e) => c3(e) && !(yR(e) || e.type === "keyup" && e.keyCode === 229), pL = (e, t, n) => {
      if (Yr(be.fromDom(t), !1)) {
        const r = t.firstElementChild;
        return r ? e.getStyle(t.firstElementChild, "padding-left") || e.getStyle(t.firstElementChild, "padding-right") ? !1 : n === r.nodeName.toLowerCase() : !0;
      } else
        return !1;
    }, gL = (e) => {
      var t;
      const n = e.dom, r = li(e), a = (t = Tv(e)) !== null && t !== void 0 ? t : "", c = (d, h) => {
        if (vR(d))
          return;
        const k = e.getBody(), D = mL(d) ? !1 : pL(n, k, r);
        (n.getAttrib(k, xy) !== "" !== D || h) && (n.setAttrib(k, xy, D ? a : null), n.setAttrib(k, "aria-placeholder", D ? a : null), xk(e, D), e.on(D ? "keydown" : "keyup", c), e.off(D ? "keyup" : "keydown", c));
      };
      Na(a) && e.on("init", (d) => {
        c(d, !0), e.on("change SetContent ExecCommand", c), e.on("paste", (h) => du.setEditorTimeout(e, () => c(h)));
      });
    }, u3 = (e, t) => ({
      block: e,
      position: t
    }), xR = (e, t) => ({
      from: e,
      to: t
    }), d3 = (e, t) => {
      const n = be.fromDom(e), r = be.fromDom(t.container());
      return V0(n, r).map((a) => u3(a, t));
    }, wR = (e) => !Le(e.from.block, e.to.block), kR = (e, t) => st(t, (a) => Tf(a) || cc(a.dom), (a) => Le(a, e)).filter(Ji).getOr(e), f3 = (e, t) => {
      const n = be.fromDom(e);
      return Le(kR(n, t.from.block), kR(n, t.to.block));
    }, hL = (e) => Kr(e.from.block.dom) === !1 && Kr(e.to.block.dom) === !1, _R = (e) => {
      const t = (n) => cm(n) || Dp(n.dom);
      return t(e.from.block) && t(e.to.block);
    }, m3 = (e, t, n) => cs(n.position.getNode()) && !Yr(n.block) ? f1(!1, n.block.dom).bind((r) => r.isEqual(n.position) ? Hf(t, e, r).bind((a) => d3(e, a)) : K.some(n)).getOr(n) : n, CR = (e, t, n) => {
      const r = d3(e, nt.fromRangeStart(n)), a = r.bind((c) => Hf(t, e, c.position).bind((d) => d3(e, d).map((h) => m3(e, t, h))));
      return ns(r, a, xR).filter((c) => wR(c) && f3(e, c) && hL(c) && _R(c));
    }, p3 = (e, t, n) => n.collapsed ? CR(e, t, n) : K.none(), bL = (e, t) => {
      const n = Pr(e);
      return Ra(n, (r) => t.isBlock(Eo(r))).fold(dt(n), (r) => n.slice(0, r));
    }, g3 = (e, t) => {
      const n = bL(e, t);
      return ut(n, dr), n;
    }, SR = (e, t) => {
      const n = Zp(t, e);
      return po(n.reverse(), (r) => Yr(r)).each(dr);
    }, ER = (e) => ct(cg(e), (t) => !Yr(t)).length === 0, TR = (e, t, n, r, a) => {
      if (Yr(n))
        return zf(n), lu(n.dom);
      ER(a) && Yr(t) && Fs(a, be.fromTag("br"));
      const c = cf(n.dom, nt.before(a.dom));
      return ut(g3(t, r), (d) => {
        Fs(a, d);
      }), SR(e, t), c;
    }, yL = (e, t) => e.isInline(Eo(t)), vL = (e, t, n, r) => {
      if (Yr(n)) {
        if (Yr(t)) {
          const d = xn(((h) => {
            const k = (D, H) => qr(D).fold(() => H, (U) => yL(r, U) ? k(U, H.concat(_m(U))) : H);
            return k(h, []);
          })(n), (h, k) => (im(h, k), k), Vm());
          yi(t), Ir(t, d);
        }
        return dr(n), lu(t.dom);
      }
      const a = dp(n.dom);
      return ut(g3(t, r), (c) => {
        Ir(n, c);
      }), SR(e, t), a;
    }, xL = (e, t) => {
      const n = Zp(t, e);
      return K.from(n[n.length - 1]);
    }, wL = (e, t) => Dt(t, e) ? xL(t, e) : K.none(), zR = (e, t) => {
      f1(e, t.dom).bind((n) => K.from(n.getNode())).map(be.fromDom).filter(tl).each(dr);
    }, wy = (e, t, n, r) => (zR(!0, t), zR(!1, n), wL(t, n).fold(Tt(vL, e, t, n, r), Tt(TR, e, t, n, r))), h3 = (e, t, n, r, a) => t ? wy(e, r, n, a) : wy(e, n, r, a), b2 = (e, t) => {
      const n = be.fromDom(e.getBody());
      return p3(n.dom, t, e.selection.getRng()).map((a) => () => {
        h3(n, t, a.from.block, a.to.block, e.schema).each((c) => {
          e.selection.setRng(c.toRange());
        });
      });
    }, OR = (e, t, n) => {
      const r = t.getRng();
      return ns(V0(e, be.fromDom(r.startContainer)), V0(e, be.fromDom(r.endContainer)), (a, c) => Le(a, c) ? K.none() : K.some(() => {
        r.deleteContents(), h3(e, !0, a, c, n).each((d) => {
          t.setRng(d.toRange());
        });
      })).getOr(K.none());
    }, AR = (e, t) => {
      const n = be.fromDom(t), r = Tt(Le, e);
      return si(n, Tf, r).isSome();
    }, kL = (e, t) => AR(e, t.startContainer) || AR(e, t.endContainer), ky = (e, t) => {
      const n = cf(e.dom, nt.fromRangeStart(t)).isNone(), r = kd(e.dom, nt.fromRangeEnd(t)).isNone();
      return !kL(e, t) && n && r;
    }, DR = (e) => K.some(() => {
      e.setContent(""), e.selection.setCursorLocation();
    }), y2 = (e) => {
      const t = be.fromDom(e.getBody()), n = e.selection.getRng();
      return ky(t, n) ? DR(e) : OR(t, e.selection, e.schema);
    }, b3 = (e, t) => e.selection.isCollapsed() ? K.none() : y2(e), qg = (e, t, n, r, a) => K.from(t._selectionOverrides.showCaret(e, n, r, a)), _L = (e) => {
      const t = e.ownerDocument.createRange();
      return t.selectNode(e), t;
    }, Jx = (e, t) => e.dispatch("BeforeObjectSelected", { target: t }).isDefaultPrevented() ? K.none() : K.some(_L(t)), y3 = (e, t, n) => {
      const r = Jt(1, e.getBody(), t), a = nt.fromRangeStart(r), c = a.getNode();
      if (jb(c))
        return qg(1, e, c, !a.isAtEnd(), !1);
      const d = a.getNode(!0);
      if (jb(d))
        return qg(1, e, d, !1, !1);
      const h = Uh(e.dom.getRoot(), a.getNode());
      return jb(h) ? qg(1, e, h, !1, n) : K.none();
    }, v3 = (e, t, n) => t.collapsed ? y3(e, t, n).getOr(t) : t, xl = (e) => $h(e) || I0(e), CL = (e) => Hh(e) || F0(e), SL = (e, t) => {
      At(t) && t.data.length === 0 && e.remove(t);
    }, v2 = (e, t, n, r, a, c) => {
      qg(r, e, c.getNode(!a), a, !0).each((d) => {
        if (t.collapsed) {
          const h = t.cloneRange();
          a ? h.setEnd(d.startContainer, d.startOffset) : h.setStart(d.endContainer, d.endOffset), h.deleteContents();
        } else
          t.deleteContents();
        e.selection.setRng(d);
      }), SL(e.dom, n);
    }, RR = (e, t) => {
      const n = e.selection.getRng();
      if (!At(n.commonAncestorContainer))
        return K.none();
      const r = t ? _a.Forwards : _a.Backwards, a = Bg(e.getBody()), c = Tt(al, t ? a.next : a.prev), d = t ? xl : CL, h = Nc(r, e.getBody(), n), k = c(h), D = k && ju(t, k);
      if (!D || !Wc(h, D))
        return K.none();
      if (d(D))
        return K.some(() => v2(e, n, h.getNode(), r, t, D));
      const H = c(D);
      return H && d(H) && Wc(D, H) ? K.some(() => v2(e, n, h.getNode(), r, t, H)) : K.none();
    }, Qx = (e, t) => RR(e, t), x3 = (e, t) => {
      const n = e.getBody();
      return t ? lu(n).filter($h) : dp(n).filter(Hh);
    }, w3 = (e) => {
      const t = e.selection.getRng();
      return !t.collapsed && (x3(e, !0).exists((n) => n.isEqual(nt.fromRangeStart(t))) || x3(e, !1).exists((n) => n.isEqual(nt.fromRangeEnd(t))));
    }, EL = (e) => Xe(e) && (Tf(be.fromDom(e)) || Jd(be.fromDom(e))), Yf = $e.generate([
      { remove: ["element"] },
      { moveToElement: ["element"] },
      { moveToPosition: ["position"] }
    ]), TL = (e, t) => {
      const n = t.getNode(!e), r = e ? "after" : "before";
      return wn(n) && n.getAttribute("data-mce-caret") === r;
    }, zL = (e, t, n, r, a) => {
      const c = (d) => a.isInline(d.nodeName.toLowerCase()) && !Kt(n, r, e);
      return bs(!t, n).fold(() => bs(t, r).fold(Pn, c), c);
    }, NR = (e, t, n, r) => {
      const a = r.getNode(!t);
      return V0(be.fromDom(e), be.fromDom(n.getNode())).map((c) => Yr(c) ? Yf.remove(c.dom) : Yf.moveToElement(a)).orThunk(() => K.some(Yf.moveToElement(a)));
    }, I1 = (e, t, n, r) => Hf(t, e, n).bind((a) => EL(a.getNode()) || zL(e, t, n, a, r) ? K.none() : t && Kr(a.getNode()) || !t && Kr(a.getNode(!0)) ? NR(e, t, n, a) : t && Hh(n) || !t && $h(n) ? K.some(Yf.moveToPosition(a)) : K.none()), Xp = (e, t) => jn(t) ? K.none() : e && Kr(t.nextSibling) ? K.some(Yf.moveToElement(t.nextSibling)) : !e && Kr(t.previousSibling) ? K.some(Yf.moveToElement(t.previousSibling)) : K.none(), OL = (e, t, n) => n.fold((r) => K.some(Yf.remove(r)), (r) => K.some(Yf.moveToElement(r)), (r) => Kt(t, r, e) ? K.none() : K.some(Yf.moveToPosition(r))), AL = (e, t, n, r) => TL(t, n) ? Xp(t, n.getNode(!t)).orThunk(() => I1(e, t, n, r)) : I1(e, t, n, r).bind((a) => OL(e, n, a)), DL = (e, t, n, r) => {
      const a = Jt(t ? 1 : -1, e, n), c = nt.fromRangeStart(a), d = be.fromDom(e);
      return !t && Hh(c) ? K.some(Yf.remove(c.getNode(!0))) : t && $h(c) ? K.some(Yf.remove(c.getNode())) : !t && $h(c) && nE(d, c, r) ? Xz(d, c, r).map((h) => Yf.remove(h.getNode())) : t && Hh(c) && tE(d, c, r) ? PM(d, c, r).map((h) => Yf.remove(h.getNode())) : AL(e, t, c, r);
    }, RL = (e, t) => (n) => (e._selectionOverrides.hideFakeCaret(), Uu(e, t, be.fromDom(n)), !0), NL = (e, t) => (n) => {
      const r = t ? nt.before(n) : nt.after(n);
      return e.selection.setRng(r.toRange()), !0;
    }, ML = (e) => (t) => (e.selection.setRng(t.toRange()), !0), MR = (e, t) => K.from(Uh(e.getBody(), t)), BL = (e, t) => {
      const n = e.selection.getNode();
      return MR(e, n).filter(Kr).fold(() => DL(e.getBody(), t, e.selection.getRng(), e.schema).map((r) => () => r.fold(RL(e, t), NL(e, t), ML(e))), () => K.some(ht));
    }, LL = (e) => {
      ut(Ni(e, ".mce-offscreen-selection"), dr);
    }, PL = (e, t) => {
      const n = e.selection.getNode();
      return Kr(n) && !Sf(n) ? MR(e, n.parentNode).filter(Kr).fold(() => K.some(() => {
        LL(be.fromDom(e.getBody())), Uu(e, t, be.fromDom(e.selection.getNode())), mx(e);
      }), () => K.some(ht)) : w3(e) ? K.some(() => {
        pO(e, e.selection.getRng(), be.fromDom(e.getBody()));
      }) : K.none();
    }, BR = (e) => {
      const t = e.dom, n = e.selection, r = Uh(e.getBody(), n.getNode());
      if (cc(r) && t.isBlock(r) && t.isEmpty(r)) {
        const a = t.create("br", { "data-mce-bogus": "1" });
        t.setHTML(r, ""), r.appendChild(a), n.setRng(nt.before(a).toRange());
      }
      return !0;
    }, k3 = (e, t) => e.selection.isCollapsed() ? BL(e, t) : PL(e, t), IL = (e, t) => {
      const n = nt.fromRangeStart(e.selection.getRng());
      return Hf(t, e.getBody(), n).filter((r) => t ? KS(r) : Wz(r)).bind((r) => dn(t ? 0 : -1, r)).map((r) => () => e.selection.select(r));
    }, _3 = (e, t) => e.selection.isCollapsed() ? IL(e, t) : K.none(), sv = At, LR = (e) => sv(e) && e.data[0] === C, PR = (e) => sv(e) && e.data[e.data.length - 1] === C, IR = (e) => {
      var t;
      return ((t = e.ownerDocument) !== null && t !== void 0 ? t : document).createTextNode(C);
    }, FL = (e) => {
      var t;
      if (sv(e.previousSibling))
        return PR(e.previousSibling) || e.previousSibling.appendData(C), e.previousSibling;
      if (sv(e))
        return LR(e) || e.insertData(0, C), e;
      {
        const n = IR(e);
        return (t = e.parentNode) === null || t === void 0 || t.insertBefore(n, e), n;
      }
    }, $L = (e) => {
      var t, n;
      if (sv(e.nextSibling))
        return LR(e.nextSibling) || e.nextSibling.insertData(0, C), e.nextSibling;
      if (sv(e))
        return PR(e) || e.appendData(C), e;
      {
        const r = IR(e);
        return e.nextSibling ? (t = e.parentNode) === null || t === void 0 || t.insertBefore(r, e.nextSibling) : (n = e.parentNode) === null || n === void 0 || n.appendChild(r), r;
      }
    }, x2 = (e, t) => e ? FL(t) : $L(t), HL = Tt(x2, !0), VL = Tt(x2, !1), FR = (e, t) => At(e.container()) ? x2(t, e.container()) : x2(t, e.getNode()), $R = (e, t) => {
      const n = t.get();
      return n && e.container() === n && on(n);
    }, C3 = (e, t) => t.fold((n) => {
      up(e.get());
      const r = HL(n);
      return e.set(r), K.some(nt(r, r.length - 1));
    }, (n) => lu(n).map((r) => {
      if ($R(r, e)) {
        const a = e.get();
        return nt(a, 1);
      } else {
        up(e.get());
        const a = FR(r, !0);
        return e.set(a), nt(a, 1);
      }
    }), (n) => dp(n).map((r) => {
      if ($R(r, e)) {
        const a = e.get();
        return nt(a, a.length - 1);
      } else {
        up(e.get());
        const a = FR(r, !1);
        return e.set(a), nt(a, a.length - 1);
      }
    }), (n) => {
      up(e.get());
      const r = VL(n);
      return e.set(r), K.some(nt(r, 1));
    }), HR = (e, t) => {
      for (let n = 0; n < e.length; n++) {
        const r = e[n].apply(null, t);
        if (r.isSome())
          return r;
      }
      return K.none();
    }, Wu = $e.generate([
      { before: ["element"] },
      { start: ["element"] },
      { end: ["element"] },
      { after: ["element"] }
    ]), VR = (e, t) => {
      const n = Yt(t, e);
      return n || e;
    }, UL = (e, t, n) => {
      const r = mO(n), a = VR(t, r.container());
      return iy(e, a, r).fold(() => kd(a, r).bind(Tt(iy, e, a)).map((c) => Wu.before(c)), K.none);
    }, jL = (e, t) => Mh(e, t) === null, S3 = (e, t, n) => iy(e, t, n).filter(Tt(jL, t)), ZL = (e, t, n) => {
      const r = pE(n);
      return S3(e, t, r).bind((a) => cf(a, r).isNone() ? K.some(Wu.start(a)) : K.none());
    }, WL = (e, t, n) => {
      const r = mO(n);
      return S3(e, t, r).bind((a) => kd(a, r).isNone() ? K.some(Wu.end(a)) : K.none());
    }, qL = (e, t, n) => {
      const r = pE(n), a = VR(t, r.container());
      return iy(e, a, r).fold(() => cf(a, r).bind(Tt(iy, e, a)).map((c) => Wu.after(c)), K.none);
    }, UR = (e) => !Fr(E3(e)), Gg = (e, t, n) => HR([
      UL,
      ZL,
      WL,
      qL
    ], [
      e,
      t,
      n
    ]).filter(UR), E3 = (e) => e.fold(Bn, Bn, Bn, Bn), jR = (e) => e.fold(dt("before"), dt("start"), dt("end"), dt("after")), w2 = (e) => e.fold(Wu.before, Wu.before, Wu.after, Wu.after), k2 = (e) => e.fold(Wu.start, Wu.start, Wu.end, Wu.end), GL = (e, t) => jR(e) === jR(t) && E3(e) === E3(t), KL = (e, t, n, r, a, c) => ns(iy(t, n, r), iy(t, n, a), (d, h) => d !== h && Aa(n, d, h) ? Wu.after(e ? d : h) : c).getOr(c), YL = (e, t) => e.fold(Mo, (n) => !GL(n, t)), XL = (e, t, n, r, a) => {
      const c = ju(e, a);
      return Hf(e, n, c).map(Tt(ju, e)).fold(() => r.map(w2), (k) => Gg(t, n, k).map(Tt(KL, e, t, n, c, k)).filter(Tt(YL, r))).filter(UR);
    }, JL = (e, t) => e ? t.fold(mn(K.some, Wu.start), K.none, mn(K.some, Wu.after), K.none) : t.fold(K.none, mn(K.some, Wu.before), K.none, mn(K.some, Wu.end)), QL = (e, t, n, r) => {
      const a = ju(e, r), c = Gg(t, n, a);
      return Gg(t, n, a).bind(Tt(JL, e)).orThunk(() => XL(e, t, n, c, r));
    }, eP = (e) => un(e.selection.getSel().modify), ZR = (e, t, n) => {
      const r = e ? 1 : -1;
      return t.setRng(nt(n.container(), n.offset() + r).toRange()), t.getSel().modify("move", e ? "forward" : "backward", "word"), !0;
    }, WR = (e, t) => {
      const n = t.selection.getRng(), r = e ? nt.fromRangeEnd(n) : nt.fromRangeStart(n);
      return eP(t) ? e && _o(r) ? ZR(!0, t.selection, r) : !e && fr(r) ? ZR(!1, t.selection, r) : !1 : !1;
    };
    var Jp;
    (function(e) {
      e[e.Br = 0] = "Br", e[e.Block = 1] = "Block", e[e.Wrap = 2] = "Wrap", e[e.Eol = 3] = "Eol";
    })(Jp || (Jp = {}));
    const _2 = (e, t) => e === _a.Backwards ? Ca(t) : t, qR = (e, t, n) => e === _a.Forwards ? t.next(n) : t.prev(n), tP = (e, t, n, r) => cs(r.getNode(t === _a.Forwards)) ? Jp.Br : Kt(n, r) === !1 ? Jp.Block : Jp.Wrap, GR = (e, t, n, r) => {
      const a = Bg(n);
      let c = r;
      const d = [];
      for (; c; ) {
        const h = qR(t, a, c);
        if (!h)
          break;
        if (cs(h.getNode(!1)))
          return t === _a.Forwards ? {
            positions: _2(t, d).concat([h]),
            breakType: Jp.Br,
            breakAt: K.some(h)
          } : {
            positions: _2(t, d),
            breakType: Jp.Br,
            breakAt: K.some(h)
          };
        if (!h.isVisible()) {
          c = h;
          continue;
        }
        if (e(c, h)) {
          const k = tP(n, t, c, h);
          return {
            positions: _2(t, d),
            breakType: k,
            breakAt: K.some(h)
          };
        }
        d.push(h), c = h;
      }
      return {
        positions: _2(t, d),
        breakType: Jp.Eol,
        breakAt: K.none()
      };
    }, KR = (e, t, n, r) => t(n, r).breakAt.map((a) => {
      const c = t(n, a).positions;
      return e === _a.Backwards ? c.concat(a) : [a].concat(c);
    }).getOr([]), T3 = (e, t) => co(e, (n, r) => n.fold(() => K.some(r), (a) => ns(ro(a.getClientRects()), ro(r.getClientRects()), (c, d) => {
      const h = Math.abs(t - c.left);
      return Math.abs(t - d.left) <= h ? r : a;
    }).or(n)), K.none()), C2 = (e, t) => ro(t.getClientRects()).bind((n) => T3(e, n.left)), ew = Tt(GR, nt.isAbove, -1), F1 = Tt(GR, nt.isBelow, 1), S2 = Tt(KR, -1, ew), YR = Tt(KR, 1, F1), z3 = (e, t) => ew(e, t).breakAt.isNone(), XR = (e, t) => F1(e, t).breakAt.isNone(), nP = (e) => lu(e).map((t) => [t].concat(F1(e, t).positions)).getOr([]), oP = (e) => dp(e).map((t) => ew(e, t).positions.concat(t)).getOr([]), rP = (e, t) => C2(S2(e, t), t), sP = (e, t) => C2(YR(e, t), t), aP = Kr, JR = (e, t) => Math.abs(e.left - t), QR = (e, t) => Math.abs(e.right - t), O3 = (e) => qi(e, "node"), eN = (e, t) => wc(e, (n, r) => {
      const a = Math.min(JR(n, t), QR(n, t)), c = Math.min(JR(r, t), QR(r, t));
      return c === a && O3(r) && aP(r.node) || c < a ? r : n;
    }), iP = (e) => {
      const t = (n) => oo(n, (r) => {
        const a = af(r);
        return a.node = e, a;
      });
      if (wn(e))
        return t(e.getClientRects());
      if (At(e)) {
        const n = e.ownerDocument.createRange();
        return n.setStart(e, 0), n.setEnd(e, e.data.length), t(n.getClientRects());
      } else
        return [];
    }, tN = (e) => ho(e, iP);
    var av;
    (function(e) {
      e[e.Up = -1] = "Up", e[e.Down = 1] = "Down";
    })(av || (av = {}));
    const $1 = (e, t, n, r) => {
      let a = r;
      for (; a = Ve(a, e, nl, t); )
        if (n(a))
          return;
    }, nN = (e, t, n, r, a, c) => {
      let d = 0;
      const h = [], k = (U) => {
        let G = tN([U]);
        e === -1 && (G = G.reverse());
        for (let ie = 0; ie < G.length; ie++) {
          const ye = G[ie];
          if (!n(ye, D)) {
            if (h.length > 0 && t(ye, ra(h)) && d++, ye.line = d, a(ye))
              return !0;
            h.push(ye);
          }
        }
        return !1;
      }, D = ra(c.getClientRects());
      if (!D)
        return h;
      const H = c.getNode();
      return H && (k(H), $1(e, r, k, H)), h;
    }, lP = (e, t) => t.line > e, cP = (e, t) => t.line === e, pf = Tt(nN, av.Up, op, Fp), oN = Tt(nN, av.Down, Fp, op), rN = (e) => ra(e.getClientRects()), uP = (e, t, n, r) => {
      const a = Bg(t);
      let c, d, h, k;
      const D = [];
      let H = 0;
      e === 1 ? (c = a.next, d = Fp, h = op, k = nt.after(r)) : (c = a.prev, d = op, h = Fp, k = nt.before(r));
      const U = rN(k);
      do {
        if (!k.isVisible())
          continue;
        const G = rN(k);
        if (h(G, U))
          continue;
        D.length > 0 && d(G, ra(D)) && H++;
        const ie = af(G);
        if (ie.position = k, ie.line = H, n(ie))
          return D;
        D.push(ie);
      } while (k = c(k));
      return D;
    }, sN = (e) => (t) => lP(e, t), A3 = (e) => (t) => cP(e, t), Wh = (e, t) => {
      e.selection.setRng(t), A0(e, e.selection.getRng());
    }, E2 = (e, t, n) => K.some(v3(e, t, n)), aN = (e, t, n, r, a, c) => {
      const d = t === _a.Forwards, h = Bg(e.getBody()), k = Tt(al, d ? h.next : h.prev), D = d ? r : a;
      if (!n.collapsed) {
        const ye = lf(n);
        if (c(ye))
          return qg(t, e, ye, t === _a.Backwards, !1);
        if (w3(e)) {
          const ae = n.cloneRange();
          return ae.collapse(t === _a.Backwards), K.from(ae);
        }
      }
      const H = Nc(t, e.getBody(), n);
      if (D(H))
        return Jx(e, H.getNode(!d));
      let U = k(H);
      const G = Of(n);
      if (U)
        U = ju(d, U);
      else
        return G ? K.some(n) : K.none();
      if (D(U))
        return qg(t, e, U.getNode(!d), d, !1);
      const ie = k(U);
      return ie && D(ie) && Wc(U, ie) ? qg(t, e, ie.getNode(!d), d, !1) : G ? E2(e, U.toRange(), !1) : K.none();
    }, iN = (e, t, n, r, a, c) => {
      const d = Nc(t, e.getBody(), n), h = ra(d.getClientRects()), k = t === av.Down, D = e.getBody();
      if (!h)
        return K.none();
      if (w3(e)) {
        const xe = k ? nt.fromRangeEnd(n) : nt.fromRangeStart(n);
        return (k ? sP : rP)(D, xe).orThunk(() => K.from(xe)).map((Ie) => Ie.toRange());
      }
      const U = (k ? oN : pf)(D, sN(1), d), G = ct(U, A3(1)), ie = h.left, ye = eN(G, ie);
      if (ye && c(ye.node)) {
        const xe = Math.abs(ie - ye.left), Ne = Math.abs(ie - ye.right);
        return qg(t, e, ye.node, xe < Ne, !1);
      }
      let ae;
      if (r(d) ? ae = d.getNode() : a(d) ? ae = d.getNode(!0) : ae = lf(n), ae) {
        const xe = uP(t, D, sN(1), ae);
        let Ne = eN(ct(xe, A3(1)), ie);
        if (Ne || (Ne = ra(ct(xe, A3(0))), Ne))
          return E2(e, Ne.position.toRange(), !1);
      }
      return G.length === 0 ? D3(e, k).filter(k ? a : r).map((xe) => v3(e, xe.toRange(), !1)) : K.none();
    }, D3 = (e, t) => {
      const n = e.selection.getRng(), r = t ? nt.fromRangeEnd(n) : nt.fromRangeStart(n), a = ot(r.container(), e.getBody());
      if (t) {
        const c = F1(a, r);
        return cn(c.positions);
      } else {
        const c = ew(a, r);
        return ro(c.positions);
      }
    }, lN = (e, t, n) => D3(e, t).filter(n).exists((r) => (e.selection.setRng(r.toRange()), !0)), T2 = (e, t) => {
      const n = e.dom.createRng();
      n.setStart(t.container(), t.offset()), n.setEnd(t.container(), t.offset()), e.selection.setRng(n);
    }, H1 = (e, t) => {
      e ? t.setAttribute("data-mce-selected", "inline-boundary") : t.removeAttribute("data-mce-selected");
    }, R3 = (e, t, n) => C3(t, n).map((r) => (T2(e, r), n)), z2 = (e, t, n) => {
      const r = nt.fromRangeStart(e);
      if (e.collapsed)
        return r;
      {
        const a = nt.fromRangeEnd(e);
        return n ? cf(t, a).getOr(a) : kd(t, r).getOr(r);
      }
    }, N3 = (e, t, n) => {
      const r = e.getBody(), a = z2(e.selection.getRng(), r, n), c = Tt(_1, e);
      return QL(n, c, r, a).bind((h) => R3(e, t, h));
    }, cN = (e, t, n) => {
      const r = oo(Ni(be.fromDom(t.getRoot()), '*[data-mce-selected="inline-boundary"]'), (d) => d.dom), a = ct(r, e), c = ct(n, e);
      ut(Zr(a, c), Tt(H1, !1)), ut(Zr(c, a), Tt(H1, !0));
    }, uN = (e, t) => {
      const n = t.get();
      if (e.selection.isCollapsed() && !e.composing && n) {
        const r = nt.fromRangeStart(e.selection.getRng());
        nt.isTextPosition(r) && !KM(r) && (T2(e, xC(n, r)), t.set(null));
      }
    }, dP = (e, t, n, r) => {
      if (t.selection.isCollapsed()) {
        const a = ct(r, e);
        ut(a, (c) => {
          const d = nt.fromRangeStart(t.selection.getRng());
          Gg(e, t.getBody(), d).bind((h) => R3(t, n, h));
        });
      }
    }, M3 = (e, t, n) => mr(e) ? N3(e, t, n).isSome() : !1, dN = (e, t, n) => mr(t) ? WR(e, t) : !1, fN = (e) => {
      const t = Ja(null), n = Tt(_1, e);
      return e.on("NodeChange", (r) => {
        mr(e) && (cN(n, e.dom, r.parents), uN(e, t), dP(n, e, t, r.parents));
      }), t;
    }, mN = Tt(dN, !0), pN = Tt(dN, !1), tw = (e, t, n) => {
      if (mr(e)) {
        const r = D3(e, t).getOrThunk(() => {
          const a = e.selection.getRng();
          return t ? nt.fromRangeEnd(a) : nt.fromRangeStart(a);
        });
        return Gg(Tt(_1, e), e.getBody(), r).exists((a) => {
          const c = w2(a);
          return C3(n, c).exists((d) => (T2(e, d), !0));
        });
      } else
        return !1;
    }, gN = (e, t) => {
      const n = document.createRange();
      return n.setStart(e.container(), e.offset()), n.setEnd(t.container(), t.offset()), n;
    }, hN = (e) => ns(lu(e), dp(e), (t, n) => {
      const r = ju(!0, t), a = ju(!1, n);
      return kd(e, r).forall((c) => c.isEqual(a));
    }).getOr(!0), O2 = (e, t) => (n) => C3(t, n).map((r) => () => T2(e, r)), B3 = (e, t, n, r) => {
      const a = e.getBody(), c = Tt(_1, e);
      e.undoManager.ignore(() => {
        e.selection.setRng(gN(n, r)), C1(e), Gg(c, a, nt.fromRangeStart(e.selection.getRng())).map(k2).bind(O2(e, t)).each(oa);
      }), e.nodeChanged();
    }, bN = (e, t) => {
      const n = Yt(t, e);
      return n || e;
    }, yN = (e, t, n, r) => {
      const a = bN(e.getBody(), r.container()), c = Tt(_1, e), d = Gg(c, a, r);
      return d.bind((k) => n ? k.fold(dt(K.some(k2(k))), K.none, dt(K.some(w2(k))), K.none) : k.fold(K.none, dt(K.some(w2(k))), K.none, dt(K.some(k2(k))))).map(O2(e, t)).getOrThunk(() => {
        const k = d1(n, a, r), D = k.bind((H) => Gg(c, a, H));
        return ns(d, D, () => iy(c, a, r).bind((H) => hN(H) ? K.some(() => {
          Uu(e, n, be.fromDom(H));
        }) : K.none())).getOrThunk(() => D.bind(() => k.map((H) => () => {
          n ? B3(e, t, r, H) : B3(e, t, H, r);
        })));
      });
    }, A2 = (e, t, n) => {
      if (e.selection.isCollapsed() && mr(e)) {
        const r = nt.fromRangeStart(e.selection.getRng());
        return yN(e, t, n, r);
      }
      return K.none();
    }, vN = (e) => $c(e) > 1, L3 = (e, t) => {
      const n = be.fromDom(e.getBody()), r = be.fromDom(e.selection.getStart()), a = Zp(r, n);
      return Ra(a, t).fold(dt(a), (c) => a.slice(0, c));
    }, xN = (e) => $c(e) === 1, P3 = (e) => L3(e, (t) => e.schema.isBlock(Eo(t)) || vN(t)), I3 = (e) => L3(e, (t) => e.schema.isBlock(Eo(t))), nw = (e, t) => {
      const n = Tt(x_, e);
      return ho(t, (r) => n(r) ? [r.dom] : []);
    }, F3 = (e) => {
      const t = I3(e);
      return nw(e, t);
    }, wN = (e, t, n, r) => {
      const a = nw(t, r);
      if (a.length === 0)
        Uu(t, e, n);
      else {
        const c = v_(n.dom, a);
        t.selection.setRng(c.toRange());
      }
    }, kN = (e, t) => {
      const n = ct(P3(e), xN);
      return cn(n).bind((r) => {
        const a = nt.fromRangeStart(e.selection.getRng());
        return gE(t, a, r.dom) && !_d(r) ? K.some(() => wN(t, e, r, n)) : K.none();
      });
    }, $3 = (e, t) => {
      const n = t.parentElement;
      return cs(t) && !We(n) && e.dom.isEmpty(n);
    }, _N = (e) => _d(be.fromDom(e)), H3 = (e, t) => {
      const n = e.selection.getStart(), r = $3(e, n) || _N(n) ? v_(n, t) : YO(e.selection.getRng(), t);
      e.selection.setRng(r.toRange());
    }, CN = (e, t) => {
      const n = Zr(t, F3(e));
      n.length > 0 && H3(e, n);
    }, SN = (e) => At(e.startContainer), EN = (e) => e.startOffset === 0 && SN(e), TN = (e, t) => {
      const n = t.startContainer.parentElement;
      return !We(n) && x_(e, be.fromDom(n));
    }, zN = (e) => {
      const t = e.startContainer.parentNode, n = e.endContainer.parentNode;
      return !We(t) && !We(n) && t.isEqualNode(n);
    }, ON = (e) => {
      const t = e.endContainer;
      return e.endOffset === (At(t) ? t.length : t.childNodes.length);
    }, AN = (e) => zN(e) && ON(e), V3 = (e) => !e.endContainer.isEqualNode(e.commonAncestorContainer), fP = (e) => AN(e) || V3(e), DN = (e) => {
      const t = e.selection.getRng();
      return EN(t) && TN(e, t) && fP(t);
    }, mP = (e) => {
      if (DN(e)) {
        const t = F3(e);
        return K.some(() => {
          C1(e), CN(e, t);
        });
      } else
        return K.none();
    }, D2 = (e, t) => e.selection.isCollapsed() ? kN(e, t) : mP(e), RN = (e, t) => YM(e, (n) => uf(n.dom), (n) => t.isBlock(Eo(n))), pP = (e) => RN(be.fromDom(e.selection.getStart()), e.schema), gP = (e) => {
      const t = e.selection.getRng();
      return t.collapsed && (SN(t) || e.dom.isEmpty(t.startContainer)) && !pP(e);
    }, o = (e) => (gP(e) && H3(e, []), !0), s = (e, t, n) => Xe(n) ? K.some(() => {
      e._selectionOverrides.hideFakeCaret(), Uu(e, t, be.fromDom(n));
    }) : K.none(), i = (e, t) => {
      const n = t ? I0 : F0, r = t ? _a.Forwards : _a.Backwards, a = Nc(r, e.getBody(), e.selection.getRng());
      return n(a) ? s(e, t, a.getNode(!t)) : K.from(ju(t, a)).filter((c) => n(c) && Wc(a, c)).bind((c) => s(e, t, c.getNode(!t)));
    }, l = (e, t) => {
      const n = e.selection.getNode();
      return pn(n) ? s(e, t, n) : K.none();
    }, f = (e, t) => e.selection.isCollapsed() ? i(e, t) : l(e, t), m = (e) => st(e, (t) => cc(t.dom) || Kr(t.dom)).exists((t) => cc(t.dom)), b = (e) => Us(e ?? "").getOr(0), x = (e, t) => {
      const n = e || Hm(t) ? "margin" : "padding", r = Ya(t, "direction") === "rtl" ? "-right" : "-left";
      return n + r;
    }, w = (e, t, n, r, a, c) => {
      const d = x(n, be.fromDom(c)), h = b(e.getStyle(c, d));
      if (t === "outdent") {
        const k = Math.max(0, h - r);
        e.setStyle(c, d, k ? k + a : "");
      } else {
        const k = h + r + a;
        e.setStyle(c, d, k);
      }
    }, E = (e, t) => Ns(t, (n) => {
      const r = x(o0(e), n), a = He(n, r).map(b).getOr(0);
      return e.dom.getContentEditable(n.dom) !== "false" && a > 0;
    }), O = (e) => {
      const t = $(e);
      return !e.mode.isReadOnly() && (t.length > 1 || E(e, t));
    }, A = (e) => Eu(e) || Jd(e), B = (e) => Br(e).exists(A), $ = (e) => ct(lc(e.selection.getSelectedBlocks()), (t) => !A(t) && !B(t) && m(t)), Z = (e, t) => {
      var n, r;
      const { dom: a } = e, c = Yl(e), d = (r = (n = /[a-z%]+$/i.exec(c)) === null || n === void 0 ? void 0 : n[0]) !== null && r !== void 0 ? r : "px", h = b(c), k = o0(e);
      ut($(e), (D) => {
        w(a, t, k, h, d, D.dom);
      });
    }, oe = (e) => Z(e, "indent"), re = (e) => Z(e, "outdent"), fe = (e) => {
      if (e.selection.isCollapsed() && O(e)) {
        const t = e.dom, n = e.selection.getRng(), r = nt.fromRangeStart(n), a = t.getParent(n.startContainer, t.isBlock);
        if (a !== null && Zk(be.fromDom(a), r, e.schema))
          return K.some(() => re(e));
      }
      return K.none();
    }, ee = (e, t, n) => Ys([
      fe,
      k3,
      Qx,
      (r, a) => A2(r, t, a),
      b2,
      vx,
      _3,
      f,
      b3,
      D2
    ], (r) => r(e, n)).filter((r) => e.selection.isEditable()), J = (e, t) => {
      ee(e, t, !1).fold(() => {
        e.selection.isEditable() && (C1(e), mx(e));
      }, oa);
    }, le = (e, t) => {
      ee(e, t, !0).fold(() => {
        e.selection.isEditable() && ly(e);
      }, oa);
    }, me = (e, t) => {
      e.addCommand("delete", () => {
        J(e, t);
      }), e.addCommand("forwardDelete", () => {
        le(e, t);
      });
    }, ke = 5, Re = 400, qe = (e) => e.touches === void 0 || e.touches.length !== 1 ? K.none() : K.some(e.touches[0]), mt = (e, t) => {
      const n = Math.abs(e.clientX - t.x), r = Math.abs(e.clientY - t.y);
      return n > ke || r > ke;
    }, bt = (e) => {
      const t = sf(), n = Ja(!1), r = Ru((a) => {
        e.dispatch("longpress", {
          ...a,
          type: "longpress"
        }), n.set(!0);
      }, Re);
      e.on("touchstart", (a) => {
        qe(a).each((c) => {
          r.cancel();
          const d = {
            x: c.clientX,
            y: c.clientY,
            target: a.target
          };
          r.throttle(a), n.set(!1), t.set(d);
        });
      }, !0), e.on("touchmove", (a) => {
        r.cancel(), qe(a).each((c) => {
          t.on((d) => {
            mt(c, d) && (t.clear(), n.set(!1), e.dispatch("longpresscancel"));
          });
        });
      }, !0), e.on("touchend touchcancel", (a) => {
        r.cancel(), a.type !== "touchcancel" && t.get().filter((c) => c.target.isEqualNode(a.target)).each(() => {
          n.get() ? a.preventDefault() : e.dispatch("tap", {
            ...a,
            type: "tap"
          });
        });
      }, !0);
    }, St = (e, t) => Yn(e, t.nodeName), Qt = (e, t) => At(t) ? !0 : wn(t) ? !St(e.getBlockElements(), t) && !Vf(t) && !ef(e, t) && !pg(t) : !1, vn = (e, t, n) => cr(JS(be.fromDom(n), be.fromDom(t)), (r) => St(e, r.dom)), Mn = (e, t) => {
      if (At(t)) {
        if (t.data.length === 0)
          return !0;
        if (/^\s+$/.test(t.data))
          return !t.nextSibling || St(e, t.nextSibling) || pg(t.nextSibling);
      }
      return !1;
    }, Qn = (e) => e.dom.create(li(e), Mg(e)), fo = (e) => {
      const t = e.dom, n = e.selection, r = e.schema, a = r.getBlockElements(), c = n.getStart(), d = e.getBody();
      let h, k, D = !1;
      const H = li(e);
      if (!c || !wn(c))
        return;
      const U = d.nodeName.toLowerCase();
      if (!r.isValidChild(U, H.toLowerCase()) || vn(a, d, c))
        return;
      const G = n.getRng(), { startContainer: ie, startOffset: ye, endContainer: ae, endOffset: xe } = G, Ne = ty(e);
      let Ie = d.firstChild;
      for (; Ie; )
        if (wn(Ie) && Wm(r, Ie), Qt(r, Ie)) {
          if (Mn(a, Ie)) {
            k = Ie, Ie = Ie.nextSibling, t.remove(k);
            continue;
          }
          h || (h = Qn(e), d.insertBefore(h, Ie), D = !0), k = Ie, Ie = Ie.nextSibling, h.appendChild(k);
        } else
          h = null, Ie = Ie.nextSibling;
      D && Ne && (G.setStart(ie, ye), G.setEnd(ae, xe), n.setRng(G), e.nodeChanged());
    }, $o = (e, t, n) => {
      const r = be.fromDom(Qn(e)), a = Vm();
      Ir(r, a), n(t, r);
      const c = document.createRange();
      return c.setStartBefore(a.dom), c.setEndBefore(a.dom), c;
    }, Hs = (e) => {
      e.on("NodeChange", Tt(fo, e));
    }, ga = (e) => (t) => (" " + t.attr("class") + " ").indexOf(e) !== -1, Xo = (e, t, n) => function(r) {
      const a = arguments, c = a[a.length - 2], d = c > 0 ? t.charAt(c - 1) : "";
      if (d === '"')
        return r;
      if (d === ">") {
        const h = t.lastIndexOf("<", c);
        if (h !== -1 && t.substring(h, c).indexOf('contenteditable="false"') !== -1)
          return r;
      }
      return '<span class="' + n + '" data-mce-content="' + e.dom.encode(a[0]) + '">' + e.dom.encode(typeof a[1] == "string" ? a[1] : a[0]) + "</span>";
    }, Fl = (e, t, n) => {
      let r = t.length, a = n.content;
      if (n.format !== "raw") {
        for (; r--; )
          a = a.replace(t[r], Xo(e, a, l1(e)));
        n.content = a;
      }
    }, go = (e, t) => Ns(e, (n) => {
      const r = t.match(n);
      return r !== null && r[0].length === t.length;
    }), ui = (e) => {
      const t = "contenteditable", n = " " + Ht.trim(Zw(e)) + " ", r = " " + Ht.trim(l1(e)) + " ", a = ga(n), c = ga(r), d = Ww(e);
      d.length > 0 && e.on("BeforeSetContent", (h) => {
        Fl(e, d, h);
      }), e.parser.addAttributeFilter("class", (h) => {
        let k = h.length;
        for (; k--; ) {
          const D = h[k];
          a(D) ? D.attr(t, "true") : c(D) && D.attr(t, "false");
        }
      }), e.serializer.addAttributeFilter(t, (h) => {
        let k = h.length;
        for (; k--; ) {
          const D = h[k];
          if (!a(D) && !c(D))
            continue;
          const H = D.attr("data-mce-content");
          d.length > 0 && H ? go(d, H) ? (D.name = "#text", D.type = 3, D.raw = !0, D.value = H) : D.remove() : D.attr(t, null);
        }
      });
    }, qs = (e) => Ia(be.fromDom(e.getBody()), "*[data-mce-caret]").map((t) => t.dom).getOrNull(), qu = (e, t) => {
      t.hasAttribute("data-mce-caret") && (Um(t), e.selection.setRng(e.selection.getRng()), e.selection.scrollIntoView(t));
    }, Er = (e, t) => {
      const n = qs(e);
      if (n) {
        if (t.type === "compositionstart") {
          t.preventDefault(), t.stopPropagation(), qu(e, n);
          return;
        }
        uo(n) && (qu(e, n), e.undoManager.add());
      }
    }, Ui = (e) => {
      e.on("keyup compositionstart", Tt(Er, e));
    }, Gu = Kr, iv = (e, t, n) => aN(t, e, n, $h, Hh, Gu), V1 = (e, t, n) => iN(t, e, n, (c) => $h(c) || qz(c), (c) => Hh(c) || Gz(c), Gu), R2 = (e) => {
      const t = e.dom.create(li(e));
      return t.innerHTML = '<br data-mce-bogus="1">', t;
    }, ow = (e, t, n) => {
      const r = Bg(e.getBody()), a = Tt(al, t === 1 ? r.next : r.prev);
      if (n.collapsed) {
        const c = e.dom.getParent(n.startContainer, "PRE");
        if (!c)
          return;
        if (!a(nt.fromRangeStart(n))) {
          const h = be.fromDom(R2(e));
          t === 1 ? rs(be.fromDom(c), h) : Fs(be.fromDom(c), h), e.selection.select(h.dom, !0), e.selection.collapse();
        }
      }
    }, _y = (e, t) => {
      const n = t ? _a.Forwards : _a.Backwards, r = e.selection.getRng();
      return iv(n, e, r).orThunk(() => (ow(e, n, r), K.none()));
    }, Cy = (e, t) => {
      const n = t ? 1 : -1, r = e.selection.getRng();
      return V1(n, e, r).orThunk(() => (ow(e, n, r), K.none()));
    }, Kg = (e, t) => {
      const n = t ? e.getEnd(!0) : e.getStart(!0);
      return Fr(n) ? !t : t;
    }, U1 = (e, t) => _y(e, Kg(e.selection, t)).exists((n) => (Wh(e, n), !0)), j1 = (e, t) => Cy(e, t).exists((n) => (Wh(e, n), !0)), Yg = (e, t) => lN(e, t, t ? Hh : $h), qh = (e, t) => x3(e, !t).map((n) => {
      const r = n.toRange(), a = e.selection.getRng();
      return t ? r.setStart(a.startContainer, a.startOffset) : r.setEnd(a.endContainer, a.endOffset), r;
    }).exists((n) => (Wh(e, n), !0)), lv = (e) => So(["figcaption"], Eo(e)), rw = (e, t, n) => {
      const r = Tt(Le, t);
      return st(be.fromDom(e.container()), (a) => n.isBlock(Eo(a)), r).filter(lv);
    }, sw = (e, t, n) => t ? XR(e.dom, n) : z3(e.dom, n), cv = (e, t) => {
      const n = be.fromDom(e.getBody()), r = nt.fromRangeStart(e.selection.getRng());
      return rw(r, n, e.schema).exists(() => {
        if (sw(n, t, r)) {
          const c = $o(e, n, t ? Ir : fs);
          return e.selection.setRng(c), !0;
        } else
          return !1;
      });
    }, is = (e, t) => e.selection.isCollapsed() ? cv(e, t) : !1, vp = (e, t, n) => {
      const r = e.selection.getRng(), a = nt.fromRangeStart(r);
      return e.getBody().firstChild === t && z3(n, a) ? (e.execCommand("InsertNewBlockBefore"), !0) : !1;
    }, gf = (e, t) => {
      const n = e.selection.getRng(), r = nt.fromRangeStart(n);
      return e.getBody().lastChild === t && XR(t, r) ? (e.execCommand("InsertNewBlockAfter"), !0) : !1;
    }, NN = (e, t) => t ? K.from(e.dom.getParent(e.selection.getNode(), "details")).map((n) => gf(e, n)).getOr(!1) : K.from(e.dom.getParent(e.selection.getNode(), "summary")).bind((n) => K.from(e.dom.getParent(n, "details")).map((r) => vp(e, r, n))).getOr(!1), U3 = (e, t) => NN(e, t), j3 = {
      shiftKey: !1,
      altKey: !1,
      ctrlKey: !1,
      metaKey: !1,
      keyCode: 0
    }, Z3 = (e) => oo(e, (t) => ({
      ...j3,
      ...t
    })), MN = (e) => oo(e, (t) => ({
      ...j3,
      ...t
    })), aw = (e, t) => t.keyCode === e.keyCode && t.shiftKey === e.shiftKey && t.altKey === e.altKey && t.ctrlKey === e.ctrlKey && t.metaKey === e.metaKey, N2 = (e, t) => ho(Z3(e), (n) => aw(n, t) ? [n] : []), Gh = (e, t) => ho(MN(e), (n) => aw(n, t) ? [n] : []), to = (e, ...t) => () => e.apply(null, t), Z1 = (e, t) => po(N2(e, t), (n) => n.action()), M2 = (e, t) => Ys(Gh(e, t), (n) => n.action()), BN = (e, t) => {
      const n = t ? _a.Forwards : _a.Backwards, r = e.selection.getRng();
      return aN(e, n, r, I0, F0, pn).exists((a) => (Wh(e, a), !0));
    }, uv = (e, t) => {
      const n = t ? 1 : -1, r = e.selection.getRng();
      return iN(e, n, r, I0, F0, pn).exists((a) => (Wh(e, a), !0));
    }, LN = (e, t) => lN(e, t, t ? F0 : I0), Kc = $e.generate([
      { none: ["current"] },
      { first: ["current"] },
      {
        middle: [
          "current",
          "target"
        ]
      },
      { last: ["current"] }
    ]), lw = {
      ...Kc,
      none: (e) => Kc.none(e)
    }, PN = (e, t) => B2(e, t, Mo), B2 = (e, t, n) => ho(Pr(e), (r) => Ai(r, t) ? n(r) ? [r] : [] : B2(r, t, n)), IN = (e, t, n = Pn) => {
      if (n(t))
        return K.none();
      if (So(e, Eo(t)))
        return K.some(t);
      const r = (a) => Ai(a, "table") || n(a);
      return Pa(t, e.join(","), r);
    }, FN = (e, t) => IN([
      "td",
      "th"
    ], e, t), hP = (e) => PN(e, "th,td"), W3 = (e, t) => el(e, "table", t), L2 = (e, t, n, r, a = Mo) => {
      const c = r === 1;
      if (!c && n <= 0)
        return lw.first(e[0]);
      if (c && n >= e.length - 1)
        return lw.last(e[e.length - 1]);
      {
        const d = n + r, h = e[d];
        return a(h) ? lw.middle(t, h) : L2(e, t, d, r, a);
      }
    }, Qp = (e, t) => W3(e, t).bind((n) => {
      const r = hP(n);
      return Ra(r, (c) => Le(e, c)).map((c) => ({
        index: c,
        all: r
      }));
    }), cw = (e, t, n) => Qp(e, n).fold(() => lw.none(e), (a) => L2(a.all, e, a.index, 1, t)), $N = (e, t, n) => Qp(e, n).fold(() => lw.none(), (a) => L2(a.all, e, a.index, -1, t)), HN = (e, t) => ({
      left: e.left - t,
      top: e.top - t,
      right: e.right + t * 2,
      bottom: e.bottom + t * 2,
      width: e.width + t,
      height: e.height + t
    }), VN = (e, t) => ho(t, (n) => {
      const r = HN(af(n.getBoundingClientRect()), -1);
      return [
        {
          x: r.left,
          y: e(r),
          cell: n
        },
        {
          x: r.right,
          y: e(r),
          cell: n
        }
      ];
    }), UN = (e, t, n) => co(e, (r, a) => r.fold(() => K.some(a), (c) => {
      const d = Math.sqrt(Math.abs(c.x - t) + Math.abs(c.y - n)), h = Math.sqrt(Math.abs(a.x - t) + Math.abs(a.y - n));
      return K.some(h < d ? a : c);
    }), K.none()), Xg = (e, t, n, r, a) => {
      const c = Ni(be.fromDom(n), "td,th,caption").map((h) => h.dom), d = ct(VN(e, c), (h) => t(h, a));
      return UN(d, r, a).map((h) => h.cell);
    }, jN = (e) => e.bottom, ZN = (e) => e.top, WN = (e, t) => e.y < t, qN = (e, t) => e.y > t, bP = Tt(Xg, jN, WN), Ue = Tt(Xg, ZN, qN), Ho = (e, t) => ro(t.getClientRects()).bind((n) => bP(e, n.left, n.top)).bind((n) => C2(oP(n), t)), mo = (e, t) => cn(t.getClientRects()).bind((n) => Ue(e, n.left, n.top)).bind((n) => C2(nP(n), t)), Gs = (e, t, n) => n.breakAt.exists((r) => e(t, r).breakAt.isSome()), Da = (e) => e.breakType === Jp.Wrap && e.positions.length === 0, Cs = (e) => e.breakType === Jp.Br && e.positions.length === 1, Bc = (e, t, n) => {
      const r = e(t, n);
      return Da(r) || !cs(n.getNode()) && Cs(r) ? !Gs(e, t, r) : r.breakAt.isNone();
    }, Kh = Tt(Bc, ew), Jg = Tt(Bc, F1), Ku = (e, t, n) => {
      const r = nt.fromRangeStart(t);
      return f1(!e, n).exists((a) => a.isEqual(r));
    }, yP = (e, t, n, r) => {
      const a = e.selection.getRng(), c = t ? 1 : -1;
      return Bv() && Ku(t, a, n) ? (qg(c, e, n, !t, !1).each((d) => {
        Wh(e, d);
      }), !0) : !1;
    }, GN = (e, t, n) => Ho(t, n).orThunk(() => ro(n.getClientRects()).bind((r) => T3(S2(e, nt.before(t)), r.left))).getOr(nt.before(t)), KN = (e, t, n) => mo(t, n).orThunk(() => ro(n.getClientRects()).bind((r) => T3(YR(e, nt.after(t)), r.left))).getOr(nt.after(t)), B8 = (e, t) => {
      const n = t.getNode(e);
      return Cu(n) ? K.some(n) : K.none();
    }, y$ = (e, t, n) => {
      t.undoManager.transact(() => {
        const r = e ? rs : Fs, a = $o(t, be.fromDom(n), r);
        Wh(t, a);
      });
    }, L8 = (e, t, n) => {
      const r = B8(!!t, n), a = t === !1;
      r.fold(() => Wh(e, n.toRange()), (c) => f1(a, e.getBody()).filter((d) => d.isEqual(n)).fold(() => Wh(e, n.toRange()), (d) => y$(t, e, c)));
    }, v$ = (e, t, n, r) => {
      const a = e.selection.getRng(), c = nt.fromRangeStart(a), d = e.getBody();
      if (!t && Kh(r, c)) {
        const h = GN(d, n, c);
        return L8(e, t, h), !0;
      } else if (t && Jg(r, c)) {
        const h = KN(d, n, c);
        return L8(e, t, h), !0;
      } else
        return !1;
    }, P8 = (e, t, n) => K.from(e.dom.getParent(e.selection.getNode(), "td,th")).bind((r) => K.from(e.dom.getParent(r, "table")).map((a) => n(e, t, a, r))).getOr(!1), I8 = (e, t) => P8(e, t, yP), vP = (e, t) => P8(e, t, v$), x$ = (e) => {
      const t = pp.exact(e, 0, e, 0);
      return lM(t);
    }, F8 = (e, t, n) => n.fold(K.none, K.none, (r, a) => Rz(a).map((c) => x$(c)), (r) => (e.execCommand("mceTableInsertRowAfter"), $8(e, t, r))), $8 = (e, t, n) => F8(e, t, cw(n, Ka)), w$ = (e, t, n) => F8(e, t, $N(n, Ka)), H8 = (e, t) => {
      const n = [
        "table",
        "li",
        "dl"
      ], r = be.fromDom(e.getBody()), a = (h) => {
        const k = Eo(h);
        return Le(h, r) || So(n, k);
      }, c = e.selection.getRng(), d = be.fromDom(t ? c.endContainer : c.startContainer);
      return FN(d, a).map((h) => (W3(h, a).each((H) => {
        e.model.table.clearSelectedCells(H.dom);
      }), e.selection.collapse(!t), (t ? $8 : w$)(e, a, h).each((H) => {
        e.selection.setRng(H);
      }), !0)).getOr(!1);
    }, k$ = (e, t, n) => {
      const r = nr.os.isMacOS() || nr.os.isiOS();
      Z1([
        {
          keyCode: yn.RIGHT,
          action: to(U1, e, !0)
        },
        {
          keyCode: yn.LEFT,
          action: to(U1, e, !1)
        },
        {
          keyCode: yn.UP,
          action: to(j1, e, !1)
        },
        {
          keyCode: yn.DOWN,
          action: to(j1, e, !0)
        },
        ...r ? [
          {
            keyCode: yn.UP,
            action: to(qh, e, !1),
            metaKey: !0,
            shiftKey: !0
          },
          {
            keyCode: yn.DOWN,
            action: to(qh, e, !0),
            metaKey: !0,
            shiftKey: !0
          }
        ] : [],
        {
          keyCode: yn.RIGHT,
          action: to(I8, e, !0)
        },
        {
          keyCode: yn.LEFT,
          action: to(I8, e, !1)
        },
        {
          keyCode: yn.UP,
          action: to(vP, e, !1)
        },
        {
          keyCode: yn.DOWN,
          action: to(vP, e, !0)
        },
        {
          keyCode: yn.UP,
          action: to(vP, e, !1)
        },
        {
          keyCode: yn.UP,
          action: to(U3, e, !1)
        },
        {
          keyCode: yn.DOWN,
          action: to(U3, e, !0)
        },
        {
          keyCode: yn.RIGHT,
          action: to(BN, e, !0)
        },
        {
          keyCode: yn.LEFT,
          action: to(BN, e, !1)
        },
        {
          keyCode: yn.UP,
          action: to(uv, e, !1)
        },
        {
          keyCode: yn.DOWN,
          action: to(uv, e, !0)
        },
        {
          keyCode: yn.RIGHT,
          action: to(M3, e, t, !0)
        },
        {
          keyCode: yn.LEFT,
          action: to(M3, e, t, !1)
        },
        {
          keyCode: yn.RIGHT,
          ctrlKey: !r,
          altKey: r,
          action: to(mN, e, t)
        },
        {
          keyCode: yn.LEFT,
          ctrlKey: !r,
          altKey: r,
          action: to(pN, e, t)
        },
        {
          keyCode: yn.UP,
          action: to(is, e, !1)
        },
        {
          keyCode: yn.DOWN,
          action: to(is, e, !0)
        }
      ], n).each((a) => {
        n.preventDefault();
      });
    }, _$ = (e, t) => {
      e.on("keydown", (n) => {
        n.isDefaultPrevented() || k$(e, t, n);
      });
    }, Yh = (e, t) => ({
      container: e,
      offset: t
    }), YN = gs.DOM, XN = (e) => (t) => e === t ? -1 : 0, C$ = (e) => (t) => e.isBlock(t) || So([
      "BR",
      "IMG",
      "HR",
      "INPUT"
    ], t.nodeName) || e.getContentEditable(t) === "false", xP = (e, t, n) => {
      if (At(e) && t >= 0)
        return K.some(Yh(e, t));
      {
        const r = tp(YN);
        return K.from(r.backwards(e, t, XN(e), n)).map((a) => Yh(a.container, a.container.data.length));
      }
    }, S$ = (e, t, n) => {
      if (At(e) && t >= e.length)
        return K.some(Yh(e, t));
      {
        const r = tp(YN);
        return K.from(r.forwards(e, t, XN(e), n)).map((a) => Yh(a.container, 0));
      }
    }, wP = (e, t, n) => {
      if (!At(e))
        return K.none();
      const r = e.data;
      if (t >= 0 && t <= r.length)
        return K.some(Yh(e, t));
      {
        const a = tp(YN);
        return K.from(a.backwards(e, t, XN(e), n)).bind((c) => {
          const d = c.container.data;
          return wP(c.container, t + d.length, n);
        });
      }
    }, V8 = (e, t, n) => {
      if (!At(e))
        return K.none();
      const r = e.data;
      if (t <= r.length)
        return K.some(Yh(e, t));
      {
        const a = tp(YN);
        return K.from(a.forwards(e, t, XN(e), n)).bind((c) => V8(c.container, t - r.length, n));
      }
    }, kP = (e, t, n, r, a) => {
      const c = tp(e, C$(e));
      return K.from(c.backwards(t, n, r, a));
    }, E$ = (e) => e.collapsed && At(e.startContainer), U8 = (e) => q(e.toString().replace(/\u00A0/g, " ")), j8 = (e) => e !== "" && `  \f
\r	\v`.indexOf(e) !== -1, _P = (e, t) => e.substring(t.length), T$ = (e, t, n) => {
      let r;
      const a = n.charAt(0);
      for (r = t - 1; r >= 0; r--) {
        const c = e.charAt(r);
        if (j8(c))
          return K.none();
        if (a === c && _r(e, n, r, t))
          break;
      }
      return K.some(r);
    }, z$ = (e, t, n, r = 0) => {
      if (!E$(t))
        return K.none();
      const a = {
        text: "",
        offset: 0
      }, c = (h, k, D) => (a.text = D + a.text, a.offset += k, T$(a.text, a.offset, n).getOr(k)), d = e.getParent(t.startContainer, e.isBlock) || e.getRoot();
      return kP(e, t.startContainer, t.startOffset, c, d).bind((h) => {
        const k = t.cloneRange();
        if (k.setStart(h.container, h.offset), k.setEnd(t.endContainer, t.endOffset), k.collapsed)
          return K.none();
        const D = U8(k);
        return D.lastIndexOf(n) !== 0 || _P(D, n).length < r ? K.none() : K.some({
          text: _P(D, n),
          range: k,
          trigger: n
        });
      });
    }, Z8 = (e, t, n, r = 0) => Bz(be.fromDom(t.startContainer)).fold(() => z$(e, t, n, r), (a) => {
      const c = e.createRng();
      c.selectNode(a.dom);
      const d = U8(c);
      return K.some({
        range: c,
        text: _P(d, n),
        trigger: n
      });
    }), O$ = (e) => e.nodeType === Ic, A$ = (e) => e.nodeType === _c, W8 = (e) => {
      if (O$(e))
        return Yh(e, e.data.length);
      {
        const t = e.childNodes;
        return t.length > 0 ? W8(t[t.length - 1]) : Yh(e, t.length);
      }
    }, q8 = (e, t) => {
      const n = e.childNodes;
      return n.length > 0 && t < n.length ? q8(n[t], 0) : n.length > 0 && A$(e) && n.length === t ? W8(n[n.length - 1]) : Yh(e, t);
    }, D$ = (e, t) => {
      var n;
      const r = (n = e.getParent(t.container, e.isBlock)) !== null && n !== void 0 ? n : e.getRoot();
      return kP(e, t.container, t.offset, (a, c) => c === 0 ? -1 : c, r).filter((a) => {
        const c = a.container.data.charAt(a.offset - 1);
        return !j8(c);
      }).isSome();
    }, R$ = (e) => (t) => {
      const n = q8(t.startContainer, t.startOffset);
      return !D$(e, n);
    }, N$ = (e, t, n) => Ys(n.triggers, (r) => Z8(e, t, r)), M$ = (e, t) => {
      const n = t(), r = e.selection.getRng();
      return N$(e.dom, r, n).bind((a) => G8(e, t, a));
    }, G8 = (e, t, n, r = {}) => {
      var a;
      const c = t(), h = (a = e.selection.getRng().startContainer.nodeValue) !== null && a !== void 0 ? a : "", k = ct(c.lookupByTrigger(n.trigger), (H) => n.text.length >= H.minChars && H.matches.getOrThunk(() => R$(e.dom))(n.range, h, n.text));
      if (k.length === 0)
        return K.none();
      const D = Promise.all(oo(k, (H) => H.fetch(n.text, H.maxResults, r).then((G) => ({
        matchText: n.text,
        items: G,
        columns: H.columns,
        onAction: H.onAction,
        highlightOn: H.highlightOn
      }))));
      return K.some({
        lookupData: D,
        context: n
      });
    };
    var Xh;
    (function(e) {
      e[e.Error = 0] = "Error", e[e.Value = 1] = "Value";
    })(Xh || (Xh = {}));
    const CP = (e, t, n) => e.stype === Xh.Error ? t(e.serror) : n(e.svalue), B$ = (e) => {
      const t = [], n = [];
      return ut(e, (r) => {
        CP(r, (a) => n.push(a), (a) => t.push(a));
      }), {
        values: t,
        errors: n
      };
    }, L$ = (e, t) => e.stype === Xh.Error ? {
      stype: Xh.Error,
      serror: t(e.serror)
    } : e, P$ = (e, t) => e.stype === Xh.Value ? {
      stype: Xh.Value,
      svalue: t(e.svalue)
    } : e, I$ = (e, t) => e.stype === Xh.Value ? t(e.svalue) : e, F$ = (e, t) => e.stype === Xh.Error ? t(e.serror) : e, K8 = (e) => ({
      stype: Xh.Value,
      svalue: e
    }), Y8 = (e) => ({
      stype: Xh.Error,
      serror: e
    }), mu = {
      fromResult: (e) => e.fold(Y8, K8),
      toResult: (e) => CP(e, Ae.error, Ae.value),
      svalue: K8,
      partition: B$,
      serror: Y8,
      bind: I$,
      bindError: F$,
      map: P$,
      mapError: L$,
      fold: CP
    }, SP = (e) => Ee(e) && Nt(e).length > 100 ? " removed due to size" : JSON.stringify(e, null, 2), $$ = (e) => {
      const t = e.length > 10 ? e.slice(0, 10).concat([{
        path: [],
        getErrorInfo: dt("... (only showing first ten failures)")
      }]) : e;
      return oo(t, (n) => "Failed path: (" + n.path.join(" > ") + `)
` + n.getErrorInfo());
    }, JN = (e, t) => mu.serror([{
      path: e,
      getErrorInfo: t
    }]), H$ = (e, t, n) => JN(e, () => 'Could not find valid *required* value for "' + t + '" in ' + SP(n)), V$ = (e, t) => JN(e, () => 'Choice schema did not contain choice key: "' + t + '"'), U$ = (e, t, n) => JN(e, () => 'The chosen schema: "' + n + '" did not exist in branches: ' + SP(t)), j$ = (e, t) => JN(e, dt(t)), Z$ = (e, t, n, r) => Hr(n, r).fold(() => U$(e, n, r), (c) => c.extract(e.concat(["branch: " + r]), t)), W$ = (e, t) => ({
      extract: (a, c) => Hr(c, e).fold(() => V$(a, e), (h) => Z$(a, c, t, h)),
      toString: () => "chooseOn(" + e + "). Possible values: " + Nt(t)
    }), q$ = (e, t) => t, G$ = (e, t) => wt(e) && wt(t) ? QN(e, t) : t, X8 = (e) => (...t) => {
      if (t.length === 0)
        throw new Error("Can't merge zero objects");
      const n = {};
      for (let r = 0; r < t.length; r++) {
        const a = t[r];
        for (const c in a)
          Yn(a, c) && (n[c] = e(n[c], a[c]));
      }
      return n;
    }, QN = X8(G$), K$ = X8(q$), J8 = () => ({
      tag: "required",
      process: {}
    }), Y$ = (e) => ({
      tag: "defaultedThunk",
      process: e
    }), Q8 = (e) => Y$(dt(e)), X$ = () => ({
      tag: "option",
      process: {}
    }), J$ = (e, t) => e.length > 0 ? mu.svalue(QN(t, K$.apply(void 0, e))) : mu.svalue(t), eI = (e) => mn(mu.serror, Mr)(e), Q$ = {
      consolidateObj: (e, t) => {
        const n = mu.partition(e);
        return n.errors.length > 0 ? eI(n.errors) : J$(n.values, t);
      },
      consolidateArr: (e) => {
        const t = mu.partition(e);
        return t.errors.length > 0 ? eI(t.errors) : mu.svalue(t.values);
      }
    }, eH = (e, t, n, r) => ({
      tag: "field",
      key: e,
      newKey: t,
      presence: n,
      prop: r
    }), tH = (e, t) => ({
      tag: "custom",
      newKey: e,
      instantiator: t
    }), tI = (e, t, n) => {
      switch (e.tag) {
        case "field":
          return t(e.key, e.newKey, e.presence, e.prop);
        case "custom":
          return n(e.newKey, e.instantiator);
      }
    }, EP = (e) => {
      const t = (r, a) => mu.bindError(e(a), (c) => j$(r, c)), n = dt("val");
      return {
        extract: t,
        toString: n
      };
    }, nH = EP(mu.svalue), oH = (e, t, n, r) => Hr(t, n).fold(() => H$(e, n, t), r), nI = (e, t, n, r) => {
      const a = Hr(e, t).getOrThunk(() => n(e));
      return r(a);
    }, rH = (e, t, n) => n(Hr(e, t)), sH = (e, t, n, r) => {
      const a = Hr(e, t).map((c) => c === !0 ? n(e) : c);
      return r(a);
    }, aH = (e, t, n, r, a) => {
      const c = (h) => a.extract(t.concat([r]), h), d = (h) => h.fold(() => mu.svalue(K.none()), (k) => {
        const D = a.extract(t.concat([r]), k);
        return mu.map(D, K.some);
      });
      switch (e.tag) {
        case "required":
          return oH(t, n, r, c);
        case "defaultedThunk":
          return nI(n, r, e.process, c);
        case "option":
          return rH(n, r, d);
        case "defaultedOptionThunk":
          return sH(n, r, e.process, d);
        case "mergeWithThunk":
          return nI(n, r, dt({}), (h) => {
            const k = QN(e.process(n), h);
            return c(k);
          });
      }
    }, iH = (e, t, n) => {
      const r = {}, a = [];
      for (const c of n)
        tI(c, (d, h, k, D) => {
          const H = aH(k, e, t, d, D);
          mu.fold(H, (U) => {
            a.push(...U);
          }, (U) => {
            r[h] = U;
          });
        }, (d, h) => {
          r[d] = h(t);
        });
      return a.length > 0 ? mu.serror(a) : mu.svalue(r);
    }, TP = (e) => ({
      extract: (r, a) => iH(r, a, e),
      toString: () => `obj{
` + oo(e, (a) => tI(a, (c, d, h, k) => c + " -> " + k.toString(), (c, d) => "state(" + c + ")")).join(`
`) + "}"
    }), oI = (e) => ({
      extract: (r, a) => {
        const c = oo(a, (d, h) => e.extract(r.concat(["[" + h + "]"]), d));
        return Q$.consolidateArr(c);
      },
      toString: () => "array(" + e.toString() + ")"
    }), lH = (e) => EP((t) => e(t).fold(mu.serror, mu.svalue)), cH = (e, t, n) => {
      const r = t.extract([e], n);
      return mu.mapError(r, (a) => ({
        input: n,
        errors: a
      }));
    }, uH = (e, t, n) => mu.toResult(cH(e, t, n)), dH = (e) => `Errors: 
` + $$(e.errors).join(`
`) + `

Input object: ` + SP(e.input), rI = (e, t) => W$(e, mi(t, TP)), fH = dt(nH), e5 = (e, t) => EP((n) => {
      const r = typeof n;
      return e(n) ? mu.svalue(n) : mu.serror(`Expected type: ${t} but got: ${r}`);
    }), mH = e5(M, "number"), t5 = e5(Ot, "string"), pH = e5(Cn, "boolean"), zP = e5(un, "function"), q3 = eH, sI = tH, gH = (e) => lH((t) => So(e, t) ? Ae.value(t) : Ae.error(`Unsupported value: "${t}", choose one of "${e.join(", ")}".`)), aI = (e, t) => q3(e, e, J8(), t), iI = (e) => aI(e, t5), lI = (e) => aI(e, zP), hH = (e, t) => q3(e, e, J8(), oI(t)), OP = (e, t) => q3(e, e, X$(), t), n5 = (e) => OP(e, t5), bH = (e) => OP(e, zP), yH = (e, t) => q3(e, e, Q8(t), fH()), P2 = (e, t, n) => q3(e, e, Q8(t), n), cI = (e, t) => P2(e, t, mH), vH = (e, t) => P2(e, t, t5), uI = (e, t, n) => P2(e, t, gH(n)), AP = (e, t) => P2(e, t, pH), DP = (e, t) => P2(e, t, zP), xH = (e, t, n) => P2(e, t, oI(n)), wH = iI("type"), kH = lI("fetch"), RP = lI("onAction"), _H = DP("onSetup", () => ht), CH = n5("text"), SH = n5("icon"), EH = n5("tooltip"), TH = n5("label"), zH = AP("active", !1), OH = AP("enabled", !0), dI = AP("primary", !1), AH = (e) => yH("columns", e), G3 = (e) => vH("type", e), DH = TP([
      wH,
      iI("trigger"),
      cI("minChars", 1),
      AH(1),
      cI("maxResults", 10),
      bH("matches"),
      kH,
      RP,
      xH("highlightOn", [], t5)
    ]), RH = (e) => uH("Autocompleter", DH, {
      trigger: e.ch,
      ...e
    }), NP = [
      OH,
      EH,
      SH,
      CH,
      _H
    ], fI = [zH].concat(NP), NH = [
      DP("predicate", Pn),
      uI("scope", "node", [
        "node",
        "editor"
      ]),
      uI("position", "selection", [
        "node",
        "selection",
        "line"
      ])
    ], MH = NP.concat([
      G3("contextformbutton"),
      dI,
      RP,
      sI("original", Bn)
    ]), BH = fI.concat([
      G3("contextformbutton"),
      dI,
      RP,
      sI("original", Bn)
    ]), LH = NP.concat([G3("contextformbutton")]), PH = fI.concat([G3("contextformtogglebutton")]), IH = rI("type", {
      contextformbutton: MH,
      contextformtogglebutton: BH
    });
    TP([
      G3("contextform"),
      DP("initValue", dt("")),
      TH,
      hH("commands", IH),
      OP("launch", rI("type", {
        contextformbutton: LH,
        contextformtogglebutton: PH
      }))
    ].concat(NH));
    const FH = (e) => {
      const t = e.ui.registry.getAll().popups, n = mi(t, (d) => RH(d).fold((h) => {
        throw new Error(dH(h));
      }, Bn)), r = Cl(Wi(n, (d) => d.trigger)), a = oc(n);
      return {
        dataset: n,
        triggers: r,
        lookupByTrigger: (d) => ct(a, (h) => h.trigger === d)
      };
    }, $H = (e, t) => {
      const n = Ru(t.load, 50);
      e.on("keypress compositionend", (r) => {
        r.which !== 27 && n.throttle();
      }), e.on("keydown", (r) => {
        const a = r.which;
        a === 8 ? n.throttle() : a === 27 && t.cancelIfNecessary();
      }), e.on("remove", n.cancel);
    }, HH = (e) => {
      const t = sf(), n = Ja(!1), r = t.isSet, a = () => {
        r() && (H6(e), XT(e), n.set(!1), t.clear());
      }, c = (D) => {
        r() || (P4(e, D.range), t.set({
          trigger: D.trigger,
          matchLength: D.text.length
        }));
      }, d = Gi(() => FH(e)), h = (D) => t.get().map((H) => Z8(e.dom, e.selection.getRng(), H.trigger).bind((U) => G8(e, d, U, D))).getOrThunk(() => M$(e, d)), k = (D) => {
        h(D).fold(a, (H) => {
          c(H.context), H.lookupData.then((U) => {
            t.get().map((G) => {
              const ie = H.context;
              G.trigger === ie.trigger && (ie.text.length - G.matchLength >= 10 ? a() : (t.set({
                ...G,
                matchLength: ie.text.length
              }), n.get() ? YT(e, { lookupData: U }) : (n.set(!0), KT(e, { lookupData: U }))));
            });
          });
        });
      };
      e.addCommand("mceAutocompleterReload", (D, H) => {
        const U = Ee(H) ? H.fetchOptions : {};
        k(U);
      }), e.addCommand("mceAutocompleterClose", a), $H(e, {
        cancelIfNecessary: a,
        load: k
      });
    }, VH = Zn().browser.isSafari(), mI = (e) => zf(be.fromDom(e)), pI = (e, t) => {
      var n;
      return e.startOffset === 0 && e.endOffset === ((n = t.textContent) === null || n === void 0 ? void 0 : n.length);
    }, o5 = (e, t) => K.from(e.getParent(t.container(), "details")), gI = (e, t) => o5(e, t).isSome(), UH = (e, t) => {
      const n = K.from(e.getParent(t.startContainer, "details")), r = K.from(e.getParent(t.endContainer, "details"));
      if (n.isSome() || r.isSome()) {
        const a = n.bind((c) => K.from(e.select("summary", c)[0]));
        return K.some({
          startSummary: a,
          startDetails: n,
          endDetails: r
        });
      } else
        return K.none();
    }, jH = (e, t) => lu(t).exists((n) => n.isEqual(e)), ZH = (e, t) => dp(t).exists((n) => cs(n.getNode()) && cf(t, n).exists((r) => r.isEqual(e)) || n.isEqual(e)), WH = (e, t) => t.startSummary.exists((n) => jH(e, n)), qH = (e, t) => t.startSummary.exists((n) => ZH(e, n)), GH = (e, t) => t.startDetails.exists((n) => cf(n, e).forall((r) => t.startSummary.exists((a) => !a.contains(e.container()) && a.contains(r.container())))), KH = (e, t, n) => n.startDetails.exists((r) => kd(e, t).forall((a) => !r.contains(a.container()))), hI = (e, t) => {
      const n = t.getNode();
      ko(n) || e.selection.setCursorLocation(n, t.offset());
    }, bI = (e, t, n) => {
      const r = e.dom.getParent(t.container(), "details");
      if (r && !r.open) {
        const a = e.dom.select("summary", r)[0];
        a && (n ? lu(a) : dp(a)).each((d) => hI(e, d));
      } else
        hI(e, t);
    }, YH = (e, t) => {
      const n = (k) => k.contains(e.startContainer), r = (k) => k.contains(e.endContainer), a = t.startSummary.exists(n), c = t.startSummary.exists(r), d = t.startDetails.forall((k) => t.endDetails.forall((D) => k !== D));
      return (a || c) && !(a && c) || d;
    }, yI = (e, t, n) => {
      const { dom: r, selection: a } = e, c = e.getBody();
      if (n === "character") {
        const d = nt.fromRangeStart(a.getRng()), h = r.getParent(d.container(), r.isBlock), k = o5(r, d), D = h && r.isEmpty(h), H = We(h == null ? void 0 : h.previousSibling), U = We(h == null ? void 0 : h.nextSibling);
        return D && (t ? U : H) && d1(!t, c, d).exists((ye) => gI(r, ye) && !_p(k, o5(r, ye))) ? !0 : d1(t, c, d).fold(Pn, (G) => {
          const ie = o5(r, G);
          if (gI(r, G) && !_p(k, ie)) {
            if (t || bI(e, G, !1), h && D) {
              if (t && H)
                return !0;
              if (!t && U)
                return !0;
              bI(e, G, t), e.dom.remove(h);
            }
            return !0;
          } else
            return !1;
        });
      } else
        return !1;
    }, XH = (e, t, n, r) => {
      const c = e.selection.getRng(), d = nt.fromRangeStart(c), h = e.getBody();
      return r === "selection" ? YH(c, t) : n ? qH(d, t) || KH(h, d, t) : WH(d, t) || GH(d, t);
    }, JH = (e, t, n) => UH(e.dom, e.selection.getRng()).fold(() => yI(e, t, n), (r) => XH(e, r, t, n) || yI(e, t, n)), QH = (e, t, n) => {
      const r = e.selection, a = r.getNode(), c = r.getRng(), d = nt.fromRangeStart(c);
      return Ef(a) ? (n === "selection" && pI(c, a) || gE(t, d, a) ? mI(a) : e.undoManager.transact(() => {
        const h = r.getSel();
        let { anchorNode: k, anchorOffset: D, focusNode: H, focusOffset: U } = h ?? {};
        const G = () => {
          Xe(k) && Xe(D) && Xe(H) && Xe(U) && (h == null || h.setBaseAndExtent(k, D, H, U));
        }, ie = () => {
          k = h == null ? void 0 : h.anchorNode, D = h == null ? void 0 : h.anchorOffset, H = h == null ? void 0 : h.focusNode, U = h == null ? void 0 : h.focusOffset;
        }, ye = (xe, Ne) => {
          ut(xe.childNodes, (Ie) => {
            Hu(Ie) && Ne.appendChild(Ie);
          });
        }, ae = e.dom.create("span", { "data-mce-bogus": "1" });
        ye(a, ae), a.appendChild(ae), G(), (n === "word" || n === "line") && (h == null || h.modify("extend", t ? "right" : "left", n)), !r.isCollapsed() && pI(r.getRng(), ae) ? mI(a) : (e.execCommand(t ? "ForwardDelete" : "Delete"), ie(), ye(ae, a), G()), e.dom.remove(ae);
      }), !0) : !1;
    }, uw = (e, t, n) => JH(e, t, n) || VH && QH(e, t, n) ? K.some(ht) : K.none(), vI = (e) => (t, n, r = {}) => {
      const a = t.getBody(), c = {
        bubbles: !0,
        composed: !0,
        data: null,
        isComposing: !1,
        detail: 0,
        view: null,
        target: a,
        currentTarget: a,
        eventPhase: Event.AT_TARGET,
        originalTarget: a,
        explicitOriginalTarget: a,
        isTrusted: !1,
        srcElement: a,
        cancelable: !1,
        preventDefault: ht,
        inputType: n
      }, d = Vy(new InputEvent(e));
      return t.dispatch(e, {
        ...d,
        ...c,
        ...r
      });
    }, K3 = vI("input"), r5 = vI("beforeinput"), xI = Zn(), wI = xI.os, kI = wI.isMacOS() || wI.isiOS(), eV = xI.browser.isFirefox(), tV = (e, t, n) => {
      const r = n.keyCode === yn.BACKSPACE ? "deleteContentBackward" : "deleteContentForward", a = e.selection.isCollapsed(), c = a ? "character" : "selection", d = (h) => a ? h ? "word" : "line" : "selection";
      M2([
        {
          keyCode: yn.BACKSPACE,
          action: to(fe, e)
        },
        {
          keyCode: yn.BACKSPACE,
          action: to(k3, e, !1)
        },
        {
          keyCode: yn.DELETE,
          action: to(k3, e, !0)
        },
        {
          keyCode: yn.BACKSPACE,
          action: to(Qx, e, !1)
        },
        {
          keyCode: yn.DELETE,
          action: to(Qx, e, !0)
        },
        {
          keyCode: yn.BACKSPACE,
          action: to(A2, e, t, !1)
        },
        {
          keyCode: yn.DELETE,
          action: to(A2, e, t, !0)
        },
        {
          keyCode: yn.BACKSPACE,
          action: to(vx, e, !1)
        },
        {
          keyCode: yn.DELETE,
          action: to(vx, e, !0)
        },
        {
          keyCode: yn.BACKSPACE,
          action: to(uw, e, !1, c)
        },
        {
          keyCode: yn.DELETE,
          action: to(uw, e, !0, c)
        },
        ...kI ? [
          {
            keyCode: yn.BACKSPACE,
            altKey: !0,
            action: to(uw, e, !1, d(!0))
          },
          {
            keyCode: yn.DELETE,
            altKey: !0,
            action: to(uw, e, !0, d(!0))
          },
          {
            keyCode: yn.BACKSPACE,
            metaKey: !0,
            action: to(uw, e, !1, d(!1))
          }
        ] : [
          {
            keyCode: yn.BACKSPACE,
            ctrlKey: !0,
            action: to(uw, e, !1, d(!0))
          },
          {
            keyCode: yn.DELETE,
            ctrlKey: !0,
            action: to(uw, e, !0, d(!0))
          }
        ],
        {
          keyCode: yn.BACKSPACE,
          action: to(_3, e, !1)
        },
        {
          keyCode: yn.DELETE,
          action: to(_3, e, !0)
        },
        {
          keyCode: yn.BACKSPACE,
          action: to(f, e, !1)
        },
        {
          keyCode: yn.DELETE,
          action: to(f, e, !0)
        },
        {
          keyCode: yn.BACKSPACE,
          action: to(b3, e, !1)
        },
        {
          keyCode: yn.DELETE,
          action: to(b3, e, !0)
        },
        {
          keyCode: yn.BACKSPACE,
          action: to(b2, e, !1)
        },
        {
          keyCode: yn.DELETE,
          action: to(b2, e, !0)
        },
        {
          keyCode: yn.BACKSPACE,
          action: to(D2, e, !1)
        },
        {
          keyCode: yn.DELETE,
          action: to(D2, e, !0)
        }
      ], n).filter((h) => e.selection.isEditable()).each((h) => {
        n.preventDefault(), r5(e, r).isDefaultPrevented() || (h(), K3(e, r));
      });
    }, nV = (e, t, n) => Z1([
      {
        keyCode: yn.BACKSPACE,
        action: to(BR, e)
      },
      {
        keyCode: yn.DELETE,
        action: to(BR, e)
      },
      ...kI ? [
        {
          keyCode: yn.BACKSPACE,
          altKey: !0,
          action: to(o, e)
        },
        {
          keyCode: yn.DELETE,
          altKey: !0,
          action: to(o, e)
        },
        ...n ? [{
          keyCode: eV ? 224 : 91,
          action: to(o, e)
        }] : []
      ] : [
        {
          keyCode: yn.BACKSPACE,
          ctrlKey: !0,
          action: to(o, e)
        },
        {
          keyCode: yn.DELETE,
          ctrlKey: !0,
          action: to(o, e)
        }
      ]
    ], t), oV = (e, t) => {
      let n = !1;
      e.on("keydown", (r) => {
        n = r.keyCode === yn.BACKSPACE, r.isDefaultPrevented() || tV(e, t, r);
      }), e.on("keyup", (r) => {
        r.isDefaultPrevented() || nV(e, r, n), n = !1;
      });
    }, rV = (e) => {
      for (; e; ) {
        if (wn(e) || At(e) && e.data && /[\r\n\s]/.test(e.data))
          return e;
        e = e.nextSibling;
      }
      return null;
    }, I2 = (e, t) => {
      const n = e.dom, r = e.schema.getMoveCaretBeforeOnEnterElements();
      if (!t)
        return;
      if (/^(LI|DT|DD)$/.test(t.nodeName)) {
        const c = rV(t.firstChild);
        c && /^(UL|OL|DL)$/.test(c.nodeName) && t.insertBefore(n.doc.createTextNode(Bo), t.firstChild);
      }
      const a = n.createRng();
      if (t.normalize(), t.hasChildNodes()) {
        const c = new vi(t, t);
        let d = t, h;
        for (; h = c.current(); ) {
          if (At(h)) {
            a.setStart(h, 0), a.setEnd(h, 0);
            break;
          }
          if (r[h.nodeName.toLowerCase()]) {
            a.setStartBefore(h), a.setEndBefore(h);
            break;
          }
          d = h, h = c.next();
        }
        h || (a.setStart(d, 0), a.setEnd(d, 0));
      } else
        cs(t) ? t.nextSibling && n.isBlock(t.nextSibling) ? (a.setStartBefore(t), a.setEndBefore(t)) : (a.setStartAfter(t), a.setEndAfter(t)) : (a.setStart(t, 0), a.setEnd(t, 0));
      e.selection.setRng(a), A0(e, a);
    }, Y3 = (e, t) => {
      const n = e.getRoot();
      let r, a = t;
      for (; a !== n && a && e.getContentEditable(a) !== "false"; ) {
        if (e.getContentEditable(a) === "true") {
          r = a;
          break;
        }
        a = a.parentNode;
      }
      return a !== n ? r : n;
    }, MP = (e) => K.from(e.dom.getParent(e.selection.getStart(!0), e.dom.isBlock)), sV = (e) => MP(e).fold(dt(""), (t) => t.nodeName.toUpperCase()), aV = (e) => MP(e).filter((t) => Jd(be.fromDom(t))).isSome(), BP = (e) => {
      e.innerHTML = '<br data-mce-bogus="1">';
    }, iV = (e, t, n) => {
      const r = e.dom;
      K.from(n.style).map(r.parseStyle).each((k) => {
        const H = {
          ...za(be.fromDom(t)),
          ...k
        };
        r.setStyles(t, H);
      });
      const a = K.from(n.class).map((k) => k.split(/\s+/)), c = K.from(t.className).map((k) => ct(k.split(/\s+/), (D) => D !== ""));
      ns(a, c, (k, D) => {
        const H = ct(D, (G) => !So(k, G)), U = [
          ...k,
          ...H
        ];
        r.setAttrib(t, "class", U.join(" "));
      });
      const d = [
        "style",
        "class"
      ], h = _l(n, (k, D) => !So(d, D));
      r.setAttribs(t, h);
    }, X3 = (e, t) => {
      if (li(e).toLowerCase() === t.tagName.toLowerCase()) {
        const r = Mg(e);
        iV(e, t, r);
      }
    }, _I = (e, t, n, r, a = !0, c, d) => {
      const h = e.dom, k = e.schema, D = li(e), H = n ? n.nodeName.toUpperCase() : "";
      let U = t;
      const G = k.getTextInlineElements();
      let ie;
      c || H === "TABLE" || H === "HR" ? ie = h.create(c || D, d || {}) : ie = n.cloneNode(!1);
      let ye = ie;
      if (!a)
        h.setAttrib(ie, "style", null), h.setAttrib(ie, "class", null);
      else
        do
          if (G[U.nodeName]) {
            if (uf(U) || Vf(U))
              continue;
            const ae = U.cloneNode(!1);
            h.setAttrib(ae, "id", ""), ie.hasChildNodes() ? (ae.appendChild(ie.firstChild), ie.appendChild(ae)) : (ye = ae, ie.appendChild(ae));
          }
        while ((U = U.parentNode) && U !== r);
      return X3(e, ie), BP(ye), ie;
    }, lV = (e, t) => e.dom.getParent(t, zp), cV = (e, t, n) => {
      let r = t;
      for (; r && r !== e && We(r.nextSibling); ) {
        const a = r.parentElement;
        if (!a || !n(a))
          return zp(a);
        r = a;
      }
      return !1;
    }, uV = (e, t, n) => !t && n.nodeName.toLowerCase() === li(e) && e.dom.isEmpty(n) && cV(e.getBody(), n, (r) => Yn(e.schema.getTextBlockElements(), r.nodeName.toLowerCase())), dV = (e, t, n) => {
      var r, a, c;
      const d = t(li(e)), h = lV(e, n);
      h && (e.dom.insertAfter(d, h), I2(e, d), ((c = (a = (r = n.parentElement) === null || r === void 0 ? void 0 : r.childNodes) === null || a === void 0 ? void 0 : a.length) !== null && c !== void 0 ? c : 0) > 1 && e.dom.remove(n));
    }, fV = (e, t) => e.firstChild && e.firstChild.nodeName === t, mV = (e) => {
      var t;
      return ((t = e.parentNode) === null || t === void 0 ? void 0 : t.firstChild) === e;
    }, CI = (e, t) => {
      const n = e == null ? void 0 : e.parentNode;
      return Xe(n) && n.nodeName === t;
    }, SI = (e) => Xe(e) && /^(OL|UL|LI)$/.test(e.nodeName), LP = (e) => Xe(e) && /^(LI|DT|DD)$/.test(e.nodeName), pV = (e) => SI(e) && SI(e.parentNode), s5 = (e) => {
      const t = e.parentNode;
      return LP(t) ? t : e;
    }, a5 = (e, t, n) => {
      let r = e[n ? "firstChild" : "lastChild"];
      for (; r && !wn(r); )
        r = r[n ? "nextSibling" : "previousSibling"];
      return r === t;
    }, EI = (e) => co(Wi(za(be.fromDom(e)), (t, n) => `${n}: ${t};`), (t, n) => t + n, ""), gV = (e, t, n, r, a) => {
      const c = e.dom, d = e.selection.getRng(), h = n.parentNode;
      if (n === e.getBody() || !h)
        return;
      pV(n) && (a = "LI");
      const k = LP(r) ? EI(r) : void 0;
      let D = LP(r) && k ? t(a, { style: EI(r) }) : t(a);
      if (a5(n, r, !0) && a5(n, r, !1))
        if (CI(n, "LI")) {
          const H = s5(n);
          c.insertAfter(D, H), mV(n) ? c.remove(H) : c.remove(n);
        } else
          c.replace(D, n);
      else if (a5(n, r, !0))
        CI(n, "LI") ? (c.insertAfter(D, s5(n)), D.appendChild(c.doc.createTextNode(" ")), D.appendChild(n)) : h.insertBefore(D, n), c.remove(r);
      else if (a5(n, r, !1))
        c.insertAfter(D, s5(n)), c.remove(r);
      else {
        n = s5(n);
        const H = d.cloneRange();
        H.setStartAfter(r), H.setEndAfter(n);
        const U = H.extractContents();
        if (a === "LI" && fV(U, "LI")) {
          const G = ct(oo(D.children, be.fromDom), yo(ya("br")));
          D = U.firstChild, c.insertAfter(U, n), ut(G, (ie) => fs(be.fromDom(D), ie)), k && D.setAttribute("style", k);
        } else
          c.insertAfter(U, n), c.insertAfter(D, n);
        c.remove(r);
      }
      I2(e, D);
    }, hV = (e) => {
      ut(_u(be.fromDom(e), Zs), (t) => {
        const n = t.dom;
        n.nodeValue = q(n.data);
      });
    }, bV = (e, t) => {
      const n = e.dom.getParent(t, "ol,ul,dl");
      return n !== null && e.dom.getContentEditableParent(n) === "false";
    }, yV = (e, t) => t && t.nodeName === "A" && e.isEmpty(t), PP = (e, t) => e.nodeName === t || e.previousSibling && e.previousSibling.nodeName === t, IP = (e, t) => Xe(t) && e.isBlock(t) && !/^(TD|TH|CAPTION|FORM)$/.test(t.nodeName) && !/^(fixed|absolute)/i.test(t.style.position) && e.isEditable(t.parentNode) && e.getContentEditable(t) !== "false", vV = (e, t, n) => {
      var r;
      const a = [];
      if (!n)
        return;
      let c = n;
      for (; c = c.firstChild; ) {
        if (e.isBlock(c))
          return;
        wn(c) && !t[c.nodeName.toLowerCase()] && a.push(c);
      }
      let d = a.length;
      for (; d--; )
        c = a[d], (!c.hasChildNodes() || c.firstChild === c.lastChild && ((r = c.firstChild) === null || r === void 0 ? void 0 : r.nodeValue) === "" || yV(e, c)) && e.remove(c);
    }, FP = (e, t, n) => At(t) ? e ? n === 1 && t.data.charAt(n - 1) === C ? 0 : n : n === t.data.length - 1 && t.data.charAt(n) === C ? t.data.length : n : n, xV = (e) => {
      const t = e.cloneRange();
      return t.setStart(e.startContainer, FP(!0, e.startContainer, e.startOffset)), t.setEnd(e.endContainer, FP(!1, e.endContainer, e.endOffset)), t;
    }, wV = (e) => {
      let t = e;
      do
        At(t) && (t.data = t.data.replace(/^[\r\n]+/, "")), t = t.firstChild;
      while (t);
    }, kV = (e, t, n, r, a) => {
      var c, d;
      const h = e.dom, k = (c = Y3(h, r)) !== null && c !== void 0 ? c : h.getRoot();
      let D = h.getParent(r, h.isBlock);
      if (!D || !IP(h, D)) {
        if (D = D || k, !D.hasChildNodes()) {
          const ie = h.create(t);
          return X3(e, ie), D.appendChild(ie), n.setStart(ie, 0), n.setEnd(ie, 0), ie;
        }
        let H = r;
        for (; H && H.parentNode !== D; )
          H = H.parentNode;
        let U;
        for (; H && !h.isBlock(H); )
          U = H, H = H.previousSibling;
        const G = (d = U == null ? void 0 : U.parentElement) === null || d === void 0 ? void 0 : d.nodeName;
        if (U && G && e.schema.isValidChild(G, t.toLowerCase())) {
          const ie = U.parentNode, ye = h.create(t);
          for (X3(e, ye), ie.insertBefore(ye, U), H = U; H && !h.isBlock(H); ) {
            const ae = H.nextSibling;
            ye.appendChild(H), H = ae;
          }
          n.setStart(r, a), n.setEnd(r, a);
        }
      }
      return r;
    }, _V = (e, t) => {
      t.normalize();
      const n = t.lastChild;
      (!n || wn(n) && /^(left|right)$/gi.test(e.getStyle(n, "float", !0))) && e.add(t, "br");
    }, CV = (e, t) => {
      const n = Q2(e);
      return jn(t) ? !1 : Ot(n) ? So(Ht.explode(n), t.nodeName.toLowerCase()) : n;
    }, TI = {
      insert: (e, t) => {
        let n, r, a, c, d = !1;
        const h = e.dom, k = e.schema, D = k.getNonEmptyElements(), H = e.selection.getRng(), U = li(e), G = be.fromDom(H.startContainer), ie = Tc(G, H.startOffset), ye = ie.exists((Mt) => $d(Mt) && !Ka(Mt)), ae = H.collapsed && ye, xe = (Mt, gn) => _I(e, n, Zt, _t, J2(e), Mt, gn), Ne = (Mt) => {
          const gn = FP(Mt, n, r);
          if (At(n) && (Mt ? gn > 0 : gn < n.data.length))
            return !1;
          if (n.parentNode === Zt && d && !Mt || Mt && wn(n) && n === Zt.firstChild)
            return !0;
          if (PP(n, "TABLE") || PP(n, "HR"))
            return d && !Mt || !d && Mt;
          const Fn = new vi(n, Zt);
          At(n) && (Mt && gn === 0 ? Fn.prev() : !Mt && gn === n.data.length && Fn.next());
          let Uo;
          for (; Uo = Fn.current(); ) {
            if (wn(Uo)) {
              if (!Uo.getAttribute("data-mce-bogus")) {
                const qo = Uo.nodeName.toLowerCase();
                if (D[qo] && qo !== "br")
                  return !1;
              }
            } else if (At(Uo) && !pd(Uo.data))
              return !1;
            Mt ? Fn.prev() : Fn.next();
          }
          return !0;
        }, Ie = () => {
          let Mt;
          return /^(H[1-6]|PRE|FIGURE)$/.test(a) && fn !== "HGROUP" ? Mt = xe(U) : Mt = xe(), CV(e, c) && IP(h, c) && h.isEmpty(Zt, void 0, { includeZwsp: !0 }) ? Mt = h.split(c, Zt) : h.insertAfter(Mt, Zt), I2(e, Mt), Mt;
        };
        Wv(h, H).each((Mt) => {
          H.setStart(Mt.startContainer, Mt.startOffset), H.setEnd(Mt.endContainer, Mt.endOffset);
        }), n = H.startContainer, r = H.startOffset;
        const Fe = !!(t && t.shiftKey), je = !!(t && t.ctrlKey);
        wn(n) && n.hasChildNodes() && !ae && (d = r > n.childNodes.length - 1, n = n.childNodes[Math.min(r, n.childNodes.length - 1)] || n, d && At(n) ? r = n.data.length : r = 0);
        const _t = Y3(h, n);
        if (!_t || bV(e, n))
          return;
        Fe || (n = kV(e, U, H, n, r));
        let Zt = h.getParent(n, h.isBlock) || h.getRoot();
        c = Xe(Zt == null ? void 0 : Zt.parentNode) ? h.getParent(Zt.parentNode, h.isBlock) : null, a = Zt ? Zt.nodeName.toUpperCase() : "";
        const fn = c ? c.nodeName.toUpperCase() : "";
        if (fn === "LI" && !je) {
          const Mt = c;
          Zt = Mt, c = Mt.parentNode, a = fn;
        }
        if (wn(c) && uV(e, Fe, Zt))
          return dV(e, xe, Zt);
        if (/^(LI|DT|DD)$/.test(a) && wn(c) && h.isEmpty(Zt)) {
          gV(e, xe, c, Zt, U);
          return;
        }
        if (!ae && (Zt === e.getBody() || !IP(h, Zt)))
          return;
        const at = Zt.parentNode;
        let et;
        if (ae)
          et = xe(U), ie.fold(() => {
            Ir(G, be.fromDom(et));
          }, (Mt) => {
            Fs(Mt, be.fromDom(et));
          }), e.selection.setCursorLocation(et, 0);
        else if (Pt(Zt))
          et = Um(Zt), h.isEmpty(Zt) && BP(Zt), X3(e, et), I2(e, et);
        else if (Ne(!1))
          et = Ie();
        else if (Ne(!0) && at) {
          et = at.insertBefore(xe(), Zt);
          const Mt = Ud(be.fromDom(H.startContainer)) && H.collapsed;
          I2(e, PP(Zt, "HR") || Mt ? et : Zt);
        } else {
          const Mt = xV(H).cloneRange();
          Mt.setEndAfter(Zt);
          const gn = Mt.extractContents();
          hV(gn), wV(gn), et = gn.firstChild, h.insertAfter(gn, Zt), vV(h, D, et), _V(h, Zt), h.isEmpty(Zt) && BP(Zt), et.normalize(), h.isEmpty(et) ? (h.remove(et), Ie()) : (X3(e, et), I2(e, et));
        }
        h.setAttrib(et, "id", ""), e.dispatch("NewBlock", { newBlock: et });
      },
      fakeEventName: "insertParagraph"
    }, SV = (e, t, n) => {
      const r = new vi(t, n);
      let a;
      const c = e.getNonEmptyElements();
      for (; a = r.next(); )
        if (c[a.nodeName.toLowerCase()] || At(a) && a.length > 0)
          return !0;
      return !1;
    }, zI = (e, t, n) => {
      const r = e.dom.createRng();
      n ? (r.setStartBefore(t), r.setEndBefore(t)) : (r.setStartAfter(t), r.setEndAfter(t)), e.selection.setRng(r), A0(e, r);
    }, EV = (e, t) => {
      const n = e.selection, r = e.dom, a = n.getRng();
      let c, d = !1;
      Wv(r, a).each((ie) => {
        a.setStart(ie.startContainer, ie.startOffset), a.setEnd(ie.endContainer, ie.endOffset);
      });
      let h = a.startOffset, k = a.startContainer;
      if (wn(k) && k.hasChildNodes()) {
        const ie = h > k.childNodes.length - 1;
        k = k.childNodes[Math.min(h, k.childNodes.length - 1)] || k, ie && At(k) ? h = k.data.length : h = 0;
      }
      let D = r.getParent(k, r.isBlock);
      const H = D && D.parentNode ? r.getParent(D.parentNode, r.isBlock) : null, U = H ? H.nodeName.toUpperCase() : "", G = !!(t && t.ctrlKey);
      U === "LI" && !G && (D = H), At(k) && h >= k.data.length && (SV(e.schema, k, D || r.getRoot()) || (c = r.create("br"), a.insertNode(c), a.setStartAfter(c), a.setEndAfter(c), d = !0)), c = r.create("br"), Dg(r, a, c), zI(e, c, d), e.undoManager.add();
    }, TV = (e, t) => {
      const n = be.fromTag("br");
      Fs(be.fromDom(t), n), e.undoManager.add();
    }, zV = (e, t) => {
      AV(e.getBody(), t) || rs(be.fromDom(t), be.fromTag("br"));
      const n = be.fromTag("br");
      rs(be.fromDom(t), n), zI(e, n.dom, !1), e.undoManager.add();
    }, OV = (e) => cs(e.getNode()), AV = (e, t) => OV(nt.after(t)) ? !0 : kd(e, nt.after(t)).map((n) => cs(n.getNode())).getOr(!1), OI = (e) => e && e.nodeName === "A" && "href" in e, DV = (e) => e.fold(Pn, OI, OI, Pn), RV = (e) => {
      const t = Tt(_1, e), n = nt.fromRangeStart(e.selection.getRng());
      return Gg(t, e.getBody(), n).filter(DV);
    }, NV = (e, t) => {
      t.fold(ht, Tt(TV, e), Tt(zV, e), ht);
    }, AI = {
      insert: (e, t) => {
        const n = RV(e);
        n.isSome() ? n.each(Tt(NV, e)) : EV(e, t);
      },
      fakeEventName: "insertLineBreak"
    }, DI = (e, t) => MP(e).filter((n) => t.length > 0 && Ai(be.fromDom(n), t)).isSome(), MV = (e) => DI(e, Sv(e)), BV = (e) => DI(e, Tw(e)), xp = $e.generate([
      { br: [] },
      { block: [] },
      { none: [] }
    ]), LV = (e, t) => BV(e), RI = (e) => (t, n) => aV(t) === e, NI = (e, t) => (n, r) => sV(n) === e.toUpperCase() === t, PV = (e) => {
      const t = Y3(e.dom, e.selection.getStart());
      return jn(t);
    }, J3 = (e) => NI("pre", e), IV = () => NI("summary", !0), i5 = (e) => (t, n) => Dh(t) === e, FV = (e, t) => MV(e), l5 = (e, t) => t, $V = (e) => {
      const t = li(e), n = Y3(e.dom, e.selection.getStart());
      return Xe(n) && e.schema.isValidChild(n.nodeName, t);
    }, HV = (e) => {
      const t = e.selection.getRng(), n = be.fromDom(t.startContainer), a = Tc(n, t.startOffset).map((c) => $d(c) && !Ka(c));
      return t.collapsed && a.getOr(!0);
    }, eg = (e, t) => (n, r) => co(e, (c, d) => c && d(n, r), !0) ? K.some(t) : K.none(), VV = (e, t) => HR([
      eg([LV], xp.none()),
      eg([
        J3(!0),
        PV
      ], xp.none()),
      eg([IV()], xp.br()),
      eg([
        J3(!0),
        i5(!1),
        l5
      ], xp.br()),
      eg([
        J3(!0),
        i5(!1)
      ], xp.block()),
      eg([
        J3(!0),
        i5(!0),
        l5
      ], xp.block()),
      eg([
        J3(!0),
        i5(!0)
      ], xp.br()),
      eg([
        RI(!0),
        l5
      ], xp.br()),
      eg([RI(!0)], xp.block()),
      eg([FV], xp.br()),
      eg([l5], xp.br()),
      eg([$V], xp.block()),
      eg([HV], xp.block())
    ], [
      e,
      !!(t && t.shiftKey)
    ]).getOr(xp.none()), c5 = (e, t, n) => {
      t.selection.isCollapsed() || df(t), !(Xe(n) && r5(t, e.fakeEventName).isDefaultPrevented()) && (e.insert(t, n), Xe(n) && K3(t, e.fakeEventName));
    }, MI = (e, t) => {
      const n = () => c5(AI, e, t), r = () => c5(TI, e, t), a = VV(e, t);
      switch (Ew(e)) {
        case "linebreak":
          a.fold(n, n, ht);
          break;
        case "block":
          a.fold(r, r, ht);
          break;
        case "invert":
          a.fold(r, n, ht);
          break;
        default:
          a.fold(n, r, ht);
          break;
      }
    }, BI = Zn(), UV = BI.os.isiOS() && BI.browser.isSafari(), LI = (e, t) => {
      t.isDefaultPrevented() || (t.preventDefault(), w6(e.undoManager), e.undoManager.transact(() => {
        MI(e, t);
      }));
    }, jV = (e) => {
      if (!e.collapsed)
        return !1;
      const t = e.startContainer;
      if (At(t)) {
        const n = /^[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF]$/, r = t.data.charAt(e.startOffset - 1);
        return n.test(r);
      } else
        return !1;
    }, ZV = (e) => {
      let t = K.none();
      const n = (a) => {
        t = K.some(a.selection.getBookmark()), a.undoManager.add();
      }, r = (a, c) => {
        a.undoManager.undo(), t.fold(ht, (d) => a.selection.moveToBookmark(d)), LI(a, c), t = K.none();
      };
      e.on("keydown", (a) => {
        a.keyCode === yn.ENTER && (UV && jV(e.selection.getRng()) ? n(e) : LI(e, a));
      }), e.on("keyup", (a) => {
        a.keyCode === yn.ENTER && t.each(() => r(e, a));
      });
    }, WV = (e, t, n) => {
      const r = nr.os.isMacOS() || nr.os.isiOS();
      Z1([
        {
          keyCode: yn.END,
          action: to(Yg, e, !0)
        },
        {
          keyCode: yn.HOME,
          action: to(Yg, e, !1)
        },
        ...r ? [] : [
          {
            keyCode: yn.HOME,
            action: to(qh, e, !1),
            ctrlKey: !0,
            shiftKey: !0
          },
          {
            keyCode: yn.END,
            action: to(qh, e, !0),
            ctrlKey: !0,
            shiftKey: !0
          }
        ],
        {
          keyCode: yn.END,
          action: to(LN, e, !0)
        },
        {
          keyCode: yn.HOME,
          action: to(LN, e, !1)
        },
        {
          keyCode: yn.END,
          action: to(tw, e, !0, t)
        },
        {
          keyCode: yn.HOME,
          action: to(tw, e, !1, t)
        }
      ], n).each((a) => {
        n.preventDefault();
      });
    }, qV = (e, t) => {
      e.on("keydown", (n) => {
        n.isDefaultPrevented() || WV(e, t, n);
      });
    }, GV = (e) => {
      e.on("input", (t) => {
        t.isComposing || VM(e);
      });
    }, KV = Zn(), YV = (e, t, n) => {
      Z1([
        {
          keyCode: yn.PAGE_UP,
          action: to(tw, e, !1, t)
        },
        {
          keyCode: yn.PAGE_DOWN,
          action: to(tw, e, !0, t)
        }
      ], n);
    }, PI = (e) => e.stopImmediatePropagation(), II = (e) => e.keyCode === yn.PAGE_UP || e.keyCode === yn.PAGE_DOWN, FI = (e, t, n) => {
      n && !e.get() ? t.on("NodeChange", PI, !0) : !n && e.get() && t.off("NodeChange", PI), e.set(n);
    }, XV = (e, t) => {
      if (KV.os.isMacOS())
        return;
      const n = Ja(!1);
      e.on("keydown", (r) => {
        II(r) && FI(n, e, !0);
      }), e.on("keyup", (r) => {
        r.isDefaultPrevented() || YV(e, t, r), II(r) && n.get() && (FI(n, e, !1), e.nodeChanged());
      });
    }, JV = (e) => {
      e.on("beforeinput", (t) => {
        (!e.selection.isEditable() || cr(t.getTargetRanges(), (n) => !Qv(e.dom, n))) && t.preventDefault();
      });
    }, $I = (e, t) => {
      const n = t.container(), r = t.offset();
      return At(n) ? (n.insertData(r, e), K.some(nt(n, r + e.length))) : Mc(t).map((a) => {
        const c = be.fromText(e);
        return t.isAtEnd() ? rs(a, c) : Fs(a, c), nt(c.dom, e.length);
      });
    }, HI = Tt($I, Bo), VI = Tt($I, " "), QV = (e, t, n) => rE(e, t, n) ? HI(t) : VI(t), e9 = (e) => (t) => t.fold((n) => cf(e.dom, nt.before(n)), (n) => lu(n), (n) => dp(n), (n) => kd(e.dom, nt.after(n))), t9 = (e, t, n) => (r) => rE(e, r, n) ? HI(t) : VI(t), UI = (e) => (t) => {
      e.selection.setRng(t.toRange()), e.nodeChanged();
    }, n9 = (e, t) => e.isEditable(e.getParent(t, "summary")), o9 = (e) => {
      const t = nt.fromRangeStart(e.selection.getRng()), n = be.fromDom(e.getBody());
      if (e.selection.isCollapsed()) {
        const r = Tt(_1, e), a = nt.fromRangeStart(e.selection.getRng());
        return Gg(r, e.getBody(), a).bind(e9(n)).map((c) => () => t9(n, t, e.schema)(c).each(UI(e)));
      } else
        return K.none();
    }, r9 = (e) => {
      const t = () => {
        const n = be.fromDom(e.getBody());
        e.selection.isCollapsed() || e.getDoc().execCommand("Delete");
        const r = nt.fromRangeStart(e.selection.getRng());
        QV(n, r, e.schema).each(UI(e));
      };
      return Xi(nr.browser.isFirefox() && e.selection.isEditable() && n9(e.dom, e.selection.getRng().startContainer), t);
    }, s9 = (e, t) => {
      M2([
        {
          keyCode: yn.SPACEBAR,
          action: to(o9, e)
        },
        {
          keyCode: yn.SPACEBAR,
          action: to(r9, e)
        }
      ], t).each((n) => {
        t.preventDefault(), r5(e, "insertText", { data: " " }).isDefaultPrevented() || (n(), K3(e, "insertText", { data: " " }));
      });
    }, a9 = (e) => {
      e.on("keydown", (t) => {
        t.isDefaultPrevented() || s9(e, t);
      });
    }, i9 = (e) => Dv(e) ? [
      {
        keyCode: yn.TAB,
        action: to(H8, e, !0)
      },
      {
        keyCode: yn.TAB,
        shiftKey: !0,
        action: to(H8, e, !1)
      }
    ] : [], l9 = (e, t) => {
      Z1([...i9(e)], t).each((n) => {
        t.preventDefault();
      });
    }, c9 = (e) => {
      e.on("keydown", (t) => {
        t.isDefaultPrevented() || l9(e, t);
      });
    }, u9 = (e) => {
      if (e.addShortcut("Meta+P", "", "mcePrint"), HH(e), yp(e))
        return Ja(null);
      {
        const t = fN(e);
        return JV(e), Ui(e), _$(e, t), oV(e, t), ZV(e), a9(e), GV(e), c9(e), qV(e, t), XV(e, t), t;
      }
    };
    class d9 {
      constructor(t) {
        this.lastPath = [], this.editor = t;
        let n;
        const r = this;
        "onselectionchange" in t.getDoc() || t.on("NodeChange click mouseup keyup focus", (a) => {
          const c = t.selection.getRng(), d = {
            startContainer: c.startContainer,
            startOffset: c.startOffset,
            endContainer: c.endContainer,
            endOffset: c.endOffset
          };
          (a.type === "nodechange" || !Tk(d, n)) && t.dispatch("SelectionChange"), n = d;
        }), t.on("contextmenu", () => {
          t.dispatch("SelectionChange");
        }), t.on("SelectionChange", () => {
          const a = t.selection.getStart(!0);
          a && uu(t) && !r.isSameElementPath(a) && t.dom.isChildOf(a, t.getBody()) && t.nodeChanged({ selectionChange: !0 });
        }), t.on("mouseup", (a) => {
          !a.isDefaultPrevented() && uu(t) && (t.selection.getNode().nodeName === "IMG" ? du.setEditorTimeout(t, () => {
            t.nodeChanged();
          }) : t.nodeChanged());
        });
      }
      nodeChanged(t = {}) {
        const n = this.editor.selection;
        let r;
        if (this.editor.initialized && n && !iC(this.editor) && !this.editor.mode.isReadOnly()) {
          const a = this.editor.getBody();
          r = n.getStart(!0) || a, (r.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(r, a)) && (r = a);
          const c = [];
          this.editor.dom.getParent(r, (d) => d === a ? !0 : (c.push(d), !1)), this.editor.dispatch("NodeChange", {
            ...t,
            element: r,
            parents: c
          });
        }
      }
      isSameElementPath(t) {
        let n;
        const r = this.editor, a = Ca(r.dom.getParents(t, Mo, r.getBody()));
        if (a.length === this.lastPath.length) {
          for (n = a.length; n >= 0 && a[n] === this.lastPath[n]; n--)
            ;
          if (n === -1)
            return this.lastPath = a, !0;
        }
        return this.lastPath = a, !1;
      }
    }
    const jI = km("image"), f9 = (e) => {
      const t = e;
      return K.from(t[jI]);
    }, m9 = (e, t) => {
      const n = e;
      n[jI] = t;
    }, $P = km("event"), p9 = (e) => {
      const t = e;
      return K.from(t[$P]);
    }, u5 = (e) => (t) => {
      const n = t;
      n[$P] = e;
    }, g9 = (e, t) => u5(t)(e), ZI = u5(0), h9 = u5(2), b9 = u5(1), y9 = ((e) => (t) => {
      const n = t;
      return K.from(n[$P]).exists((r) => r === e);
    })(0), v9 = () => Object.freeze({
      length: 0,
      item: (e) => null
    }), HP = km("mode"), x9 = (e) => {
      const t = e;
      return K.from(t[HP]);
    }, d5 = (e) => (t) => {
      const n = t;
      n[HP] = e;
    }, WI = (e, t) => d5(t)(e), qI = d5(0), VP = d5(2), w9 = d5(1), GI = (e) => (t) => {
      const n = t;
      return K.from(n[HP]).exists((r) => r === e);
    }, F2 = GI(0), KI = GI(1), k9 = (e, t) => ({
      ...t,
      get length() {
        return t.length;
      },
      add: (n, r) => {
        if (F2(e))
          if (Ot(n)) {
            if (!ko(r))
              return t.add(n, r);
          } else
            return t.add(n);
        return null;
      },
      remove: (n) => {
        F2(e) && t.remove(n);
      },
      clear: () => {
        F2(e) && t.clear();
      }
    }), _9 = [
      "none",
      "copy",
      "link",
      "move"
    ], C9 = [
      "none",
      "copy",
      "copyLink",
      "copyMove",
      "link",
      "linkMove",
      "move",
      "all",
      "uninitialized"
    ], UP = () => {
      const e = new window.DataTransfer();
      let t = "move", n = "all";
      const r = {
        get dropEffect() {
          return t;
        },
        set dropEffect(a) {
          So(_9, a) && (t = a);
        },
        get effectAllowed() {
          return n;
        },
        set effectAllowed(a) {
          y9(r) && So(C9, a) && (n = a);
        },
        get items() {
          return k9(r, e.items);
        },
        get files() {
          return KI(r) ? v9() : e.files;
        },
        get types() {
          return e.types;
        },
        setDragImage: (a, c, d) => {
          F2(r) && (m9(r, {
            image: a,
            x: c,
            y: d
          }), e.setDragImage(a, c, d));
        },
        getData: (a) => KI(r) ? "" : e.getData(a),
        setData: (a, c) => {
          F2(r) && e.setData(a, c);
        },
        clearData: (a) => {
          F2(r) && e.clearData(a);
        }
      };
      return qI(r), r;
    }, S9 = (e) => {
      const t = UP(), n = x9(e);
      return VP(e), ZI(t), t.dropEffect = e.dropEffect, t.effectAllowed = e.effectAllowed, f9(e).each((r) => t.setDragImage(r.image, r.x, r.y)), ut(e.types, (r) => {
        r !== "Files" && t.setData(r, e.getData(r));
      }), ut(e.files, (r) => t.items.add(r)), p9(e).each((r) => {
        g9(t, r);
      }), n.each((r) => {
        WI(e, r), WI(t, r);
      }), t;
    }, E9 = (e) => {
      const t = e.getData("text/html");
      return t === "" ? K.none() : K.some(t);
    }, YI = (e, t) => e.setData("text/html", t), XI = "x-tinymce/html", f5 = dt(XI), jP = "<!-- " + XI + " -->", T9 = (e) => jP + e, z9 = (e) => e.replace(jP, ""), JI = (e) => e.indexOf(jP) !== -1, O9 = (e) => !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(e), A9 = (e, t) => {
      let n = "<" + e;
      const r = Wi(t, (a, c) => c + '="' + ma.encodeAllRaw(a) + '"');
      return r.length && (n += " " + r.join(" ")), n + ">";
    }, D9 = (e, t, n) => {
      const r = e.split(/\n\n/), a = A9(t, n), c = "</" + t + ">", d = oo(r, (k) => k.split(/\n/).join("<br />")), h = (k) => a + k + c;
      return d.length === 1 ? d[0] : oo(d, h).join("");
    }, QI = "%MCEPASTEBIN%", R9 = (e, t) => {
      const { dom: n, selection: r } = e, a = e.getBody();
      t.set(r.getRng());
      const c = n.add(e.getBody(), "div", {
        id: "mcepastebin",
        class: "mce-pastebin",
        contentEditable: !0,
        "data-mce-bogus": "all",
        style: "position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0"
      }, QI);
      nr.browser.isFirefox() && n.setStyle(c, "left", n.getStyle(a, "direction", !0) === "rtl" ? 65535 : -65535), n.bind(c, "beforedeactivate focusin focusout", (d) => {
        d.stopPropagation();
      }), c.focus(), r.select(c, !0);
    }, N9 = (e, t) => {
      const n = e.dom;
      if (ZP(e)) {
        let r;
        const a = t.get();
        for (; r = ZP(e); )
          n.remove(r), n.unbind(r);
        a && e.selection.setRng(a);
      }
      t.set(null);
    }, ZP = (e) => e.dom.get("mcepastebin"), M9 = (e) => Xe(e) && e.id === "mcepastebin", B9 = (e) => {
      const t = e.dom, n = (d, h) => {
        d.appendChild(h), t.remove(h, !0);
      }, [r, ...a] = ct(e.getBody().childNodes, M9);
      ut(a, (d) => {
        n(r, d);
      });
      const c = t.select("div[id=mcepastebin]", r);
      for (let d = c.length - 1; d >= 0; d--) {
        const h = t.create("div");
        r.insertBefore(h, c[d]), n(h, c[d]);
      }
      return r ? r.innerHTML : "";
    }, e7 = (e) => e === QI, L9 = (e) => {
      const t = Ja(null);
      return {
        create: () => R9(e, t),
        remove: () => N9(e, t),
        getEl: () => ZP(e),
        getHtml: () => B9(e),
        getLastRng: t.get
      };
    }, t7 = (e, t) => (Ht.each(t, (n) => {
      an(n, RegExp) ? e = e.replace(n, "") : e = e.replace(n[0], n[1]);
    }), e), P9 = (e) => {
      const t = of(), n = yy({}, t);
      let r = "";
      const a = t.getVoidElements(), c = Ht.makeMap("script noscript style textarea video audio iframe object", " "), d = t.getBlockElements(), h = (k) => {
        const D = k.name, H = k;
        if (D === "br") {
          r += `
`;
          return;
        }
        if (D !== "wbr") {
          if (a[D] && (r += " "), c[D]) {
            r += " ";
            return;
          }
          if (k.type === 3 && (r += k.value), !(k.name in t.getVoidElements())) {
            let U = k.firstChild;
            if (U)
              do
                h(U);
              while (U = U.next);
          }
          d[D] && H.next && (r += `
`, D === "p" && (r += `
`));
        }
      };
      return e = t7(e, [/<!\[[^\]]+\]>/g]), h(n.parse(e)), r;
    }, n7 = (e) => (e = t7(e, [
      /^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/ig,
      /<!--StartFragment-->|<!--EndFragment-->/g,
      [
        /( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g,
        (n, r, a) => !r && !a ? " " : Bo
      ],
      /<br class="Apple-interchange-newline">/g,
      /<br>$/i
    ]), e), I9 = (e) => {
      let t = 0;
      return () => e + t++;
    }, F9 = (e) => {
      const t = e.toLowerCase(), n = {
        jpg: "jpeg",
        jpe: "jpeg",
        jfi: "jpeg",
        jif: "jpeg",
        jfif: "jpeg",
        pjpeg: "jpeg",
        pjp: "jpeg",
        svg: "svg+xml"
      };
      return Ht.hasOwn(n, t) ? "image/" + n[t] : "image/" + t;
    }, $9 = (e, t) => {
      const n = yy({
        sanitize: Vb(e),
        sandbox_iframes: Rv(e)
      }, e.schema);
      n.addNodeFilter("meta", (a) => {
        Ht.each(a, (c) => {
          c.remove();
        });
      });
      const r = n.parse(t, {
        forced_root_block: !1,
        isRootContent: !0
      });
      return Jl({ validate: !0 }, e.schema).serialize(r);
    }, o7 = (e, t) => ({
      content: e,
      cancelled: t
    }), H9 = (e, t, n) => {
      const r = e.dom.create("div", { style: "display:none" }, t), a = JT(e, r, n);
      return o7(a.node.innerHTML, a.isDefaultPrevented());
    }, V9 = (e, t, n) => {
      const r = iS(e, t, n), a = $9(e, r.content);
      return e.hasEventListeners("PastePostProcess") && !r.isDefaultPrevented() ? H9(e, a, n) : o7(a, r.isDefaultPrevented());
    }, U9 = (e, t, n) => V9(e, t, n), WP = (e, t) => (e.insertContent(t, {
      merge: zv(e),
      paste: !0
    }), !0), qP = (e) => /^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(e), j9 = (e, t) => qP(t) && cr(Av(e), (n) => El(t.toLowerCase(), `.${n.toLowerCase()}`)), Z9 = (e, t, n) => (e.undoManager.extra(() => {
      n(e, t);
    }, () => {
      e.insertContent('<img src="' + t + '">');
    }), !0), W9 = (e, t, n) => (e.undoManager.extra(() => {
      n(e, t);
    }, () => {
      e.execCommand("mceInsertLink", !1, t);
    }), !0), q9 = (e, t, n) => !e.selection.isCollapsed() && qP(t) ? W9(e, t, n) : !1, G9 = (e, t, n) => j9(e, t) ? Z9(e, t, n) : !1, K9 = (e, t) => {
      Ht.each([
        q9,
        G9,
        WP
      ], (n) => !n(e, t, WP));
    }, Y9 = (e, t, n) => {
      n || !i1(e) ? WP(e, t) : K9(e, t);
    }, X9 = I9("mceclip"), J9 = (e) => {
      const t = UP();
      return YI(t, e), VP(t), t;
    }, r7 = (e, t, n, r, a) => {
      const c = U9(e, t, n);
      if (!c.cancelled) {
        const d = c.content, h = () => Y9(e, d, r);
        a ? r5(e, "insertFromPaste", { dataTransfer: J9(d) }).isDefaultPrevented() || (h(), K3(e, "insertFromPaste")) : h();
      }
    }, m5 = (e, t, n, r) => {
      const a = n || JI(t);
      r7(e, z9(t), a, !1, r);
    }, GP = (e, t, n) => {
      const r = e.dom.encode(t).replace(/\r\n/g, `
`), a = Af(r, Ov(e)), c = D9(a, li(e), Mg(e));
      r7(e, c, !1, !0, n);
    }, s7 = (e) => {
      const t = {};
      if (e && e.types)
        for (let n = 0; n < e.types.length; n++) {
          const r = e.types[n];
          try {
            t[r] = e.getData(r);
          } catch {
            t[r] = "";
          }
        }
      return t;
    }, dv = (e, t) => t in e && e[t].length > 0, a7 = (e) => dv(e, "text/html") || dv(e, "text/plain"), Q9 = (e, t) => {
      const n = t.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
      return Xe(n) ? e.dom.encode(n[1]) : void 0;
    }, eU = (e, t, n, r) => {
      const a = X9(), c = hc(e) && Xe(n.name), d = c ? Q9(e, n.name) : a, h = c ? n.name : void 0, k = t.create(a, n, r, d, h);
      return t.add(k), k;
    }, tU = (e, t) => {
      n4(t.uri).each(({ data: n, type: r, base64Encoded: a }) => {
        const c = a ? n : btoa(n), d = t.file, h = e.editorUpload.blobCache, k = h.getByData(c, r), D = k ?? eU(e, h, d, c);
        m5(e, `<img src="${D.blobUri()}">`, !1, !0);
      });
    }, nU = (e) => e.type === "paste", oU = (e) => Promise.all(oo(e, (t) => kA(t).then((n) => ({
      file: t,
      uri: n
    })))), rU = (e) => {
      const t = Av(e);
      return (n) => Dr(n.type, "image/") && cr(t, (r) => F9(r) === n.type);
    }, sU = (e, t) => {
      const n = t.items ? ho(_n(t.items), (a) => a.kind === "file" ? [a.getAsFile()] : []) : [], r = t.files ? _n(t.files) : [];
      return ct(n.length > 0 ? n : r, rU(e));
    }, i7 = (e, t, n) => {
      const r = nU(t) ? t.clipboardData : t.dataTransfer;
      if (l0(e) && r) {
        const a = sU(e, r);
        if (a.length > 0)
          return t.preventDefault(), oU(a).then((c) => {
            n && e.selection.setRng(n), ut(c, (d) => {
              tU(e, d);
            });
          }), !0;
      }
      return !1;
    }, aU = (e) => {
      var t, n;
      return nr.os.isAndroid() && ((n = (t = e.clipboardData) === null || t === void 0 ? void 0 : t.items) === null || n === void 0 ? void 0 : n.length) === 0;
    }, iU = (e) => yn.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45, KP = (e, t, n, r, a) => {
      let c = n7(n);
      const d = dv(t, f5()) || JI(n), h = !d && O9(c), k = qP(c);
      (e7(c) || !c.length || h && !k) && (r = !0), (r || k) && (dv(t, "text/plain") && h ? c = t["text/plain"] : c = P9(c)), !e7(c) && (r ? GP(e, c, a) : m5(e, c, d, a));
    }, lU = (e, t, n) => {
      let r;
      const a = () => t.getLastRng() || e.selection.getRng();
      e.on("keydown", (c) => {
        iU(c) && !c.isDefaultPrevented() && (r = c.shiftKey && c.keyCode === 86);
      }), e.on("paste", (c) => {
        if (c.isDefaultPrevented() || aU(c))
          return;
        const d = n.get() === "text" || r;
        r = !1;
        const h = s7(c.clipboardData);
        !a7(h) && i7(e, c, a()) || (dv(h, "text/html") ? (c.preventDefault(), KP(e, h, h["text/html"], d, !0)) : dv(h, "text/plain") && dv(h, "text/uri-list") ? (c.preventDefault(), KP(e, h, h["text/plain"], d, !0)) : (t.create(), du.setEditorTimeout(e, () => {
          const k = t.getHtml();
          t.remove(), KP(e, h, k, d, !1);
        }, 0)));
      });
    }, cU = (e) => {
      const t = (a) => Dr(a, "webkit-fake-url"), n = (a) => Dr(a, "data:"), r = (a) => {
        var c;
        return ((c = a.data) === null || c === void 0 ? void 0 : c.paste) === !0;
      };
      e.parser.addNodeFilter("img", (a, c, d) => {
        if (!l0(e) && r(d))
          for (const h of a) {
            const k = h.attr("src");
            Ot(k) && !h.attr("data-mce-object") && k !== nr.transparentSrc && (t(k) || !Uw(e) && n(k)) && h.remove();
          }
      });
    }, uU = (e, t, n) => {
      lU(e, t, n), cU(e);
    }, dU = (e, t) => {
      t.get() === "text" ? (t.set("html"), lS(e, !1)) : (t.set("text"), lS(e, !0)), e.focus();
    }, fU = (e, t) => {
      e.addCommand("mceTogglePlainTextPaste", () => {
        dU(e, t);
      }), e.addCommand("mceInsertClipboardContent", (n, r) => {
        r.html && m5(e, r.html, r.internal, !1), r.text && GP(e, r.text, !1);
      });
    }, mU = (e, t, n) => {
      if (e)
        try {
          return e.clearData(), e.setData("text/html", t), e.setData("text/plain", n), e.setData(f5(), t), !0;
        } catch {
          return !1;
        }
      else
        return !1;
    }, l7 = (e, t, n, r) => {
      mU(e.clipboardData, t.html, t.text) ? (e.preventDefault(), r()) : n(t.html, r);
    }, c7 = (e) => (t, n) => {
      const { dom: r, selection: a } = e, c = r.create("div", {
        contenteditable: "false",
        "data-mce-bogus": "all"
      }), d = r.create("div", { contenteditable: "true" }, t);
      r.setStyles(c, {
        position: "fixed",
        top: "0",
        left: "-3000px",
        width: "1000px",
        overflow: "hidden"
      }), c.appendChild(d), r.add(e.getBody(), c);
      const h = a.getRng();
      d.focus();
      const k = r.createRng();
      k.selectNodeContents(d), a.setRng(k), du.setEditorTimeout(e, () => {
        a.setRng(h), r.remove(c), n();
      }, 0);
    }, u7 = (e) => ({
      html: T9(e.selection.getContent({ contextual: !0 })),
      text: e.selection.getContent({ format: "text" })
    }), pU = (e) => !!e.dom.getParent(e.selection.getStart(), "td[data-mce-selected],th[data-mce-selected]", e.getBody()), d7 = (e) => !e.selection.isCollapsed() || pU(e), gU = (e) => (t) => {
      !t.isDefaultPrevented() && d7(e) && e.selection.isEditable() && l7(t, u7(e), c7(e), () => {
        if (nr.browser.isChromium() || nr.browser.isFirefox()) {
          const n = e.selection.getRng();
          du.setEditorTimeout(e, () => {
            e.selection.setRng(n), e.execCommand("Delete");
          }, 0);
        } else
          e.execCommand("Delete");
      });
    }, hU = (e) => (t) => {
      !t.isDefaultPrevented() && d7(e) && l7(t, u7(e), c7(e), ht);
    }, bU = (e) => {
      e.on("cut", gU(e)), e.on("copy", hU(e));
    }, f7 = (e, t) => {
      var n, r;
      return Fg.getCaretRangeFromPoint((n = t.clientX) !== null && n !== void 0 ? n : 0, (r = t.clientY) !== null && r !== void 0 ? r : 0, e.getDoc());
    }, yU = (e) => {
      const t = e["text/plain"];
      return t ? t.indexOf("file://") === 0 : !1;
    }, m7 = (e, t) => {
      e.focus(), t && e.selection.setRng(t);
    }, vU = (e) => cr(e.files, (t) => /^image\//.test(t.type)), xU = (e, t, n, r) => {
      const a = e.getParent(n, (d) => ef(t, d));
      if (!We(e.getParent(n, "summary")))
        return !0;
      if (a && Yn(r, "text/html")) {
        const d = new DOMParser().parseFromString(r["text/html"], "text/html").body;
        return !We(d.querySelector(a.nodeName.toLowerCase()));
      } else
        return !1;
    }, wU = (e) => {
      e.on("input", (t) => {
        const n = (r) => We(r.querySelector("summary"));
        if (t.inputType === "deleteByDrag") {
          const r = ct(e.dom.select("details"), n);
          ut(r, (a) => {
            cs(a.firstChild) && a.firstChild.remove();
            const c = e.dom.create("summary");
            c.appendChild(Vm().dom), a.prepend(c);
          });
        }
      });
    }, kU = (e, t) => {
      Hb(e) && e.on("dragend dragover draggesture dragdrop drop drag", (n) => {
        n.preventDefault(), n.stopPropagation();
      }), l0(e) || e.on("drop", (n) => {
        const r = n.dataTransfer;
        r && vU(r) && n.preventDefault();
      }), e.on("drop", (n) => {
        if (n.isDefaultPrevented())
          return;
        const r = f7(e, n);
        if (jn(r))
          return;
        const a = s7(n.dataTransfer), c = dv(a, f5());
        if ((!a7(a) || yU(a)) && i7(e, n, r))
          return;
        const d = a[f5()], h = d || a["text/html"] || a["text/plain"], k = xU(e.dom, e.schema, r.startContainer, a), D = t.get();
        D && !k || h && (n.preventDefault(), du.setEditorTimeout(e, () => {
          e.undoManager.transact(() => {
            (d || D && k) && e.execCommand("Delete"), m7(e, r);
            const H = n7(h);
            a["text/html"] ? m5(e, H, c, !0) : GP(e, H, !0);
          });
        }));
      }), e.on("dragstart", (n) => {
        t.set(!0);
      }), e.on("dragover dragend", (n) => {
        l0(e) && !t.get() && (n.preventDefault(), m7(e, f7(e, n))), n.type === "dragend" && t.set(!1);
      }), wU(e);
    }, _U = (e) => {
      const t = (a) => (c) => {
        a(e, c);
      }, n = $w(e);
      un(n) && e.on("PastePreProcess", t(n));
      const r = fC(e);
      un(r) && e.on("PastePostProcess", t(r));
    }, CU = (e, t) => {
      e.on("PastePreProcess", (n) => {
        n.content = t(e, n.content, n.internal);
      });
    }, SU = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi, p7 = (e) => Ht.trim(e).replace(SU, ql).toLowerCase(), EU = (e, t, n) => {
      const r = mC(e);
      if (n || r === "all" || !Vw(e))
        return t;
      const a = r ? r.split(/[, ]/) : [];
      if (a && r !== "none") {
        const c = e.dom, d = e.selection.getNode();
        t = t.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, (h, k, D, H) => {
          const U = c.parseStyle(c.decode(D)), G = {};
          for (let ye = 0; ye < a.length; ye++) {
            const ae = U[a[ye]];
            let xe = ae, Ne = c.getStyle(d, a[ye], !0);
            /color/.test(a[ye]) && (xe = p7(xe), Ne = p7(Ne)), Ne !== xe && (G[a[ye]] = ae);
          }
          const ie = c.serializeStyle(G, "span");
          return ie ? k + ' style="' + ie + '"' + H : k + H;
        });
      } else
        t = t.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, "$1$3");
      return t = t.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, (c, d, h, k) => d + ' style="' + h + '"' + k), t;
    }, TU = (e) => {
      (nr.browser.isChromium() || nr.browser.isSafari()) && CU(e, EU);
    }, zU = (e) => {
      const t = Ja(!1), n = Ja(c0(e) ? "text" : "html"), r = L9(e);
      TU(e), fU(e, n), _U(e), e.on("PreInit", () => {
        bU(e), kU(e, t), uU(e, r, n);
      });
    }, OU = (e) => {
      e.on("click", (t) => {
        e.dom.getParent(t.target, "details") && t.preventDefault();
      });
    }, AU = (e) => {
      e.parser.addNodeFilter("details", (t) => {
        const n = hC(e);
        ut(t, (r) => {
          n === "expanded" ? r.attr("open", "open") : n === "collapsed" && r.attr("open", null);
        });
      }), e.serializer.addNodeFilter("details", (t) => {
        const n = bC(e);
        ut(t, (r) => {
          n === "expanded" ? r.attr("open", "open") : n === "collapsed" && r.attr("open", null);
        });
      });
    }, DU = (e) => {
      OU(e), AU(e);
    }, RU = cs, g7 = At, NU = (e) => Kr(e.dom), MU = (e) => cc(e.dom), h7 = (e) => (t) => Le(be.fromDom(e), t), BU = (e, t, n) => st(be.fromDom(e), (r) => MU(r) || n.isBlock(Eo(r)), h7(t)).getOr(be.fromDom(t)).dom, b7 = (e, t) => st(be.fromDom(e), NU, h7(t)), y7 = (e, t, n) => {
      const r = new vi(e, t), a = n ? r.next.bind(r) : r.prev.bind(r);
      let c = e;
      for (let d = n ? e : a(); d && !RU(d); d = a())
        Sr(d) && (c = d);
      return c;
    }, LU = (e, t, n) => {
      const a = nt.fromRangeStart(e).getNode(), c = BU(a, t, n), d = y7(a, c, !1), h = y7(a, c, !0), k = document.createRange();
      return b7(d, c).fold(() => {
        g7(d) ? k.setStart(d, 0) : k.setStartBefore(d);
      }, (D) => k.setStartBefore(D.dom)), b7(h, c).fold(() => {
        g7(h) ? k.setEnd(h, h.data.length) : k.setEndAfter(h);
      }, (D) => k.setEndAfter(D.dom)), k;
    }, PU = (e) => {
      const t = LU(e.selection.getRng(), e.getBody(), e.schema);
      e.selection.setRng(TE(t));
    }, IU = (e) => {
      e.on("mousedown", (t) => {
        t.detail >= 3 && (t.preventDefault(), PU(e));
      });
    };
    var $2;
    (function(e) {
      e.Before = "before", e.After = "after";
    })($2 || ($2 = {}));
    const FU = (e, t) => Math.abs(e.left - t), $U = (e, t) => Math.abs(e.right - t), HU = (e, t) => e >= t.top && e <= t.bottom, VU = (e, t) => e.top < t.bottom && e.bottom > t.top, UU = (e, t) => {
      const n = Ll(e, t) / Math.min(e.height, t.height);
      return VU(e, t) && n > 0.5;
    }, jU = (e, t) => {
      const n = ct(e, (r) => HU(t, r));
      return Yy(n).fold(() => [
        [],
        e
      ], (r) => {
        const {
          pass: a,
          fail: c
        } = It(e, (d) => UU(d, r));
        return [
          a,
          c
        ];
      });
    }, ZU = (e, t) => ({
      node: e.node,
      position: FU(e, t) < $U(e, t) ? $2.Before : $2.After
    }), WU = (e, t, n) => t > e.left && t < e.right ? 0 : Math.min(Math.abs(e.left - t), Math.abs(e.right - t)), YP = (e, t, n, r) => {
      const a = (U) => Sr(U.node) ? K.some(U) : wn(U.node) ? YP(_n(U.node.childNodes), t, n, !1) : K.none(), c = (U, G, ie) => a(G).filter((ye) => Math.abs(ie(U, t, n) - ie(ye, t, n)) < 2 && At(ye.node)), d = (U, G) => {
        const ie = Po(U, (ye, ae) => G(ye, t, n) - G(ae, t, n));
        return Ys(ie, a).map((ye) => r && !At(ye.node) && ie.length > 1 ? c(ye, ie[1], G).getOr(ye) : ye);
      }, [h, k] = jU(tN(e), n), {
        pass: D,
        fail: H
      } = It(k, (U) => U.top < n);
      return d(h, WU).orThunk(() => d(H, Xy)).orThunk(() => d(D, Xy));
    }, qU = (e, t, n, r) => {
      const a = (c, d) => {
        const h = (D) => wn(D) && D.classList.contains("mce-drag-container"), k = ct(c.dom.childNodes, yo(h));
        return d.fold(() => YP(k, n, r, !0), (D) => {
          const H = ct(k, (U) => U !== D.dom);
          return YP(H, n, r, !0);
        }).orThunk(() => (Le(c, e) ? K.none() : Lr(c)).bind((H) => a(H, K.some(c))));
      };
      return a(t, K.none());
    }, GU = (e, t, n) => {
      const r = be.fromDom(e), a = Sn(r), d = be.fromPoint(a, t, n).filter((h) => Dt(r, h)).getOr(r);
      return qU(r, d, t, n);
    }, v7 = (e, t, n) => GU(e, t, n).filter((r) => u1(r.node)).map((r) => ZU(r, t)), x7 = (e) => {
      var t, n;
      const r = e.getBoundingClientRect(), a = e.ownerDocument, c = a.documentElement, d = a.defaultView;
      return {
        top: r.top + ((t = d == null ? void 0 : d.scrollY) !== null && t !== void 0 ? t : 0) - c.clientTop,
        left: r.left + ((n = d == null ? void 0 : d.scrollX) !== null && n !== void 0 ? n : 0) - c.clientLeft
      };
    }, KU = (e) => e.inline ? x7(e.getBody()) : {
      left: 0,
      top: 0
    }, YU = (e) => {
      const t = e.getBody();
      return e.inline ? {
        left: t.scrollLeft,
        top: t.scrollTop
      } : {
        left: 0,
        top: 0
      };
    }, XU = (e) => {
      const t = e.getBody(), n = e.getDoc().documentElement, r = {
        left: t.scrollLeft,
        top: t.scrollTop
      }, a = {
        left: t.scrollLeft || n.scrollLeft,
        top: t.scrollTop || n.scrollTop
      };
      return e.inline ? r : a;
    }, JU = (e, t) => {
      if (t.target.ownerDocument !== e.getDoc()) {
        const n = x7(e.getContentAreaContainer()), r = XU(e);
        return {
          left: t.pageX - n.left + r.left,
          top: t.pageY - n.top + r.top
        };
      }
      return {
        left: t.pageX,
        top: t.pageY
      };
    }, QU = (e, t, n) => ({
      pageX: n.left - e.left + t.left,
      pageY: n.top - e.top + t.top
    }), ej = (e, t) => QU(KU(e), YU(e), JU(e, t)), w7 = (e) => ({
      target: e,
      srcElement: e
    }), tj = (e, t, n, r) => ({
      ...t,
      dataTransfer: r,
      type: e,
      ...w7(n)
    }), nj = (e, t, n) => {
      const r = Ct("Function not supported on simulated event.");
      return {
        bubbles: !0,
        cancelBubble: !1,
        cancelable: !0,
        composed: !1,
        currentTarget: null,
        defaultPrevented: !1,
        eventPhase: 0,
        isTrusted: !0,
        returnValue: !1,
        timeStamp: 0,
        type: e,
        composedPath: r,
        initEvent: r,
        preventDefault: ht,
        stopImmediatePropagation: ht,
        stopPropagation: ht,
        AT_TARGET: window.Event.AT_TARGET,
        BUBBLING_PHASE: window.Event.BUBBLING_PHASE,
        CAPTURING_PHASE: window.Event.CAPTURING_PHASE,
        NONE: window.Event.NONE,
        altKey: !1,
        button: 0,
        buttons: 0,
        clientX: 0,
        clientY: 0,
        ctrlKey: !1,
        metaKey: !1,
        movementX: 0,
        movementY: 0,
        offsetX: 0,
        offsetY: 0,
        pageX: 0,
        pageY: 0,
        relatedTarget: null,
        screenX: 0,
        screenY: 0,
        shiftKey: !1,
        x: 0,
        y: 0,
        detail: 0,
        view: null,
        which: 0,
        initUIEvent: r,
        initMouseEvent: r,
        getModifierState: r,
        dataTransfer: n,
        ...w7(t)
      };
    }, oj = (e, t) => {
      const n = S9(e);
      return t === "dragstart" ? (ZI(n), qI(n)) : t === "drop" ? (h9(n), VP(n)) : (b9(n), w9(n)), n;
    }, rj = (e, t, n, r) => {
      const a = oj(n, e);
      return ko(r) ? nj(e, t, a) : tj(e, r, t, a);
    }, p5 = 32, sj = 100, g5 = 8, h5 = 16, k7 = Kr, aj = sp(k7, cc), ij = (e, t, n) => k7(n) && n !== t && e.isEditable(n.parentElement), lj = (e, t, n) => jn(t) || t === n || e.dom.isChildOf(t, n) ? !1 : e.dom.isEditable(t), cj = (e, t, n, r) => {
      const a = e.dom, c = t.cloneNode(!0);
      a.setStyles(c, {
        width: n,
        height: r
      }), a.setAttrib(c, "data-mce-selected", null);
      const d = a.create("div", {
        class: "mce-drag-container",
        "data-mce-bogus": "all",
        unselectable: "on",
        contenteditable: "false"
      });
      return a.setStyles(d, {
        position: "absolute",
        opacity: 0.5,
        overflow: "hidden",
        border: 0,
        padding: 0,
        margin: 0,
        width: n,
        height: r
      }), a.setStyles(c, {
        margin: 0,
        boxSizing: "border-box"
      }), d.appendChild(c), d;
    }, uj = (e, t) => {
      e.parentNode !== t && t.appendChild(e);
    }, b5 = (e, t) => (n) => () => {
      const r = e === "left" ? n.scrollX : n.scrollY;
      n.scroll({
        [e]: r + t,
        behavior: "smooth"
      });
    }, _7 = b5("left", -p5), C7 = b5("left", p5), S7 = b5("top", -p5), E7 = b5("top", p5), dj = (e, t, n, r, a, c, d, h, k, D, H, U) => {
      let G = 0, ie = 0;
      e.style.left = t.pageX + "px", e.style.top = t.pageY + "px", t.pageX + n > a && (G = t.pageX + n - a), t.pageY + r > c && (ie = t.pageY + r - c), e.style.width = n - G + "px", e.style.height = r - ie + "px";
      const ye = k.clientHeight, ae = k.clientWidth, xe = d + k.getBoundingClientRect().top, Ne = h + k.getBoundingClientRect().left;
      H.on((Ie) => {
        Ie.intervalId.clear(), Ie.dragging && U && (d + g5 >= ye ? Ie.intervalId.set(E7(D)) : d - g5 <= 0 ? Ie.intervalId.set(S7(D)) : h + g5 >= ae ? Ie.intervalId.set(C7(D)) : h - g5 <= 0 ? Ie.intervalId.set(_7(D)) : xe + h5 >= window.innerHeight ? Ie.intervalId.set(E7(window)) : xe - h5 <= 0 ? Ie.intervalId.set(S7(window)) : Ne + h5 >= window.innerWidth ? Ie.intervalId.set(C7(window)) : Ne - h5 <= 0 && Ie.intervalId.set(_7(window)));
      });
    }, T7 = (e) => {
      e && e.parentNode && e.parentNode.removeChild(e);
    }, fj = (e, t) => {
      const n = e.getParent(t.parentNode, e.isBlock);
      T7(t), n && n !== e.getRoot() && e.isEmpty(n) && zf(be.fromDom(n));
    }, mj = (e) => e.button === 0, pj = (e, t) => ({
      pageX: t.pageX - e.relX,
      pageY: t.pageY + 5
    }), gj = (e, t) => (n) => {
      if (mj(n)) {
        const r = po(t.dom.getParents(n.target), aj).getOr(null);
        if (Xe(r) && ij(t.dom, t.getBody(), r)) {
          const a = t.dom.getPos(r), c = t.getBody(), d = t.getDoc().documentElement;
          e.set({
            element: r,
            dataTransfer: UP(),
            dragging: !1,
            screenX: n.screenX,
            screenY: n.screenY,
            maxX: (t.inline ? c.scrollWidth : d.offsetWidth) - 2,
            maxY: (t.inline ? c.scrollHeight : d.offsetHeight) - 2,
            relX: n.pageX - a.x,
            relY: n.pageY - a.y,
            width: r.offsetWidth,
            height: r.offsetHeight,
            ghost: cj(t, r, r.offsetWidth, r.offsetHeight),
            intervalId: xb(sj)
          });
        }
      }
    }, hj = (e, t, n) => {
      e._selectionOverrides.hideFakeCaret(), v7(e.getBody(), t, n).fold(() => e.selection.placeCaretAt(t, n), (r) => {
        const a = e._selectionOverrides.showCaret(1, r.node, r.position === $2.Before, !1);
        a ? e.selection.setRng(a) : e.selection.placeCaretAt(t, n);
      });
    }, Q3 = (e, t, n, r, a) => {
      t === "dragstart" && YI(r, e.dom.getOuterHTML(n));
      const c = rj(t, n, r, a);
      return e.dispatch(t, c);
    }, bj = (e, t) => {
      const n = xh((a, c) => hj(t, a, c), 0);
      t.on("remove", n.cancel);
      const r = e;
      return (a) => e.on((c) => {
        const d = Math.max(Math.abs(a.screenX - c.screenX), Math.abs(a.screenY - c.screenY));
        if (!c.dragging && d > 10) {
          const h = Q3(t, "dragstart", c.element, c.dataTransfer, a);
          if (Xe(h.dataTransfer) && (c.dataTransfer = h.dataTransfer), h.isDefaultPrevented())
            return;
          c.dragging = !0, t.focus();
        }
        if (c.dragging) {
          const h = a.currentTarget === t.getDoc().documentElement, k = pj(c, ej(t, a));
          uj(c.ghost, t.getBody()), dj(c.ghost, k, c.width, c.height, c.maxX, c.maxY, a.clientY, a.clientX, t.getContentAreaContainer(), t.getWin(), r, h), n.throttle(a.clientX, a.clientY);
        }
      });
    }, yj = (e) => {
      const t = e.getSel();
      if (Xe(t)) {
        const r = t.getRangeAt(0).startContainer;
        return At(r) ? r.parentNode : r;
      } else
        return null;
    }, vj = (e, t) => (n) => {
      e.on((r) => {
        var a;
        if (r.intervalId.clear(), r.dragging) {
          if (lj(t, yj(t.selection), r.element)) {
            const c = (a = t.getDoc().elementFromPoint(n.clientX, n.clientY)) !== null && a !== void 0 ? a : t.getBody();
            Q3(t, "drop", c, r.dataTransfer, n).isDefaultPrevented() || t.undoManager.transact(() => {
              fj(t.dom, r.element), E9(r.dataTransfer).each((h) => t.insertContent(h)), t._selectionOverrides.hideFakeCaret();
            });
          }
          Q3(t, "dragend", t.getBody(), r.dataTransfer, n);
        }
      }), O7(e);
    }, z7 = (e, t, n) => {
      e.on((r) => {
        r.intervalId.clear(), r.dragging && n.fold(() => Q3(t, "dragend", r.element, r.dataTransfer), (a) => Q3(t, "dragend", r.element, r.dataTransfer, a));
      }), O7(e);
    }, xj = (e, t) => (n) => z7(e, t, K.some(n)), O7 = (e) => {
      e.on((t) => {
        t.intervalId.clear(), T7(t.ghost);
      }), e.clear();
    }, wj = (e) => {
      const t = sf(), n = gs.DOM, r = document, a = gj(t, e), c = bj(t, e), d = vj(t, e), h = xj(t, e);
      e.on("mousedown", a), e.on("mousemove", c), e.on("mouseup", d), n.bind(r, "mousemove", c), n.bind(r, "mouseup", h), e.on("remove", () => {
        n.unbind(r, "mousemove", c), n.unbind(r, "mouseup", h);
      }), e.on("keydown", (k) => {
        k.keyCode === yn.ESC && z7(t, e, K.none());
      });
    }, kj = (e) => {
      const t = (a) => {
        if (!a.isDefaultPrevented()) {
          const c = a.dataTransfer;
          c && (So(c.types, "Files") || c.files.length > 0) && (a.preventDefault(), a.type === "drop" && qx(e, "Dropped file type is not supported"));
        }
      }, n = (a) => {
        N0(e, a.target) && t(a);
      }, r = () => {
        const a = gs.DOM, c = e.dom, d = document, h = e.inline ? e.getBody() : e.getDoc(), k = [
          "drop",
          "dragover"
        ];
        ut(k, (D) => {
          a.bind(d, D, n), c.bind(h, D, t);
        }), e.on("remove", () => {
          ut(k, (D) => {
            a.unbind(d, D, n), c.unbind(h, D, t);
          });
        });
      };
      e.on("init", () => {
        du.setEditorTimeout(e, r, 0);
      });
    }, _j = (e) => {
      wj(e), s1(e) && kj(e);
    }, Cj = (e) => {
      const t = xh(() => {
        if (!e.removed && e.getBody().contains(document.activeElement)) {
          const n = e.selection.getRng();
          if (n.collapsed) {
            const r = v3(e, n, !1);
            e.selection.setRng(r);
          }
        }
      }, 0);
      e.on("focus", () => {
        t.throttle();
      }), e.on("blur", () => {
        t.cancel();
      });
    }, Sj = (e) => {
      e.on("init", () => {
        e.on("focusin", (t) => {
          const n = t.target;
          if (pn(n)) {
            const r = Uh(e.getBody(), n), a = Kr(r) ? r : n;
            e.selection.getNode() !== a && Jx(e, a).each((c) => e.selection.setRng(c));
          }
        });
      });
    }, eT = Kr, A7 = (e, t) => Uh(e.getBody(), t), Ej = (e) => {
      const t = e.selection, n = e.dom, r = e.getBody(), a = p0(e, r, n.isBlock, () => ty(e)), c = "sel-" + n.uniqueId(), d = "data-mce-selected";
      let h;
      const k = (fn) => Xe(fn) && n.hasClass(fn, "mce-offscreen-selection"), D = (fn) => fn !== r && (eT(fn) || pn(fn)) && n.isChildOf(fn, r) && n.isEditable(fn.parentNode), H = (fn) => {
        fn && t.setRng(fn);
      }, U = (fn, at, et, Mt = !0) => e.dispatch("ShowCaret", {
        target: at,
        direction: fn,
        before: et
      }).isDefaultPrevented() ? null : (Mt && t.scrollIntoView(at, fn === -1), a.show(et, at)), G = (fn) => {
        fn.hasAttribute("data-mce-caret") && (Um(fn), t.scrollIntoView(fn));
      }, ie = () => {
        e.on("click", (at) => {
          n.isEditable(at.target) || (at.preventDefault(), e.focus());
        }), e.on("blur NewBlock", je), e.on("ResizeWindow FullscreenStateChanged", a.reposition), e.on("tap", (at) => {
          const et = at.target, Mt = A7(e, et);
          eT(Mt) ? (at.preventDefault(), Jx(e, Mt).each(Fe)) : D(et) && Jx(e, et).each(Fe);
        }, !0), e.on("mousedown", (at) => {
          const et = at.target;
          if (et !== r && et.nodeName !== "HTML" && !n.isChildOf(et, r) || !XD(e, at.clientX, at.clientY))
            return;
          je(), Zt();
          const Mt = A7(e, et);
          eT(Mt) ? (at.preventDefault(), Jx(e, Mt).each(Fe)) : v7(r, at.clientX, at.clientY).each((gn) => {
            at.preventDefault();
            const Fn = U(1, gn.node, gn.position === $2.Before, !1);
            H(Fn), ta(Mt) ? Mt.focus() : e.getBody().focus();
          });
        }), e.on("keypress", (at) => {
          yn.modifierPressed(at) || eT(t.getNode()) && at.preventDefault();
        }), e.on("GetSelectionRange", (at) => {
          let et = at.range;
          if (h) {
            if (!h.parentNode) {
              h = null;
              return;
            }
            et = et.cloneRange(), et.selectNode(h), at.range = et;
          }
        }), e.on("SetSelectionRange", (at) => {
          at.range = xe(at.range);
          const et = Fe(at.range, at.forward);
          et && (at.range = et);
        });
        const fn = (at) => wn(at) && at.id === "mcepastebin";
        e.on("AfterSetSelectionRange", (at) => {
          const et = at.range, Mt = et.startContainer.parentElement;
          !ae(et) && !fn(Mt) && Zt(), k(Mt) || je();
        }), _j(e), Cj(e), Sj(e);
      }, ye = (fn) => Tn(fn) || Ha(fn) || Xa(fn), ae = (fn) => ye(fn.startContainer) || ye(fn.endContainer), xe = (fn) => {
        const at = e.schema.getVoidElements(), et = n.createRng(), Mt = fn.startContainer, gn = fn.startOffset, Fn = fn.endContainer, Uo = fn.endOffset;
        return Yn(at, Mt.nodeName.toLowerCase()) ? gn === 0 ? et.setStartBefore(Mt) : et.setStartAfter(Mt) : et.setStart(Mt, gn), Yn(at, Fn.nodeName.toLowerCase()) ? Uo === 0 ? et.setEndBefore(Fn) : et.setEndAfter(Fn) : et.setEnd(Fn, Uo), et;
      }, Ne = (fn, at) => {
        const et = be.fromDom(e.getBody()), Mt = e.getDoc(), gn = Ia(et, "#" + c).getOrThunk(() => {
          const qo = be.fromHtml('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>', Mt);
          return Vr(qo, "id", c), Ir(et, qo), qo;
        }), Fn = n.createRng();
        yi(gn), Fa(gn, [
          be.fromText(Bo, Mt),
          be.fromDom(at),
          be.fromText(Bo, Mt)
        ]), Fn.setStart(gn.dom.firstChild, 1), Fn.setEnd(gn.dom.lastChild, 0), Vl(gn, { top: n.getPos(fn, e.getBody()).y + "px" }), bz(gn);
        const Uo = t.getSel();
        return Uo && (Uo.removeAllRanges(), Uo.addRange(Fn)), Fn;
      }, Ie = (fn) => {
        const at = fn.cloneNode(!0), et = e.dispatch("ObjectSelected", {
          target: fn,
          targetClone: at
        });
        if (et.isDefaultPrevented())
          return null;
        const Mt = Ne(fn, et.targetClone), gn = be.fromDom(fn);
        return ut(Ni(be.fromDom(e.getBody()), `*[${d}]`), (Fn) => {
          Le(gn, Fn) || xs(Fn, d);
        }), n.getAttrib(fn, d) || fn.setAttribute(d, "1"), h = fn, Zt(), Mt;
      }, Fe = (fn, at) => {
        if (!fn)
          return null;
        if (fn.collapsed) {
          if (!ae(fn)) {
            const Fn = at ? 1 : -1, Uo = Nc(Fn, r, fn), qo = Uo.getNode(!at);
            if (Xe(qo)) {
              if (u1(qo))
                return U(Fn, qo, at ? !Uo.isAtEnd() : !1, !1);
              if (on(qo) && Kr(qo.nextSibling)) {
                const Vs = n.createRng();
                return Vs.setStart(qo, 0), Vs.setEnd(qo, 0), Vs;
              }
            }
            const vs = Uo.getNode(at);
            if (Xe(vs)) {
              if (u1(vs))
                return U(Fn, vs, at ? !1 : !Uo.isAtEnd(), !1);
              if (on(vs) && Kr(vs.previousSibling)) {
                const Vs = n.createRng();
                return Vs.setStart(vs, 1), Vs.setEnd(vs, 1), Vs;
              }
            }
          }
          return null;
        }
        let et = fn.startContainer, Mt = fn.startOffset;
        const gn = fn.endOffset;
        if (At(et) && Mt === 0 && eT(et.parentNode) && (et = et.parentNode, Mt = n.nodeIndex(et), et = et.parentNode), !wn(et))
          return null;
        if (gn === Mt + 1 && et === fn.endContainer) {
          const Fn = et.childNodes[Mt];
          if (D(Fn))
            return Ie(Fn);
        }
        return null;
      }, je = () => {
        h && h.removeAttribute(d), Ia(be.fromDom(e.getBody()), "#" + c).each(dr), h = null;
      }, _t = () => {
        a.destroy(), h = null;
      }, Zt = () => {
        a.hide();
      };
      return yp(e) || ie(), {
        showCaret: U,
        showBlockCaretContainer: G,
        hideFakeCaret: Zt,
        destroy: _t
      };
    }, Tj = (e, t) => {
      let n = t;
      for (let r = e.previousSibling; At(r); r = r.previousSibling)
        n += r.data.length;
      return n;
    }, D7 = (e, t, n, r, a) => {
      if (At(n) && (r < 0 || r > n.data.length))
        return [];
      const c = a && At(n) ? [Tj(n, r)] : [r];
      let d = n;
      for (; d !== t && d.parentNode; )
        c.push(e.nodeIndex(d, a)), d = d.parentNode;
      return d === t ? c.reverse() : [];
    }, XP = (e, t, n, r, a, c, d = !1) => {
      const h = D7(e, t, n, r, d), k = D7(e, t, a, c, d);
      return {
        start: h,
        end: k
      };
    }, R7 = (e, t) => {
      const n = t.slice(), r = n.pop();
      return M(r) ? co(n, (c, d) => c.bind((h) => K.from(h.childNodes[d])), K.some(e)).bind((c) => At(c) && (r < 0 || r > c.data.length) ? K.none() : K.some({
        node: c,
        offset: r
      })) : K.none();
    }, N7 = (e, t) => R7(e, t.start).bind(({
      node: n,
      offset: r
    }) => R7(e, t.end).map(({
      node: a,
      offset: c
    }) => {
      const d = document.createRange();
      return d.setStart(n, r), d.setEnd(a, c), d;
    })), zj = (e, t, n, r = !1) => XP(e, t, n.startContainer, n.startOffset, n.endContainer, n.endOffset, r), H2 = (e, t, n) => {
      if (t && e.isEmpty(t) && !n(t)) {
        const r = t.parentNode;
        e.remove(t, At(t.firstChild) && pd(t.firstChild.data)), H2(e, r, n);
      }
    }, y5 = (e, t, n, r = !0) => {
      const a = t.startContainer.parentNode, c = t.endContainer.parentNode;
      t.deleteContents(), r && !n(t.startContainer) && (At(t.startContainer) && t.startContainer.data.length === 0 && e.remove(t.startContainer), At(t.endContainer) && t.endContainer.data.length === 0 && e.remove(t.endContainer), H2(e, a, n), a !== c && H2(e, c, n));
    }, JP = (e, t) => K.from(e.dom.getParent(t.startContainer, e.dom.isBlock)), M7 = (e, t, n) => {
      const r = e.dynamicPatternsLookup({
        text: n,
        block: t
      });
      return {
        ...e,
        blockPatterns: Lt(r).concat(e.blockPatterns),
        inlinePatterns: Vt(r).concat(e.inlinePatterns)
      };
    }, B7 = (e, t, n, r) => {
      const a = e.createRng();
      return a.setStart(t, 0), a.setEnd(n, r), a.toString();
    }, Oj = (e) => /^\s[^\s]/.test(e), L7 = (e, t, n) => {
      S$(t, 0, t).each((a) => {
        const c = a.container;
        V8(c, n.start.length, t).each((k) => {
          const D = e.createRng();
          D.setStart(c, 0), D.setEnd(k.container, k.offset), y5(e, D, (H) => H === t);
        });
        const d = be.fromDom(c), h = ld(d);
        Oj(h) && Yd(d, h.slice(1));
      });
    }, Aj = (e, t) => {
      const n = e.dom, r = t.pattern, a = N7(n.getRoot(), t.range).getOrDie("Unable to resolve path range"), c = (d, h) => {
        const k = h.get(d);
        return Se(k) && ro(k).exists((D) => Yn(D, "block"));
      };
      return JP(e, a).each((d) => {
        r.type === "block-format" ? c(r.format, e.formatter) && e.undoManager.transact(() => {
          L7(e.dom, d, r), e.formatter.apply(r.format);
        }) : r.type === "block-command" && e.undoManager.transact(() => {
          L7(e.dom, d, r), e.execCommand(r.cmd, !1, r.value);
        });
      }), !0;
    }, Dj = (e) => Po(e, (t, n) => n.start.length - t.start.length), Rj = (e, t) => {
      const n = Dj(e), r = t.replace(Bo, " ");
      return po(n, (a) => t.indexOf(a.start) === 0 || r.indexOf(a.start) === 0);
    }, Nj = (e, t, n, r) => {
      var a;
      const c = e.dom, d = li(e);
      if (!c.is(t, d))
        return [];
      const h = (a = t.textContent) !== null && a !== void 0 ? a : "";
      return Rj(n.blockPatterns, h).map((k) => Ht.trim(h).length === k.start.length ? [] : [{
        pattern: k,
        range: XP(c, c.getRoot(), t, 0, t, 0, r)
      }]).getOr([]);
    }, Mj = (e, t) => {
      if (t.length === 0)
        return;
      const n = e.selection.getBookmark();
      ut(t, (r) => Aj(e, r)), e.selection.moveToBookmark(n);
    }, P7 = (e, t) => e.create("span", {
      "data-mce-type": "bookmark",
      id: t
    }), v5 = (e, t) => {
      const n = e.createRng();
      return n.setStartAfter(t.start), n.setEndBefore(t.end), n;
    }, I7 = (e, t, n) => {
      const r = N7(e.getRoot(), n).getOrDie("Unable to resolve path range"), a = r.startContainer, c = r.endContainer, d = r.endOffset === 0 ? c : c.splitText(r.endOffset), h = r.startOffset === 0 ? a : a.splitText(r.startOffset), k = h.parentNode, D = d.parentNode;
      return {
        prefix: t,
        end: D.insertBefore(P7(e, t + "-end"), d),
        start: k.insertBefore(P7(e, t + "-start"), h)
      };
    }, F7 = (e, t, n) => {
      H2(e, e.get(t.prefix + "-end"), n), H2(e, e.get(t.prefix + "-start"), n);
    }, QP = (e) => e.start.length === 0, Bj = (e) => (t, n) => {
      const a = t.data.substring(0, n), c = a.lastIndexOf(e.charAt(e.length - 1)), d = a.lastIndexOf(e);
      return d !== -1 ? d + e.length : c !== -1 ? c + 1 : -1;
    }, $7 = (e, t, n, r) => {
      const a = t.start;
      return kP(e, r.container, r.offset, Bj(a), n).bind((d) => {
        var h, k;
        const D = (k = (h = n.textContent) === null || h === void 0 ? void 0 : h.indexOf(a)) !== null && k !== void 0 ? k : -1;
        if (D !== -1 && d.offset >= D + a.length) {
          const U = e.createRng();
          return U.setStart(d.container, d.offset - a.length), U.setEnd(d.container, d.offset), K.some(U);
        } else {
          const U = d.offset - a.length;
          return wP(d.container, U, n).map((G) => {
            const ie = e.createRng();
            return ie.setStart(G.container, G.offset), ie.setEnd(d.container, d.offset), ie;
          }).filter((G) => G.toString() === a).orThunk(() => $7(e, t, n, Yh(d.container, 0)));
        }
      });
    }, Lj = (e, t, n, r, a, c = !1) => {
      if (t.start.length === 0 && !c) {
        const d = e.createRng();
        return d.setStart(n, r), d.setEnd(n, r), K.some(d);
      }
      return xP(n, r, a).bind((d) => $7(e, t, a, d).bind((k) => {
        var D;
        if (c) {
          if (k.endContainer === d.container && k.endOffset === d.offset)
            return K.none();
          if (d.offset === 0 && ((D = k.endContainer.textContent) === null || D === void 0 ? void 0 : D.length) === k.endOffset)
            return K.none();
        }
        return K.some(k);
      }));
    }, Pj = (e, t, n, r) => {
      const a = e.dom, c = a.getRoot(), d = n.pattern, h = n.position.container, k = n.position.offset;
      return wP(h, k - n.pattern.end.length, t).bind((D) => {
        const H = XP(a, c, D.container, D.offset, h, k, r);
        if (QP(d))
          return K.some({
            matches: [{
              pattern: d,
              startRng: H,
              endRng: H
            }],
            position: D
          });
        {
          const U = x5(e, n.remainingPatterns, D.container, D.offset, t, r), G = U.getOr({
            matches: [],
            position: D
          }), ie = G.position;
          return Lj(a, d, ie.container, ie.offset, t, U.isNone()).map((ae) => {
            const xe = zj(a, c, ae, r);
            return {
              matches: G.matches.concat([{
                pattern: d,
                startRng: xe,
                endRng: H
              }]),
              position: Yh(ae.startContainer, ae.startOffset)
            };
          });
        }
      });
    }, x5 = (e, t, n, r, a, c) => {
      const d = e.dom;
      return xP(n, r, d.getRoot()).bind((h) => {
        const k = B7(d, a, n, r);
        for (let D = 0; D < t.length; D++) {
          const H = t[D];
          if (!El(k, H.end))
            continue;
          const U = t.slice();
          U.splice(D, 1);
          const G = Pj(e, a, {
            pattern: H,
            remainingPatterns: U,
            position: h
          }, c);
          if (G.isNone() && r > 0)
            return x5(e, t, n, r - 1, a, c);
          if (G.isSome())
            return G;
        }
        return K.none();
      });
    }, H7 = (e, t, n) => {
      e.selection.setRng(n), t.type === "inline-format" ? ut(t.format, (r) => {
        e.formatter.apply(r);
      }) : e.execCommand(t.cmd, !1, t.value);
    }, Ij = (e, t, n, r) => {
      const a = v5(e.dom, n);
      y5(e.dom, a, r), H7(e, t, a);
    }, Fj = (e, t, n, r, a) => {
      const c = e.dom, d = v5(c, r), h = v5(c, n);
      y5(c, h, a), y5(c, d, a);
      const k = {
        prefix: n.prefix,
        start: n.end,
        end: r.start
      }, D = v5(c, k);
      H7(e, t, D);
    }, $j = (e, t) => {
      const n = km("mce_textpattern"), r = xn(t, (a, c) => {
        const d = I7(e, n + `_end${a.length}`, c.endRng);
        return a.concat([{
          ...c,
          endMarker: d
        }]);
      }, []);
      return xn(r, (a, c) => {
        const d = r.length - a.length - 1, h = QP(c.pattern) ? c.endMarker : I7(e, n + `_start${d}`, c.startRng);
        return a.concat([{
          ...c,
          startMarker: h
        }]);
      }, []);
    }, Hj = (e) => Po(e, (t, n) => n.end.length - t.end.length), Vj = (e, t) => {
      const n = Ns(e, (r) => cr(t, (a) => r.pattern.start === a.pattern.start && r.pattern.end === a.pattern.end));
      return e.length === t.length ? n ? e : t : e.length > t.length ? e : t;
    }, V7 = (e, t, n, r, a, c) => {
      const d = x5(e, a.inlinePatterns, n, r, t, c).fold(() => [], (k) => k.matches), h = x5(e, Hj(a.inlinePatterns), n, r, t, c).fold(() => [], (k) => k.matches);
      return Vj(d, h);
    }, U7 = (e, t) => {
      if (t.length === 0)
        return;
      const n = e.dom, r = e.selection.getBookmark(), a = $j(n, t);
      ut(a, (c) => {
        const d = n.getParent(c.startMarker.start, n.isBlock), h = (k) => k === d;
        QP(c.pattern) ? Ij(e, c.pattern, c.endMarker, h) : Fj(e, c.pattern, c.startMarker, c.endMarker, h), F7(n, c.endMarker, h), F7(n, c.startMarker, h);
      }), e.selection.moveToBookmark(r);
    }, Uj = (e, t) => {
      const n = e.selection.getRng();
      return JP(e, n).map((r) => {
        var a;
        const c = Math.max(0, n.startOffset), d = M7(t, r, (a = r.textContent) !== null && a !== void 0 ? a : ""), h = V7(e, r, n.startContainer, c, d, !0), k = Nj(e, r, d, !0);
        return k.length > 0 || h.length > 0 ? (e.undoManager.add(), e.undoManager.extra(() => {
          e.execCommand("mceInsertNewLine");
        }, () => {
          se(e), U7(e, h), Mj(e, k);
          const D = e.selection.getRng(), H = xP(D.startContainer, D.startOffset, e.dom.getRoot());
          e.execCommand("mceInsertNewLine"), H.each((U) => {
            const G = U.container;
            G.data.charAt(U.offset - 1) === uc && (G.deleteData(U.offset - 1, 1), H2(e.dom, G.parentNode, (ie) => ie === e.dom.getRoot()));
          });
        }), !0) : !1;
      }).getOr(!1);
    }, jj = (e, t) => {
      const n = e.selection.getRng();
      JP(e, n).map((r) => {
        const a = Math.max(0, n.startOffset - 1), c = B7(e.dom, r, n.startContainer, a), d = M7(t, r, c), h = V7(e, r, n.startContainer, a, d, !1);
        h.length > 0 && e.undoManager.transact(() => {
          U7(e, h);
        });
      });
    }, j7 = (e, t, n) => {
      for (let r = 0; r < e.length; r++)
        if (n(e[r], t))
          return !0;
      return !1;
    }, Zj = (e, t) => j7(e, t, (n, r) => n === r.keyCode && !yn.modifierPressed(r)), Wj = (e, t) => j7(e, t, (n, r) => n.charCodeAt(0) === r.charCode), qj = (e) => {
      const t = [
        ",",
        ".",
        ";",
        ":",
        "!",
        "?"
      ], n = [32], r = () => rn(jw(e), u0(e)), a = () => gC(e);
      e.on("keydown", (d) => {
        if (d.keyCode === 13 && !yn.modifierPressed(d) && e.selection.isCollapsed()) {
          const h = r();
          (h.inlinePatterns.length > 0 || h.blockPatterns.length > 0 || a()) && Uj(e, h) && d.preventDefault();
        }
      }, !0);
      const c = () => {
        if (e.selection.isCollapsed()) {
          const d = r();
          (d.inlinePatterns.length > 0 || a()) && jj(e, d);
        }
      };
      e.on("keyup", (d) => {
        Zj(n, d) && c();
      }), e.on("keypress", (d) => {
        Wj(t, d) && du.setEditorTimeout(e, c);
      });
    }, Gj = (e) => {
      qj(e);
    }, Kj = (e) => {
      const t = Ht.each, n = yn.BACKSPACE, r = yn.DELETE, a = e.dom, c = e.selection, d = e.parser, h = nr.browser, k = h.isFirefox(), D = h.isChromium() || h.isSafari(), H = nr.deviceType.isiPhone() || nr.deviceType.isiPad(), U = nr.os.isMacOS() || nr.os.isiOS(), G = (On, Rn) => {
        try {
          e.getDoc().execCommand(On, !1, String(Rn));
        } catch {
        }
      }, ie = (On) => On.isDefaultPrevented(), ye = () => {
        const On = (qt) => {
          const bo = a.create("body"), hr = qt.cloneContents();
          return bo.appendChild(hr), c.serializer.serialize(bo, { format: "html" });
        }, Rn = (qt) => {
          const bo = On(qt), hr = a.createRng();
          hr.selectNode(e.getBody());
          const Ss = On(hr);
          return bo === Ss;
        };
        e.on("keydown", (qt) => {
          const bo = qt.keyCode;
          if (!ie(qt) && (bo === r || bo === n) && e.selection.isEditable()) {
            const hr = e.selection.isCollapsed(), Ss = e.getBody();
            if (hr && !Yr(be.fromDom(Ss)) || !hr && !Rn(e.selection.getRng()))
              return;
            qt.preventDefault(), e.setContent(""), Ss.firstChild && a.isBlock(Ss.firstChild) ? e.selection.setCursorLocation(Ss.firstChild, 0) : e.selection.setCursorLocation(Ss, 0), e.nodeChanged();
          }
        });
      }, ae = () => {
        e.shortcuts.add("meta+a", null, "SelectAll");
      }, xe = () => {
        e.inline || a.bind(e.getDoc(), "mousedown mouseup", (On) => {
          let Rn;
          if (On.target === e.getDoc().documentElement)
            if (Rn = c.getRng(), e.getBody().focus(), On.type === "mousedown") {
              if (Tn(Rn.startContainer))
                return;
              c.placeCaretAt(On.clientX, On.clientY);
            } else
              c.setRng(Rn);
        });
      }, Ne = () => {
        e.on("keydown", (On) => {
          if (!ie(On) && On.keyCode === n) {
            if (!e.getBody().getElementsByTagName("hr").length)
              return;
            if (c.isCollapsed() && c.getRng().startOffset === 0) {
              const Rn = c.getNode(), qt = Rn.previousSibling;
              if (Rn.nodeName === "HR") {
                a.remove(Rn), On.preventDefault();
                return;
              }
              qt && qt.nodeName && qt.nodeName.toLowerCase() === "hr" && (a.remove(qt), On.preventDefault());
            }
          }
        });
      }, Ie = () => {
        Range.prototype.getClientRects || e.on("mousedown", (On) => {
          if (!ie(On) && On.target.nodeName === "HTML") {
            const Rn = e.getBody();
            Rn.blur(), du.setEditorTimeout(e, () => {
              Rn.focus();
            });
          }
        });
      }, Fe = () => {
        const On = i0(e);
        e.on("click", (Rn) => {
          const qt = Rn.target;
          /^(IMG|HR)$/.test(qt.nodeName) && a.isEditable(qt) && (Rn.preventDefault(), e.selection.select(qt), e.nodeChanged()), qt.nodeName === "A" && a.hasClass(qt, On) && qt.childNodes.length === 0 && a.isEditable(qt.parentNode) && (Rn.preventDefault(), c.select(qt));
        });
      }, je = () => {
        const On = () => {
          const qt = a.getAttribs(c.getStart().cloneNode(!1));
          return () => {
            const bo = c.getStart();
            bo !== e.getBody() && (a.setAttrib(bo, "style", null), t(qt, (hr) => {
              bo.setAttributeNode(hr.cloneNode(!0));
            }));
          };
        }, Rn = () => !c.isCollapsed() && a.getParent(c.getStart(), a.isBlock) !== a.getParent(c.getEnd(), a.isBlock);
        e.on("keypress", (qt) => {
          let bo;
          return !ie(qt) && (qt.keyCode === 8 || qt.keyCode === 46) && Rn() ? (bo = On(), e.getDoc().execCommand("delete", !1), bo(), qt.preventDefault(), !1) : !0;
        }), a.bind(e.getDoc(), "cut", (qt) => {
          if (!ie(qt) && Rn()) {
            const bo = On();
            du.setEditorTimeout(e, () => {
              bo();
            });
          }
        });
      }, _t = () => {
        e.on("keydown", (On) => {
          if (!ie(On) && On.keyCode === n && c.isCollapsed() && c.getRng().startOffset === 0) {
            const Rn = c.getNode().previousSibling;
            if (Rn && Rn.nodeName && Rn.nodeName.toLowerCase() === "table")
              return On.preventDefault(), !1;
          }
          return !0;
        });
      }, Zt = () => {
        e.on("keydown", (On) => {
          if (ie(On) || On.keyCode !== yn.BACKSPACE)
            return;
          let Rn = c.getRng();
          const qt = Rn.startContainer, bo = Rn.startOffset, hr = a.getRoot();
          let Ss = qt;
          if (!(!Rn.collapsed || bo !== 0)) {
            for (; Ss.parentNode && Ss.parentNode.firstChild === Ss && Ss.parentNode !== hr; )
              Ss = Ss.parentNode;
            Ss.nodeName === "BLOCKQUOTE" && (e.formatter.toggle("blockquote", void 0, Ss), Rn = a.createRng(), Rn.setStart(qt, 0), Rn.setEnd(qt, 0), c.setRng(Rn));
          }
        });
      }, fn = () => {
        const On = () => {
          G("StyleWithCSS", !1), G("enableInlineTableEditing", !1), Ev(e) || G("enableObjectResizing", !1);
        };
        Pw(e) || e.on("BeforeExecCommand mousedown", On);
      }, at = () => {
        const On = () => {
          t(a.select("a:not([data-mce-block])"), (Rn) => {
            var qt;
            let bo = Rn.parentNode;
            const hr = a.getRoot();
            if ((bo == null ? void 0 : bo.lastChild) === Rn) {
              for (; bo && !a.isBlock(bo); ) {
                if (((qt = bo.parentNode) === null || qt === void 0 ? void 0 : qt.lastChild) !== bo || bo === hr)
                  return;
                bo = bo.parentNode;
              }
              a.add(bo, "br", { "data-mce-bogus": 1 });
            }
          });
        };
        e.on("SetContent ExecCommand", (Rn) => {
          (Rn.type === "setcontent" || Rn.command === "mceInsertLink") && On();
        });
      }, et = () => {
        e.on("init", () => {
          G("DefaultParagraphSeparator", li(e));
        });
      }, Mt = (On) => {
        const Rn = On.getBody(), qt = On.selection.getRng();
        return qt.startContainer === qt.endContainer && qt.startContainer === Rn && qt.startOffset === 0 && qt.endOffset === Rn.childNodes.length;
      }, gn = () => {
        e.on("keyup focusin mouseup", (On) => {
          !yn.modifierPressed(On) && !Mt(e) && c.normalize();
        }, !0);
      }, Fn = () => {
        e.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}");
      }, Uo = () => {
        e.inline || e.on("keydown", () => {
          document.activeElement === document.body && e.getWin().focus();
        });
      }, qo = () => {
        e.inline || (e.contentStyles.push("body {min-height: 150px}"), e.on("click", (On) => {
          let Rn;
          On.target.nodeName === "HTML" && (Rn = e.selection.getRng(), e.getBody().focus(), e.selection.setRng(Rn), e.selection.normalize(), e.nodeChanged());
        }));
      }, vs = () => {
        U && e.on("keydown", (On) => {
          yn.metaKeyPressed(On) && !On.shiftKey && (On.keyCode === 37 || On.keyCode === 39) && (On.preventDefault(), e.selection.getSel().modify("move", On.keyCode === 37 ? "backward" : "forward", "lineboundary"));
        });
      }, Vs = () => {
        e.on("click", (On) => {
          let Rn = On.target;
          do
            if (Rn.tagName === "A") {
              On.preventDefault();
              return;
            }
          while (Rn = Rn.parentNode);
        }), e.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}");
      }, Ci = () => {
        e.on("init", () => {
          e.dom.bind(e.getBody(), "submit", (On) => {
            On.preventDefault();
          });
        });
      }, Yc = () => {
        d.addNodeFilter("br", (On) => {
          let Rn = On.length;
          for (; Rn--; )
            On[Rn].attr("class") === "Apple-interchange-newline" && On[Rn].remove();
        });
      }, Ql = ht, sn = () => {
        if (!k || e.removed)
          return !1;
        const On = e.selection.getSel();
        return !On || !On.rangeCount || On.rangeCount === 0;
      }, zn = () => {
        D && (xe(), Fe(), Ci(), ae(), H && (Uo(), qo(), Vs())), k && (Ie(), fn(), Fn(), vs());
      }, Ar = () => {
        e.on("drop", (On) => {
          var Rn;
          const qt = (Rn = On.dataTransfer) === null || Rn === void 0 ? void 0 : Rn.getData("text/html");
          Ot(qt) && /^<img[^>]*>$/.test(qt) && e.dispatch("dragend", new window.DragEvent("dragend", On));
        });
      }, xr = () => {
        Zt(), ye(), nr.windowsPhone || gn(), D && (xe(), Fe(), et(), Ci(), _t(), Yc(), H ? (Uo(), qo(), Vs()) : ae()), k && (Ne(), Ie(), je(), fn(), at(), Fn(), vs(), _t(), Ar());
      };
      return yp(e) ? zn() : xr(), {
        refreshContentEditable: Ql,
        isHidden: sn
      };
    }, e8 = gs.DOM, Yj = (e, t) => {
      const n = be.fromDom(e.getBody()), r = Gr(pl(n)), a = be.fromTag("style");
      Vr(a, "type", "text/css"), Ir(a, be.fromText(t)), Ir(r, a), e.on("remove", () => {
        dr(a);
      });
    }, Xj = (e) => e.inline ? e.getElement().nodeName.toLowerCase() : void 0, t8 = (e) => _l(e, (t) => ko(t) === !1), Z7 = (e) => {
      const t = e.options.get, n = e.editorUpload.blobCache;
      return t8({
        allow_conditional_comments: t("allow_conditional_comments"),
        allow_html_data_urls: t("allow_html_data_urls"),
        allow_svg_data_urls: t("allow_svg_data_urls"),
        allow_html_in_named_anchor: t("allow_html_in_named_anchor"),
        allow_script_urls: t("allow_script_urls"),
        allow_unsafe_link_target: t("allow_unsafe_link_target"),
        convert_unsafe_embeds: t("convert_unsafe_embeds"),
        convert_fonts_to_spans: t("convert_fonts_to_spans"),
        fix_list_elements: t("fix_list_elements"),
        font_size_legacy_values: t("font_size_legacy_values"),
        forced_root_block: t("forced_root_block"),
        forced_root_block_attrs: t("forced_root_block_attrs"),
        preserve_cdata: t("preserve_cdata"),
        inline_styles: t("inline_styles"),
        root_name: Xj(e),
        sandbox_iframes: t("sandbox_iframes"),
        sanitize: t("xss_sanitization"),
        validate: !0,
        blob_cache: n,
        document: e.getDoc()
      });
    }, W7 = (e) => {
      const t = e.options.get;
      return t8({
        custom_elements: t("custom_elements"),
        extended_valid_elements: t("extended_valid_elements"),
        invalid_elements: t("invalid_elements"),
        invalid_styles: t("invalid_styles"),
        schema: t("schema"),
        valid_children: t("valid_children"),
        valid_classes: t("valid_classes"),
        valid_elements: t("valid_elements"),
        valid_styles: t("valid_styles"),
        verify_html: t("verify_html"),
        padd_empty_block_inline_children: t("format_empty_lines")
      });
    }, Jj = (e) => {
      const t = e.options.get;
      return {
        ...Z7(e),
        ...W7(e),
        ...t8({
          remove_trailing_brs: t("remove_trailing_brs"),
          pad_empty_with_br: t("pad_empty_with_br"),
          url_converter: t("url_converter"),
          url_converter_scope: t("url_converter_scope"),
          element_format: t("element_format"),
          entities: t("entities"),
          entity_encoding: t("entity_encoding"),
          indent: t("indent"),
          indent_after: t("indent_after"),
          indent_before: t("indent_before")
        })
      };
    }, Qj = (e) => {
      const t = yy(Z7(e), e.schema);
      return t.addAttributeFilter("src,href,style,tabindex", (n, r) => {
        const a = e.dom, c = "data-mce-" + r;
        let d = n.length;
        for (; d--; ) {
          const h = n[d];
          let k = h.attr(r);
          if (k && !h.attr(c)) {
            if (k.indexOf("data:") === 0 || k.indexOf("blob:") === 0)
              continue;
            r === "style" ? (k = a.serializeStyle(a.parseStyle(k), h.name), k.length || (k = null), h.attr(c, k), h.attr(r, k)) : r === "tabindex" ? (h.attr(c, k), h.attr(r, null)) : h.attr(c, e.convertURL(k, r, h.name));
          }
        }
      }), t.addNodeFilter("script", (n) => {
        let r = n.length;
        for (; r--; ) {
          const a = n[r], c = a.attr("type") || "no/type";
          c.indexOf("mce-") !== 0 && a.attr("type", "mce-" + c);
        }
      }), qw(e) && t.addNodeFilter("#cdata", (n) => {
        var r;
        let a = n.length;
        for (; a--; ) {
          const c = n[a];
          c.type = 8, c.name = "#comment", c.value = "[CDATA[" + e.dom.encode((r = c.value) !== null && r !== void 0 ? r : "") + "]]";
        }
      }), t.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", (n) => {
        let r = n.length;
        const a = e.schema.getNonEmptyElements();
        for (; r--; ) {
          const c = n[r];
          c.isEmpty(a) && c.getAll("br").length === 0 && c.append(new qc("br", 1));
        }
      }), t;
    }, eZ = (e) => {
      const t = uC(e);
      t && du.setEditorTimeout(e, () => {
        let n;
        t === !0 ? n = e : n = e.editorManager.get(t), n && !n.destroyed && (n.focus(), n.selection.scrollIntoView());
      }, 100);
    }, tZ = (e) => {
      const t = e.dom.getRoot();
      !e.inline && (!uu(e) || e.selection.getStart(!0) === t) && lu(t).each((n) => {
        const r = n.getNode(), a = Cu(r) ? lu(r).getOr(n) : n;
        e.selection.setRng(a.toRange());
      });
    }, nZ = (e) => {
      e.bindPendingEventDelegates(), e.initialized = !0, WT(e), e.focus(!0), tZ(e), e.nodeChanged({ initial: !0 });
      const t = Nh(e);
      un(t) && t.call(e, e), eZ(e);
    }, n8 = (e) => e.inline ? e.ui.styleSheetLoader : e.dom.styleSheetLoader, oZ = (e, t, n) => {
      const {
        pass: r,
        fail: a
      } = It(t, (h) => tinymce.Resource.has(n3(h))), d = [
        ...r.map((h) => {
          const k = tinymce.Resource.get(n3(h));
          return Ot(k) ? Promise.resolve(n8(e).loadRawCss(h, k)) : Promise.resolve();
        }),
        n8(e).loadAll(a)
      ];
      return e.inline ? d : d.concat([e.ui.styleSheetLoader.loadAll(n)]);
    }, q7 = (e) => {
      const t = n8(e), n = Dw(e), r = e.contentCSS, a = () => {
        t.unloadAll(r), e.inline || e.ui.styleSheetLoader.unloadAll(n);
      }, c = () => {
        e.removed ? a() : e.on("remove", a);
      };
      if (e.contentStyles.length > 0) {
        let k = "";
        Ht.each(e.contentStyles, (D) => {
          k += D + `\r
`;
        }), e.dom.addStyle(k);
      }
      const d = Promise.all(oZ(e, r, n)).then(c).catch(c), h = rC(e);
      return h && Yj(e, h), d;
    }, rZ = (e) => {
      const t = e.getDoc(), n = e.getBody();
      jT(e), dC(e) || (t.body.spellcheck = !1, e8.setAttrib(n, "spellcheck", "false")), e.quirks = Kj(e), ZT(e);
      const r = sC(e);
      r !== void 0 && (n.dir = r);
      const a = a1(e);
      a && e.on("BeforeSetContent", (c) => {
        Ht.each(a, (d) => {
          c.content = c.content.replace(d, (h) => "<!--mce:protected " + escape(h) + "-->");
        });
      }), e.on("SetContent", () => {
        e.addVisual(e.getBody());
      }), e.on("compositionstart compositionend", (c) => {
        e.composing = c.type === "compositionstart";
      });
    }, sZ = (e) => {
      yp(e) || e.load({
        initial: !0,
        format: "html"
      }), e.startContent = e.getContent({ format: "raw" });
    }, o8 = (e) => {
      e.removed !== !0 && (sZ(e), nZ(e));
    }, aZ = (e) => {
      let t = !1;
      const n = setTimeout(() => {
        t || e.setProgressState(!0);
      }, 500);
      return () => {
        clearTimeout(n), t = !0, e.setProgressState(!1);
      };
    }, G7 = (e) => {
      const t = e.getElement();
      let n = e.getDoc();
      e.inline && (e8.addClass(t, "mce-content-body"), e.contentDocument = n = document, e.contentWindow = window, e.bodyElement = t, e.contentAreaContainer = t);
      const r = e.getBody();
      r.disabled = !0, e.readonly = Pw(e), e._editableRoot = lr(e), !e.readonly && e.hasEditableRoot() && (e.inline && e8.getStyle(r, "position", !0) === "static" && (r.style.position = "relative"), r.contentEditable = "true"), r.disabled = !1, e.editorUpload = dL(e), e.schema = of(W7(e)), e.dom = gs(n, {
        keep_values: !0,
        url_converter: e.convertURL,
        url_converter_scope: e,
        update_styles: !0,
        root_element: e.inline ? e.getBody() : null,
        collect: e.inline,
        schema: e.schema,
        contentCssCors: nC(e),
        referrerPolicy: n1(e),
        onSetAttrib: (d) => {
          e.dispatch("SetAttrib", d);
        },
        force_hex_color: yC(e)
      }), e.parser = Qj(e), e.serializer = j4(Jj(e), e), e.selection = H4(e.dom, e.getWin(), e.serializer, e), e.annotator = QC(e), e.formatter = P1(e), e.undoManager = Xx(e), e._nodeChangeDispatcher = new d9(e), e._selectionOverrides = Ej(e), bt(e), DU(e), ui(e), yp(e) || (IU(e), Gj(e));
      const a = u9(e);
      me(e, a), Hs(e), gL(e), zU(e);
      const c = yD(e);
      rZ(e), c.fold(() => {
        const d = aZ(e);
        q7(e).then(() => {
          o8(e), d();
        });
      }, (d) => {
        e.setProgressState(!0), q7(e).then(() => {
          d().then((h) => {
            e.setProgressState(!1), o8(e), L4(e);
          }, (h) => {
            e.notificationManager.open({
              type: "error",
              text: String(h)
            }), o8(e), L4(e);
          });
        });
      });
    }, iZ = Mo, lZ = (e, t, n) => Cf(e, t, iZ, n), r8 = gs.DOM, cZ = (e, t, n, r) => {
      const a = be.fromTag("iframe");
      return r.each((c) => Vr(a, "tabindex", c)), zs(a, n), zs(a, {
        id: e + "_ifr",
        frameBorder: "0",
        allowTransparency: "true",
        title: t
      }), ca(a, "tox-edit-area__iframe"), a;
    }, uZ = (e) => {
      let t = ii(e) + "<html><head>";
      yl(e) !== e.documentBaseUrl && (t += '<base href="' + e.documentBaseURI.getURI() + '" />'), t += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
      const n = Ng(e), r = Ah(e), a = e.translate(cC(e));
      return hs(e) && (t += '<meta http-equiv="Content-Security-Policy" content="' + hs(e) + '" />'), t += `</head><body id="${n}" class="mce-content-body ${r}" data-id="${e.id}" aria-label="${a}"><br></body></html>`, t;
    }, dZ = (e, t) => {
      const n = e.translate("Rich Text Area"), r = Js(be.fromDom(e.getElement()), "tabindex").bind(Us), a = cZ(e.id, n, Dn(e), r).dom;
      a.onload = () => {
        a.onload = null, e.dispatch("load");
      }, e.contentAreaContainer = t.iframeContainer, e.iframeElement = a, e.iframeHTML = uZ(e), r8.add(t.iframeContainer, a);
    }, fZ = (e) => {
      const t = e.iframeElement, n = () => {
        e.contentDocument = t.contentDocument, G7(e);
      };
      if (pC(e) || nr.browser.isFirefox()) {
        const r = e.getDoc();
        r.open(), r.write(e.iframeHTML), r.close(), n();
      } else {
        const r = lZ(be.fromDom(t), "load", () => {
          r.unbind(), n();
        });
        t.srcdoc = e.iframeHTML;
      }
    }, mZ = (e, t) => {
      dZ(e, t), t.editorContainer && (t.editorContainer.style.display = e.orgDisplay, e.hidden = r8.isHidden(t.editorContainer)), e.getElement().style.display = "none", r8.setAttrib(e.id, "aria-hidden", "true"), e.getElement().style.visibility = e.orgVisibility, fZ(e);
    }, K7 = gs.DOM, pZ = (e, t, n) => {
      const r = M1.get(n), a = M1.urls[n] || e.documentBaseUrl.replace(/\/$/, "");
      if (n = Ht.trim(n), r && Ht.inArray(t, n) === -1) {
        if (e.plugins[n])
          return;
        try {
          const c = r(e, a) || {};
          e.plugins[n] = c, un(c.init) && (c.init(e, a), t.push(n));
        } catch (c) {
          t3(e, n, c);
        }
      }
    }, gZ = (e) => e.replace(/^\-/, ""), hZ = (e) => {
      const t = [];
      ut(cp(e), (n) => {
        pZ(e, t, gZ(n));
      });
    }, bZ = (e) => {
      const t = Ht.trim(zw(e)), n = e.ui.registry.getAll().icons, r = {
        ...Wx.get("default").icons,
        ...Wx.get(t).icons
      };
      Zo(r, (a, c) => {
        Yn(n, c) || e.ui.registry.addIcon(c, a);
      });
    }, yZ = (e) => {
      const t = Rh(e);
      if (Ot(t)) {
        const n = jh.get(t);
        e.theme = n(e, jh.urls[t]) || {}, un(e.theme.init) && e.theme.init(e, jh.urls[t] || e.documentBaseUrl.replace(/\/$/, ""));
      } else
        e.theme = {};
    }, vZ = (e) => {
      const t = s0(e), n = N1.get(t);
      e.model = n(e, N1.urls[t]);
    }, xZ = (e) => {
      const t = e.theme.renderUI;
      return t ? t() : X7(e);
    }, wZ = (e) => {
      const t = e.getElement(), r = Rh(e)(e, t);
      return r.editorContainer.nodeType && (r.editorContainer.id = r.editorContainer.id || e.id + "_parent"), r.iframeContainer && r.iframeContainer.nodeType && (r.iframeContainer.id = r.iframeContainer.id || e.id + "_iframecontainer"), r.height = r.iframeHeight ? r.iframeHeight : t.offsetHeight, r;
    }, Y7 = (e, t) => ({
      editorContainer: e,
      iframeContainer: t,
      api: {}
    }), kZ = (e) => {
      const t = K7.create("div");
      return K7.insertAfter(t, e), Y7(t, t);
    }, X7 = (e) => {
      const t = e.getElement();
      return e.inline ? Y7(null) : kZ(t);
    }, _Z = (e) => {
      const t = e.getElement();
      return e.orgDisplay = t.style.display, Ot(Rh(e)) ? xZ(e) : un(Rh(e)) ? wZ(e) : X7(e);
    }, CZ = (e, t) => {
      const n = {
        show: K.from(t.show).getOr(ht),
        hide: K.from(t.hide).getOr(ht),
        isEnabled: K.from(t.isEnabled).getOr(Mo),
        setEnabled: (r) => {
          e.mode.isReadOnly() || K.from(t.setEnabled).each((a) => a(r));
        }
      };
      e.ui = {
        ...e.ui,
        ...n
      };
    }, SZ = async (e) => {
      e.dispatch("ScriptsLoaded"), bZ(e), yZ(e), vZ(e), hZ(e);
      const t = await _Z(e);
      CZ(e, K.from(t.api).getOr({})), e.editorContainer = t.editorContainer, f2(e), e.inline ? G7(e) : mZ(e, {
        editorContainer: t.editorContainer,
        iframeContainer: t.iframeContainer
      });
    }, dw = gs.DOM, J7 = (e) => e.charAt(0) === "-", EZ = (e, t) => {
      const n = Aw(t), r = oC(t);
      if (!Rc.hasCode(n) && n !== "en") {
        const a = Na(r) ? r : `${t.editorManager.baseURL}/langs/${n}.js`;
        e.add(a).catch(() => {
          oR(t, a, n);
        });
      }
    }, TZ = (e, t) => {
      const n = Rh(e);
      if (Ot(n) && !J7(n) && !Yn(jh.urls, n)) {
        const r = Nw(e), a = r ? e.documentBaseURI.toAbsolute(r) : `themes/${n}/theme${t}.js`;
        jh.load(n, a).catch(() => {
          Q4(e, a, n);
        });
      }
    }, zZ = (e, t) => {
      const n = s0(e);
      if (n !== "plugin" && !Yn(N1.urls, n)) {
        const r = Mw(e), a = Ot(r) ? e.documentBaseURI.toAbsolute(r) : `models/${n}/model${t}.js`;
        N1.load(n, a).catch(() => {
          e3(e, a, n);
        });
      }
    }, OZ = (e) => K.from(eC(e)).filter(Na).map((t) => ({
      url: t,
      name: K.none()
    })), Q7 = (e, t, n) => K.from(t).filter((r) => Na(r) && !Wx.has(r)).map((r) => ({
      url: `${e.editorManager.baseURL}/icons/${r}/icons${n}.js`,
      name: K.some(r)
    })), AZ = (e, t, n) => {
      const r = Q7(t, "default", n), a = OZ(t).orThunk(() => Q7(t, zw(t), ""));
      ut(ed([
        r,
        a
      ]), (c) => {
        e.add(c.url).catch(() => {
          nR(t, c.url, c.name.getOrUndefined());
        });
      });
    }, DZ = (e, t) => {
      const n = (r, a) => {
        M1.load(r, a).catch(() => {
          sL(e, a, r);
        });
      };
      Zo(lC(e), (r, a) => {
        n(a, r), e.options.set("plugins", cp(e).concat(a));
      }), ut(cp(e), (r) => {
        r = Ht.trim(r), r && !M1.urls[r] && !J7(r) && n(r, `plugins/${r}/plugin${t}.js`);
      });
    }, RZ = (e) => {
      const t = Rh(e);
      return !Ot(t) || Xe(jh.get(t));
    }, NZ = (e) => {
      const t = s0(e);
      return Xe(N1.get(t));
    }, MZ = (e, t) => {
      const n = Gl.ScriptLoader, r = () => {
        !e.removed && RZ(e) && NZ(e) && SZ(e);
      };
      TZ(e, t), zZ(e, t), EZ(n, e), AZ(n, e, t), DZ(e, t), n.loadQueue().then(r, r);
    }, BZ = (e, t) => By.forElement(e, {
      contentCssCors: $f(t),
      referrerPolicy: n1(t)
    }), LZ = (e) => {
      const t = e.id;
      Rc.setCode(Aw(e));
      const n = () => {
        dw.unbind(window, "ready", n), e.render();
      };
      if (!pm.Event.domLoaded) {
        dw.bind(window, "ready", n);
        return;
      }
      if (!e.getElement())
        return;
      const r = be.fromDom(e.getElement()), a = Ws(r);
      e.on("remove", () => {
        kt(r.dom.attributes, (d) => xs(r, d.name)), zs(r, a);
      }), e.ui.styleSheetLoader = BZ(r, e), Ib(e) ? e.inline = !0 : (e.orgVisibility = e.getElement().style.visibility, e.getElement().style.visibility = "hidden");
      const c = e.getElement().form || dw.getParent(t, "form");
      c && (e.formElement = c, r1(e) && !Uc(e.getElement()) && (dw.insertAfter(dw.create("input", {
        type: "hidden",
        name: t
      }), t), e.hasHiddenInput = !0), e.formEventDelegate = (d) => {
        e.dispatch(d.type, d);
      }, dw.bind(c, "submit reset", e.formEventDelegate), e.on("reset", () => {
        e.resetContent();
      }), a0(e) && !c.submit.nodeType && !c.submit.length && !c._mceOldSubmit && (c._mceOldSubmit = c.submit, c.submit = () => (e.editorManager.triggerSave(), e.setDirty(!1), c._mceOldSubmit(c)))), e.windowManager = X4(e), e.notificationManager = eR(e), f0(e) && e.on("GetContent", (d) => {
        d.save && (d.content = dw.encode(d.content));
      }), Fb(e) && e.on("submit", () => {
        e.initialized && e.save();
      }), Bw(e) && (e._beforeUnload = () => {
        e.initialized && !e.destroyed && !e.isHidden() && e.save({
          format: "raw",
          no_events: !0,
          set_dirty: !1
        });
      }, e.editorManager.on("BeforeUnload", e._beforeUnload)), e.editorManager.add(e), MZ(e, e.suffix);
    }, PZ = (e, t) => {
      e._editableRoot !== t && (e._editableRoot = t, e.readonly || (e.getBody().contentEditable = String(e.hasEditableRoot()), e.nodeChanged()), QT(e, t));
    }, IZ = (e) => e._editableRoot, FZ = (e, t) => ({
      sections: dt(e),
      options: dt(t)
    }), eF = Zn().deviceType, tF = eF.isPhone(), $Z = eF.isTablet(), tT = (e) => {
      if (jn(e))
        return [];
      {
        const t = Se(e) ? e : e.split(/[ ,]/), n = oo(t, Lc);
        return ct(n, Na);
      }
    }, HZ = (e, t) => {
      const n = xc(t, (r, a) => So(e, a));
      return FZ(n.t, n.f);
    }, VZ = (e, t, n = {}) => {
      const r = e.sections(), a = Hr(r, t).getOr({});
      return Ht.extend({}, n, a);
    }, s8 = (e, t) => Yn(e.sections(), t), UZ = (e, t) => s8(e, t) ? e.sections()[t] : {}, jZ = (e, t) => ({
      ...{
        table_grid: !1,
        object_resizing: !1,
        resize: !1,
        toolbar_mode: Hr(e, "toolbar_mode").getOr("scrolling"),
        toolbar_sticky: !1
      },
      ...t ? { menubar: !1 } : {}
    }), ZZ = (e, t) => {
      var n;
      const r = (n = t.external_plugins) !== null && n !== void 0 ? n : {};
      return e && e.external_plugins ? Ht.extend({}, e.external_plugins, r) : r;
    }, WZ = (e, t) => [
      ...tT(e),
      ...tT(t)
    ], qZ = (e, t, n, r) => e && s8(t, "mobile") ? r : n, GZ = (e, t, n, r) => {
      const a = tT(n.forced_plugins), c = tT(r.plugins), d = UZ(t, "mobile"), h = d.plugins ? tT(d.plugins) : c, k = qZ(e, t, c, h), D = WZ(a, k);
      return Ht.extend(r, {
        forced_plugins: a,
        plugins: D
      });
    }, KZ = (e, t) => e && s8(t, "mobile"), YZ = (e, t, n, r, a) => {
      var c;
      const d = e ? { mobile: jZ((c = a.mobile) !== null && c !== void 0 ? c : {}, t) } : {}, h = HZ(["mobile"], QN(d, a)), k = Ht.extend(n, r, h.options(), KZ(e, h) ? VZ(h, "mobile") : {}, { external_plugins: ZZ(r, h.options()) });
      return GZ(e, h, r, k);
    }, XZ = (e, t) => YZ(tF || $Z, tF, t, e, t), JZ = (e, t) => CD(e, t), QZ = (e) => {
      const t = (r, a) => {
        e.formatter.toggle(r, a), e.nodeChanged();
      }, n = (r) => () => {
        ut("left,center,right,justify".split(","), (a) => {
          r !== a && e.formatter.remove("align" + a);
        }), r !== "none" && t("align" + r);
      };
      e.editorCommands.addCommands({
        JustifyLeft: n("left"),
        JustifyCenter: n("center"),
        JustifyRight: n("right"),
        JustifyFull: n("justify"),
        JustifyNone: n("none")
      });
    }, eW = (e) => {
      const t = (n) => () => {
        const r = e.selection, a = r.isCollapsed() ? [e.dom.getParent(r.getNode(), e.dom.isBlock)] : r.getSelectedBlocks();
        return cr(a, (c) => Xe(e.formatter.matchNode(c, n)));
      };
      e.editorCommands.addCommands({
        JustifyLeft: t("alignleft"),
        JustifyCenter: t("aligncenter"),
        JustifyRight: t("alignright"),
        JustifyFull: t("alignjustify")
      }, "state");
    }, tW = (e) => {
      QZ(e), eW(e);
    }, nW = (e) => {
      e.editorCommands.addCommands({
        "Cut,Copy,Paste": (t) => {
          const n = e.getDoc();
          let r;
          try {
            n.execCommand(t);
          } catch {
            r = !0;
          }
          if (t === "paste" && !n.queryCommandEnabled(t) && (r = !0), r || !n.queryCommandSupported(t)) {
            let a = e.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.");
            (nr.os.isMacOS() || nr.os.isiOS()) && (a = a.replace(/Ctrl\+/g, "⌘+")), e.notificationManager.open({
              text: a,
              type: "error"
            });
          }
        }
      });
    }, oW = (e, t, n, r) => {
      const a = be.fromDom(e.getRoot());
      return ay(a, nt.fromRangeStart(t), r) ? n = n.replace(/^ /, "&nbsp;") : n = n.replace(/^&nbsp;/, " "), x1(a, nt.fromRangeEnd(t), r) ? n = n.replace(/(&nbsp;| )(<br( \/)>)?$/, "&nbsp;") : n = n.replace(/&nbsp;(<br( \/)?>)?$/, " "), n;
    }, rW = (e) => {
      if (typeof e != "string") {
        const t = Ht.extend({
          paste: e.paste,
          data: { paste: e.paste }
        }, e);
        return {
          content: e.content,
          details: t
        };
      }
      return {
        content: e,
        details: {}
      };
    }, sW = (e, t) => {
      const n = e.selection, r = e.dom;
      return /^ | $/.test(t) ? oW(r, n.getRng(), t, e.schema) : t;
    }, w5 = (e, t) => {
      if (e.selection.isEditable()) {
        const { content: n, details: r } = rW(t);
        W_(e, {
          ...r,
          content: sW(e, n),
          format: "html",
          set: !1,
          selection: !0
        }).each((a) => {
          const c = _D(e, a.content, r);
          ev(e, c, a), e.addVisual();
        });
      }
    }, aW = (e) => {
      e.editorCommands.addCommands({
        mceCleanup: () => {
          const t = e.selection.getBookmark();
          e.setContent(e.getContent()), e.selection.moveToBookmark(t);
        },
        insertImage: (t, n, r) => {
          w5(e, e.dom.createHTML("img", { src: r }));
        },
        insertHorizontalRule: () => {
          e.execCommand("mceInsertContent", !1, "<hr>");
        },
        insertText: (t, n, r) => {
          w5(e, e.dom.encode(r));
        },
        insertHTML: (t, n, r) => {
          w5(e, r);
        },
        mceInsertContent: (t, n, r) => {
          w5(e, r);
        },
        mceSetContent: (t, n, r) => {
          e.setContent(r);
        },
        mceReplaceContent: (t, n, r) => {
          e.execCommand("mceInsertContent", !1, r.replace(/\{\$selection\}/g, e.selection.getContent({ format: "text" })));
        },
        mceNewDocument: () => {
          e.setContent(Hw(e));
        }
      });
    }, iW = {
      "font-size": "size",
      "font-family": "face"
    }, lW = ya("font"), cW = (e, t, n) => {
      const r = (c) => He(c, e).orThunk(() => lW(c) ? Hr(iW, e).bind((d) => Js(c, d)) : K.none()), a = (c) => Le(be.fromDom(t), c);
      return ME(be.fromDom(n), (c) => r(c), a);
    }, uW = (e) => e.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ","), dW = (e, t) => K.from(gs.DOM.getStyle(t, e, !0)), nF = (e) => (t, n) => K.from(n).map(be.fromDom).filter(Ji).bind((r) => cW(e, t, r.dom).or(dW(e, r.dom))).getOr(""), fW = nF("font-size"), mW = mn(uW, nF("font-family")), pW = (e) => lu(e.getBody()).bind((t) => {
      const n = t.container();
      return K.from(At(n) ? n.parentNode : n);
    }), gW = (e) => K.from(e.selection.getRng()).bind((t) => {
      const n = e.getBody();
      return t.startContainer === n && t.startOffset === 0 ? K.none() : K.from(e.selection.getStart(!0));
    }), hW = (e, t) => gW(e).orThunk(Tt(pW, e)).map(be.fromDom).filter(Ji).bind(t), a8 = (e, t) => hW(e, lo(K.some, t)), oF = (e, t) => {
      if (/^[0-9.]+$/.test(t)) {
        const n = parseInt(t, 10);
        if (n >= 1 && n <= 7) {
          const r = d0(e), a = Gw(e);
          return a.length > 0 ? a[n - 1] || t : r[n - 1] || t;
        } else
          return t;
      } else
        return t;
    }, bW = (e) => {
      const t = e.split(/\s*,\s*/);
      return oo(t, (n) => n.indexOf(" ") !== -1 && !(Dr(n, '"') || Dr(n, "'")) ? `'${n}'` : n).join(",");
    }, yW = (e, t) => {
      const n = oF(e, t);
      e.formatter.toggle("fontname", { value: bW(n) }), e.nodeChanged();
    }, vW = (e) => a8(e, (t) => mW(e.getBody(), t.dom)).getOr(""), xW = (e, t) => {
      e.formatter.toggle("fontsize", { value: oF(e, t) }), e.nodeChanged();
    }, wW = (e) => a8(e, (t) => fW(e.getBody(), t.dom)).getOr(""), kW = (e) => a8(e, (t) => {
      const n = be.fromDom(e.getBody()), r = ME(t, (c) => He(c, "line-height"), Tt(Le, n)), a = () => {
        const c = parseFloat(Ya(t, "line-height")), d = parseFloat(Ya(t, "font-size"));
        return String(c / d);
      };
      return r.getOrThunk(a);
    }).getOr(""), _W = (e, t) => {
      e.formatter.toggle("lineheight", { value: String(t) }), e.nodeChanged();
    }, CW = (e) => {
      const t = (n, r) => {
        e.formatter.toggle(n, r), e.nodeChanged();
      };
      e.editorCommands.addCommands({
        "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (n) => {
          t(n);
        },
        "ForeColor,HiliteColor": (n, r, a) => {
          t(n, { value: a });
        },
        BackColor: (n, r, a) => {
          t("hilitecolor", { value: a });
        },
        FontName: (n, r, a) => {
          yW(e, a);
        },
        FontSize: (n, r, a) => {
          xW(e, a);
        },
        LineHeight: (n, r, a) => {
          _W(e, a);
        },
        Lang: (n, r, a) => {
          var c;
          t(n, {
            value: a.code,
            customValue: (c = a.customCode) !== null && c !== void 0 ? c : null
          });
        },
        RemoveFormat: (n) => {
          e.formatter.remove(n);
        },
        mceBlockQuote: () => {
          t("blockquote");
        },
        FormatBlock: (n, r, a) => {
          t(Ot(a) ? a : "p");
        },
        mceToggleFormat: (n, r, a) => {
          t(a);
        }
      });
    }, SW = (e) => {
      const t = (n) => e.formatter.match(n);
      e.editorCommands.addCommands({
        "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (n) => t(n),
        mceBlockQuote: () => t("blockquote")
      }, "state"), e.editorCommands.addQueryValueHandler("FontName", () => vW(e)), e.editorCommands.addQueryValueHandler("FontSize", () => wW(e)), e.editorCommands.addQueryValueHandler("LineHeight", () => kW(e));
    }, EW = (e) => {
      CW(e), SW(e);
    }, TW = (e) => {
      e.editorCommands.addCommands({
        mceAddUndoLevel: () => {
          e.undoManager.add();
        },
        mceEndUndoLevel: () => {
          e.undoManager.add();
        },
        Undo: () => {
          e.undoManager.undo();
        },
        Redo: () => {
          e.undoManager.redo();
        }
      });
    }, zW = (e) => {
      e.editorCommands.addCommands({
        Indent: () => {
          oe(e);
        },
        Outdent: () => {
          re(e);
        }
      }), e.editorCommands.addCommands({ Outdent: () => O(e) }, "state");
    }, OW = (e) => {
      const t = (n, r, a) => {
        const c = Ot(a) ? { href: a } : a, d = e.dom.getParent(e.selection.getNode(), "a");
        Ee(c) && Ot(c.href) && (c.href = c.href.replace(/ /g, "%20"), (!d || !c.href) && e.formatter.remove("link"), c.href && e.formatter.apply("link", c, d));
      };
      e.editorCommands.addCommands({
        unlink: () => {
          if (e.selection.isEditable()) {
            if (e.selection.isCollapsed()) {
              const n = e.dom.getParent(e.selection.getStart(), "a");
              n && e.dom.remove(n, !0);
              return;
            }
            e.formatter.remove("link");
          }
        },
        mceInsertLink: t,
        createLink: t
      });
    }, AW = (e) => {
      e.editorCommands.addCommands({
        "InsertUnorderedList,InsertOrderedList": (t) => {
          e.getDoc().execCommand(t);
          const n = e.dom.getParent(e.selection.getNode(), "ol,ul");
          if (n) {
            const r = n.parentNode;
            if (r && /^(H[1-6]|P|ADDRESS|PRE)$/.test(r.nodeName)) {
              const a = e.selection.getBookmark();
              e.dom.split(r, n), e.selection.moveToBookmark(a);
            }
          }
        }
      });
    }, DW = (e) => {
      e.editorCommands.addCommands({
        "InsertUnorderedList,InsertOrderedList": (t) => {
          const n = e.dom.getParent(e.selection.getNode(), "ul,ol");
          return n && (t === "insertunorderedlist" && n.tagName === "UL" || t === "insertorderedlist" && n.tagName === "OL");
        }
      }, "state");
    }, RW = (e) => {
      AW(e), DW(e);
    }, NW = (e, t, n, r) => {
      const a = e.dom, c = (h) => a.isBlock(h) && h.parentElement === n, d = c(t) ? t : a.getParent(r, c, n);
      return K.from(d).map(be.fromDom);
    }, rF = (e, t) => {
      const n = e.dom, r = e.selection.getRng(), a = t ? e.selection.getStart() : e.selection.getEnd(), c = t ? r.startContainer : r.endContainer, d = Y3(n, c);
      if (!d || !d.isContentEditable)
        return;
      const h = t ? Fs : rs, k = li(e);
      NW(e, a, d, c).each((D) => {
        const H = _I(e, c, D.dom, d, !1, k);
        h(D, be.fromDom(H)), e.selection.setCursorLocation(H, 0), e.dispatch("NewBlock", { newBlock: H }), K3(e, "insertParagraph");
      });
    }, MW = (e) => rF(e, !0), BW = (e) => rF(e, !1), LW = (e) => {
      e.editorCommands.addCommands({
        InsertNewBlockBefore: () => {
          MW(e);
        },
        InsertNewBlockAfter: () => {
          BW(e);
        }
      });
    }, PW = (e) => {
      e.editorCommands.addCommands({
        insertParagraph: () => {
          c5(TI, e);
        },
        mceInsertNewLine: (t, n, r) => {
          MI(e, r);
        },
        InsertLineBreak: (t, n, r) => {
          c5(AI, e);
        }
      });
    }, IW = (e) => {
      e.editorCommands.addCommands({
        mceSelectNodeDepth: (t, n, r) => {
          let a = 0;
          e.dom.getParent(e.selection.getNode(), (c) => wn(c) && a++ === r ? (e.selection.select(c), !1) : !0, e.getBody());
        },
        mceSelectNode: (t, n, r) => {
          e.selection.select(r);
        },
        selectAll: () => {
          const t = e.dom.getParent(e.selection.getStart(), cc);
          if (t) {
            const n = e.dom.createRng();
            n.selectNodeContents(t), e.selection.setRng(n);
          }
        }
      });
    }, FW = (e) => {
      e.editorCommands.addCommands({
        mceRemoveNode: (t, n, r) => {
          const a = r ?? e.selection.getNode();
          if (a !== e.getBody()) {
            const c = e.selection.getBookmark();
            e.dom.remove(a, !0), e.selection.moveToBookmark(c);
          }
        },
        mcePrint: () => {
          e.getWin().print();
        },
        mceFocus: (t, n, r) => {
          MS(e, r === !0);
        },
        mceToggleVisualAid: () => {
          e.hasVisual = !e.hasVisual, e.addVisual();
        }
      });
    }, $W = (e) => {
      tW(e), nW(e), TW(e), IW(e), aW(e), OW(e), zW(e), LW(e), PW(e), RW(e), EW(e), FW(e);
    }, HW = ["toggleview"], sF = (e) => So(HW, e.toLowerCase());
    class aF {
      constructor(t) {
        this.commands = {
          state: {},
          exec: {},
          value: {}
        }, this.editor = t;
      }
      execCommand(t, n = !1, r, a) {
        const c = this.editor, d = t.toLowerCase(), h = a == null ? void 0 : a.skip_focus;
        if (c.removed || (d !== "mcefocus" && (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(d) && !h ? c.focus() : _M(c)), c.dispatch("BeforeExecCommand", {
          command: t,
          ui: n,
          value: r
        }).isDefaultPrevented()))
          return !1;
        const D = this.commands.exec[d];
        return un(D) ? (D(d, n, r), c.dispatch("ExecCommand", {
          command: t,
          ui: n,
          value: r
        }), !0) : !1;
      }
      queryCommandState(t) {
        if (!sF(t) && this.editor.quirks.isHidden() || this.editor.removed)
          return !1;
        const n = t.toLowerCase(), r = this.commands.state[n];
        return un(r) ? r(n) : !1;
      }
      queryCommandValue(t) {
        if (!sF(t) && this.editor.quirks.isHidden() || this.editor.removed)
          return "";
        const n = t.toLowerCase(), r = this.commands.value[n];
        return un(r) ? r(n) : "";
      }
      addCommands(t, n = "exec") {
        const r = this.commands;
        Zo(t, (a, c) => {
          ut(c.toLowerCase().split(","), (d) => {
            r[n][d] = a;
          });
        });
      }
      addCommand(t, n, r) {
        const a = t.toLowerCase();
        this.commands.exec[a] = (c, d, h) => n.call(r ?? this.editor, d, h);
      }
      queryCommandSupported(t) {
        const n = t.toLowerCase();
        return !!this.commands.exec[n];
      }
      addQueryStateHandler(t, n, r) {
        this.commands.state[t.toLowerCase()] = () => n.call(r ?? this.editor);
      }
      addQueryValueHandler(t, n, r) {
        this.commands.value[t.toLowerCase()] = () => n.call(r ?? this.editor);
      }
    }
    const fw = "data-mce-contenteditable", VW = (e, t, n) => {
      Fc(e, t) && !n ? Oi(e, t) : n && ca(e, t);
    }, i8 = (e, t, n) => {
      try {
        e.getDoc().execCommand(t, !1, String(n));
      } catch {
      }
    }, k5 = (e, t) => {
      e.dom.contentEditable = t ? "true" : "false";
    }, UW = (e) => {
      ut(Ni(e, '*[contenteditable="true"]'), (t) => {
        Vr(t, fw, "true"), k5(t, !1);
      });
    }, jW = (e) => {
      ut(Ni(e, `*[${fw}="true"]`), (t) => {
        xs(t, fw), k5(t, !0);
      });
    }, ZW = (e) => {
      K.from(e.selection.getNode()).each((t) => {
        t.removeAttribute("data-mce-selected");
      });
    }, WW = (e) => {
      e.selection.setRng(e.selection.getRng());
    }, qW = (e, t) => {
      const n = be.fromDom(e.getBody());
      VW(n, "mce-content-readonly", t), t ? (e.selection.controlSelection.hideResizeRect(), e._selectionOverrides.hideFakeCaret(), ZW(e), e.readonly = !0, k5(n, !1), UW(n)) : (e.readonly = !1, e.hasEditableRoot() && k5(n, !0), jW(n), i8(e, "StyleWithCSS", !1), i8(e, "enableInlineTableEditing", !1), i8(e, "enableObjectResizing", !1), il(e) && e.focus(), WW(e), e.nodeChanged());
    }, mw = (e) => e.readonly, iF = (e) => {
      e.parser.addAttributeFilter("contenteditable", (t) => {
        mw(e) && ut(t, (n) => {
          n.attr(fw, n.attr("contenteditable")), n.attr("contenteditable", "false");
        });
      }), e.serializer.addAttributeFilter(fw, (t) => {
        mw(e) && ut(t, (n) => {
          n.attr("contenteditable", n.attr(fw));
        });
      }), e.serializer.addTempAttr(fw);
    }, GW = (e) => {
      e.serializer ? iF(e) : e.on("PreInit", () => {
        iF(e);
      });
    }, KW = (e) => e.type === "click", YW = ["copy"], XW = (e) => So(YW, e.type), JW = (e, t) => el(t, "a", (r) => Le(r, be.fromDom(e.getBody()))).bind((r) => Js(r, "href")), QW = (e, t) => {
      if (KW(t) && !yn.metaKeyPressed(t)) {
        const n = be.fromDom(t.target);
        JW(e, n).each((r) => {
          if (t.preventDefault(), /^#/.test(r)) {
            const a = e.dom.select(`${r},[name="${nm(r, "#")}"]`);
            a.length && e.selection.scrollIntoView(a[0], !0);
          } else
            window.open(r, "_blank", "rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes");
        });
      } else
        XW(t) && e.dispatch(t.type, t);
    }, eq = (e) => {
      e.on("ShowCaret", (t) => {
        mw(e) && t.preventDefault();
      }), e.on("ObjectSelected", (t) => {
        mw(e) && t.preventDefault();
      });
    }, tq = Ht.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel", " ");
    class l8 {
      static isNative(t) {
        return !!tq[t.toLowerCase()];
      }
      constructor(t) {
        this.bindings = {}, this.settings = t || {}, this.scope = this.settings.scope || this, this.toggleEvent = this.settings.toggleEvent || Pn;
      }
      fire(t, n) {
        return this.dispatch(t, n);
      }
      dispatch(t, n) {
        const r = t.toLowerCase(), a = Uy(r, n ?? {}, this.scope);
        this.settings.beforeFire && this.settings.beforeFire(a);
        const c = this.bindings[r];
        if (c)
          for (let d = 0, h = c.length; d < h; d++) {
            const k = c[d];
            if (!k.removed) {
              if (k.once && this.off(r, k.func), a.isImmediatePropagationStopped())
                return a;
              if (k.func.call(this.scope, a) === !1)
                return a.preventDefault(), a;
            }
          }
        return a;
      }
      on(t, n, r, a) {
        if (n === !1 && (n = Pn), n) {
          const c = {
            func: n,
            removed: !1
          };
          a && Ht.extend(c, a);
          const d = t.toLowerCase().split(" ");
          let h = d.length;
          for (; h--; ) {
            const k = d[h];
            let D = this.bindings[k];
            D || (D = [], this.toggleEvent(k, !0)), r ? D = [
              c,
              ...D
            ] : D = [
              ...D,
              c
            ], this.bindings[k] = D;
          }
        }
        return this;
      }
      off(t, n) {
        if (t) {
          const r = t.toLowerCase().split(" ");
          let a = r.length;
          for (; a--; ) {
            const c = r[a];
            let d = this.bindings[c];
            if (!c)
              return Zo(this.bindings, (h, k) => {
                this.toggleEvent(k, !1), delete this.bindings[k];
              }), this;
            if (d) {
              if (!n)
                d.length = 0;
              else {
                const h = It(d, (k) => k.func === n);
                d = h.fail, this.bindings[c] = d, ut(h.pass, (k) => {
                  k.removed = !0;
                });
              }
              d.length || (this.toggleEvent(t, !1), delete this.bindings[c]);
            }
          }
        } else
          Zo(this.bindings, (r, a) => {
            this.toggleEvent(a, !1);
          }), this.bindings = {};
        return this;
      }
      once(t, n, r) {
        return this.on(t, n, r, { once: !0 });
      }
      has(t) {
        t = t.toLowerCase();
        const n = this.bindings[t];
        return !(!n || n.length === 0);
      }
    }
    const nT = (e) => (e._eventDispatcher || (e._eventDispatcher = new l8({
      scope: e,
      toggleEvent: (t, n) => {
        l8.isNative(t) && e.toggleNativeEvent && e.toggleNativeEvent(t, n);
      }
    })), e._eventDispatcher), c8 = {
      fire(e, t, n) {
        return this.dispatch(e, t, n);
      },
      dispatch(e, t, n) {
        const r = this;
        if (r.removed && e !== "remove" && e !== "detach")
          return Uy(e.toLowerCase(), t ?? {}, r);
        const a = nT(r).dispatch(e, t);
        if (n !== !1 && r.parent) {
          let c = r.parent();
          for (; c && !a.isPropagationStopped(); )
            c.dispatch(e, a, !1), c = c.parent ? c.parent() : void 0;
        }
        return a;
      },
      on(e, t, n) {
        return nT(this).on(e, t, n);
      },
      off(e, t) {
        return nT(this).off(e, t);
      },
      once(e, t) {
        return nT(this).once(e, t);
      },
      hasEventListeners(e) {
        return nT(this).has(e);
      }
    }, _5 = gs.DOM;
    let pw;
    const C5 = (e, t) => {
      if (t === "selectionchange")
        return e.getDoc();
      if (!e.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(t))
        return e.getDoc().documentElement;
      const n = r0(e);
      return n ? (e.eventRoot || (e.eventRoot = _5.select(n)[0]), e.eventRoot) : e.getBody();
    }, nq = (e) => !e.hidden && !mw(e), lF = (e, t, n) => {
      nq(e) ? e.dispatch(t, n) : mw(e) && QW(e, n);
    }, cF = (e, t) => {
      if (e.delegates || (e.delegates = {}), e.delegates[t] || e.removed)
        return;
      const n = C5(e, t);
      if (r0(e)) {
        if (pw || (pw = {}, e.editorManager.on("removeEditor", () => {
          e.editorManager.activeEditor || pw && (Zo(pw, (a, c) => {
            e.dom.unbind(C5(e, c));
          }), pw = null);
        })), pw[t])
          return;
        const r = (a) => {
          const c = a.target, d = e.editorManager.get();
          let h = d.length;
          for (; h--; ) {
            const k = d[h].getBody();
            (k === c || _5.isChildOf(c, k)) && lF(d[h], t, a);
          }
        };
        pw[t] = r, _5.bind(n, t, r);
      } else {
        const r = (a) => {
          lF(e, t, a);
        };
        _5.bind(n, t, r), e.delegates[t] = r;
      }
    }, uF = {
      ...c8,
      bindPendingEventDelegates() {
        const e = this;
        Ht.each(e._pendingNativeEvents, (t) => {
          cF(e, t);
        });
      },
      toggleNativeEvent(e, t) {
        const n = this;
        e === "focus" || e === "blur" || n.removed || (t ? n.initialized ? cF(n, e) : n._pendingNativeEvents ? n._pendingNativeEvents.push(e) : n._pendingNativeEvents = [e] : n.initialized && n.delegates && (n.dom.unbind(C5(n, e), e, n.delegates[e]), delete n.delegates[e]));
      },
      unbindAllNativeEvents() {
        const e = this, t = e.getBody(), n = e.dom;
        e.delegates && (Zo(e.delegates, (r, a) => {
          e.dom.unbind(C5(e, a), a, r);
        }), delete e.delegates), !e.inline && t && n && (t.onload = null, n.unbind(e.getWin()), n.unbind(e.getDoc())), n && (n.unbind(t), n.unbind(e.getContainer()));
      }
    }, oq = (e) => Ot(e) ? {
      value: e.split(/[ ,]/),
      valid: !0
    } : Et(e, Ot) ? {
      value: e,
      valid: !0
    } : {
      valid: !1,
      message: "The value must be a string[] or a comma/space separated string."
    }, rq = (e) => {
      const t = (() => {
        switch (e) {
          case "array":
            return Se;
          case "boolean":
            return Cn;
          case "function":
            return un;
          case "number":
            return M;
          case "object":
            return Ee;
          case "string":
            return Ot;
          case "string[]":
            return oq;
          case "object[]":
            return (n) => Et(n, Ee);
          case "regexp":
            return (n) => an(n, RegExp);
          default:
            return Mo;
        }
      })();
      return (n) => u8(n, t, `The value must be a ${e}.`);
    }, sq = (e) => Ot(e.processor), dF = (e, t) => {
      const n = us(t.message) ? "" : `. ${t.message}`;
      return e + n;
    }, fF = (e) => e.valid, u8 = (e, t, n = "") => {
      const r = t(e);
      return Cn(r) ? r ? {
        value: e,
        valid: !0
      } : {
        valid: !1,
        message: n
      } : r;
    }, aq = (e, t, n) => {
      if (!ko(t)) {
        const r = u8(t, n);
        if (fF(r))
          return r.value;
        console.error(dF(`Invalid default value passed for the "${e}" option`, r));
      }
    }, iq = (e, t) => {
      const n = {}, r = {}, a = (U, G, ie) => {
        const ye = u8(G, ie);
        return fF(ye) ? (r[U] = ye.value, !0) : (console.warn(dF(`Invalid value passed for the ${U} option`, ye)), !1);
      }, c = (U, G) => {
        const ie = sq(G) ? rq(G.processor) : G.processor, ye = aq(U, G.default, ie);
        n[U] = {
          ...G,
          default: ye,
          processor: ie
        }, Hr(r, U).orThunk(() => Hr(t, U)).each((xe) => a(U, xe, ie));
      }, d = (U) => Yn(n, U);
      return {
        register: c,
        isRegistered: d,
        get: (U) => Hr(r, U).orThunk(() => Hr(n, U).map((G) => G.default)).getOrUndefined(),
        set: (U, G) => {
          if (d(U)) {
            const ie = n[U];
            return ie.immutable ? (console.error(`"${U}" is an immutable option and cannot be updated`), !1) : a(U, G, ie.processor);
          } else
            return console.warn(`"${U}" is not a registered option. Ensure the option has been registered before setting a value.`), !1;
        },
        unset: (U) => {
          const G = d(U);
          return G && delete r[U], G;
        },
        isSet: (U) => Yn(r, U)
      };
    }, lq = [
      "design",
      "readonly"
    ], mF = (e, t, n, r) => {
      const a = n[t.get()], c = n[r];
      try {
        c.activate();
      } catch (d) {
        console.error(`problem while activating editor mode ${r}:`, d);
        return;
      }
      a.deactivate(), a.editorReadOnly !== c.editorReadOnly && qW(e, c.editorReadOnly), t.set(r), tS(e, r);
    }, cq = (e, t, n, r) => {
      if (r !== n.get()) {
        if (!Yn(t, r))
          throw new Error(`Editor mode '${r}' is invalid`);
        e.initialized ? mF(e, n, t, r) : e.on("init", () => mF(e, n, t, r));
      }
    }, uq = (e, t, n) => {
      if (So(lq, t))
        throw new Error(`Cannot override default mode ${t}`);
      return {
        ...e,
        [t]: {
          ...n,
          deactivate: () => {
            try {
              n.deactivate();
            } catch (r) {
              console.error(`problem while deactivating editor mode ${t}:`, r);
            }
          }
        }
      };
    }, dq = (e) => {
      const t = Ja("design"), n = Ja({
        design: {
          activate: ht,
          deactivate: ht,
          editorReadOnly: !1
        },
        readonly: {
          activate: ht,
          deactivate: ht,
          editorReadOnly: !0
        }
      });
      return GW(e), eq(e), {
        isReadOnly: () => mw(e),
        set: (r) => cq(e, n.get(), t, r),
        get: () => t.get(),
        register: (r, a) => {
          n.set(uq(n.get(), r, a));
        }
      };
    }, d8 = Ht.each, f8 = Ht.explode, fq = {
      f1: 112,
      f2: 113,
      f3: 114,
      f4: 115,
      f5: 116,
      f6: 117,
      f7: 118,
      f8: 119,
      f9: 120,
      f10: 121,
      f11: 122,
      f12: 123
    }, pF = Ht.makeMap("alt,ctrl,shift,meta,access"), mq = (e) => e in pF, pq = (e) => {
      const t = {}, n = nr.os.isMacOS() || nr.os.isiOS();
      d8(f8(e.toLowerCase(), "+"), (c) => {
        mq(c) ? t[c] = !0 : /^[0-9]{2,}$/.test(c) ? t.keyCode = parseInt(c, 10) : (t.charCode = c.charCodeAt(0), t.keyCode = fq[c] || c.toUpperCase().charCodeAt(0));
      });
      const r = [t.keyCode];
      let a;
      for (a in pF)
        t[a] ? r.push(a) : t[a] = !1;
      return t.id = r.join(","), t.access && (t.alt = !0, n ? t.ctrl = !0 : t.shift = !0), t.meta && (n ? t.meta = !0 : (t.ctrl = !0, t.meta = !1)), t;
    };
    class gF {
      constructor(t) {
        this.shortcuts = {}, this.pendingPatterns = [], this.editor = t;
        const n = this;
        t.on("keyup keypress keydown", (r) => {
          (n.hasModifier(r) || n.isFunctionKey(r)) && !r.isDefaultPrevented() && (d8(n.shortcuts, (a) => {
            n.matchShortcut(r, a) && (n.pendingPatterns = a.subpatterns.slice(0), r.type === "keydown" && n.executeShortcutAction(a));
          }), n.matchShortcut(r, n.pendingPatterns[0]) && (n.pendingPatterns.length === 1 && r.type === "keydown" && n.executeShortcutAction(n.pendingPatterns[0]), n.pendingPatterns.shift()));
        });
      }
      add(t, n, r, a) {
        const c = this, d = c.normalizeCommandFunc(r);
        return d8(f8(Ht.trim(t)), (h) => {
          const k = c.createShortcut(h, n, d, a);
          c.shortcuts[k.id] = k;
        }), !0;
      }
      remove(t) {
        const n = this.createShortcut(t);
        return this.shortcuts[n.id] ? (delete this.shortcuts[n.id], !0) : !1;
      }
      normalizeCommandFunc(t) {
        const n = this, r = t;
        return typeof r == "string" ? () => {
          n.editor.execCommand(r, !1, null);
        } : Ht.isArray(r) ? () => {
          n.editor.execCommand(r[0], r[1], r[2]);
        } : r;
      }
      createShortcut(t, n, r, a) {
        const c = Ht.map(f8(t, ">"), pq);
        return c[c.length - 1] = Ht.extend(c[c.length - 1], {
          func: r,
          scope: a || this.editor
        }), Ht.extend(c[0], {
          desc: this.editor.translate(n),
          subpatterns: c.slice(1)
        });
      }
      hasModifier(t) {
        return t.altKey || t.ctrlKey || t.metaKey;
      }
      isFunctionKey(t) {
        return t.type === "keydown" && t.keyCode >= 112 && t.keyCode <= 123;
      }
      matchShortcut(t, n) {
        return !n || n.ctrl !== t.ctrlKey || n.meta !== t.metaKey || n.alt !== t.altKey || n.shift !== t.shiftKey ? !1 : t.keyCode === n.keyCode || t.charCode && t.charCode === n.charCode ? (t.preventDefault(), !0) : !1;
      }
      executeShortcutAction(t) {
        return t.func ? t.func.call(t.scope) : null;
      }
    }
    const gq = () => {
      const e = {}, t = {}, n = {}, r = {}, a = {}, c = {}, d = {}, h = {}, k = (H, U) => (G, ie) => {
        H[G.toLowerCase()] = {
          ...ie,
          type: U
        };
      }, D = (H, U) => r[H.toLowerCase()] = U;
      return {
        addButton: k(e, "button"),
        addGroupToolbarButton: k(e, "grouptoolbarbutton"),
        addToggleButton: k(e, "togglebutton"),
        addMenuButton: k(e, "menubutton"),
        addSplitButton: k(e, "splitbutton"),
        addMenuItem: k(t, "menuitem"),
        addNestedMenuItem: k(t, "nestedmenuitem"),
        addToggleMenuItem: k(t, "togglemenuitem"),
        addAutocompleter: k(n, "autocompleter"),
        addContextMenu: k(a, "contextmenu"),
        addContextToolbar: k(c, "contexttoolbar"),
        addContextForm: k(c, "contextform"),
        addSidebar: k(d, "sidebar"),
        addView: k(h, "views"),
        addIcon: D,
        getAll: () => ({
          buttons: e,
          menuItems: t,
          icons: r,
          popups: n,
          contextMenus: a,
          contextToolbars: c,
          sidebars: d,
          views: h
        })
      };
    }, hq = () => {
      const e = gq();
      return {
        addAutocompleter: e.addAutocompleter,
        addButton: e.addButton,
        addContextForm: e.addContextForm,
        addContextMenu: e.addContextMenu,
        addContextToolbar: e.addContextToolbar,
        addIcon: e.addIcon,
        addMenuButton: e.addMenuButton,
        addMenuItem: e.addMenuItem,
        addNestedMenuItem: e.addNestedMenuItem,
        addSidebar: e.addSidebar,
        addSplitButton: e.addSplitButton,
        addToggleButton: e.addToggleButton,
        addGroupToolbarButton: e.addGroupToolbarButton,
        addToggleMenuItem: e.addToggleMenuItem,
        addView: e.addView,
        getAll: e.getAll
      };
    }, gw = gs.DOM, hF = Ht.extend, bq = Ht.each;
    class S5 {
      constructor(t, n, r) {
        this.plugins = {}, this.contentCSS = [], this.contentStyles = [], this.loadedCSS = {}, this.isNotDirty = !1, this.composing = !1, this.destroyed = !1, this.hasHiddenInput = !1, this.iframeElement = null, this.initialized = !1, this.readonly = !1, this.removed = !1, this.startContent = "", this._pendingNativeEvents = [], this._skinLoaded = !1, this._editableRoot = !0, this.editorManager = r, this.documentBaseUrl = r.documentBaseURL, hF(this, uF);
        const a = this;
        this.id = t, this.hidden = !1;
        const c = XZ(r.defaultOptions, n);
        this.options = iq(a, c), ai(a);
        const d = this.options.get;
        d("deprecation_warnings") && jD(n, c);
        const h = d("suffix");
        h && (r.suffix = h), this.suffix = r.suffix;
        const k = d("base_url");
        k && r._setBaseUrl(k), this.baseUri = r.baseURI;
        const D = n1(a);
        D && (Gl.ScriptLoader._setReferrerPolicy(D), gs.DOM.styleSheetLoader._setReferrerPolicy(D));
        const H = $f(a);
        Xe(H) && gs.DOM.styleSheetLoader._setContentCssCors(H), Bl.languageLoad = d("language_load"), Bl.baseURL = r.baseURL, this.setDirty(!1), this.documentBaseURI = new Zu(yl(a), { base_uri: this.baseUri }), this.baseURI = this.baseUri, this.inline = Ib(a), this.hasVisual = gr(a), this.shortcuts = new gF(this), this.editorCommands = new aF(this), $W(this);
        const U = d("cache_suffix");
        U && (nr.cacheSuffix = U.replace(/^[\?\&]+/, "")), this.ui = {
          registry: hq(),
          styleSheetLoader: void 0,
          show: ht,
          hide: ht,
          setEnabled: ht,
          isEnabled: Mo
        }, this.mode = dq(a), r.dispatch("SetupEditor", { editor: this });
        const G = $b(a);
        un(G) && G.call(a, a);
      }
      render() {
        LZ(this);
      }
      focus(t) {
        this.execCommand("mceFocus", !1, t);
      }
      hasFocus() {
        return ty(this);
      }
      translate(t) {
        return Rc.translate(t);
      }
      getParam(t, n, r) {
        const a = this.options;
        return a.isRegistered(t) || (Xe(r) ? a.register(t, {
          processor: r,
          default: n
        }) : a.register(t, {
          processor: Mo,
          default: n
        })), !a.isSet(t) && !ko(n) ? n : a.get(t);
      }
      hasPlugin(t, n) {
        return So(cp(this), t) ? n ? M1.get(t) !== void 0 : !0 : !1;
      }
      nodeChanged(t) {
        this._nodeChangeDispatcher.nodeChanged(t);
      }
      addCommand(t, n, r) {
        this.editorCommands.addCommand(t, n, r);
      }
      addQueryStateHandler(t, n, r) {
        this.editorCommands.addQueryStateHandler(t, n, r);
      }
      addQueryValueHandler(t, n, r) {
        this.editorCommands.addQueryValueHandler(t, n, r);
      }
      addShortcut(t, n, r, a) {
        this.shortcuts.add(t, n, r, a);
      }
      execCommand(t, n, r, a) {
        return this.editorCommands.execCommand(t, n, r, a);
      }
      queryCommandState(t) {
        return this.editorCommands.queryCommandState(t);
      }
      queryCommandValue(t) {
        return this.editorCommands.queryCommandValue(t);
      }
      queryCommandSupported(t) {
        return this.editorCommands.queryCommandSupported(t);
      }
      show() {
        const t = this;
        t.hidden && (t.hidden = !1, t.inline ? t.getBody().contentEditable = "true" : (gw.show(t.getContainer()), gw.hide(t.id)), t.load(), t.dispatch("show"));
      }
      hide() {
        const t = this;
        t.hidden || (t.save(), t.inline ? (t.getBody().contentEditable = "false", t === t.editorManager.focusedEditor && (t.editorManager.focusedEditor = null)) : (gw.hide(t.getContainer()), gw.setStyle(t.id, "display", t.orgDisplay)), t.hidden = !0, t.dispatch("hide"));
      }
      isHidden() {
        return this.hidden;
      }
      setProgressState(t, n) {
        this.dispatch("ProgressState", {
          state: t,
          time: n
        });
      }
      load(t = {}) {
        const n = this, r = n.getElement();
        if (n.removed)
          return "";
        if (r) {
          const a = {
            ...t,
            load: !0
          }, c = Uc(r) ? r.value : r.innerHTML, d = n.setContent(c, a);
          return a.no_events || n.dispatch("LoadContent", {
            ...a,
            element: r
          }), d;
        } else
          return "";
      }
      save(t = {}) {
        const n = this;
        let r = n.getElement();
        if (!r || !n.initialized || n.removed)
          return "";
        const a = {
          ...t,
          save: !0,
          element: r
        };
        let c = n.getContent(a);
        const d = {
          ...a,
          content: c
        };
        if (d.no_events || n.dispatch("SaveContent", d), d.format === "raw" && n.dispatch("RawSaveContent", d), c = d.content, Uc(r))
          r.value = c;
        else {
          (t.is_removing || !n.inline) && (r.innerHTML = c);
          const h = gw.getParent(n.id, "form");
          h && bq(h.elements, (k) => k.name === n.id ? (k.value = c, !1) : !0);
        }
        return d.element = a.element = r = null, d.set_dirty !== !1 && n.setDirty(!1), c;
      }
      setContent(t, n) {
        return Z4(this, t, n);
      }
      getContent(t) {
        return G6(this, t);
      }
      insertContent(t, n) {
        n && (t = hF({ content: t }, n)), this.execCommand("mceInsertContent", !1, t);
      }
      resetContent(t) {
        t === void 0 ? Z4(this, this.startContent, { format: "raw" }) : Z4(this, t), this.undoManager.reset(), this.setDirty(!1), this.nodeChanged();
      }
      isDirty() {
        return !this.isNotDirty;
      }
      setDirty(t) {
        const n = !this.isNotDirty;
        this.isNotDirty = !t, t && t !== n && this.dispatch("dirty");
      }
      getContainer() {
        const t = this;
        return t.container || (t.container = t.editorContainer || gw.get(t.id + "_parent")), t.container;
      }
      getContentAreaContainer() {
        return this.contentAreaContainer;
      }
      getElement() {
        return this.targetElm || (this.targetElm = gw.get(this.id)), this.targetElm;
      }
      getWin() {
        const t = this;
        if (!t.contentWindow) {
          const n = t.iframeElement;
          n && (t.contentWindow = n.contentWindow);
        }
        return t.contentWindow;
      }
      getDoc() {
        const t = this;
        if (!t.contentDocument) {
          const n = t.getWin();
          n && (t.contentDocument = n.document);
        }
        return t.contentDocument;
      }
      getBody() {
        var t, n;
        const r = this.getDoc();
        return (n = (t = this.bodyElement) !== null && t !== void 0 ? t : r == null ? void 0 : r.body) !== null && n !== void 0 ? n : null;
      }
      convertURL(t, n, r) {
        const a = this, c = a.options.get, d = Fw(a);
        if (un(d))
          return d.call(a, t, r, !0, n);
        if (!c("convert_urls") || r === "link" || Ee(r) && r.nodeName === "LINK" || t.indexOf("file:") === 0 || t.length === 0)
          return t;
        const h = new Zu(t);
        return h.protocol !== "http" && h.protocol !== "https" && h.protocol !== "" ? t : c("relative_urls") ? a.documentBaseURI.toRelative(t) : (t = a.documentBaseURI.toAbsolute(t, c("remove_script_host")), t);
      }
      addVisual(t) {
        JZ(this, t);
      }
      setEditableRoot(t) {
        PZ(this, t);
      }
      hasEditableRoot() {
        return IZ(this);
      }
      remove() {
        tL(this);
      }
      destroy(t) {
        WD(this, t);
      }
      uploadImages() {
        return this.editorUpload.uploadImages();
      }
      _scanForImages() {
        return this.editorUpload.scanForImages();
      }
    }
    const V2 = gs.DOM, E5 = Ht.each;
    let bF = !1, T5, Xf = [];
    const z5 = (e) => {
      const t = e.type;
      E5(fv.get(), (n) => {
        switch (t) {
          case "scroll":
            n.dispatch("ScrollWindow", e);
            break;
          case "resize":
            n.dispatch("ResizeWindow", e);
            break;
        }
      });
    }, yF = (e) => {
      if (e !== bF) {
        const t = gs.DOM;
        e ? (t.bind(window, "resize", z5), t.bind(window, "scroll", z5)) : (t.unbind(window, "resize", z5), t.unbind(window, "scroll", z5)), bF = e;
      }
    }, vF = (e) => {
      const t = Xf;
      return Xf = ct(Xf, (n) => e !== n), fv.activeEditor === e && (fv.activeEditor = Xf.length > 0 ? Xf[0] : null), fv.focusedEditor === e && (fv.focusedEditor = null), t.length !== Xf.length;
    }, yq = (e) => {
      e && e.initialized && !(e.getContainer() || e.getBody()).parentNode && (vF(e), e.unbindAllNativeEvents(), e.destroy(!0), e.removed = !0);
    }, vq = document.compatMode !== "CSS1Compat", fv = {
      ...c8,
      baseURI: null,
      baseURL: null,
      defaultOptions: {},
      documentBaseURL: null,
      suffix: null,
      majorVersion: "6",
      minorVersion: "8.5",
      releaseDate: "TBD",
      i18n: Rc,
      activeEditor: null,
      focusedEditor: null,
      setup() {
        const e = this;
        let t = "", n = "", r = Zu.getDocumentBaseUrl(document.location);
        /^[^:]+:\/\/\/?[^\/]+\//.test(r) && (r = r.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(r) || (r += "/"));
        const a = window.tinymce || window.tinyMCEPreInit;
        if (a)
          t = a.base || a.baseURL, n = a.suffix;
        else {
          const c = document.getElementsByTagName("script");
          for (let d = 0; d < c.length; d++) {
            const h = c[d].src || "";
            if (h === "")
              continue;
            const k = h.substring(h.lastIndexOf("/"));
            if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(h)) {
              k.indexOf(".min") !== -1 && (n = ".min"), t = h.substring(0, h.lastIndexOf("/"));
              break;
            }
          }
          if (!t && document.currentScript) {
            const d = document.currentScript.src;
            d.indexOf(".min") !== -1 && (n = ".min"), t = d.substring(0, d.lastIndexOf("/"));
          }
        }
        e.baseURL = new Zu(r).toAbsolute(t), e.documentBaseURL = r, e.baseURI = new Zu(e.baseURL), e.suffix = n, Jv(e);
      },
      overrideDefaults(e) {
        const t = e.base_url;
        t && this._setBaseUrl(t);
        const n = e.suffix;
        n && (this.suffix = n), this.defaultOptions = e;
        const r = e.plugin_base_urls;
        r !== void 0 && Zo(r, (a, c) => {
          Bl.PluginManager.urls[c] = a;
        });
      },
      init(e) {
        const t = this;
        let n;
        const r = Ht.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu", " "), a = (H, U) => H.inline && U.tagName.toLowerCase() in r, c = (H) => {
          let U = H.id;
          return U || (U = Hr(H, "name").filter((G) => !V2.get(G)).getOrThunk(V2.uniqueId), H.setAttribute("id", U)), U;
        }, d = (H) => {
          const U = e[H];
          if (U)
            return U.apply(t, []);
        }, h = (H) => nr.browser.isIE() || nr.browser.isEdge() ? (d2("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers"), []) : vq ? (d2("Failed to initialize the editor as the document is not in standards mode. TinyMCE requires standards mode."), []) : Ot(H.selector) ? V2.select(H.selector) : Xe(H.target) ? [H.target] : [];
        let k = (H) => {
          n = H;
        };
        const D = () => {
          let H = 0;
          const U = [];
          let G;
          const ie = (ye, ae, xe) => {
            const Ne = new S5(ye, ae, t);
            U.push(Ne), Ne.on("init", () => {
              ++H === G.length && k(U);
            }), Ne.targetElm = Ne.targetElm || xe, Ne.render();
          };
          V2.unbind(window, "ready", D), d("onpageload"), G = Si(h(e)), Ht.each(G, (ye) => {
            yq(t.get(ye.id));
          }), G = Ht.grep(G, (ye) => !t.get(ye.id)), G.length === 0 ? k([]) : E5(G, (ye) => {
            a(e, ye) ? d2("Could not initialize inline editor on invalid inline target element", ye) : ie(c(ye), e, ye);
          });
        };
        return V2.bind(window, "ready", D), new Promise((H) => {
          n ? H(n) : k = (U) => {
            H(U);
          };
        });
      },
      get(e) {
        return arguments.length === 0 ? Xf.slice(0) : Ot(e) ? po(Xf, (t) => t.id === e).getOr(null) : M(e) && Xf[e] ? Xf[e] : null;
      },
      add(e) {
        const t = this, n = t.get(e.id);
        return n === e || (n === null && Xf.push(e), yF(!0), t.activeEditor = e, t.dispatch("AddEditor", { editor: e }), T5 || (T5 = (r) => {
          const a = t.dispatch("BeforeUnload");
          if (a.returnValue)
            return r.preventDefault(), r.returnValue = a.returnValue, a.returnValue;
        }, window.addEventListener("beforeunload", T5))), e;
      },
      createEditor(e, t) {
        return this.add(new S5(e, t, this));
      },
      remove(e) {
        const t = this;
        let n;
        if (!e) {
          for (let r = Xf.length - 1; r >= 0; r--)
            t.remove(Xf[r]);
          return;
        }
        if (Ot(e)) {
          E5(V2.select(e), (r) => {
            n = t.get(r.id), n && t.remove(n);
          });
          return;
        }
        return n = e, We(t.get(n.id)) ? null : (vF(n) && t.dispatch("RemoveEditor", { editor: n }), Xf.length === 0 && window.removeEventListener("beforeunload", T5), n.remove(), yF(Xf.length > 0), n);
      },
      execCommand(e, t, n) {
        var r;
        const a = this, c = Ee(n) ? (r = n.id) !== null && r !== void 0 ? r : n.index : n;
        switch (e) {
          case "mceAddEditor": {
            if (!a.get(c)) {
              const d = n.options;
              new S5(c, d, a).render();
            }
            return !0;
          }
          case "mceRemoveEditor": {
            const d = a.get(c);
            return d && d.remove(), !0;
          }
          case "mceToggleEditor": {
            const d = a.get(c);
            return d ? (d.isHidden() ? d.show() : d.hide(), !0) : (a.execCommand("mceAddEditor", !1, n), !0);
          }
        }
        return a.activeEditor ? a.activeEditor.execCommand(e, t, n) : !1;
      },
      triggerSave: () => {
        E5(Xf, (e) => {
          e.save();
        });
      },
      addI18n: (e, t) => {
        Rc.add(e, t);
      },
      translate: (e) => Rc.translate(e),
      setActive(e) {
        const t = this.activeEditor;
        this.activeEditor !== e && (t && t.dispatch("deactivate", { relatedTarget: e }), e.dispatch("activate", { relatedTarget: t })), this.activeEditor = e;
      },
      _setBaseUrl(e) {
        this.baseURL = new Zu(this.documentBaseURL).toAbsolute(e.replace(/\/+$/, "")), this.baseURI = new Zu(this.baseURL);
      }
    };
    fv.setup();
    const xq = (() => {
      const e = sf(), t = (c) => ({
        items: c,
        types: Nt(c),
        getType: (d) => Hr(c, d).getOrUndefined()
      }), n = (c) => {
        e.set(c);
      }, r = () => e.get().getOrUndefined(), a = e.clear;
      return {
        FakeClipboardItem: t,
        write: n,
        read: r,
        clear: a
      };
    })(), xF = Math.min, U2 = Math.max, O5 = Math.round, wF = (e, t, n) => {
      let r = t.x, a = t.y;
      const c = e.w, d = e.h, h = t.w, k = t.h, D = (n || "").split("");
      return D[0] === "b" && (a += k), D[1] === "r" && (r += h), D[0] === "c" && (a += O5(k / 2)), D[1] === "c" && (r += O5(h / 2)), D[3] === "b" && (a -= d), D[4] === "r" && (r -= c), D[3] === "c" && (a -= O5(d / 2)), D[4] === "c" && (r -= O5(c / 2)), j2(r, a, c, d);
    }, wq = (e, t, n, r) => {
      for (let a = 0; a < r.length; a++) {
        const c = wF(e, t, r[a]);
        if (c.x >= n.x && c.x + c.w <= n.w + n.x && c.y >= n.y && c.y + c.h <= n.h + n.y)
          return r[a];
      }
      return null;
    }, kq = (e, t, n) => j2(e.x - t, e.y - n, e.w + t * 2, e.h + n * 2), _q = (e, t) => {
      const n = U2(e.x, t.x), r = U2(e.y, t.y), a = xF(e.x + e.w, t.x + t.w), c = xF(e.y + e.h, t.y + t.h);
      return a - n < 0 || c - r < 0 ? null : j2(n, r, a - n, c - r);
    }, Cq = (e, t, n) => {
      let r = e.x, a = e.y, c = e.x + e.w, d = e.y + e.h;
      const h = t.x + t.w, k = t.y + t.h, D = U2(0, t.x - r), H = U2(0, t.y - a), U = U2(0, c - h), G = U2(0, d - k);
      return r += D, a += H, n && (c += D, d += H, r -= U, a -= G), c -= U, d -= G, j2(r, a, c - r, d - a);
    }, j2 = (e, t, n, r) => ({
      x: e,
      y: t,
      w: n,
      h: r
    }), Sq = {
      inflate: kq,
      relativePosition: wF,
      findBestRelativePosition: wq,
      intersect: _q,
      clamp: Cq,
      create: j2,
      fromClientRect: (e) => j2(e.left, e.top, e.width, e.height)
    }, Eq = (e, t, n = 1e3) => {
      let r = !1, a = null;
      const c = (D) => (...H) => {
        r || (r = !0, a !== null && (clearTimeout(a), a = null), D.apply(null, H));
      }, d = c(e), h = c(t);
      return {
        start: (...D) => {
          !r && a === null && (a = setTimeout(() => h.apply(null, D), n));
        },
        resolve: d,
        reject: h
      };
    }, Tq = (() => {
      const e = {}, t = {}, n = {};
      return {
        load: (k, D) => {
          const H = `Script at URL "${D}" failed to load`, U = `Script at URL "${D}" did not call \`tinymce.Resource.add('${k}', data)\` within 1 second`;
          if (e[k] !== void 0)
            return e[k];
          {
            const G = new Promise((ie, ye) => {
              const ae = Eq(ie, ye);
              t[k] = ae.resolve, Gl.ScriptLoader.loadScript(D).then(() => ae.start(U), () => ae.reject(H));
            });
            return e[k] = G, G;
          }
        },
        add: (k, D) => {
          t[k] !== void 0 && (t[k](D), delete t[k]), e[k] = Promise.resolve(D), n[k] = D;
        },
        has: (k) => k in n,
        get: (k) => n[k],
        unload: (k) => {
          delete e[k];
        }
      };
    })(), zq = () => (() => {
      let e = {}, t = [];
      const n = {
        getItem: (r) => {
          const a = e[r];
          return a || null;
        },
        setItem: (r, a) => {
          t.push(r), e[r] = String(a);
        },
        key: (r) => t[r],
        removeItem: (r) => {
          t = t.filter((a) => a === r), delete e[r];
        },
        clear: () => {
          t = [], e = {};
        },
        length: 0
      };
      return Object.defineProperty(n, "length", {
        get: () => t.length,
        configurable: !1,
        enumerable: !1
      }), n;
    })();
    let oT;
    try {
      const e = "__storage_test__";
      oT = window.localStorage, oT.setItem(e, e), oT.removeItem(e);
    } catch {
      oT = zq();
    }
    var Oq = oT;
    const Aq = {
      geom: { Rect: Sq },
      util: {
        Delay: du,
        Tools: Ht,
        VK: yn,
        URI: Zu,
        EventDispatcher: l8,
        Observable: c8,
        I18n: Rc,
        LocalStorage: Oq,
        ImageUploader: fR
      },
      dom: {
        EventUtils: pm,
        TreeWalker: vi,
        TextSeeker: tp,
        DOMUtils: gs,
        ScriptLoader: Gl,
        RangeUtils: Fg,
        Serializer: j4,
        StyleSheetLoader: ms,
        ControlSelection: cS,
        BookmarkManager: w0,
        Selection: H4,
        Event: pm.Event
      },
      html: {
        Styles: rf,
        Entities: ma,
        Node: qc,
        Schema: of,
        DomParser: yy,
        Writer: WS,
        Serializer: Jl
      },
      Env: nr,
      AddOnManager: Bl,
      Annotator: QC,
      Formatter: P1,
      UndoManager: Xx,
      EditorCommands: aF,
      WindowManager: X4,
      NotificationManager: eR,
      EditorObservable: uF,
      Shortcuts: gF,
      Editor: S5,
      FocusManager: vz,
      EditorManager: fv,
      DOM: gs.DOM,
      ScriptLoader: Gl.ScriptLoader,
      PluginManager: M1,
      ThemeManager: jh,
      ModelManager: N1,
      IconManager: Wx,
      Resource: Tq,
      FakeClipboard: xq,
      trim: Ht.trim,
      isArray: Ht.isArray,
      is: Ht.is,
      toArray: Ht.toArray,
      makeMap: Ht.makeMap,
      each: Ht.each,
      map: Ht.map,
      grep: Ht.grep,
      inArray: Ht.inArray,
      extend: Ht.extend,
      walk: Ht.walk,
      resolve: Ht.resolve,
      explode: Ht.explode,
      _addCacheSuffix: Ht._addCacheSuffix
    }, kF = Ht.extend(fv, Aq), Dq = (e) => {
      try {
        v.exports = e;
      } catch {
      }
    };
    ((e) => {
      window.tinymce = e, window.tinyMCE = e;
    })(kF), Dq(kF);
  })();
})(fK);
tinymce.IconManager.add("default", { icons: { "accessibility-check": '<svg width="24" height="24"><path d="M12 2a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2c0-1.1.9-2 2-2Zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5c0-.6-.4-1-1-1a1 1 0 0 0-1 1v5c0 .6-.4 1-1 1a1 1 0 0 1-1-1V9H4a1 1 0 1 1 0-2h16c.6 0 1 .4 1 1s-.4 1-1 1Z" fill-rule="nonzero"/></svg>', "accordion-toggle": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 15c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1h-6a1 1 0 0 1-1-1Z"/><path opacity=".2" fill-rule="evenodd" clip-rule="evenodd" d="M4 15c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1-1-1Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12 19c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1h-6a1 1 0 0 1-1-1Z"/><path opacity=".2" fill-rule="evenodd" clip-rule="evenodd" d="M4 19c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1-1-1Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3 7.3a1 1 0 0 1 1.4 0L16 9.6l2.3-2.3a1 1 0 1 1 1.4 1.4L16 12.4l-3.7-3.7a1 1 0 0 1 0-1.4ZM4.3 11.7a1 1 0 0 1 0-1.4L6.6 8 4.3 5.7a1 1 0 0 1 1.4-1.4L9.4 8l-3.7 3.7a1 1 0 0 1-1.4 0Z"/></svg>', accordion: '<svg width="24" height="24"><rect x="12" y="7" width="10" height="2" rx="1"/><rect x="12" y="11" width="10" height="2" rx="1"/><rect x="12" y="15" width="6" height="2" rx="1"/><path fill-rule="evenodd" clip-rule="evenodd" d="M2.3 7.3a1 1 0 0 1 1.4 0L6 9.6l2.3-2.3a1 1 0 0 1 1.4 1.4L6 12.4 2.3 8.7a1 1 0 0 1 0-1.4Z"/></svg>', "action-next": '<svg width="24" height="24"><path fill-rule="nonzero" d="M5.7 7.3a1 1 0 0 0-1.4 1.4l7.7 7.7 7.7-7.7a1 1 0 1 0-1.4-1.4L12 13.6 5.7 7.3Z"/></svg>', "action-prev": '<svg width="24" height="24"><path fill-rule="nonzero" d="M18.3 15.7a1 1 0 0 0 1.4-1.4L12 6.6l-7.7 7.7a1 1 0 0 0 1.4 1.4L12 9.4l6.3 6.3Z"/></svg>', addtag: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 5a2 2 0 0 1 1.6.8L21 12l-4.4 6.2a2 2 0 0 1-1.6.8h-3v-2h3l3.5-5L15 7H5v3H3V7c0-1.1.9-2 2-2h10Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6 12a1 1 0 0 0-1 1v2H3a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2H7v-2c0-.6-.4-1-1-1Z"/></svg>', "ai-prompt": '<svg width="24" height="24"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 6.7a1 1 0 0 0-1.4 0l-9.9 10a1 1 0 0 0 0 1.3l2.1 2.1c.4.4 1 .4 1.4 0l10-9.9c.3-.3.3-1 0-1.4l-2.2-2Zm1.4 2.8-2-2-3 2.7 2.2 2.2 2.8-2.9Z"/><path d="m18.5 7.3-.7-1.5-1.5-.8 1.5-.7.7-1.5.7 1.5 1.5.7-1.5.8-.7 1.5ZM18.5 16.5l-.7-1.6-1.5-.7 1.5-.7.7-1.6.7 1.6 1.5.7-1.5.7-.7 1.6ZM9.7 7.3 9 5.8 7.5 5 9 4.3l.7-1.5.7 1.5L12 5l-1.5.8-.7 1.5Z"/></g><defs><clipPath id="a"><path d="M0 0h24v24H0z"/></clipPath></defs></svg>', ai: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M5 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3H5Zm6.8 11.5.5 1.2a68.3 68.3 0 0 0 .7 1.1l.4.1c.3 0 .5 0 .7-.3.2-.1.3-.3.3-.6l-.3-1-2.6-6.2a20.4 20.4 0 0 0-.5-1.3l-.5-.4-.7-.2c-.2 0-.5 0-.6.2-.2 0-.4.2-.5.4l-.3.6-.3.7L5.7 15l-.2.6-.1.4c0 .3 0 .5.3.7l.6.2c.3 0 .5 0 .7-.2l.4-1 .5-1.2h3.9ZM9.8 9l1.5 4h-3l1.5-4Zm5.6-.9v7.6c0 .4 0 .7.2 1l.7.2c.3 0 .6 0 .8-.3l.2-.9V8.1c0-.4 0-.7-.2-.9a1 1 0 0 0-.8-.3c-.2 0-.5.1-.7.3l-.2 1Z"/></svg>', "align-center": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>', "align-justify": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>', "align-left": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>', "align-none": '<svg width="24" height="24"><path d="M14.2 5 13 7H5a1 1 0 1 1 0-2h9.2Zm4 0h.8a1 1 0 0 1 0 2h-2l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h6.8Zm4 0H19a1 1 0 0 1 0 2h-4.4l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h4.4Zm4 0H19a1 1 0 0 1 0 2h-6.8l1.2-2ZM7 17l-1.2 2H5a1 1 0 0 1 0-2h2Zm4 0h8a1 1 0 0 1 0 2H9.8l1.2-2Zm5.2-13.5 1.3.7-9.7 16.3-1.3-.7 9.7-16.3Z" fill-rule="evenodd"/></svg>', "align-right": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>', "arrow-left": '<svg width="24" height="24"><path d="m5.6 13 12 6a1 1 0 0 0 1.4-1V6a1 1 0 0 0-1.4-.9l-12 6a1 1 0 0 0 0 1.8Z" fill-rule="evenodd"/></svg>', "arrow-right": '<svg width="24" height="24"><path d="m18.5 13-12 6A1 1 0 0 1 5 18V6a1 1 0 0 1 1.4-.9l12 6a1 1 0 0 1 0 1.8Z" fill-rule="evenodd"/></svg>', bold: '<svg width="24" height="24"><path d="M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 0 1-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8Zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4Zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4Z" fill-rule="evenodd"/></svg>', bookmark: '<svg width="24" height="24"><path d="M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 0 0-1 1Z" fill-rule="nonzero"/></svg>', "border-style": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="2" x="3" y="6" rx="1"/><rect width="2.8" height="2" x="3" y="16" rx="1"/><rect width="2.8" height="2" x="6.8" y="16" rx="1"/><rect width="2.8" height="2" x="10.6" y="16" rx="1"/><rect width="2.8" height="2" x="14.4" y="16" rx="1"/><rect width="2.8" height="2" x="18.2" y="16" rx="1"/><rect width="8" height="2" x="3" y="11" rx="1"/><rect width="8" height="2" x="13" y="11" rx="1"/></g></svg>', "border-width": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="5" x="3" y="5" rx="1"/><rect width="18" height="3.5" x="3" y="11.5" rx="1"/><rect width="18" height="2" x="3" y="17" rx="1"/></g></svg>', brightness: '<svg width="24" height="24"><path d="M12 17c.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7v-1c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3Zm0-10a1 1 0 0 1-.7-.3A1 1 0 0 1 11 6V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3Zm7 4c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-1a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1ZM7 12c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H5a1 1 0 0 1-.7-.3A1 1 0 0 1 4 12c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1c.3 0 .5.1.7.3.2.2.3.4.3.7Zm10 3.5.7.8c.2.1.3.4.3.6 0 .3-.1.6-.3.8a1 1 0 0 1-.8.3 1 1 0 0 1-.6-.3l-.8-.7a1 1 0 0 1-.3-.8c0-.2.1-.5.3-.7a1 1 0 0 1 1.4 0Zm-10-7-.7-.8a1 1 0 0 1-.3-.6c0-.3.1-.6.3-.8.2-.2.5-.3.8-.3.2 0 .5.1.7.3l.7.7c.2.2.3.5.3.8 0 .2-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.8-.3Zm10 0a1 1 0 0 1-.8.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.6.3-.8l.8-.7c.1-.2.4-.3.6-.3.3 0 .6.1.8.3.2.2.3.5.3.8 0 .2-.1.5-.3.7l-.7.7Zm-10 7c.2-.2.5-.3.8-.3.2 0 .5.1.7.3a1 1 0 0 1 0 1.4l-.8.8a1 1 0 0 1-.6.3 1 1 0 0 1-.8-.3 1 1 0 0 1-.3-.8c0-.2.1-.5.3-.6l.7-.8ZM12 8a4 4 0 0 1 3.7 2.4 4 4 0 0 1 0 3.2A4 4 0 0 1 12 16a4 4 0 0 1-3.7-2.4 4 4 0 0 1 0-3.2A4 4 0 0 1 12 8Zm0 6.5c.7 0 1.3-.2 1.8-.7.5-.5.7-1.1.7-1.8s-.2-1.3-.7-1.8c-.5-.5-1.1-.7-1.8-.7s-1.3.2-1.8.7c-.5.5-.7 1.1-.7 1.8s.2 1.3.7 1.8c.5.5 1.1.7 1.8.7Z" fill-rule="evenodd"/></svg>', browse: '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9.4-2.3 2.3a1 1 0 1 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1-1.4 1.4L13 13.4V20a1 1 0 0 1-2 0v-6.6Z" fill-rule="nonzero"/></svg>', cancel: '<svg width="24" height="24"><path d="M12 4.6a7.4 7.4 0 1 1 0 14.8 7.4 7.4 0 0 1 0-14.8ZM12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7Z" fill-rule="nonzero"/></svg>', "cell-background-color": '<svg width="24" height="24"><path d="m15.7 2 1.6 1.6-2.7 2.6 5.9 5.8c.7.7.7 1.7 0 2.4l-6.3 6.1a1.7 1.7 0 0 1-2.4 0l-6.3-6.1c-.7-.7-.7-1.7 0-2.4L15.7 2ZM18 12l-4.5-4L9 12h9ZM4 16s2 2.4 2 3.8C6 21 5.1 22 4 22s-2-1-2-2.2C2 18.4 4 16 4 16Z"/></svg>', "cell-border-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M5 13v5h2v2H5a2 2 0 0 1-2-2v-5h2zm8-7V4h6a2 2 0 0 1 2 2h-8z" opacity=".2"/><path fill-rule="nonzero" d="M13 4v2H5v7H3V6c0-1.1.9-2 2-2h8zm-2.6 14.1.1-.1.1.1.2.3.2.2.2.2c.4.6.8 1.2.8 1.7 0 .8-.7 1.5-1.5 1.5S9 21.3 9 20.5c0-.5.4-1.1.8-1.7l.2-.2.2-.2.2-.3z"/><path d="m13 11-2 2H5v-2h6V6h2z"/><path fill-rule="nonzero" d="m18.4 8 1 1-1.8 1.9 4 4c.5.4.5 1.1 0 1.6l-4.3 4.2a1.2 1.2 0 0 1-1.6 0l-4.4-4.2c-.4-.5-.4-1.2 0-1.7l7-6.8Zm1.6 7-3-3-3 3h6Z"/></g></svg>', "change-case": '<svg width="24" height="24"><path d="M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 0 1-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 0 1-1 .7h-.2a.7.7 0 0 1-.7-1l4-12a1 1 0 0 1 2 0l4 12a.7.7 0 0 1-.8 1h-.2a1 1 0 0 1-1-.7l-.8-2.6zm-.3-1.5-2-6.5-1.9 6.5h3.9z" fill-rule="evenodd"/></svg>', "character-count": '<svg width="24" height="24"><path d="M4 11.5h16v1H4v-1Zm4.8-6.8V10H7.7V5.8h-1v-1h2ZM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1Zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1ZM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2V18.7l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 0 1-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 0 0-.5-.1 1 1 0 0 0-.4 0l-.3.4h-1Zm2.3.8h-.2l-.2.1-.4.1a1 1 0 0 0-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6Zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4Zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 0 0 1.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 0 0-.6-.3l-.6.3-.2.8Zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 0 0-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 0 1-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 0 1-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1Z" fill-rule="evenodd"/></svg>', "checklist-rtl": '<svg width="24" height="24"><path d="M5 17h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm14.2 11c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 8c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>', checklist: '<svg width="24" height="24"><path d="M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2h-8a1 1 0 0 1 0-2ZM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Z" fill-rule="evenodd"/></svg>', checkmark: '<svg width="24" height="24"><path d="M18.2 5.4a1 1 0 0 1 1.6 1.2l-8 12a1 1 0 0 1-1.5.1l-5-5a1 1 0 1 1 1.4-1.4l4.1 4.1 7.4-11Z" fill-rule="nonzero"/></svg>', "chevron-down": '<svg width="10" height="10"><path d="M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 0 1 0-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8Z" fill-rule="nonzero"/></svg>', "chevron-left": '<svg width="10" height="10"><path d="M7.8 1.3 4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 0 1 0-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1Z" fill-rule="nonzero"/></svg>', "chevron-right": '<svg width="10" height="10"><path d="M2.2 1.3a.8.8 0 0 1 0-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 0 1 0-1.1L6 5 2.2 1.3Z" fill-rule="nonzero"/></svg>', "chevron-up": '<svg width="10" height="10"><path d="M8.7 7.8 5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 0 1 0-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0Z" fill-rule="nonzero"/></svg>', close: '<svg width="24" height="24"><path d="M17.3 8.2 13.4 12l3.9 3.8a1 1 0 0 1-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 0 1-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 0 1 1.5-1.5l3.8 3.9 3.8-3.9a1 1 0 0 1 1.5 1.5Z" fill-rule="evenodd"/></svg>', "code-sample": '<svg width="24" height="26"><path d="M7.1 11a2.8 2.8 0 0 1-.8 2 2.8 2.8 0 0 1 .8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11Zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 0 1-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 0 1 .8-2 2.8 2.8 0 0 1-.8-2Zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2ZM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 0 1-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 0 1-.5-.5V17a3 3 0 0 0 1-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5Z" fill-rule="evenodd"/></svg>', "color-levels": '<svg width="24" height="24"><path d="M17.5 11.4A9 9 0 0 1 18 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 0 1-3.7 3 5.7 5.7 0 0 1-3.2 0A5.9 5.9 0 0 1 7.6 18a6.2 6.2 0 0 1-1.4-2.6 6.7 6.7 0 0 1 0-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 0 1 2.3-4A20 20 0 0 1 12 4a26.4 26.4 0 0 1 3.2 3.4 18.2 18.2 0 0 1 2.3 4Zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 0 0-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 0 1-1.3 3 5.3 5.3 0 0 1-2.3 1.5 4.9 4.9 0 0 1-2 .1 4.3 4.3 0 0 0 2.4.8 4 4 0 0 0 2-.6 4 4 0 0 0 1.5-1.5Z" fill-rule="evenodd"/></svg>', "color-picker": '<svg width="24" height="24"><path d="M12 3a9 9 0 0 0 0 18 1.5 1.5 0 0 0 1.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 0 0 5-5c0-4.4-4-8-9-8Zm-5.5 9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3-4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3 4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Z" fill-rule="nonzero"/></svg>', "color-swatch-remove-color": '<svg width="24" height="24"><path stroke="#000" stroke-width="2" d="M21 3 3 21" fill-rule="evenodd"/></svg>', "color-swatch": '<svg width="24" height="24"><rect x="3" y="3" width="18" height="18" rx="1" fill-rule="evenodd"/></svg>', "comment-add": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/><path d="M13 10h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 0v-2H9a1 1 0 0 1 0-2h2V8a1 1 0 0 1 2 0v2Z"/></g></svg>', comment: '<svg width="24" height="24"><path fill-rule="nonzero" d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/></svg>', contrast: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-6 8a6 6 0 0 0 6 6V6a6 6 0 0 0-6 6Z" fill-rule="evenodd"/></svg>', copy: '<svg width="24" height="24"><path d="M16 3H6a2 2 0 0 0-2 2v11h2V5h10V3Zm1 4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7Zm0 12V9h-7v10h7Z" fill-rule="nonzero"/></svg>', crop: '<svg width="24" height="24"><path d="M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-2H7V9H5a1 1 0 1 1 0-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3ZM9 9v5l5-5H9Zm1 6h5v-5l-5 5Z" fill-rule="evenodd"/></svg>', "cut-column": '<svg width="24" height="24"><path fill-rule="evenodd" d="M7.2 4.5c.9 0 1.6.4 2.2 1A3.7 3.7 0 0 1 10.5 8v.5l1 1 4-4 1-.5a3.3 3.3 0 0 1 2 0c.4 0 .7.3 1 .5L17 8h4v13h-6V10l-1.5 1.5.5.5v4l-2.5-2.5-1 1v.5c0 .4 0 .8-.3 1.2-.2.5-.4.9-.8 1.2-.6.7-1.3 1-2.2 1-.8.2-1.5 0-2-.6l-.5-.8-.2-1c0-.4 0-.8.3-1.2A3.9 3.9 0 0 1 7 12.7c.5-.2 1-.3 1.5-.2l1-1-1-1c-.5 0-1 0-1.5-.2-.5-.1-1-.4-1.4-.9-.4-.3-.6-.7-.8-1.2L4.5 7c0-.4 0-.7.2-1 0-.3.3-.6.5-.8.5-.5 1.2-.8 2-.7Zm12.3 5h-3v10h3v-10ZM8 13.8h-.3l-.4.2a2.8 2.8 0 0 0-.7.4v.1a2.8 2.8 0 0 0-.6.8l-.1.4v.7l.2.5.5.2h.7a2.6 2.6 0 0 0 .8-.3 2.4 2.4 0 0 0 .7-.7 2.5 2.5 0 0 0 .3-.8 1.5 1.5 0 0 0 0-.8 1 1 0 0 0-.2-.4 1 1 0 0 0-.5-.2H8Zm3.5-3.7c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4ZM7 5.8h-.4a1 1 0 0 0-.5.3 1 1 0 0 0-.2.5v.7a2.5 2.5 0 0 0 .3.8l.2.3h.1l.4.4.4.2.4.1h.7L9 9l.2-.4a1.6 1.6 0 0 0 0-.8 2.6 2.6 0 0 0-.3-.8A2.5 2.5 0 0 0 7.7 6l-.4-.1H7Z"/></svg>', "cut-row": '<svg width="24" height="24"><path fill-rule="evenodd" d="M22 3v5H9l3 3 2-2h4l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8.7.6 1 1.3 1 2.2.2.8 0 1.5-.6 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l2 2V3h14ZM8.5 15.3h-.3a2.6 2.6 0 0 0-.8.4 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3L9 18V18l.4-.4.2-.4.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2h-.5Zm7 0H15a1 1 0 0 0-.4.3 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4a2.8 2.8 0 0 0 .5.7h.1a2.8 2.8 0 0 0 .8.6l.4.1h.7l.5-.2.2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3h-.3ZM12 11.6c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4Zm8.5-7.1h-11v2h11v-2Z"/></svg>', cut: '<svg width="24" height="24"><path d="M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 0 1 0 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8Zm-8.5 2.2.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2 1.6 1.6 0 0 0-.8 0 2.6 2.6 0 0 0-.8.3 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3 2.8 2.8 0 0 0 1-1Zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4Zm5.4 4 .2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3 1.5 1.5 0 0 0-.8 0 1 1 0 0 0-.4.2 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4l.3.4.3.4a2.8 2.8 0 0 0 .8.5l.4.1h.7l.5-.2Z" fill-rule="evenodd"/></svg>', "document-properties": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>', drag: '<svg width="24" height="24"><path d="M13 5h2v2h-2V5Zm0 4h2v2h-2V9ZM9 9h2v2H9V9Zm4 4h2v2h-2v-2Zm-4 0h2v2H9v-2Zm0 4h2v2H9v-2Zm4 0h2v2h-2v-2ZM9 5h2v2H9V5Z" fill-rule="evenodd"/></svg>', "duplicate-column": '<svg width="24" height="24"><path d="M17 6v16h-7V6h7Zm-2 2h-3v12h3V8Zm-2-6v2H8v15H6V2h7Z"/></svg>', "duplicate-row": '<svg width="24" height="24"><path d="M22 11v7H6v-7h16Zm-2 2H8v3h12v-3Zm-1-6v2H4v5H2V7h17Z"/></svg>', duplicate: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10Zm3 8h-2V9h-7v10h9a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7a2 2 0 0 1 2 2v2Z"/><path d="M17 14h1a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1h-1a1 1 0 0 1 0-2h1v-1a1 1 0 0 1 2 0v1Z"/></g></svg>', "edit-block": '<svg width="24" height="24"><path fill-rule="nonzero" d="m19.8 8.8-9.4 9.4c-.2.2-.5.4-.9.4l-5.4 1.2 1.2-5.4.5-.8 9.4-9.4c.7-.7 1.8-.7 2.5 0l2.1 2.1c.7.7.7 1.8 0 2.5Zm-2-.2 1-.9v-.3l-2.2-2.2a.3.3 0 0 0-.3 0l-1 1L18 8.5Zm-1 1-2.5-2.4-6 6 2.5 2.5 6-6Zm-7 7.1-2.6-2.4-.3.3-.1.2-.7 3 3.1-.6h.1l.4-.5Z"/></svg>', "edit-image": '<svg width="24" height="24"><path d="M18 16h2V7a2 2 0 0 0-2-2H7v2h11v9ZM6 17h15a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1H6a2 2 0 0 1-2-2V7H3a1 1 0 1 1 0-2h1V4a1 1 0 1 1 2 0v13Zm3-5.3 1.3 2 3-4.7 3.7 6H7l2-3.3Z" fill-rule="nonzero"/></svg>', "embed-page": '<svg width="24" height="24"><path d="M19 6V5H5v14h2A13 13 0 0 1 19 6Zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4Zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6Zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3Zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 0 0 8 19h3ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 0 0-4 4.5h2.2Zm-3.4 0a12 12 0 0 1 2.8-4 12 12 0 0 0-5 4h2.2Z" fill-rule="nonzero"/></svg>', embed: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm4.8 2.6 5.6 4a.5.5 0 0 1 0 .8l-5.6 4A.5.5 0 0 1 9 16V8a.5.5 0 0 1 .8-.4Z" fill-rule="nonzero"/></svg>', emoji: '<svg width="24" height="24"><path d="M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5ZM12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16Zm0 14.5a6.5 6.5 0 1 1 0-13 6.5 6.5 0 0 1 0 13Z" fill-rule="nonzero"/></svg>', export: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M14.4 3 18 7v1h-5V5H7v14h9a1 1 0 0 1 2 0c0 1-.8 2-1.9 2H7c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2h7.5Z"/><path d="M18.1 12c.5 0 .9.4.9 1 0 .5-.3 1-.8 1h-7.3c-.5 0-.9-.4-.9-1 0-.5.3-1 .8-1h7.3Z"/><path d="M16.4 9.2a1 1 0 0 1 1.4.2l2.4 3.6-2.4 3.6a1 1 0 0 1-1.7-1v-.2l1.7-2.4-1.6-2.4a1 1 0 0 1 .2-1.4Z"/></g></svg>', fill: '<svg width="24" height="26"><path d="m16.6 12-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 0 0 2.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2ZM5.2 13 10 8.2l4.8 4.8H5.2ZM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.3-2-3.5-2-3.5Z" fill-rule="nonzero"/></svg>', "flip-horizontally": '<svg width="24" height="24"><path d="M14 19h2v-2h-2v2Zm4-8h2V9h-2v2ZM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 0 0-2 2Zm14-2v2h2a2 2 0 0 0-2-2Zm-7 16h2V3h-2v18Zm7-6h2v-2h-2v2Zm-4-8h2V5h-2v2Zm4 12a2 2 0 0 0 2-2h-2v2Z" fill-rule="nonzero"/></svg>', "flip-vertically": '<svg width="24" height="24"><path d="M5 14v2h2v-2H5Zm8 4v2h2v-2h-2Zm4-14H7a2 2 0 0 0-2 2v3h2V6h10v3h2V6a2 2 0 0 0-2-2Zm2 14h-2v2a2 2 0 0 0 2-2ZM3 11v2h18v-2H3Zm6 7v2h2v-2H9Zm8-4v2h2v-2h-2ZM5 18c0 1.1.9 2 2 2v-2H5Z" fill-rule="nonzero"/></svg>', footnote: '<svg width="24" height="24"><path d="M19 13c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h14Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M19 4v6h-1V5h-1.5V4h2.6Z"/><path d="M12 18c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h7ZM14 8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2h9Z"/></svg>', "format-painter": '<svg width="24" height="24"><path d="M18 5V4c0-.5-.4-1-1-1H5a1 1 0 0 0-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3Z" fill-rule="nonzero"/></svg>', format: '<svg width="24" height="24"><path fill-rule="evenodd" d="M17 5a1 1 0 0 1 0 2h-4v11a1 1 0 0 1-2 0V7H7a1 1 0 1 1 0-2h10Z"/></svg>', fullscreen: '<svg width="24" height="24"><path d="m15.3 10-1.2-1.3 2.9-3h-2.3a.9.9 0 1 1 0-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 1 1-1.8 0V7l-2.9 3Zm0 4 3 3v-2.3a.9.9 0 1 1 1.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 1 1 0-1.8H17l-3-2.9 1.3-1.2ZM10 15.4l-2.9 3h2.3a.9.9 0 1 1 0 1.7H5a.9.9 0 0 1-.9-.9v-4.4a.9.9 0 1 1 1.8 0V17l2.9-3 1.2 1.3ZM8.7 10 5.7 7v2.3a.9.9 0 0 1-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 0 1 0 1.8H7l3 2.9-1.3 1.2Z" fill-rule="nonzero"/></svg>', gallery: '<svg width="24" height="24"><path fill-rule="nonzero" d="m5 15.7 2.3-2.2c.3-.3.7-.3 1 0L11 16l5.1-5c.3-.4.8-.4 1 0l2 1.9V8H5v7.7ZM5 18V19h3l1.8-1.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 6h16c.6 0 1 .4 1 1v13c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V7c0-.6.4-1 1-1Zm6 7a2 2 0 1 1 0-4 2 2 0 0 1 0 4ZM4.5 4h15a.5.5 0 1 1 0 1h-15a.5.5 0 0 1 0-1Zm2-2h11a.5.5 0 1 1 0 1h-11a.5.5 0 0 1 0-1Z"/></svg>', gamma: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm6.5 11.8V14L9.2 8.7a5.1 5.1 0 0 0-.4-.8l-.1-.2H8v-1l.3-.1.3-.1h.7a1 1 0 0 1 .6.5l.1.3a8.5 8.5 0 0 1 .3.6l1.9 4.6 2-5.2a1 1 0 0 1 1-.6.5.5 0 0 1 .5.6L13 14v2.8a.7.7 0 0 1-1.4 0Z" fill-rule="nonzero"/></svg>', help: '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M12 5.5a6.5 6.5 0 0 0-6 9 6.3 6.3 0 0 0 1.4 2l1 1a6.3 6.3 0 0 0 3.6 1 6.5 6.5 0 0 0 6-9 6.3 6.3 0 0 0-1.4-2l-1-1a6.3 6.3 0 0 0-3.6-1ZM12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Z"/><path d="M9.6 9.7a.7.7 0 0 1-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 0 0-.8.8.8.8 0 0 1-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8Z" fill-rule="nonzero"/><circle cx="12" cy="16" r="1"/></g></svg>', "highlight-bg-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path class="tox-icon-highlight-bg-color__color" d="M3 18h18v3H3z"/><path fill-rule="nonzero" d="M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 0 1 2.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6"/></g></svg>', home: '<svg width="24" height="24"><path fill-rule="nonzero" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>', "horizontal-rule": '<svg width="24" height="24"><path d="M4 11h16v2H4z" fill-rule="evenodd"/></svg>', "image-options": '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>', image: '<svg width="24" height="24"><path d="m5 15.7 3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7ZM5 18V19h3l2.8-2.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm6 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z" fill-rule="nonzero"/></svg>', indent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>', info: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-1 3v2h2V7h-2Zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4Z" fill-rule="evenodd"/></svg>', "insert-character": '<svg width="24" height="24"><path d="M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 0 0 1.8-2.9 6.3 6.3 0 0 0-.1-4.1 5.8 5.8 0 0 0-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 0 0-3.9 1.8 6.3 6.3 0 0 0-1.3 6 6.2 6.2 0 0 0 1.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 0 1 4 11c0-1 .2-1.9.6-2.7A7 7 0 0 1 6.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 0 1 5.7 2 7 7 0 0 1 1.7 2.3 6 6 0 0 1 .2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 0 1-3.6 2.5v.5Z" fill-rule="evenodd"/></svg>', "insert-time": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M12 19a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm0 2a9 9 0 1 1 0-18 9 9 0 0 1 0 18Z"/><path d="M16 12h-3V7c0-.6-.4-1-1-1a1 1 0 0 0-1 1v7h5c.6 0 1-.4 1-1s-.4-1-1-1Z"/></g></svg>', invert: '<svg width="24" height="24"><path d="M18 19.3 16.5 18a5.8 5.8 0 0 1-3.1 1.9 6.1 6.1 0 0 1-5.5-1.6A5.8 5.8 0 0 1 6 14v-.3l.1-1.2A13.9 13.9 0 0 1 7.7 9l-3-3 .7-.8 2.8 2.9 9 8.9 1.5 1.6-.7.6Zm0-5.5v.3l-.1 1.1-.4 1-1.2-1.2a4.3 4.3 0 0 0 .2-1v-.2c0-.4 0-.8-.2-1.3l-.5-1.4a14.8 14.8 0 0 0-3-4.2L12 6a26.1 26.1 0 0 0-2.2 2.5l-1-1a20.9 20.9 0 0 1 2.9-3.3L12 4l1 .8a22.2 22.2 0 0 1 4 5.4c.6 1.2 1 2.4 1 3.6Z" fill-rule="evenodd"/></svg>', italic: '<svg width="24" height="24"><path d="m16.7 4.7-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8Z" fill-rule="evenodd"/></svg>', language: '<svg width="24" height="24"><path d="M12 3a9 9 0 1 1 0 18 9 9 0 0 1 0-18Zm4.3 13.3c-.5 1-1.2 2-2 2.9a7.5 7.5 0 0 0 3.2-2.1l-.2-.2a6 6 0 0 0-1-.6Zm-8.6 0c-.5.2-.9.5-1.2.8.9 1 2 1.7 3.2 2a10 10 0 0 1-2-2.8Zm3.6-.8c-.8 0-1.6.1-2.2.3.5 1 1.2 1.9 2.1 2.7Zm1.5 0v3c.9-.8 1.6-1.7 2.1-2.7-.6-.2-1.4-.3-2.1-.3Zm-6-2.7H4.5c.2 1 .5 2.1 1 3h.3l1.3-1a10 10 0 0 1-.3-2Zm12.7 0h-2.3c0 .7-.1 1.4-.3 2l1.6 1.1c.5-1 .9-2 1-3.1Zm-3.8 0h-3V14c1 0 2 .1 2.7.4.2-.5.3-1 .3-1.6Zm-4.4 0h-3l.3 1.6c.8-.3 1.7-.4 2.7-.4v-1.3Zm-5.5-5c-.7 1-1.1 2.2-1.3 3.5h2.3c0-1 .2-1.8.5-2.6l-1.5-1Zm2.9 1.4v.1c-.2.6-.4 1.3-.4 2h3V9.4c-1 0-1.8-.1-2.6-.3Zm6.6 0h-.1l-2.4.3v1.8h3l-.5-2.1Zm3-1.4-.3.1-1.3.8c.3.8.5 1.6.5 2.6h2.3a7.5 7.5 0 0 0-1.3-3.5Zm-9 0 2 .2V5.5a9 9 0 0 0-2 2.2Zm3.5-2.3V8c.6 0 1.3 0 1.9-.2a9 9 0 0 0-2-2.3Zm-3-.7h-.1c-1.1.4-2.1 1-3 1.8l1.2.7a10 10 0 0 1 1.9-2.5Zm4.4 0 .1.1a10 10 0 0 1 1.8 2.4l1.1-.7a7.5 7.5 0 0 0-3-1.8Z"/></svg>', "line-height": '<svg width="24" height="24"><path d="M21 5a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zM7 3.6l3.7 3.7a1 1 0 0 1-1.3 1.5h-.1L8 7.3v9.2l1.3-1.3a1 1 0 0 1 1.3 0h.1c.4.4.4 1 0 1.3v.1L7 20.4l-3.7-3.7a1 1 0 0 1 1.3-1.5h.1L6 16.7V7.4L4.7 8.7a1 1 0 0 1-1.3 0h-.1a1 1 0 0 1 0-1.3v-.1L7 3.6z"/></svg>', line: '<svg width="24" height="24"><path d="m15 9-8 8H4v-3l8-8 3 3Zm1-1-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1ZM4 18h16v2H4v-2Z" fill-rule="evenodd"/></svg>', link: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2-2a2 2 0 1 0-2.6-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2Z" fill-rule="nonzero"/></svg>', "list-bull-circle": '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M11 16a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 26a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 36a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6Z" fill-rule="nonzero"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>', "list-bull-default": '<svg width="48" height="48"><g fill-rule="evenodd"><circle cx="11" cy="14" r="3"/><circle cx="11" cy="24" r="3"/><circle cx="11" cy="34" r="3"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>', "list-bull-square": '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M8 11h6v6H8zM8 21h6v6H8zM8 31h6v6H8z"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>', "list-num-default-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 17v-4.8h-.1l-1.5 1v-1.1l1.6-1.1h1.2v6zM33.3 17.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm1.7 5.7c0-1.2 1-2 2.2-2 1.3 0 2.1.8 2.1 1.8 0 .7-.3 1.2-1.3 2.2l-1.2 1v.2h2.6v1h-4.3v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H35zm-1.7 4.3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm3.2 7.3v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H35c0-1.1 1-1.8 2.2-1.8 1.2 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.7.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .6 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm-3.3 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>', "list-num-default": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2Zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5Zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7Zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Z"/></g></svg>', "list-num-lower-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M36.5 16c-.9 0-1.5-.5-1.5-1.3s.6-1.3 1.8-1.4h1v-.4c0-.4-.2-.6-.7-.6-.4 0-.7.1-.8.4h-1.1c0-.8.8-1.4 2-1.4S39 12 39 13V16h-1.2v-.6c-.3.4-.8.7-1.4.7Zm.4-.8c.6 0 1-.4 1-.9V14h-1c-.5.1-.7.3-.7.6 0 .4.3.6.7.6ZM33.1 16.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7ZM37.7 26c-.7 0-1.2-.2-1.5-.7v.7H35v-6.3h1.2v2.5c.3-.5.8-.9 1.5-.9 1.1 0 1.8 1 1.8 2.4 0 1.5-.7 2.4-1.8 2.4Zm-.5-3.6c-.6 0-1 .5-1 1.3s.4 1.4 1 1.4c.7 0 1-.6 1-1.4 0-.8-.3-1.3-1-1.3ZM33.2 26.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm6 7h-1c-.1-.5-.4-.8-1-.8s-1 .5-1 1.4c0 1 .4 1.4 1 1.4.5 0 .9-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm-6.1 3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>', "list-num-lower-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6Zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7Zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4Zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3Zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7Zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>', "list-num-lower-greek-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 16c-1.2 0-2-.8-2-2.3 0-1.5.8-2.4 2-2.4.6 0 1 .4 1.3 1v-.9H40v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1-.7h-.2c-.2.4-.7.8-1.3.8Zm.3-1c.6 0 1-.5 1-1.3s-.4-1.3-1-1.3-1 .5-1 1.3.4 1.4 1 1.4ZM33.3 16.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM36 21.9c0-1.5.8-2.3 2.1-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.9 1.3.9.3 1.3.8 1.3 1.7 0 1.2-.7 1.9-1.8 1.9-.6 0-1.1-.3-1.4-.8v2.2H36V22Zm1.8 1.2v-1h.3c.5 0 .9-.2.9-.7 0-.5-.3-.8-.9-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1 1.3s1-.4 1-1-.4-1-1.2-1h-.3ZM33.3 26.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM37.1 34.6 34.8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.2.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1ZM33.3 36.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>', "list-num-lower-greek": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4Zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8Zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3ZM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22Zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1Zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>', "list-num-lower-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M32.9 16v-1.2h-1.3V16H33Zm0 10v-1.2h-1.3V26H33Zm0 10v-1.2h-1.3V36H33Z"/><path fill-rule="nonzero" d="M36 21h-1.5v5H36zM36 31h-1.5v5H36zM39 21h-1.5v5H39zM39 31h-1.5v5H39zM42 31h-1.5v5H42zM36 11h-1.5v5H36zM36 19h-1.5v1H36zM36 29h-1.5v1H36zM39 19h-1.5v1H39zM39 29h-1.5v1H39zM42 29h-1.5v1H42zM36 9h-1.5v1H36z"/></g></svg>', "list-num-lower-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 16v-1.2h1.3V16H15Zm0 10v-1.2h1.3V26H15Zm0 10v-1.2h1.3V36H15Z"/><path fill-rule="nonzero" d="M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z"/></g></svg>', "list-num-upper-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="m39.3 17-.5-1.4h-2l-.5 1.4H35l2-6h1.6l2 6h-1.3Zm-1.6-4.7-.7 2.3h1.6l-.8-2.3ZM33.4 17c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm4.7 9.9h-2.7v-6H38c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7Zm-1.4-5v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4h1.1c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9h-1.1V26ZM33 27.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm4.9 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm-4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>', "list-num-upper-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="m12.6 17-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3ZM11 12.3l-.7 2.3h1.6l-.8-2.3Zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7ZM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7ZM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26Zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>', "list-num-upper-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M31.6 17v-1.2H33V17h-1.3Zm0 10v-1.2H33V27h-1.3Zm0 10v-1.2H33V37h-1.3Z"/><path fill-rule="nonzero" d="M34.5 20H36v7h-1.5zM34.5 30H36v7h-1.5zM37.5 20H39v7h-1.5zM37.5 30H39v7h-1.5zM40.5 30H42v7h-1.5zM34.5 10H36v7h-1.5z"/></g></svg>', "list-num-upper-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 17v-1.2h1.3V17H15Zm0 10v-1.2h1.3V27H15Zm0 10v-1.2h1.3V37H15Z"/><path fill-rule="nonzero" d="M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z"/></g></svg>', lock: '<svg width="24" height="24"><path d="M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3ZM10 8v3h4V8a1 1 0 0 0-.3-.7A1 1 0 0 0 13 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7Z" fill-rule="evenodd"/></svg>', ltr: '<svg width="24" height="24"><path d="M11 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 7.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L11 5ZM4.4 16.2 6.2 15l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>', minus: '<svg width="24" height="24"><path d="M19 11a1 1 0 0 1 .1 2H5a1 1 0 0 1-.1-2H19Z"/></svg>', "more-drawer": '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>', "new-document": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>', "new-tab": '<svg width="24" height="24"><path d="m15 13 2-2v8H5V7h8l-2 2H7v8h8v-4Zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19Z" fill-rule="evenodd"/></svg>', "non-breaking": '<svg width="24" height="24"><path d="M11 11H8a1 1 0 1 1 0-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-3Zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1Z" fill-rule="evenodd"/></svg>', notice: '<svg width="24" height="24"><path d="M15.5 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7ZM13 17v-2h-2v2h2Zm0-4V7h-2v6h2Z" fill-rule="evenodd" clip-rule="evenodd"/></svg>', "ordered-list-rtl": '<svg width="24" height="24"><path d="M6 17h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 1 1 0-2Zm13-1v3.5a.5.5 0 1 1-1 0V5h-.5a.5.5 0 1 1 0-1H19Zm-1 8.8.2.2h1.3a.5.5 0 1 1 0 1h-1.6a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2h-1.3a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3Zm2 4.2v2c0 .6-.4 1-1 1h-1.5a.5.5 0 0 1 0-1h1.2a.3.3 0 1 0 0-.6h-1.3a.4.4 0 1 1 0-.8h1.3a.3.3 0 0 0 0-.6h-1.2a.5.5 0 1 1 0-1H19c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>', "ordered-list": '<svg width="24" height="24"><path d="M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 1 1 0-2ZM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 0 1-.5-.5V5h-.5a.5.5 0 0 1 0-1H6Zm-1 8.8.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2H4.5a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3ZM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 0 1 0-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 1 1 0-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 1 1 0-1H6c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>', orientation: '<svg width="24" height="24"><path d="M7.3 6.4 1 13l6.4 6.5 6.5-6.5-6.5-6.5ZM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7ZM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 0 1 0-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 1 1-4.3 16.9l1.5-1.5A7 7 0 1 0 13 6h-1Z" fill-rule="nonzero"/></svg>', outdent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm1.6-3.8a1 1 0 0 1-1.2 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 0 1 1.2 1.6L6.8 12l1.8 1.2Z" fill-rule="evenodd"/></svg>', "page-break": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2ZM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1ZM6 22a1 1 0 0 1-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5H7v5c0 .6-.4 1-1 1Z"/></g></svg>', paragraph: '<svg width="24" height="24"><path fill-rule="evenodd" d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z"/></svg>', "paste-column-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h7v2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm8 7v12h-6V8h6Zm-1.5 1.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>', "paste-column-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V18c0 1-.8 2-1.9 2H11v-2h7V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v2H4V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm-2 7v12H4V8h6ZM8.5 9.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>', "paste-row-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V11h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h14c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 11v5H8v-5h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>', "paste-row-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h12v-4h2v4c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 7v5H8V8h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>', "paste-text": '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2Z" fill-rule="nonzero"/></svg>', paste: '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Z" fill-rule="nonzero"/></svg>', "permanent-pen": '<svg width="24" height="24"><path d="M10.5 17.5 8 20H3v-3l3.5-3.5a2 2 0 0 1 0-3L14 3l1 1-7.3 7.3a1 1 0 0 0 0 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 0 1-2.8 0l-.1-.1Z" fill-rule="nonzero"/></svg>', plus: '<svg width="24" height="24"><path d="M12 4c.5 0 1 .4 1 .9V11h6a1 1 0 0 1 .1 2H13v6a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H11V5c0-.6.4-1 1-1Z"/></svg>', preferences: '<svg width="24" height="24"><path d="m20.1 13.5-1.9.2a5.8 5.8 0 0 1-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 0 1-1.4 0l-1.5-1.2a6.2 6.2 0 0 1-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 0 1-1-.9l-.2-1.9a5.8 5.8 0 0 1-1.5-.6l-1.5 1.2a1 1 0 0 1-1.4 0l-.7-.7a1 1 0 0 1 0-1.4l1.2-1.5a6.2 6.2 0 0 1-.6-1.5l-1.9-.2a1 1 0 0 1-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 0 1 .6-1.5L5.2 7.3a1 1 0 0 1 0-1.4l.7-.7a1 1 0 0 1 1.4 0l1.5 1.2a6.2 6.2 0 0 1 1.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 0 1 1.5.6l1.5-1.2a1 1 0 0 1 1.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 0 1 .6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1ZM12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" fill-rule="evenodd"/></svg>', preview: '<svg width="24" height="24"><path d="M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 0 0 2.1-2.8 15.7 15.7 0 0 0-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 0 0-6.7 3.2A16.2 16.2 0 0 0 3.2 12c0 .2.2.3.3.5Zm-2.4-1 .7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 0 1 2.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 0 1-2.8-3.7 1 1 0 0 1 0-1Zm12-3.3a2 2 0 1 0 2.7 2.6 4 4 0 1 1-2.6-2.6Z" fill-rule="nonzero"/></svg>', print: '<svg width="24" height="24"><path d="M18 8H6a3 3 0 0 0-3 3v6h2v3h14v-3h2v-6a3 3 0 0 0-3-3Zm-1 10H7v-4h10v4Zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5Zm.5-8H6v2h12V5Z" fill-rule="nonzero"/></svg>', quote: '<svg width="24" height="24"><path d="M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Z" fill-rule="nonzero"/></svg>', redo: '<svg width="24" height="24"><path d="M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 1 1-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 1 1 1.4-1.4l5 5a1 1 0 0 1 0 1.4l-5 5a1 1 0 0 1-1.4-1.4l3.3-3.3Z" fill-rule="nonzero"/></svg>', reload: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m5 22.1-1.2-4.7v-.2a1 1 0 0 1 1-1l5 .4a1 1 0 1 1-.2 2l-2.2-.2a7.8 7.8 0 0 0 8.4.2 7.5 7.5 0 0 0 3.5-6.4 1 1 0 1 1 2 0 9.5 9.5 0 0 1-4.5 8 9.9 9.9 0 0 1-10.2 0l.4 1.4a1 1 0 1 1-2 .5ZM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 0 0-9.5-1 7.5 7.5 0 0 0-3.6 7 1 1 0 0 1-2 0 9.5 9.5 0 0 1 4.5-8.6 10 10 0 0 1 10.9.3l-.3-1a1 1 0 0 1 2-.5l1.1 4.8a1 1 0 0 1-1 1.2l-5-.4a1 1 0 0 1-.9-1Z"/></g></svg>', "remove-formatting": '<svg width="24" height="24"><path d="M13.2 6a1 1 0 0 1 0 .2l-2.6 10a1 1 0 0 1-1 .8h-.2a.8.8 0 0 1-.8-1l2.6-10H8a1 1 0 1 1 0-2h9a1 1 0 0 1 0 2h-3.8ZM5 18h7a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Zm13 1.5L16.5 18 15 19.5a.7.7 0 0 1-1-1l1.5-1.5-1.5-1.5a.7.7 0 0 1 1-1l1.5 1.5 1.5-1.5a.7.7 0 0 1 1 1L17.5 17l1.5 1.5a.7.7 0 0 1-1 1Z" fill-rule="evenodd"/></svg>', remove: '<svg width="24" height="24"><path d="M16 7h3a1 1 0 0 1 0 2h-1v9a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V9H5a1 1 0 1 1 0-2h3V6a3 3 0 0 1 3-3h2a3 3 0 0 1 3 3v1Zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 0 0-1 1v1h4Zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9Zm-7 3a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Zm4 0a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Z" fill-rule="nonzero"/></svg>', "resize-handle": '<svg width="10" height="10"><g fill-rule="nonzero"><path d="M8.1 1.1A.5.5 0 1 1 9 2l-7 7A.5.5 0 1 1 1 8l7-7ZM8.1 5.1A.5.5 0 1 1 9 6l-3 3A.5.5 0 1 1 5 8l3-3Z"/></g></svg>', resize: '<svg width="24" height="24"><path d="M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-6a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3A1 1 0 0 1 4 11V5Z" fill-rule="evenodd"/></svg>', "restore-draft": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1Z"/><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></g></svg>', "rotate-left": '<svg width="24" height="24"><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></svg>', "rotate-right": '<svg width="24" height="24"><path d="M20 8V5a1 1 0 0 1 2 0v6c0 .6-.4 1-1 1h-6a1 1 0 0 1 0-2h4.3L16 7A7.2 7.2 0 0 0 7.7 6a7 7 0 0 0 3 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 0 1 1.4 1.5A9.2 9.2 0 0 1 2.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8Z" fill-rule="nonzero"/></svg>', rtl: '<svg width="24" height="24"><path d="M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 4.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L8 5Zm12 11.2a1 1 0 1 1-1 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 1 1 1 1.6L18.4 15l1.8 1.2Z" fill-rule="evenodd"/></svg>', save: '<svg width="24" height="24"><path d="M5 16h14a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2c0-1.1.9-2 2-2Zm0 2v2h14v-2H5Zm10 0h2v2h-2v-2Zm-4-6.4L8.7 9.3a1 1 0 1 0-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 1 0-1.4-1.4L13 11.6V4a1 1 0 0 0-2 0v7.6Z" fill-rule="nonzero"/></svg>', search: '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z" fill-rule="nonzero"/></svg>', "select-all": '<svg width="24" height="24"><path d="M3 5h2V3a2 2 0 0 0-2 2Zm0 8h2v-2H3v2Zm4 8h2v-2H7v2ZM3 9h2V7H3v2Zm10-6h-2v2h2V3Zm6 0v2h2a2 2 0 0 0-2-2ZM5 21v-2H3c0 1.1.9 2 2 2Zm-2-4h2v-2H3v2ZM9 3H7v2h2V3Zm2 18h2v-2h-2v2Zm8-8h2v-2h-2v2Zm0 8a2 2 0 0 0 2-2h-2v2Zm0-12h2V7h-2v2Zm0 8h2v-2h-2v2Zm-4 4h2v-2h-2v2Zm0-16h2V3h-2v2ZM7 17h10V7H7v10Zm2-8h6v6H9V9Z" fill-rule="nonzero"/></svg>', selected: '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm3.6 10.9L7 12.3a.7.7 0 0 0-1 1L9.6 17 18 8.6a.7.7 0 0 0 0-1 .7.7 0 0 0-1 0l-7.4 7.3Z"/></svg>', send: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="m13.3 22 7-18.3-18.3 7L9 15l4.3 7ZM18 6.8l-.7-.7L9.4 14l.7.7L18 6.8Z"/></svg>', settings: '<svg width="24" height="24"><path d="M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V8H5a1 1 0 1 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6ZM8 8h2V6H8v2Zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V13H5a1 1 0 0 1 0-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6ZM14 13h2v-2h-2v2Zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V18H5a1 1 0 0 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6ZM8 18h2v-2H8v2Z" fill-rule="evenodd"/></svg>', sharpen: '<svg width="24" height="24"><path d="m16 6 4 4-8 9-8-9 4-4h8Zm-4 10.2 5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2Z" fill-rule="evenodd"/></svg>', sourcecode: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 0 1 0-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7ZM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 0 0-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7Z"/></g></svg>', "spell-check": '<svg width="24" height="24"><path d="M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6Zm0-3v2h2V5H6Zm13 0h-3v5h3v1h-3a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1Zm-5 1.5-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5ZM13 10V8h-2v2h2Zm0-3V5h-2v2h2Zm3 5 1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12Z" fill-rule="evenodd"/></svg>', "strike-through": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 0 1 7 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1Z"/><path d="M5 11h14a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Z" fill-rule="nonzero"/></g></svg>', subscript: '<svg width="24" height="24"><path d="m10.4 10 4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10ZM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 0 0-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 0 1-1.3 1.3l-.6.6h2.6V19Z" fill-rule="nonzero"/></svg>', superscript: '<svg width="24" height="24"><path d="M15 9.4 10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4Zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11Z" fill-rule="nonzero"/></svg>', "table-caption": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="12" height="2" x="3" y="4" rx="1"/><path d="M19 8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-8c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></g></svg>', "table-cell-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M13 4v9H3V6c0-1.1.9-2 2-2h8Zm-2 2H5v5h6V6Z"/><path fill-rule="nonzero" d="M13 4h6a2 2 0 0 1 2 2v7h-8v-2h6V6h-6V4Z" opacity=".2"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/><path fill-rule="nonzero" d="M3 13v5c0 1.1.9 2 2 2h8v-7h-2v5H5v-5H3Z" opacity=".2"/></g></svg>', "table-cell-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8 0h-6v5h6v-5Zm-8-7H5v5h6V6Z"/></svg>', "table-cell-select-all": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z" opacity=".2"/></g></svg>', "table-cell-select-inner": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z" opacity=".2"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z"/></g></svg>', "table-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v7h-8v7H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8-7h-6v5h6V6Zm-8 0H5v5h6V6Z"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/></g></svg>', "table-delete-column": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-4 4h-2V6h-2v2H9V6H5v12h4v-2h2v2h2v-2h2v2h4V6h-4v2Zm.3.5 1 1.2-3 2.3 3 2.3-1 1.2L12 13l-3.3 2.6-1-1.2 3-2.3-3-2.3 1-1.2L12 11l3.3-2.5Z"/></svg>', "table-delete-row": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v3h2.5v2H5v2h2.5v2H5v3h14v-3h-2.5v-2H19v-2h-2.5V9H19V6Zm-4.7 1.8 1.2 1L13 12l2.6 3.3-1.2 1-2.3-3-2.3 3-1.2-1L11 12 8.5 8.7l1.2-1 2.3 3 2.3-3Z"/></svg>', "table-delete-table": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 6v12h14V6H5Z"/><path d="m14.4 8.6 1.1 1-2.4 2.4 2.4 2.4-1.1 1.1-2.4-2.4-2.4 2.4-1-1.1 2.3-2.4-2.3-2.4 1-1 2.4 2.3z"/></g></svg>', "table-insert-column-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M20 4c.6 0 1 .4 1 1v2a1 1 0 0 1-2 0V6h-8v12h8v-1a1 1 0 0 1 2 0v2c0 .5-.4 1-.9 1H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h15ZM9 13H5v5h4v-5Zm7-5c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H17v2a1 1 0 0 1-2 .1V13h-2a1 1 0 0 1-.1-2H15V9c0-.6.4-1 1-1ZM9 6H5v5h4V6Z"/></svg>', "table-insert-column-before": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a1 1 0 0 1-1-1v-2a1 1 0 0 1 2 0v1h8V6H5v1a1 1 0 1 1-2 0V5c0-.6.4-1 1-1h15Zm0 9h-4v5h4v-5ZM8 8c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H9v2a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H7V9c0-.6.4-1 1-1Zm11-2h-4v5h4V6Z"/></svg>', "table-insert-row-above": '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4a1 1 0 1 1 0 2H5v6h14V6h-1a1 1 0 0 1 0-2h2c.6 0 1 .4 1 1v13a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5c0-.6.4-1 1-1h2Zm5 10H5v4h6v-4Zm8 0h-6v4h6v-4ZM12 3c.5 0 1 .4 1 .9V6h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 .1V8H9a1 1 0 0 1 0-2h2V4c0-.6.4-1 1-1Z"/></svg>', "table-insert-row-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M12 13c.5 0 1 .4 1 .9V16h2a1 1 0 0 1 .1 2H13v2a1 1 0 0 1-2 .1V18H9a1 1 0 0 1-.1-2H11v-2c0-.6.4-1 1-1Zm6 7a1 1 0 0 1 0-2h1v-6H5v6h1a1 1 0 0 1 0 2H4a1 1 0 0 1-1-1V6c0-1.1.9-2 2-2h14a2 2 0 0 1 2 2v13c0 .5-.4 1-.9 1H18ZM11 6H5v4h6V6Zm8 0h-6v4h6V6Z"/></svg>', "table-left-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 9h-4v5h4v-5Zm-6 0H9v5h4v-5Zm0-7H9v5h4V6Zm6 0h-4v5h4V6Z"/></svg>', "table-merge-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15.5V18h3v-2.5H5Zm14-5h-9V18h9v-7.5ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Zm-8 7.5h3v-3H5v3Z"/></svg>', "table-row-numbering-rtl": '<svg width="24" height="24"><path d="M6 4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H6Zm0 12h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 11h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 6h8v3H6V6Zm11 0c.6 0 1 .4 1 1v1a1 1 0 1 1-2 0V7c0-.6.4-1 1-1Z"/></svg>', "table-row-numbering": '<svg width="24" height="24"><path d="M18 4a2 2 0 0 1 2 2v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h12Zm0 12h-8v3h8v-3ZM7 16a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8v-3ZM7 11a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8V6ZM7 6a1 1 0 0 0-1 1v1a1 1 0 1 0 2 0V7c0-.6-.4-1-1-1Z"/></svg>', "table-row-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-9h-6v3h6V6ZM5 9h6V6H5v3Z"/></svg>', "table-split-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM8 15.5H5V18h3v-2.5Zm11-5h-9V18h9v-7.5Zm-2.5 1 1 1-2 2 2 2-1 1-2-2-2 2-1-1 2-2-2-2 1-1 2 2 2-2Zm-8.5-1H5v3h3v-3ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Z"/></svg>', "table-top-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 11H5v3h6v-3Zm8 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></svg>', table: '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 14v4h6v-4H5Zm14 0h-6v4h6v-4Zm0-6h-6v4h6V8ZM5 12h6V8H5v4Z"/></svg>', "template-add": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 12v4H5a2 2 0 0 0-2 2v3h9.3a6 6 0 0 1-.3-2H5v-1h7a6 6 0 0 1 .8-2H11v-5l-.8-.6a3 3 0 1 1 3.6 0l-.8.6v4.7a6 6 0 0 1 2-1.9V12a5 5 0 1 0-6 0Z"/><path d="M18 15c.5 0 1 .4 1 .9V18h2a1 1 0 0 1 .1 2H19v2a1 1 0 0 1-2 .1V20h-2a1 1 0 0 1-.1-2H17v-2c0-.6.4-1 1-1Z"/></svg>', template: '<svg width="24" height="24"><path d="M19 19v-1H5v1h14ZM9 16v-4a5 5 0 1 1 6 0v4h4a2 2 0 0 1 2 2v3H3v-3c0-1.1.9-2 2-2h4Zm4 0v-5l.8-.6a3 3 0 1 0-3.6 0l.8.6v5h2Z" fill-rule="nonzero"/></svg>', "temporary-placeholder": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M9 7.6V6h2.5V4.5a.5.5 0 1 1 1 0V6H15v1.6a8 8 0 1 1-6 0Zm-2.6 5.3a.5.5 0 0 0 .3.6c.3 0 .6 0 .6-.3l.1-.2a5 5 0 0 1 3.3-2.8c.3-.1.4-.4.4-.6-.1-.3-.4-.5-.6-.4a6 6 0 0 0-4.1 3.7Z"/><circle cx="14" cy="4" r="1"/><circle cx="12" cy="2" r="1"/><circle cx="10" cy="4" r="1"/></g></svg>', "text-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path class="tox-icon-text-color__color" d="M3 18h18v3H3z"/><path d="M8.7 16h-.8a.5.5 0 0 1-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 0 1-.5.6h-.8a.5.5 0 0 1-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4Zm2.6-7.6-.6 2a.5.5 0 0 0 .5.6h1.6a.5.5 0 0 0 .5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4Z"/></g></svg>', "text-size-decrease": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM14 12a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-6Z"/></svg>', "text-size-increase": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM17 9a1 1 0 0 0-1 1v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2h-2v-2c0-.6-.4-1-1-1Z"/></svg>', toc: '<svg width="24" height="24"><path d="M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>', translate: '<svg width="24" height="24"><path d="m12.7 14.3-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 0 1 0-1l3.1-3A12.4 12.4 0 0 1 6.7 9H8a10.1 10.1 0 0 0 1.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 1 1 0-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 0 1-1 2.4 13.5 13.5 0 0 1-1.7 2.3l1.9 1.8Zm4.3-3 2.7 7.3a.5.5 0 0 1-.4.7 1 1 0 0 1-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 0 1-1 .7.5.5 0 0 1-.4-.7l2.7-7.4a1 1 0 0 1 2 0Zm-2.2 4.4h2.4L16 12.5l-1.2 3.2Z" fill-rule="evenodd"/></svg>', typography: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M17 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H7a1 1 0 0 1 0-2h10Z"/><path d="m17.5 14 .8-1.7 1.7-.8-1.7-.8-.8-1.7-.8 1.7-1.7.8 1.7.8.8 1.7ZM7 14l1 2 2 1-2 1-1 2-1-2-2-1 2-1 1-2Z"/></svg>', underline: '<svg width="24" height="24"><path d="M16 5c.6 0 1 .4 1 1v5.5a4 4 0 0 1-.4 1.8l-1 1.4a5.3 5.3 0 0 1-5.5 1 5 5 0 0 1-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 0 1-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 0 0 2.2.8 3.4 3.4 0 0 0 2.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1ZM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>', undo: '<svg width="24" height="24"><path d="M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 0 1-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 1 1-1.4 1.4l-5-5a1 1 0 0 1 0-1.4l5-5a1 1 0 0 1 1.4 1.4L6.4 8Z" fill-rule="nonzero"/></svg>', unlink: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2.1-2a2 2 0 1 0-2.7-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2ZM7.6 6.3a.8.8 0 0 1-1 1.1L3.3 4.2a.7.7 0 1 1 1-1l3.2 3.1ZM5.1 8.6a.8.8 0 0 1 0 1.5H3a.8.8 0 0 1 0-1.5H5Zm5-3.5a.8.8 0 0 1-1.5 0V3a.8.8 0 0 1 1.5 0V5Zm6 11.8a.8.8 0 0 1 1-1l3.2 3.2a.8.8 0 0 1-1 1L16 17Zm-2.2 2a.8.8 0 0 1 1.5 0V21a.8.8 0 0 1-1.5 0V19Zm5-3.5a.7.7 0 1 1 0-1.5H21a.8.8 0 0 1 0 1.5H19Z" fill-rule="nonzero"/></svg>', unlock: '<svg width="24" height="24"><path d="M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 0 0-.3-.7A1 1 0 0 0 16 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2Z" fill-rule="evenodd"/></svg>', "unordered-list": '<svg width="24" height="24"><path d="M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2ZM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Z" fill-rule="evenodd"/></svg>', unselected: '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm0 1a1 1 0 0 0-1 1v12c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H6Z"/></svg>', upload: '<svg width="24" height="24"><path d="M18 19v-2a1 1 0 0 1 2 0v3c0 .6-.4 1-1 1H5a1 1 0 0 1-1-1v-3a1 1 0 0 1 2 0v2h12ZM11 6.4 8.7 8.7a1 1 0 0 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 1 1-1.4 1.4L13 6.4V16a1 1 0 0 1-2 0V6.4Z" fill-rule="nonzero"/></svg>', user: '<svg width="24" height="24"><path d="M12 24a12 12 0 1 1 0-24 12 12 0 0 1 0 24Zm-8.7-5.3a11 11 0 0 0 17.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7ZM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13Z" fill-rule="nonzero"/></svg>', "vertical-align": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="18" height="2" x="3" y="11" rx="1"/><path d="M12 2c.6 0 1 .4 1 1v4l2-1.3a1 1 0 0 1 1.2 1.5l-.1.1-4.1 3-4-3a1 1 0 0 1 1-1.7l2 1.5V3c0-.6.4-1 1-1zm0 11.8 4 2.9a1 1 0 0 1-1 1.7l-2-1.5V21c0 .5-.4 1-.9 1H12a1 1 0 0 1-1-1v-4l-2 1.3a1 1 0 0 1-1.2-.1l-.1-.1a1 1 0 0 1 .1-1.3l.1-.1 4.1-3z"/></g></svg>', visualblocks: '<svg width="24" height="24"><path d="M9 19v2H7v-2h2Zm-4 0v2a2 2 0 0 1-2-2h2Zm8 0v2h-2v-2h2Zm8 0a2 2 0 0 1-2 2v-2h2Zm-4 0v2h-2v-2h2ZM15 7a1 1 0 0 1 0 2v7a1 1 0 0 1-2 0V9h-1v7a1 1 0 0 1-2 0v-4a2.5 2.5 0 0 1-.2-5H15ZM5 15v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 11v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 7v2H3V7h2Zm16 0v2h-2V7h2ZM5 3v2H3c0-1.1.9-2 2-2Zm8 0v2h-2V3h2Zm6 0a2 2 0 0 1 2 2h-2V3ZM9 3v2H7V3h2Zm8 0v2h-2V3h2Z" fill-rule="evenodd"/></svg>', visualchars: '<svg width="24" height="24"><path d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z" fill-rule="evenodd"/></svg>', warning: '<svg width="24" height="24"><path d="M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6ZM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3Zm.7-3 .3-4a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7l.3 4h1.4Z" fill-rule="evenodd"/></svg>', "zoom-in": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-1-9a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0V8Zm-2 4a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>', "zoom-out": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-3-5a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>' } });
(function() {
  const v = Object.getPrototypeOf, L = (o, s, i) => {
    var l;
    return !!i(o, s.prototype) || ((l = o.constructor) === null || l === void 0 ? void 0 : l.name) === s.name;
  }, N = (o) => (s) => ((i) => {
    const l = typeof i;
    return i === null ? "null" : l === "object" && Array.isArray(i) ? "array" : l === "object" && L(i, String, (f, m) => m.isPrototypeOf(f)) ? "string" : l;
  })(s) === o, W = (o) => (s) => typeof s === o, ue = (o) => (s) => o === s, ce = N("string"), he = N("object"), pe = (o) => ((s, i) => he(s) && L(s, i, (l, f) => v(l) === f))(o, Object), Me = N("array"), Ze = ue(null), Ye = W("boolean"), yt = ue(void 0), jt = (o) => o == null, it = (o) => !jt(o), Rt = W("function"), en = W("number"), Gt = (o, s) => {
    if (Me(o)) {
      for (let i = 0, l = o.length; i < l; ++i)
        if (!s(o[i]))
          return !1;
      return !0;
    }
    return !1;
  }, gt = () => {
  }, an = (o) => () => o(), Ot = (o, s) => (...i) => o(s.apply(null, i)), Ee = (o) => () => o, wt = (o) => o, Se = (o, s) => o === s;
  function We(o, ...s) {
    return (...i) => {
      const l = s.concat(i);
      return o.apply(null, l);
    };
  }
  const Cn = (o) => (s) => !o(s), ko = (o) => () => {
    throw new Error(o);
  }, jn = (o) => o(), Xe = Ee(!1), un = Ee(!0);
  class M {
    constructor(s, i) {
      this.tag = s, this.value = i;
    }
    static some(s) {
      return new M(!0, s);
    }
    static none() {
      return M.singletonNone;
    }
    fold(s, i) {
      return this.tag ? i(this.value) : s();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(s) {
      return this.tag ? M.some(s(this.value)) : M.none();
    }
    bind(s) {
      return this.tag ? s(this.value) : M.none();
    }
    exists(s) {
      return this.tag && s(this.value);
    }
    forall(s) {
      return !this.tag || s(this.value);
    }
    filter(s) {
      return !this.tag || s(this.value) ? this : M.none();
    }
    getOr(s) {
      return this.tag ? this.value : s;
    }
    or(s) {
      return this.tag ? this : s;
    }
    getOrThunk(s) {
      return this.tag ? this.value : s();
    }
    orThunk(s) {
      return this.tag ? this : s();
    }
    getOrDie(s) {
      if (this.tag)
        return this.value;
      throw new Error(s ?? "Called getOrDie on None");
    }
    static from(s) {
      return it(s) ? M.some(s) : M.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(s) {
      this.tag && s(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  M.singletonNone = new M(!1);
  const Et = Array.prototype.slice, ht = Array.prototype.indexOf, mn = Array.prototype.push, lo = (o, s) => ht.call(o, s), dt = (o, s) => {
    const i = lo(o, s);
    return i === -1 ? M.none() : M.some(i);
  }, Bn = (o, s) => lo(o, s) > -1, jr = (o, s) => {
    for (let i = 0, l = o.length; i < l; i++)
      if (s(o[i], i))
        return !0;
    return !1;
  }, Tt = (o, s) => {
    const i = [];
    for (let l = 0; l < o; l++)
      i.push(s(l));
    return i;
  }, yo = (o, s) => {
    const i = [];
    for (let l = 0; l < o.length; l += s) {
      const f = Et.call(o, l, l + s);
      i.push(f);
    }
    return i;
  }, Ct = (o, s) => {
    const i = o.length, l = new Array(i);
    for (let f = 0; f < i; f++) {
      const m = o[f];
      l[f] = s(m, f);
    }
    return l;
  }, tn = (o, s) => {
    for (let i = 0, l = o.length; i < l; i++)
      s(o[i], i);
  }, oa = (o, s) => {
    const i = [], l = [];
    for (let f = 0, m = o.length; f < m; f++) {
      const b = o[f];
      (s(b, f) ? i : l).push(b);
    }
    return { pass: i, fail: l };
  }, Pn = (o, s) => {
    const i = [];
    for (let l = 0, f = o.length; l < f; l++) {
      const m = o[l];
      s(m, l) && i.push(m);
    }
    return i;
  }, Mo = (o, s, i) => (((l, f) => {
    for (let m = l.length - 1; m >= 0; m--)
      f(l[m], m);
  })(o, (l, f) => {
    i = s(i, l, f);
  }), i), K = (o, s, i) => (tn(o, (l, f) => {
    i = s(i, l, f);
  }), i), Go = (o, s) => ((i, l, f) => {
    for (let m = 0, b = i.length; m < b; m++) {
      const x = i[m];
      if (l(x, m))
        return M.some(x);
      if (f(x, m))
        break;
    }
    return M.none();
  })(o, s, Xe), Zi = (o, s) => {
    for (let i = 0, l = o.length; i < l; i++)
      if (s(o[i], i))
        return M.some(i);
    return M.none();
  }, er = (o) => {
    const s = [];
    for (let i = 0, l = o.length; i < l; ++i) {
      if (!Me(o[i]))
        throw new Error("Arr.flatten item " + i + " was not an array, input: " + o);
      mn.apply(s, o[i]);
    }
    return s;
  }, Qr = (o, s) => er(Ct(o, s)), nc = (o, s) => {
    for (let i = 0, l = o.length; i < l; ++i)
      if (s(o[i], i) !== !0)
        return !1;
    return !0;
  }, So = (o) => {
    const s = Et.call(o, 0);
    return s.reverse(), s;
  }, cr = (o, s) => Pn(o, (i) => !Bn(s, i)), oo = (o, s) => {
    const i = {};
    for (let l = 0, f = o.length; l < f; l++) {
      const m = o[l];
      i[String(m)] = s(m, l);
    }
    return i;
  }, ut = (o) => [o], kt = (o, s) => {
    const i = Et.call(o, 0);
    return i.sort(s), i;
  }, It = (o, s) => s >= 0 && s < o.length ? M.some(o[s]) : M.none(), ct = (o) => It(o, 0), xn = (o) => It(o, o.length - 1), co = Rt(Array.from) ? Array.from : (o) => Et.call(o), Ko = (o, s) => {
    for (let i = 0; i < o.length; i++) {
      const l = s(o[i], i);
      if (l.isSome())
        return l;
    }
    return M.none();
  }, po = Object.keys, Ra = Object.hasOwnProperty, Mr = (o, s) => {
    const i = po(o);
    for (let l = 0, f = i.length; l < f; l++) {
      const m = i[l];
      s(o[m], m);
    }
  }, ho = (o, s) => Ns(o, (i, l) => ({ k: l, v: s(i, l) })), Ns = (o, s) => {
    const i = {};
    return Mr(o, (l, f) => {
      const m = s(l, f);
      i[m.k] = m.v;
    }), i;
  }, Ca = (o) => (s, i) => {
    o[i] = s;
  }, Zr = (o, s, i, l) => {
    Mr(o, (f, m) => {
      (s(f, m) ? i : l)(f, m);
    });
  }, $r = (o, s) => {
    const i = {};
    return Zr(o, s, Ca(i), gt), i;
  }, Po = (o, s) => {
    const i = [];
    return Mr(o, (l, f) => {
      i.push(s(l, f));
    }), i;
  }, ha = (o, s) => {
    const i = po(o);
    for (let l = 0, f = i.length; l < f; l++) {
      const m = i[l], b = o[m];
      if (s(b, m, o))
        return M.some(b);
    }
    return M.none();
  }, ro = (o) => Po(o, wt), cn = (o, s) => _n(o, s) ? M.from(o[s]) : M.none(), _n = (o, s) => Ra.call(o, s), Ys = (o, s) => _n(o, s) && o[s] !== void 0 && o[s] !== null, Si = (o, s, i = Se) => o.exists((l) => i(l, s)), Nt = (o) => {
    const s = [], i = (l) => {
      s.push(l);
    };
    for (let l = 0; l < o.length; l++)
      o[l].each(i);
    return s;
  }, fi = (o, s, i) => o.isSome() && s.isSome() ? M.some(i(o.getOrDie(), s.getOrDie())) : M.none(), Zo = (o, s) => o != null ? M.some(s(o)) : M.none(), mi = (o, s) => o ? M.some(s) : M.none(), kr = (o, s, i) => s === "" || o.length >= s.length && o.substr(i, i + s.length) === s, Qu = (o, s) => xc(o, s) ? ((i, l) => i.substring(l))(o, s.length) : o, ba = (o, s, i = 0, l) => {
    const f = o.indexOf(s, i);
    return f !== -1 && (!!yt(l) || f + s.length <= l);
  }, xc = (o, s) => kr(o, s, 0), _l = (o, s) => kr(o, s, o.length - s.length), Wi = (kf = /^\s+|\s+$/g, (o) => o.replace(kf, "")), oc = (o) => o.length > 0, Hr = (o) => !oc(o), Yn = (o) => o.style !== void 0 && Rt(o.style.getPropertyValue), qi = (o) => {
    if (o == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: o };
  }, Ei = (o, s) => {
    const i = (s || document).createElement("div");
    if (i.innerHTML = o, !i.hasChildNodes() || i.childNodes.length > 1) {
      const l = "HTML does not have a single root node";
      throw console.error(l, o), new Error(l);
    }
    return qi(i.childNodes[0]);
  }, Cl = (o, s) => {
    const i = (s || document).createElement(o);
    return qi(i);
  }, Xc = (o, s) => {
    const i = (s || document).createTextNode(o);
    return qi(i);
  }, Xt = qi, Dd = typeof window < "u" ? window : Function("return this;")(), es = (o, s) => ((i, l) => {
    let f = l ?? Dd;
    for (let m = 0; m < i.length && f != null; ++m)
      f = f[i[m]];
    return f;
  })(o.split("."), s), yf = Object.getPrototypeOf, Rd = (o) => {
    const s = es("ownerDocument.defaultView", o);
    return he(o) && (((i) => ((l, f) => {
      const m = ((b, x) => es(b, x))(l, f);
      if (m == null)
        throw new Error(l + " not available on this browser");
      return m;
    })("HTMLElement", i))(s).prototype.isPrototypeOf(o) || /^HTML\w*Element$/.test(yf(o).constructor.name));
  }, Ti = (o) => o.dom.nodeName.toLowerCase(), wc = (o) => (s) => ((i) => i.dom.nodeType)(s) === o, pi = (o) => ra(o) && Rd(o.dom), ra = wc(1), Gi = wc(3), vf = wc(9), rc = wc(11), tm = (o) => (s) => ra(s) && Ti(s) === o, Sl = (o, s) => {
    const i = o.dom;
    if (i.nodeType !== 1)
      return !1;
    {
      const l = i;
      if (l.matches !== void 0)
        return l.matches(s);
      if (l.msMatchesSelector !== void 0)
        return l.msMatchesSelector(s);
      if (l.webkitMatchesSelector !== void 0)
        return l.webkitMatchesSelector(s);
      if (l.mozMatchesSelector !== void 0)
        return l.mozMatchesSelector(s);
      throw new Error("Browser lacks native selectors");
    }
  }, Nd = (o) => o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11 || o.childElementCount === 0, tr = (o, s) => o.dom === s.dom, Ms = (o, s) => {
    const i = o.dom, l = s.dom;
    return i !== l && i.contains(l);
  }, ni = (o) => Xt(o.dom.ownerDocument), Jc = (o) => vf(o) ? o : ni(o), Md = (o) => Xt(Jc(o).dom.documentElement), Bd = (o) => Xt(Jc(o).dom.defaultView), cl = (o) => M.from(o.dom.parentNode).map(Xt), sa = (o) => M.from(o.dom.parentElement).map(Xt), nm = (o) => M.from(o.dom.offsetParent).map(Xt), _r = (o) => Ct(o.dom.childNodes, Xt), Dr = (o, s) => {
    const i = o.dom.childNodes;
    return M.from(i[s]).map(Xt);
  }, El = (o) => Dr(o, 0), ul = (o, s) => ({ element: o, offset: s }), Lc = (o, s) => {
    const i = _r(o);
    return i.length > 0 && s < i.length ? ul(i[s], 0) : ul(o, s);
  }, kc = (o) => rc(o) && it(o.dom.host), gu = Rt(Element.prototype.attachShadow) && Rt(Node.prototype.getRootNode), Na = Ee(gu), us = gu ? (o) => Xt(o.dom.getRootNode()) : Jc, Ma = (o) => kc(o) ? o : Xt(Jc(o).dom.body), Us = (o) => {
    const s = us(o);
    return kc(s) ? M.some(s) : M.none();
  }, dl = (o) => Xt(o.dom.host), Rr = (o) => {
    const s = Gi(o) ? o.dom.parentNode : o.dom;
    if (s == null || s.ownerDocument === null)
      return !1;
    const i = s.ownerDocument;
    return Us(Xt(s)).fold(() => i.body.contains(s), (l = Rr, f = dl, (m) => l(f(m))));
    var l, f;
  }, Wa = () => zi(Xt(document)), zi = (o) => {
    const s = o.dom.body;
    if (s == null)
      throw new Error("Body is not available yet");
    return Xt(s);
  }, qa = (o, s, i) => {
    if (!(ce(i) || Ye(i) || en(i)))
      throw console.error("Invalid call to Attribute.set. Key ", s, ":: Value ", i, ":: Element ", o), new Error("Attribute value was not simple");
    o.setAttribute(s, i + "");
  }, eo = (o, s, i) => {
    qa(o.dom, s, i);
  }, gi = (o, s) => {
    const i = o.dom;
    Mr(s, (l, f) => {
      qa(i, f, l);
    });
  }, js = (o, s) => {
    const i = o.dom.getAttribute(s);
    return i === null ? void 0 : i;
  }, Sa = (o, s) => M.from(js(o, s)), Ki = (o, s) => {
    const i = o.dom;
    return !(!i || !i.hasAttribute) && i.hasAttribute(s);
  }, ts = (o, s) => {
    o.dom.removeAttribute(s);
  }, Bs = (o, s, i) => {
    if (!ce(i))
      throw console.error("Invalid call to CSS.set. Property ", s, ":: Value ", i, ":: Element ", o), new Error("CSS value must be a string: " + i);
    Yn(o) && o.style.setProperty(s, i);
  }, sc = (o, s) => {
    Yn(o) && o.style.removeProperty(s);
  }, qn = (o, s, i) => {
    const l = o.dom;
    Bs(l, s, i);
  }, ac = (o, s) => {
    const i = o.dom;
    Mr(s, (l, f) => {
      Bs(i, f, l);
    });
  }, Yi = (o, s) => {
    const i = o.dom;
    Mr(s, (l, f) => {
      l.fold(() => {
        sc(i, f);
      }, (m) => {
        Bs(i, f, m);
      });
    });
  }, Ts = (o, s) => {
    const i = o.dom, l = window.getComputedStyle(i).getPropertyValue(s);
    return l !== "" || Rr(o) ? l : fl(i, s);
  }, fl = (o, s) => Yn(o) ? o.style.getPropertyValue(s) : "", Xs = (o, s) => {
    const i = o.dom, l = fl(i, s);
    return M.from(l).filter((f) => f.length > 0);
  }, hu = (o) => {
    const s = {}, i = o.dom;
    if (Yn(i))
      for (let l = 0; l < i.style.length; l++) {
        const f = i.style.item(l);
        s[f] = i.style[f];
      }
    return s;
  }, xf = (o, s, i) => {
    const l = Cl(o);
    return qn(l, s, i), Xs(l, s).isSome();
  }, ar = (o, s) => {
    const i = o.dom;
    sc(i, s), Si(Sa(o, "style").map(Wi), "") && ts(o, "style");
  }, te = (o) => o.dom.offsetWidth, ze = (o, s) => {
    const i = (f) => {
      const m = s(f);
      if (m <= 0 || m === null) {
        const b = Ts(f, o);
        return parseFloat(b) || 0;
      }
      return m;
    }, l = (f, m) => K(m, (b, x) => {
      const w = Ts(f, x), E = w === void 0 ? 0 : parseInt(w, 10);
      return isNaN(E) ? b : b + E;
    }, 0);
    return { set: (f, m) => {
      if (!en(m) && !m.match(/^[0-9]+$/))
        throw new Error(o + ".set accepts only positive integer values. Value was " + m);
      const b = f.dom;
      Yn(b) && (b.style[o] = m + "px");
    }, get: i, getOuter: i, aggregate: l, max: (f, m, b) => {
      const x = l(f, b);
      return m > x ? m - x : 0;
    } };
  }, Pe = ze("height", (o) => {
    const s = o.dom;
    return Rr(o) ? s.getBoundingClientRect().height : s.offsetHeight;
  }), Qe = (o) => Pe.get(o), Ft = (o) => Pe.getOuter(o), An = (o, s) => ({ left: o, top: s, translate: (i, l) => An(o + i, s + l) }), so = An, Zn = (o, s) => o !== void 0 ? o : s !== void 0 ? s : 0, $n = (o) => {
    const s = o.dom.ownerDocument, i = s.body, l = s.defaultView, f = s.documentElement;
    if (i === o.dom)
      return so(i.offsetLeft, i.offsetTop);
    const m = Zn(l == null ? void 0 : l.pageYOffset, f.scrollTop), b = Zn(l == null ? void 0 : l.pageXOffset, f.scrollLeft), x = Zn(f.clientTop, i.clientTop), w = Zn(f.clientLeft, i.clientLeft);
    return ds(o).translate(b - w, m - x);
  }, ds = (o) => {
    const s = o.dom, i = s.ownerDocument.body;
    return i === s ? so(i.offsetLeft, i.offsetTop) : Rr(o) ? ((l) => {
      const f = l.getBoundingClientRect();
      return so(f.left, f.top);
    })(s) : so(0, 0);
  }, Cr = ze("width", (o) => o.dom.offsetWidth), Wr = (o) => Cr.get(o), Ba = (o) => Cr.getOuter(o), ml = (o) => {
    let s, i = !1;
    return (...l) => (i || (i = !0, s = o.apply(null, l)), s);
  }, nr = () => wf(0, 0), wf = (o, s) => ({ major: o, minor: s }), Qc = { nu: wf, detect: (o, s) => {
    const i = String(s).toLowerCase();
    return o.length === 0 ? nr() : ((l, f) => {
      const m = ((x, w) => {
        for (let E = 0; E < x.length; E++) {
          const O = x[E];
          if (O.test(w))
            return O;
        }
      })(l, f);
      if (!m)
        return { major: 0, minor: 0 };
      const b = (x) => Number(f.replace(m, "$" + x));
      return wf(b(1), b(2));
    })(o, i);
  }, unknown: nr }, Ga = (o, s) => {
    const i = String(s).toLowerCase();
    return Go(o, (l) => l.search(i));
  }, Ld = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, aa = (o) => (s) => ba(s, o), sg = [{ name: "Edge", versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/], search: (o) => ba(o, "edge/") && ba(o, "chrome") && ba(o, "safari") && ba(o, "applewebkit") }, { name: "Chromium", brand: "Chromium", versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, Ld], search: (o) => ba(o, "chrome") && !ba(o, "chromeframe") }, { name: "IE", versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/], search: (o) => ba(o, "msie") || ba(o, "trident") }, { name: "Opera", versionRegexes: [Ld, /.*?opera\/([0-9]+)\.([0-9]+).*/], search: aa("opera") }, { name: "Firefox", versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/], search: aa("firefox") }, { name: "Safari", versionRegexes: [Ld, /.*?cpu os ([0-9]+)_([0-9]+).*/], search: (o) => (ba(o, "safari") || ba(o, "mobile/")) && ba(o, "applewebkit") }], oi = [{ name: "Windows", search: aa("win"), versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/] }, { name: "iOS", search: (o) => ba(o, "iphone") || ba(o, "ipad"), versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/] }, { name: "Android", search: aa("android"), versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/] }, { name: "macOS", search: aa("mac os x"), versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/] }, { name: "Linux", search: aa("linux"), versionRegexes: [] }, { name: "Solaris", search: aa("sunos"), versionRegexes: [] }, { name: "FreeBSD", search: aa("freebsd"), versionRegexes: [] }, { name: "ChromeOS", search: aa("cros"), versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/] }], $l = { browsers: Ee(sg), oses: Ee(oi) }, kp = "Edge", oh = "Chromium", Ht = "Opera", Pd = "Firefox", _p = "Safari", ed = (o) => {
    const s = o.current, i = o.version, l = (f) => () => s === f;
    return { current: s, version: i, isEdge: l(kp), isChromium: l(oh), isIE: l("IE"), isOpera: l(Ht), isFirefox: l(Pd), isSafari: l(_p) };
  }, ns = () => ed({ current: void 0, version: Qc.unknown() }), ag = ed, Xi = "Windows", Id = "Android", Cp = "Linux", Pc = "macOS", bu = "Solaris", rh = "FreeBSD", Ea = "ChromeOS", yu = (o) => {
    const s = o.current, i = o.version, l = (f) => () => s === f;
    return { current: s, version: i, isWindows: l(Xi), isiOS: l("iOS"), isAndroid: l(Id), isMacOS: l(Pc), isLinux: l(Cp), isSolaris: l(bu), isFreeBSD: l(rh), isChromeOS: l(Ea) };
  }, ig = () => yu({ current: void 0, version: Qc.unknown() }), eu = yu, om = (o) => window.matchMedia(o).matches;
  var kf;
  let _c = ml(() => ((o, s, i) => {
    const l = $l.browsers(), f = $l.oses(), m = s.bind((w) => ((E, O) => Ko(O.brands, (A) => {
      const B = A.brand.toLowerCase();
      return Go(E, ($) => {
        var Z;
        return B === ((Z = $.brand) === null || Z === void 0 ? void 0 : Z.toLowerCase());
      }).map(($) => ({ current: $.name, version: Qc.nu(parseInt(A.version, 10), 0) }));
    }))(l, w)).orThunk(() => ((w, E) => Ga(w, E).map((O) => {
      const A = Qc.detect(O.versionRegexes, E);
      return { current: O.name, version: A };
    }))(l, o)).fold(ns, ag), b = ((w, E) => Ga(w, E).map((O) => {
      const A = Qc.detect(O.versionRegexes, E);
      return { current: O.name, version: A };
    }))(f, o).fold(ig, eu), x = ((w, E, O, A) => {
      const B = w.isiOS() && /ipad/i.test(O) === !0, $ = w.isiOS() && !B, Z = w.isiOS() || w.isAndroid(), oe = Z || A("(pointer:coarse)"), re = B || !$ && Z && A("(min-device-width:768px)"), fe = $ || Z && !re, ee = E.isSafari() && w.isiOS() && /safari/i.test(O) === !1, J = !fe && !re && !ee;
      return { isiPad: Ee(B), isiPhone: Ee($), isTablet: Ee(re), isPhone: Ee(fe), isTouch: Ee(oe), isAndroid: w.isAndroid, isiOS: w.isiOS, isWebView: Ee(ee), isDesktop: Ee(J) };
    })(b, m, o, i);
    return { browser: m, os: b, deviceType: x };
  })(navigator.userAgent, M.from(navigator.userAgentData), om));
  const Ic = () => _c(), Eo = (o) => {
    const s = Xt(((m) => {
      if (Na() && it(m.target)) {
        const b = Xt(m.target);
        if (ra(b) && ((x) => it(x.dom.shadowRoot))(b) && m.composed && m.composedPath) {
          const x = m.composedPath();
          if (x)
            return ct(x);
        }
      }
      return M.from(m.target);
    })(o).getOr(o.target)), i = () => o.stopPropagation(), l = () => o.preventDefault(), f = Ot(l, i);
    return ((m, b, x, w, E, O, A) => ({ target: m, x: b, y: x, stop: w, prevent: E, kill: O, raw: A }))(s, o.clientX, o.clientY, i, l, f, o);
  }, Fd = (o, s, i, l, f) => {
    const m = ((b, x) => (w) => {
      b(w) && x(Eo(w));
    })(i, l);
    return o.dom.addEventListener(s, m, f), { unbind: We(ia, o, s, m, f) };
  }, ia = (o, s, i, l) => {
    o.dom.removeEventListener(s, i, l);
  }, td = (o, s) => {
    cl(o).each((i) => {
      i.dom.insertBefore(s.dom, o.dom);
    });
  }, $d = (o, s) => {
    ((l) => M.from(l.dom.nextSibling).map(Xt))(o).fold(() => {
      cl(o).each((l) => {
        Zs(l, s);
      });
    }, (l) => {
      td(l, s);
    });
  }, Ji = (o, s) => {
    El(o).fold(() => {
      Zs(o, s);
    }, (i) => {
      o.dom.insertBefore(s.dom, i.dom);
    });
  }, Zs = (o, s) => {
    o.dom.appendChild(s.dom);
  }, nd = (o, s) => {
    tn(s, (i) => {
      Zs(o, i);
    });
  }, rm = (o) => {
    o.dom.textContent = "", tn(_r(o), (s) => {
      ya(s);
    });
  }, ya = (o) => {
    const s = o.dom;
    s.parentNode !== null && s.parentNode.removeChild(s);
  }, Ls = (o) => {
    const s = o !== void 0 ? o.dom : document, i = s.body.scrollLeft || s.documentElement.scrollLeft, l = s.body.scrollTop || s.documentElement.scrollTop;
    return so(i, l);
  }, Vr = (o, s, i) => {
    const l = (i !== void 0 ? i.dom : document).defaultView;
    l && l.scrollTo(o, s);
  }, zs = (o, s, i, l) => ({ x: o, y: s, width: i, height: l, right: o + i, bottom: s + l }), Qi = (o) => {
    const s = o === void 0 ? window : o, i = s.document, l = Ls(Xt(i));
    return ((f) => {
      const m = f === void 0 ? window : f;
      return Ic().browser.isFirefox() ? M.none() : M.from(m.visualViewport);
    })(s).fold(() => {
      const f = s.document.documentElement, m = f.clientWidth, b = f.clientHeight;
      return zs(l.left, l.top, m, b);
    }, (f) => zs(Math.max(f.pageLeft, l.left), Math.max(f.pageTop, l.top), f.width, f.height));
  }, Js = () => Xt(document), La = (o, s) => o.view(s).fold(Ee([]), (i) => {
    const l = o.owner(i), f = La(o, l);
    return [i].concat(f);
  });
  var xs = Object.freeze({ __proto__: null, view: (o) => {
    var s;
    return (o.dom === document ? M.none() : M.from((s = o.dom.defaultView) === null || s === void 0 ? void 0 : s.frameElement)).map(Xt);
  }, owner: (o) => ni(o) });
  const Hd = (o) => {
    const s = Js(), i = Ls(s);
    return ((f, m) => {
      const b = m.owner(f), x = La(m, b);
      return M.some(x);
    })(o, xs).fold(We($n, o), (f) => {
      const m = ds(o), b = Mo(f, (x, w) => {
        const E = ds(w);
        return { left: x.left + E.left, top: x.top + E.top };
      }, { left: 0, top: 0 });
      return so(b.left + m.left + i.left, b.top + m.top + i.top);
    });
  }, Ws = (o, s, i, l) => ({ x: o, y: s, width: i, height: l, right: o + i, bottom: s + l }), va = (o) => {
    const s = $n(o), i = Ba(o), l = Ft(o);
    return Ws(s.left, s.top, i, l);
  }, la = (o) => {
    const s = Hd(o), i = Ba(o), l = Ft(o);
    return Ws(s.left, s.top, i, l);
  }, od = (o, s) => {
    const i = Math.max(o.x, s.x), l = Math.max(o.y, s.y), f = Math.min(o.right, s.right), m = Math.min(o.bottom, s.bottom);
    return Ws(i, l, f - i, m - l);
  }, os = () => Qi(window);
  var sm = tinymce.util.Tools.resolve("tinymce.ThemeManager");
  const vu = (o) => {
    const s = (m) => m(o), i = Ee(o), l = () => f, f = { tag: !0, inner: o, fold: (m, b) => b(o), isValue: un, isError: Xe, map: (m) => To.value(m(o)), mapError: l, bind: s, exists: s, forall: s, getOr: i, or: l, getOrThunk: i, orThunk: l, getOrDie: i, each: (m) => {
      m(o);
    }, toOptional: () => M.some(o) };
    return f;
  }, Cc = (o) => {
    const s = () => i, i = { tag: !1, inner: o, fold: (l, f) => l(o), isValue: Xe, isError: un, map: s, mapError: (l) => To.error(l(o)), bind: s, exists: Xe, forall: un, getOr: wt, or: wt, getOrThunk: jn, orThunk: jn, getOrDie: ko(String(o)), each: gt, toOptional: M.none };
    return i;
  }, To = { value: vu, error: Cc, fromOption: (o, s) => o.fold(() => Cc(s), vu) };
  var ca;
  (function(o) {
    o[o.Error = 0] = "Error", o[o.Value = 1] = "Value";
  })(ca || (ca = {}));
  const rd = (o, s, i) => o.stype === ca.Error ? s(o.serror) : i(o.svalue), Oi = (o) => ({ stype: ca.Value, svalue: o }), Vd = (o) => ({ stype: ca.Error, serror: o }), Fc = Oi, xu = Vd, lg = rd, wu = (o, s, i, l) => ({ tag: "field", key: o, newKey: s, presence: i, prop: l }), ri = (o, s, i) => {
    switch (o.tag) {
      case "field":
        return s(o.key, o.newKey, o.presence, o.prop);
      case "custom":
        return i(o.newKey, o.instantiator);
    }
  }, Sp = (o) => (...s) => {
    if (s.length === 0)
      throw new Error("Can't merge zero objects");
    const i = {};
    for (let l = 0; l < s.length; l++) {
      const f = s[l];
      for (const m in f)
        _n(f, m) && (i[m] = o(i[m], f[m]));
    }
    return i;
  }, be = Sp((o, s) => pe(o) && pe(s) ? be(o, s) : s), Sc = Sp((o, s) => s), Ai = (o) => ({ tag: "defaultedThunk", process: o }), tu = (o) => Ai(Ee(o)), _f = (o) => ({ tag: "mergeWithThunk", process: o }), sd = (o) => {
    const s = ((l) => {
      const f = [], m = [];
      return tn(l, (b) => {
        rd(b, (x) => m.push(x), (x) => f.push(x));
      }), { values: f, errors: m };
    })(o);
    return s.errors.length > 0 ? (i = s.errors, Ot(xu, er)(i)) : Fc(s.values);
    var i;
  }, Le = (o) => he(o) && po(o).length > 100 ? " removed due to size" : JSON.stringify(o, null, 2), Dt = (o, s) => xu([{ path: o, getErrorInfo: s }]), vt = (o) => ({ extract: (s, i) => ((l, f) => l.stype === ca.Error ? f(l.serror) : l)(o(i), (l) => ((f, m) => Dt(f, Ee(m)))(s, l)), toString: Ee("val") }), Sn = vt(Fc), Fo = (o, s, i, l) => l(cn(o, s).getOrThunk(() => i(o))), ur = (o, s, i, l, f) => {
    const m = (x) => f.extract(s.concat([l]), x), b = (x) => x.fold(() => Fc(M.none()), (w) => ((E, O) => E.stype === ca.Value ? { stype: ca.Value, svalue: O(E.svalue) } : E)(f.extract(s.concat([l]), w), M.some));
    switch (o.tag) {
      case "required":
        return ((x, w, E, O) => cn(w, E).fold(() => ((A, B, $) => Dt(A, () => 'Could not find valid *required* value for "' + B + '" in ' + Le($)))(x, E, w), O))(s, i, l, m);
      case "defaultedThunk":
        return Fo(i, l, o.process, m);
      case "option":
        return ((x, w, E) => E(cn(x, w)))(i, l, b);
      case "defaultedOptionThunk":
        return ((x, w, E, O) => O(cn(x, w).map((A) => A === !0 ? E(x) : A)))(i, l, o.process, b);
      case "mergeWithThunk":
        return Fo(i, l, Ee({}), (x) => {
          const w = be(o.process(i), x);
          return m(w);
        });
    }
  }, Br = (o) => ({ extract: (s, i) => o().extract(s, i), toString: () => o().toString() }), Lr = (o) => po($r(o, it)), hi = (o) => {
    const s = Nn(o), i = Mo(o, (l, f) => ri(f, (m) => be(l, { [m]: !0 }), Ee(l)), {});
    return { extract: (l, f) => {
      const m = Ye(f) ? [] : Lr(f), b = Pn(m, (x) => !Ys(i, x));
      return b.length === 0 ? s.extract(l, f) : ((x, w) => Dt(x, () => "There are unsupported fields: [" + w.join(", ") + "] specified"))(l, b);
    }, toString: s.toString };
  }, Nn = (o) => ({ extract: (s, i) => ((l, f, m) => {
    const b = {}, x = [];
    for (const w of m)
      ri(w, (E, O, A, B) => {
        const $ = ur(A, l, f, E, B);
        lg($, (Z) => {
          x.push(...Z);
        }, (Z) => {
          b[O] = Z;
        });
      }, (E, O) => {
        b[E] = O(f);
      });
    return x.length > 0 ? xu(x) : Fc(b);
  })(s, i, o), toString: () => `obj{
` + Ct(o, (i) => ri(i, (l, f, m, b) => l + " -> " + b.toString(), (l, f) => "state(" + l + ")")).join(`
`) + "}" }), Ps = (o) => ({ extract: (s, i) => {
    const l = Ct(i, (f, m) => o.extract(s.concat(["[" + m + "]"]), f));
    return sd(l);
  }, toString: () => "array(" + o.toString() + ")" }), Di = (o, s) => {
    const i = s !== void 0 ? s : wt;
    return { extract: (l, f) => {
      const m = [];
      for (const b of o) {
        const x = b.extract(l, f);
        if (x.stype === ca.Value)
          return { stype: ca.Value, svalue: i(x.svalue) };
        m.push(x);
      }
      return sd(m);
    }, toString: () => "oneOf(" + Ct(o, (l) => l.toString()).join(", ") + ")" };
  }, cg = (o, s) => ({ extract: (i, l) => {
    const f = po(l), m = ((b, x) => Ps(vt(o)).extract(b, x))(i, f);
    return ((b, x) => b.stype === ca.Value ? x(b.svalue) : b)(m, (b) => {
      const x = Ct(b, (w) => wu(w, w, { tag: "required", process: {} }, s));
      return Nn(x).extract(i, l);
    });
  }, toString: () => "setOf(" + s.toString() + ")" }), Ec = Ot(Ps, Nn), Pr = Ee(Sn), Tc = (o, s) => vt((i) => {
    const l = typeof i;
    return o(i) ? Fc(i) : xu(`Expected type: ${s} but got: ${l}`);
  }), qr = Tc(en, "number"), xa = Tc(ce, "string"), $c = Tc(Ye, "boolean"), Ud = Tc(Rt, "function"), am = (o) => {
    if (Object(o) !== o)
      return !0;
    switch ({}.toString.call(o).slice(8, -1)) {
      case "Boolean":
      case "Number":
      case "String":
      case "Date":
      case "RegExp":
      case "Blob":
      case "FileList":
      case "ImageData":
      case "ImageBitmap":
      case "ArrayBuffer":
        return !0;
      case "Array":
      case "Object":
        return Object.keys(o).every((s) => am(o[s]));
      default:
        return !1;
    }
  }, Ep = vt((o) => am(o) ? Fc(o) : xu("Expected value to be acceptable for sending via postMessage")), ku = (o, s) => ({ extract: (i, l) => cn(l, o).fold(() => ((f, m) => Dt(f, () => 'Choice schema did not contain choice key: "' + m + '"'))(i, o), (f) => ((m, b, x, w) => cn(x, w).fold(() => ((E, O, A) => Dt(E, () => 'The chosen schema: "' + A + '" did not exist in branches: ' + Le(O)))(m, x, w), (E) => E.extract(m.concat(["branch: " + w]), b)))(i, l, s, f)), toString: () => "chooseOn(" + o + "). Possible values: " + po(s) }), Tl = (o) => vt((s) => o(s).fold(xu, Fc)), pl = (o, s) => cg((i) => o(i).fold(Vd, Oi), s), Gr = (o, s, i) => {
    return l = ((f, m, b) => ((x, w) => x.stype === ca.Error ? { stype: ca.Error, serror: w(x.serror) } : x)(m.extract([f], b), (x) => ({ input: b, errors: x })))(o, s, i), rd(l, To.error, To.value);
    var l;
  }, ic = (o) => o.fold((s) => {
    throw new Error(nu(s));
  }, wt), Ta = (o, s, i) => ic(Gr(o, s, i)), nu = (o) => `Errors: 
` + ((s) => {
    const i = s.length > 10 ? s.slice(0, 10).concat([{ path: [], getErrorInfo: Ee("... (only showing first ten failures)") }]) : s;
    return Ct(i, (l) => "Failed path: (" + l.path.join(" > ") + `)
` + l.getErrorInfo());
  })(o.errors).join(`
`) + `

Input object: ` + Le(o.input), bi = (o, s) => ku(o, ho(s, Nn)), ad = (o, s) => ((i, l) => {
    const f = ml(l);
    return { extract: (m, b) => f().extract(m, b), toString: () => f().toString() };
  })(0, s), Qs = wu, ua = (o, s) => ({ tag: "custom", newKey: o, instantiator: s }), si = (o) => Tl((s) => Bn(o, s) ? To.value(s) : To.error(`Unsupported value: "${s}", choose one of "${o.join(", ")}".`)), st = (o) => Qs(o, o, { tag: "required", process: {} }, Pr()), zl = (o, s) => Qs(o, o, { tag: "required", process: {} }, s), Lm = (o) => zl(o, qr), Is = (o) => zl(o, xa), Pa = (o, s) => Qs(o, o, { tag: "required", process: {} }, si(s)), Ia = (o) => zl(o, Ud), el = (o, s) => Qs(o, o, { tag: "required", process: {} }, Nn(s)), jd = (o, s) => Qs(o, o, { tag: "required", process: {} }, Ec(s)), Ka = (o, s) => Qs(o, o, { tag: "required", process: {} }, Ps(s)), pr = (o) => Qs(o, o, { tag: "option", process: {} }, Pr()), Hl = (o, s) => Qs(o, o, { tag: "option", process: {} }, s), ea = (o) => Hl(o, qr), Nr = (o) => Hl(o, xa), Pm = (o, s) => Hl(o, si(s)), Vl = (o) => Hl(o, Ud), Ya = (o, s) => Hl(o, Ps(s)), Ol = (o, s) => Hl(o, Nn(s)), He = (o, s) => Qs(o, o, tu(s), Pr()), za = (o, s, i) => Qs(o, o, tu(s), i), ou = (o, s) => za(o, s, qr), Al = (o, s) => za(o, s, xa), Fs = (o, s, i) => za(o, s, si(i)), rs = (o, s) => za(o, s, $c), fs = (o, s) => za(o, s, Ud), Ir = (o, s, i) => za(o, s, Ps(i)), im = (o, s, i) => za(o, s, Nn(i)), Ln = (o) => {
    let s = o;
    return { get: () => s, set: (i) => {
      s = i;
    } };
  }, Fa = (o) => {
    if (!Me(o))
      throw new Error("cases must be an array");
    if (o.length === 0)
      throw new Error("there must be at least one case");
    const s = [], i = {};
    return tn(o, (l, f) => {
      const m = po(l);
      if (m.length !== 1)
        throw new Error("one and only one name per case");
      const b = m[0], x = l[b];
      if (i[b] !== void 0)
        throw new Error("duplicate key detected:" + b);
      if (b === "cata")
        throw new Error("cannot have a case named cata (sorry)");
      if (!Me(x))
        throw new Error("case arguments must be an array");
      s.push(b), i[b] = (...w) => {
        const E = w.length;
        if (E !== x.length)
          throw new Error("Wrong number of arguments to case " + b + ". Expected " + x.length + " (" + x + "), got " + E);
        return { fold: (...O) => {
          if (O.length !== o.length)
            throw new Error("Wrong number of arguments to fold. Expected " + o.length + ", got " + O.length);
          return O[f].apply(null, w);
        }, match: (O) => {
          const A = po(O);
          if (s.length !== A.length)
            throw new Error("Wrong number of arguments to match. Expected: " + s.join(",") + `
Actual: ` + A.join(","));
          if (!nc(s, (B) => Bn(A, B)))
            throw new Error("Not all branches were specified when using match. Specified: " + A.join(", ") + `
Required: ` + s.join(", "));
          return O[b].apply(null, w);
        }, log: (O) => {
          console.log(O, { constructors: s, constructor: b, params: w });
        } };
      };
    }), i;
  };
  Fa([{ bothErrors: ["error1", "error2"] }, { firstError: ["error1", "value2"] }, { secondError: ["value1", "error2"] }, { bothValues: ["value1", "value2"] }]);
  const yi = (o, s) => ((i, l) => ({ [i]: l }))(o, s), dr = (o) => ((s) => {
    const i = {};
    return tn(s, (l) => {
      i[l.key] = l.value;
    }), i;
  })(o), wa = (o) => Rt(o) ? o : Xe, zc = (o, s, i) => {
    let l = o.dom;
    const f = wa(i);
    for (; l.parentNode; ) {
      l = l.parentNode;
      const m = Xt(l), b = s(m);
      if (b.isSome())
        return b;
      if (f(m))
        break;
    }
    return M.none();
  }, lc = (o, s, i) => {
    const l = s(o), f = wa(i);
    return l.orThunk(() => f(o) ? M.none() : zc(o, s, f));
  }, de = (o, s) => tr(o.element, s.event.target), Hc = { can: un, abort: Xe, run: gt }, Oc = (o) => {
    if (!Ys(o, "can") && !Ys(o, "abort") && !Ys(o, "run"))
      throw new Error("EventHandler defined by: " + JSON.stringify(o, null, 2) + " does not have can, abort, or run!");
    return { ...Hc, ...o };
  }, ls = Ee, Yo = ls("touchstart"), id = ls("touchmove"), Ac = ls("touchend"), Cf = ls("touchcancel"), da = ls("mousedown"), z = ls("mousemove"), F = ls("mouseout"), X = ls("mouseup"), _e = ls("mouseover"), Oe = ls("focusin"), zt = ls("focusout"), bn = ls("keydown"), ao = ls("keyup"), Hn = ls("input"), En = ls("change"), yr = ls("click"), ws = ls("transitioncancel"), Ri = ls("transitionend"), _u = ls("transitionstart"), Ni = ls("selectstart"), ka = (o) => Ee("alloy." + o), vi = { tap: ka("tap") }, Mi = ka("focus"), Im = ka("blur.post"), wn = ka("paste.post"), ta = ka("receive"), gl = ka("execute"), Vc = ka("focus.item"), Ul = vi.tap, Zd = ka("longpress"), Tp = ka("sandbox.close"), ug = ka("typeahead.cancel"), ru = ka("system.init"), sh = ka("system.touchmove"), Cu = ka("system.touchend"), Wd = ka("system.scroll"), Uc = ka("system.resize"), At = ka("system.attached"), Fm = ka("system.detached"), qd = ka("system.dismissRequested"), Gd = ka("system.repositionRequested"), Dl = ka("focusmanager.shifted"), lm = ka("slotcontainer.visibility"), cs = ka("system.external.element.scroll"), Rl = ka("change.tab"), cc = ka("dismiss.tab"), Kr = ka("highlight"), Sf = ka("dehighlight"), Io = (o, s) => {
    Ef(o, o.element, s, {});
  }, pn = (o, s, i) => {
    Ef(o, o.element, s, i);
  }, Kd = (o) => {
    Io(o, gl());
  }, zp = (o, s, i) => {
    Ef(o, s, i, {});
  }, Ef = (o, s, i, l) => {
    const f = { target: s, ...l };
    o.getSystem().triggerEvent(i, s, f);
  }, uc = (o, s, i, l) => {
    o.getSystem().triggerEvent(i, s, l.event);
  }, Bo = (o) => dr(o), $a = (o, s) => ({ key: o, value: Oc({ abort: s }) }), $m = (o) => ({ key: o, value: Oc({ run: (s, i) => {
    i.event.prevent();
  } }) }), ft = (o, s) => ({ key: o, value: Oc({ run: s }) }), dc = (o, s, i) => ({ key: o, value: Oc({ run: (l, f) => {
    s.apply(void 0, [l, f].concat(i));
  } }) }), ld = (o) => (s) => ({ key: o, value: Oc({ run: (i, l) => {
    de(i, l) && s(i, l);
  } }) }), cd = (o, s, i) => ((l, f) => ft(l, (m, b) => {
    m.getSystem().getByUid(f).each((x) => {
      uc(x, x.element, l, b);
    });
  }))(o, s.partUids[i]), Yd = (o, s) => ft(o, (i, l) => {
    const f = l.event, m = i.getSystem().getByDom(f.target).getOrThunk(() => lc(f.target, (b) => i.getSystem().getByDom(b).toOptional(), Xe).getOr(i));
    s(i, m, l);
  }), Su = (o) => ft(o, (s, i) => {
    i.cut();
  }), jl = (o) => ft(o, (s, i) => {
    i.stop();
  }), Xd = (o, s) => ld(o)(s), ss = ld(At()), ud = ld(Fm()), eb = ld(ru()), hl = (Tu = gl(), (o) => ft(Tu, o)), Hm = (o) => o.dom.innerHTML, tl = (o, s) => {
    const i = ni(o).dom, l = Xt(i.createDocumentFragment()), f = ((m, b) => {
      const x = (b || document).createElement("div");
      return x.innerHTML = m, _r(Xt(x));
    })(s, i);
    nd(l, f), rm(o), Zs(o, l);
  }, cm = (o, s) => Xt(o.dom.cloneNode(s)), Eu = (o) => ((s) => {
    if (kc(s))
      return "#shadow-root";
    {
      const i = ((l) => cm(l, !1))(s);
      return ((l) => {
        const f = Cl("div"), m = Xt(l.dom.cloneNode(!0));
        return Zs(f, m), Hm(f);
      })(i);
    }
  })(o), Jd = Bo([((o, s) => ({ key: o, value: Oc({ can: (i, l) => {
    const f = l.event, m = f.originator, b = f.target;
    return !((x, w, E) => tr(w, x.element) && !tr(w, E))(i, m, b) || (console.warn(Mi() + ` did not get interpreted by the desired target. 
Originator: ` + Eu(m) + `
Target: ` + Eu(b) + `
Check the ` + Mi() + " event handlers"), !1);
  } }) }))(Mi())]);
  var Tu, Tf = Object.freeze({ __proto__: null, events: Jd });
  let um = 0;
  const hn = (o) => {
    const s = (/* @__PURE__ */ new Date()).getTime(), i = Math.floor(1e9 * Math.random());
    return um++, o + "_" + i + um + String(s);
  }, Op = Ee("alloy-id-"), Vm = Ee("data-alloy-id"), zf = Op(), tb = Vm(), C = (o, s) => {
    Object.defineProperty(o.dom, tb, { value: s, writable: !0 });
  }, R = (o) => {
    const s = ra(o) ? o.dom[tb] : null;
    return M.from(s);
  }, q = (o) => hn(o), se = wt, De = (o) => {
    const s = (f) => `The component must be in a context to execute: ${f}` + (o ? `
` + Eu(o().element) + " is not in context." : ""), i = (f) => () => {
      throw new Error(s(f));
    }, l = (f) => () => {
      console.warn(s(f));
    };
    return { debugInfo: Ee("fake"), triggerEvent: l("triggerEvent"), triggerFocus: l("triggerFocus"), triggerEscape: l("triggerEscape"), broadcast: l("broadcast"), broadcastOn: l("broadcastOn"), broadcastEvent: l("broadcastEvent"), build: i("build"), buildOrPatch: i("buildOrPatch"), addToWorld: i("addToWorld"), removeFromWorld: i("removeFromWorld"), addToGui: i("addToGui"), removeFromGui: i("removeFromGui"), getByUid: i("getByUid"), getByDom: i("getByDom"), isConnected: Xe };
  }, rt = De(), Pt = (o) => Ct(o, (s) => _l(s, "/*") ? s.substring(0, s.length - 2) : s), on = (o, s) => {
    const i = o.toString(), l = i.indexOf(")") + 1, f = i.indexOf("("), m = i.substring(f + 1, l - 1).split(/,\s*/);
    return o.toFunctionAnnotation = () => ({ name: s, parameters: Pt(m) }), o;
  }, Tn = hn("alloy-premade"), uo = (o) => (Object.defineProperty(o.element.dom, Tn, { value: o.uid, writable: !0 }), yi(Tn, o)), ks = (o) => cn(o, Tn), _o = (o) => ((s, i) => {
    const l = i.toString(), f = l.indexOf(")") + 1, m = l.indexOf("("), b = l.substring(m + 1, f - 1).split(/,\s*/);
    return s.toFunctionAnnotation = () => ({ name: "OVERRIDE", parameters: Pt(b.slice(1)) }), s;
  })((s, ...i) => o(s.getApis(), s, ...i), o), fr = { init: () => as({ readState: Ee("No State required") }) }, as = (o) => o, Ha = (o, s) => {
    const i = {};
    return Mr(o, (l, f) => {
      Mr(l, (m, b) => {
        const x = cn(i, b).getOr([]);
        i[b] = x.concat([s(f, m)]);
      });
    }), i;
  }, Xa = (o) => ({ classes: yt(o.classes) ? [] : o.classes, attributes: yt(o.attributes) ? {} : o.attributes, styles: yt(o.styles) ? {} : o.styles }), su = (o) => o.cHandler, Um = (o, s) => ({ name: o, handler: s }), Of = (o, s) => {
    const i = {};
    return tn(o, (l) => {
      i[l.name()] = l.handlers(s);
    }), i;
  }, or = (o, s, i) => {
    const l = s[i];
    return l ? ((f, m, b, x) => {
      try {
        const w = kt(b, (E, O) => {
          const A = E[m], B = O[m], $ = x.indexOf(A), Z = x.indexOf(B);
          if ($ === -1)
            throw new Error("The ordering for " + f + " does not have an entry for " + A + `.
Order specified: ` + JSON.stringify(x, null, 2));
          if (Z === -1)
            throw new Error("The ordering for " + f + " does not have an entry for " + B + `.
Order specified: ` + JSON.stringify(x, null, 2));
          return $ < Z ? -1 : Z < $ ? 1 : 0;
        });
        return To.value(w);
      } catch (w) {
        return To.error([w]);
      }
    })("Event: " + i, "name", o, l).map((f) => ((m) => {
      const b = ((w, E) => (...O) => K(w, (A, B) => A && (($) => $.can)(B).apply(void 0, O), !0))(m), x = ((w, E) => (...O) => K(w, (A, B) => A || (($) => $.abort)(B).apply(void 0, O), !1))(m);
      return { can: b, abort: x, run: (...w) => {
        tn(m, (E) => {
          E.run.apply(void 0, w);
        });
      } };
    })(Ct(f, (m) => m.handler))) : ((f, m) => To.error(["The event (" + f + `) has more than one behaviour that listens to it.
When this occurs, you must specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).
The behaviours that can trigger it are: ` + JSON.stringify(Ct(m, (b) => b.name), null, 2)]))(i, o);
  }, jm = (o, s) => ((i, l) => {
    const f = ((b) => {
      const x = [], w = [];
      return tn(b, (E) => {
        E.fold((O) => {
          x.push(O);
        }, (O) => {
          w.push(O);
        });
      }), { errors: x, values: w };
    })(i);
    return f.errors.length > 0 ? (m = f.errors, To.error(er(m))) : ((b, x) => b.length === 0 ? To.value(x) : To.value(be(x, Sc.apply(void 0, b))))(f.values, l);
    var m;
  })(Po(o, (i, l) => (i.length === 1 ? To.value(i[0].handler) : or(i, s, l)).map((f) => {
    const m = ((x) => {
      const w = ((E) => Rt(E) ? { can: un, abort: Xe, run: E } : E)(x);
      return (E, O, ...A) => {
        const B = [E, O].concat(A);
        w.abort.apply(void 0, B) ? O.stop() : w.can.apply(void 0, B) && w.run.apply(void 0, B);
      };
    })(f), b = i.length > 1 ? Pn(s[l], (x) => jr(i, (w) => w.name === x)).join(" > ") : i[0].name;
    return yi(l, ((x, w) => ({ handler: x, purpose: w }))(m, b));
  })), {}), dd = "alloy.base.behaviour", fd = Nn([Qs("dom", "dom", { tag: "required", process: {} }, Nn([st("tag"), He("styles", {}), He("classes", []), He("attributes", {}), pr("value"), pr("innerHtml")])), st("components"), st("uid"), He("events", {}), He("apis", {}), Qs("eventOrder", "eventOrder", (Ml = { [gl()]: ["disabling", dd, "toggling", "typeaheadevents"], [Mi()]: [dd, "focusing", "keying"], [ru()]: [dd, "disabling", "toggling", "representing"], [Hn()]: [dd, "representing", "streaming", "invalidating"], [Fm()]: [dd, "representing", "item-events", "tooltipping"], [da()]: ["focusing", dd, "item-type-events"], [Yo()]: ["focusing", dd, "item-type-events"], [_e()]: ["item-type-events", "tooltipping"], [ta()]: ["receiving", "reflecting", "tooltipping"] }, _f(Ee(Ml))), Pr()), pr("domModification")]), Ap = (o) => o.events, dg = (o, s) => {
    const i = js(o, s);
    return i === void 0 || i === "" ? [] : i.split(" ");
  }, md = (o) => o.dom.classList !== void 0, Oo = (o) => dg(o, "class"), Sr = (o, s) => ((i, l, f) => {
    const m = dg(i, l).concat([f]);
    return eo(i, l, m.join(" ")), !0;
  })(o, "class", s), xi = (o, s) => ((i, l, f) => {
    const m = Pn(dg(i, l), (b) => b !== f);
    return m.length > 0 ? eo(i, l, m.join(" ")) : ts(i, l), !1;
  })(o, "class", s), vr = (o, s) => {
    md(o) ? o.dom.classList.add(s) : Sr(o, s);
  }, fg = (o) => {
    (md(o) ? o.dom.classList : Oo(o)).length === 0 && ts(o, "class");
  }, $s = (o, s) => {
    md(o) ? o.dom.classList.remove(s) : xi(o, s), fg(o);
  }, _s = (o, s) => md(o) && o.dom.classList.contains(s), nl = (o, s) => {
    tn(s, (i) => {
      vr(o, i);
    });
  }, jc = (o, s) => {
    tn(s, (i) => {
      $s(o, i);
    });
  }, pd = (o) => md(o) ? ((s) => {
    const i = s.dom.classList, l = new Array(i.length);
    for (let f = 0; f < i.length; f++) {
      const m = i.item(f);
      m !== null && (l[f] = m);
    }
    return l;
  })(o) : Oo(o), zu = (o) => o.dom.value, dm = (o, s) => {
    if (s === void 0)
      throw new Error("Value.set was undefined");
    o.dom.value = s;
  }, mg = (o, s, i) => {
    i.fold(() => Zs(o, s), (l) => {
      tr(l, s) || (td(l, s), ya(l));
    });
  }, fm = (o, s, i) => {
    const l = Ct(s, i), f = _r(o);
    return tn(f.slice(l.length), ya), l;
  }, Af = (o, s, i, l) => {
    const f = Dr(o, s), m = l(i, f), b = ((x, w, E) => Dr(x, w).map((O) => {
      if (E.exists((A) => !tr(A, O))) {
        const A = E.map(Ti).getOr("span"), B = Cl(A);
        return td(O, B), B;
      }
      return O;
    }))(o, s, f);
    return mg(o, m.element, b), m;
  }, ah = (o, s) => {
    const i = po(o), l = po(s), f = cr(l, i), m = ((b, x) => {
      const w = {}, E = {};
      return Zr(b, (O, A) => !_n(s, A) || O !== s[A], Ca(w), Ca(E)), { t: w, f: E };
    })(o).t;
    return { toRemove: f, toSet: m };
  }, Zm = (o, s) => {
    const i = s.filter((l) => Ti(l) === o.tag && !((f) => f.innerHtml.isSome() && f.domChildren.length > 0)(o) && !((f) => _n(f.dom, Tn))(l)).bind((l) => ((f, m) => {
      try {
        const b = ((x, w) => {
          const { class: E, style: O, ...A } = ((le) => K(le.dom.attributes, (me, ke) => (me[ke.name] = ke.value, me), {}))(w), { toSet: B, toRemove: $ } = ah(x.attributes, A), Z = hu(w), { toSet: oe, toRemove: re } = ah(x.styles, Z), fe = pd(w), ee = cr(fe, x.classes), J = cr(x.classes, fe);
          return tn($, (le) => ts(w, le)), gi(w, B), nl(w, J), jc(w, ee), tn(re, (le) => ar(w, le)), ac(w, oe), x.innerHtml.fold(() => {
            const le = x.domChildren;
            ((me, ke) => {
              fm(me, ke, (Re, qe) => {
                const mt = Dr(me, qe);
                return mg(me, Re, mt), Re;
              });
            })(w, le);
          }, (le) => {
            tl(w, le);
          }), (() => {
            const le = w, me = x.value.getOrUndefined();
            me !== zu(le) && dm(le, me ?? "");
          })(), w;
        })(f, m);
        return M.some(b);
      } catch {
        return M.none();
      }
    })(o, l)).getOrThunk(() => ((l) => {
      const f = Cl(l.tag);
      gi(f, l.attributes), nl(f, l.classes), ac(f, l.styles), l.innerHtml.each((b) => tl(f, b));
      const m = l.domChildren;
      return nd(f, m), l.value.each((b) => {
        dm(f, b);
      }), f;
    })(o));
    return C(i, o.uid), i;
  }, Ry = (o) => {
    const s = ((i) => {
      const l = cn(i, "behaviours").getOr({});
      return Qr(po(l), (f) => {
        const m = l[f];
        return it(m) ? [m.me] : [];
      });
    })(o);
    return ((i, l) => ((f, m) => {
      const b = Ct(m, (w) => Ol(w.name(), [st("config"), He("state", fr)])), x = Gr("component.behaviours", Nn(b), f.behaviours).fold((w) => {
        throw new Error(nu(w) + `
Complete spec:
` + JSON.stringify(f, null, 2));
      }, wt);
      return { list: m, data: ho(x, (w) => {
        const E = w.map((O) => ({ config: O.config, state: O.state.init(O.config) }));
        return Ee(E);
      }) };
    })(i, l))(o, s);
  }, gd = (o, s) => {
    const i = () => B, l = Ln(rt), f = ic((($) => Gr("custom.definition", fd, $))(o)), m = Ry(o), b = (($) => $.list)(m), x = (($) => $.data)(m), w = (($, Z, oe) => {
      const re = { ...(fe = $).dom, uid: fe.uid, domChildren: Ct(fe.components, (Re) => Re.element) };
      var fe;
      const ee = ((Re) => Re.domModification.fold(() => Xa({}), Xa))($), J = { "alloy.base.modification": ee }, le = Z.length > 0 ? ((Re, qe, mt, bt) => {
        const St = { ...qe };
        tn(mt, ($o) => {
          St[$o.name()] = $o.exhibit(Re, bt);
        });
        const Qt = Ha(St, ($o, Hs) => ({ name: $o, modification: Hs })), vn = ($o) => Mo($o, (Hs, ga) => ({ ...ga.modification, ...Hs }), {}), Mn = Mo(Qt.classes, ($o, Hs) => Hs.modification.concat($o), []), Qn = vn(Qt.attributes), fo = vn(Qt.styles);
        return Xa({ classes: Mn, attributes: Qn, styles: fo });
      })(oe, J, Z, re) : ee;
      return me = re, ke = le, { ...me, attributes: { ...me.attributes, ...ke.attributes }, styles: { ...me.styles, ...ke.styles }, classes: me.classes.concat(ke.classes) };
      var me, ke;
    })(f, b, x), E = Zm(w, s), O = (($, Z, oe) => {
      const re = { "alloy.base.behaviour": Ap($) };
      return ((fe, ee, J, le) => {
        const me = ((ke, Re, qe) => {
          const mt = { ...qe, ...Of(Re, ke) };
          return Ha(mt, Um);
        })(fe, J, le);
        return jm(me, ee);
      })(oe, $.eventOrder, Z, re).getOrDie();
    })(f, b, x), A = Ln(f.components), B = { uid: o.uid, getSystem: l.get, config: ($) => {
      const Z = x;
      return (Rt(Z[$.name()]) ? Z[$.name()] : () => {
        throw new Error("Could not find " + $.name() + " in " + JSON.stringify(o, null, 2));
      })();
    }, hasConfigured: ($) => Rt(x[$.name()]), spec: o, readState: ($) => x[$]().map((Z) => Z.state.readState()).getOr("not enabled"), getApis: () => f.apis, connect: ($) => {
      l.set($);
    }, disconnect: () => {
      l.set(De(i));
    }, element: E, syncComponents: () => {
      const $ = _r(E), Z = Qr($, (oe) => l.get().getByDom(oe).fold(() => [], ut));
      A.set(Z);
    }, components: A.get, events: O };
    return B;
  }, Os = (o) => {
    const s = Xc(o);
    return nb({ element: s });
  }, nb = (o) => {
    const s = Ta("external.component", hi([st("element"), pr("uid")]), o), i = Ln(De()), l = s.uid.getOrThunk(() => q("external"));
    C(s.element, l);
    const f = { uid: l, getSystem: i.get, config: M.none, hasConfigured: Xe, connect: (m) => {
      i.set(m);
    }, disconnect: () => {
      i.set(De(() => f));
    }, getApis: () => ({}), element: s.element, spec: o, readState: Ee("No state"), syncComponents: gt, components: Ee([]), events: {} };
    return uo(f);
  }, ob = q, rb = (o, s) => ks(o).getOrThunk(() => ((i, l) => {
    const { events: f, ...m } = se(i), b = ((w, E) => {
      const O = cn(w, "components").getOr([]);
      return E.fold(() => Ct(O, Nl), (A) => Ct(O, (B, $) => rb(B, Dr(A, $))));
    })(m, l), x = { ...m, events: { ...Tf, ...f }, components: b };
    return To.value(gd(x, l));
  })(((i) => _n(i, "uid"))(o) ? o : { uid: ob(""), ...o }, s).getOrDie()), Nl = (o) => rb(o, M.none()), Yr = uo;
  var Ml, pg = (o, s, i, l, f) => o(i, l) ? M.some(i) : Rt(f) && f(i) ? M.none() : s(i, l, f);
  const sb = (o, s, i) => {
    let l = o.dom;
    const f = Rt(i) ? i : Xe;
    for (; l.parentNode; ) {
      l = l.parentNode;
      const m = Xt(l);
      if (s(m))
        return M.some(m);
      if (f(m))
        break;
    }
    return M.none();
  }, Ny = (o, s, i) => pg((l, f) => f(l), sb, o, s, i), ih = (o, s, i) => Ny(o, s, i).isSome(), Va = (o, s, i) => sb(o, (l) => Sl(l, s), i), hd = (o, s) => ((i, l) => Go(i.dom.childNodes, (f) => {
    return m = Xt(f), Sl(m, s);
    var m;
  }).map(Xt))(o), fa = (o, s) => ((i, l) => {
    const f = l === void 0 ? document : l.dom;
    return Nd(f) ? M.none() : M.from(f.querySelector(i)).map(Xt);
  })(s, o), Ou = (o, s, i) => pg((l, f) => Sl(l, f), Va, o, s, i), Df = "aria-controls", Qd = () => {
    const o = hn(Df);
    return { id: o, link: (s) => {
      eo(s, Df, o);
    }, unlink: (s) => {
      ts(s, Df);
    } };
  }, wi = (o, s) => ih(s, (i) => tr(i, o.element), Xe) || ((i, l) => ((f) => Ny(f, (m) => {
    if (!ra(m))
      return !1;
    const b = js(m, "id");
    return b !== void 0 && b.indexOf(Df) > -1;
  }).bind((m) => {
    const b = js(m, "id"), x = us(m);
    return fa(x, `[${Df}="${b}"]`);
  }))(l).exists((f) => wi(i, f)))(o, s);
  var Rf;
  (function(o) {
    o[o.STOP = 0] = "STOP", o[o.NORMAL = 1] = "NORMAL", o[o.LOGGING = 2] = "LOGGING";
  })(Rf || (Rf = {}));
  const lh = Ln({}), ab = ["alloy/data/Fields", "alloy/debugging/Debugging"], Wm = (o, s, i) => ((l, f, m) => {
    switch (cn(lh.get(), l).orThunk(() => {
      const b = po(lh.get());
      return Ko(b, (x) => l.indexOf(x) > -1 ? M.some(lh.get()[x]) : M.none());
    }).getOr(Rf.NORMAL)) {
      case Rf.NORMAL:
        return m(ch());
      case Rf.LOGGING: {
        const b = ((w, E) => {
          const O = [], A = (/* @__PURE__ */ new Date()).getTime();
          return { logEventCut: (B, $, Z) => {
            O.push({ outcome: "cut", target: $, purpose: Z });
          }, logEventStopped: (B, $, Z) => {
            O.push({ outcome: "stopped", target: $, purpose: Z });
          }, logNoParent: (B, $, Z) => {
            O.push({ outcome: "no-parent", target: $, purpose: Z });
          }, logEventNoHandlers: (B, $) => {
            O.push({ outcome: "no-handlers-left", target: $ });
          }, logEventResponse: (B, $, Z) => {
            O.push({ outcome: "response", purpose: Z, target: $ });
          }, write: () => {
            const B = (/* @__PURE__ */ new Date()).getTime();
            Bn(["mousemove", "mouseover", "mouseout", ru()], w) || console.log(w, { event: w, time: B - A, target: E.dom, sequence: Ct(O, ($) => Bn(["cut", "stopped", "response"], $.outcome) ? "{" + $.purpose + "} " + $.outcome + " at (" + Eu($.target) + ")" : $.outcome) });
          } };
        })(l, f), x = m(b);
        return b.write(), x;
      }
      case Rf.STOP:
        return !0;
    }
  })(o, s, i), ch = Ee({ logEventCut: gt, logEventStopped: gt, logNoParent: gt, logEventNoHandlers: gt, logEventResponse: gt, write: gt }), Dp = Ee([st("menu"), st("selectedMenu")]), qm = Ee([st("item"), st("selectedItem")]);
  Ee(Nn(qm().concat(Dp())));
  const gg = Ee(Nn(qm())), ef = el("initSize", [st("numColumns"), st("numRows")]), hg = () => el("markers", [st("backgroundMenu")].concat(Dp()).concat(qm())), Au = (o) => el("markers", Ct(o, st)), Rp = (o, s, i) => ((() => {
    const l = new Error();
    if (l.stack !== void 0) {
      const f = l.stack.split(`
`);
      Go(f, (m) => m.indexOf("alloy") > 0 && !jr(ab, (b) => m.indexOf(b) > -1)).getOr("unknown");
    }
  })(), Qs(s, s, i, Tl((l) => To.value((...f) => l.apply(void 0, f))))), Vo = (o) => Rp(0, o, tu(gt)), fc = (o) => Rp(0, o, tu(M.none)), bd = (o) => Rp(0, o, { tag: "required", process: {} }), bg = (o) => Rp(0, o, { tag: "required", process: {} }), ms = (o, s) => ua(o, Ee(s)), My = (o) => ua(o, wt), By = Ee(ef), ol = (o, s, i, l, f, m, b, x = !1) => ({ x: o, y: s, bubble: i, direction: l, placement: f, restriction: m, label: `${b}-${f}`, alwaysFit: x }), mc = Fa([{ southeast: [] }, { southwest: [] }, { northeast: [] }, { northwest: [] }, { south: [] }, { north: [] }, { east: [] }, { west: [] }]), uh = mc.southeast, dh = mc.southwest, Ly = mc.northeast, ib = mc.northwest, K1 = mc.south, lb = mc.north, Nf = mc.east, Np = mc.west, tf = (o, s, i, l) => {
    const f = o + s;
    return f > l ? i : f < i ? l : f;
  }, Dc = (o, s, i) => Math.min(Math.max(o, s), i), ki = (o, s) => oo(["left", "right", "top", "bottom"], (i) => cn(s, i).map((l) => ((f, m) => {
    switch (m) {
      case 1:
        return f.x;
      case 0:
        return f.x + f.width;
      case 2:
        return f.y;
      case 3:
        return f.y + f.height;
    }
  })(o, l))), Du = "layout", Ao = (o) => o.x, fh = (o, s) => o.x + o.width / 2 - s.width / 2, cb = (o, s) => o.x + o.width - s.width, Mf = (o, s) => o.y - s.height, mh = (o) => o.y + o.height, yg = (o, s) => o.y + o.height / 2 - s.height / 2, Bi = (o, s, i) => ol(Ao(o), mh(o), i.southeast(), uh(), "southeast", ki(o, { left: 1, top: 3 }), Du), Tr = (o, s, i) => ol(cb(o, s), mh(o), i.southwest(), dh(), "southwest", ki(o, { right: 0, top: 3 }), Du), rl = (o, s, i) => ol(Ao(o), Mf(o, s), i.northeast(), Ly(), "northeast", ki(o, { left: 1, bottom: 2 }), Du), ps = (o, s, i) => ol(cb(o, s), Mf(o, s), i.northwest(), ib(), "northwest", ki(o, { right: 0, bottom: 2 }), Du), Zl = (o, s, i) => ol(fh(o, s), Mf(o, s), i.north(), lb(), "north", ki(o, { bottom: 2 }), Du), ma = (o, s, i) => ol(fh(o, s), mh(o), i.south(), K1(), "south", ki(o, { top: 3 }), Du), Li = (o, s, i) => ol(((l) => l.x + l.width)(o), yg(o, s), i.east(), Nf(), "east", ki(o, { left: 0 }), Du), ph = (o, s, i) => ol(((l, f) => l.x - f.width)(o, s), yg(o, s), i.west(), Np(), "west", ki(o, { right: 1 }), Du), Py = () => [Bi, Tr, rl, ps, ma, Zl, Li, ph], vg = () => [Tr, Bi, ps, rl, ma, Zl, Li, ph], nf = () => [rl, ps, Bi, Tr, Zl, ma], Pi = () => [ps, rl, Tr, Bi, Zl, ma], xg = () => [Bi, Tr, rl, ps, ma, Zl], gh = () => [Tr, Bi, ps, rl, ma, Zl];
  var Iy = Object.freeze({ __proto__: null, events: (o) => Bo([ft(ta(), (s, i) => {
    const l = o.channels, f = po(l), m = i, b = ((x, w) => w.universal ? x : Pn(x, (E) => Bn(w.channels, E)))(f, m);
    tn(b, (x) => {
      const w = l[x], E = w.schema, O = Ta("channel[" + x + `] data
Receiver: ` + Eu(s.element), E, m.data);
      w.onReceive(s, O);
    });
  })]) }), vv = [zl("channels", pl(To.value, hi([bd("onReceive"), He("schema", Pr())])))];
  const wg = (o, s, i) => eb((l, f) => {
    i(l, o, s);
  }), Bf = (o) => ({ key: o, value: void 0 }), au = (o, s, i, l, f, m, b) => {
    const x = (O) => Ys(O, i) ? O[i]() : M.none(), w = ho(f, (O, A) => ((B, $, Z) => ((oe, re, fe) => {
      const ee = fe.toString(), J = ee.indexOf(")") + 1, le = ee.indexOf("("), me = ee.substring(le + 1, J - 1).split(/,\s*/);
      return oe.toFunctionAnnotation = () => ({ name: re, parameters: Pt(me.slice(0, 1).concat(me.slice(3))) }), oe;
    })((oe, ...re) => {
      const fe = [oe].concat(re);
      return oe.config({ name: Ee(B) }).fold(() => {
        throw new Error("We could not find any behaviour configuration for: " + B + ". Using API: " + Z);
      }, (ee) => {
        const J = Array.prototype.slice.call(fe, 1);
        return $.apply(void 0, [oe, ee.config, ee.state].concat(J));
      });
    }, Z, $))(i, O, A)), E = { ...ho(m, (O, A) => on(O, A)), ...w, revoke: We(Bf, i), config: (O) => {
      const A = Ta(i + "-config", o, O);
      return { key: i, value: { config: A, me: E, configAsRaw: ml(() => Ta(i + "-config", o, O)), initialConfig: O, state: b } };
    }, schema: Ee(s), exhibit: (O, A) => fi(x(O), cn(l, "exhibit"), (B, $) => $(A, B.config, B.state)).getOrThunk(() => Xa({})), name: Ee(i), handlers: (O) => x(O).map((A) => cn(l, "events").getOr(() => ({}))(A.config, A.state)).getOr({}) };
    return E;
  }, $t = (o) => dr(o), Fy = hi([st("fields"), st("name"), He("active", {}), He("apis", {}), He("state", fr), He("extra", {})]), _i = (o) => {
    const s = Ta("Creating behaviour: " + o.name, Fy, o);
    return ((i, l, f, m, b, x) => {
      const w = hi(i), E = Ol(l, [(O = i, Hl("config", hi(O)))]);
      var O;
      return au(w, E, l, f, m, b, x);
    })(s.fields, s.name, s.active, s.apis, s.extra, s.state);
  }, hh = hi([st("branchKey"), st("branches"), st("name"), He("active", {}), He("apis", {}), He("state", fr), He("extra", {})]), Gm = (o) => {
    const s = Ta("Creating behaviour: " + o.name, hh, o);
    return ((i, l, f, m, b, x) => {
      const w = i, E = Ol(l, [Hl("config", i)]);
      return au(w, E, l, f, m, b, x);
    })(bi(s.branchKey, s.branches), s.name, s.active, s.apis, s.extra, s.state);
  }, of = Ee(void 0), pc = _i({ fields: vv, name: "receiving", active: Iy });
  var xv = Object.freeze({ __proto__: null, exhibit: (o, s) => Xa({ classes: [], styles: s.useFixed() ? {} : { position: "relative" } }) });
  const gc = (o, s = !1) => o.dom.focus({ preventScroll: s }), ub = (o) => o.dom.blur(), mm = (o) => {
    const s = us(o).dom;
    return o.dom === s.activeElement;
  }, Zc = (o = Js()) => M.from(o.dom.activeElement).map(Xt), iu = (o) => Zc(us(o)).filter((s) => o.dom.contains(s.dom)), Mp = (o, s) => {
    const i = us(s), l = Zc(i).bind((m) => {
      const b = (x) => tr(m, x);
      return b(s) ? M.some(s) : ((x, w) => {
        const E = (O) => {
          for (let A = 0; A < O.childNodes.length; A++) {
            const B = Xt(O.childNodes[A]);
            if (w(B))
              return M.some(B);
            const $ = E(O.childNodes[A]);
            if ($.isSome())
              return $;
          }
          return M.none();
        };
        return E(x.dom);
      })(s, b);
    }), f = o(s);
    return l.each((m) => {
      Zc(i).filter((b) => tr(b, m)).fold(() => {
        gc(m);
      }, gt);
    }), f;
  }, Wl = (o, s, i, l, f) => {
    const m = (b) => b + "px";
    return { position: o, left: s.map(m), top: i.map(m), right: l.map(m), bottom: f.map(m) };
  }, db = (o, s) => {
    Yi(o, ((i) => ({ ...i, position: M.some(i.position) }))(s));
  }, ql = Fa([{ none: [] }, { relative: ["x", "y", "width", "height"] }, { fixed: ["x", "y", "width", "height"] }]), rf = (o, s, i, l, f, m) => {
    const b = s.rect, x = b.x - i, w = b.y - l, E = f - (x + b.width), O = m - (w + b.height), A = M.some(x), B = M.some(w), $ = M.some(E), Z = M.some(O), oe = M.none();
    return s.direction.fold(() => Wl(o, A, B, oe, oe), () => Wl(o, oe, B, $, oe), () => Wl(o, A, oe, oe, Z), () => Wl(o, oe, oe, $, Z), () => Wl(o, A, B, oe, oe), () => Wl(o, A, oe, oe, Z), () => Wl(o, A, B, oe, oe), () => Wl(o, oe, B, $, oe));
  }, $y = (o, s) => o.fold(() => {
    const i = s.rect;
    return Wl("absolute", M.some(i.x), M.some(i.y), M.none(), M.none());
  }, (i, l, f, m) => rf("absolute", s, i, l, f, m), (i, l, f, m) => rf("fixed", s, i, l, f, m)), bh = (o, s) => {
    const i = We(Hd, s), l = o.fold(i, i, () => {
      const b = Ls();
      return Hd(s).translate(-b.left, -b.top);
    }), f = Ba(s), m = Ft(s);
    return Ws(l.left, l.top, f, m);
  }, wv = (o, s) => s.fold(() => o.fold(os, os, Ws), (i) => o.fold(Ee(i), Ee(i), () => {
    const l = Hy(o, i.x, i.y);
    return Ws(l.left, l.top, i.width, i.height);
  })), Hy = (o, s, i) => {
    const l = so(s, i);
    return o.fold(Ee(l), Ee(l), () => {
      const f = Ls();
      return l.translate(-f.left, -f.top);
    });
  };
  ql.none;
  const Vy = ql.relative, Uy = ql.fixed, yh = "data-alloy-placement", Y1 = (o) => Sa(o, yh), Km = Fa([{ fit: ["reposition"] }, { nofit: ["reposition", "visibleW", "visibleH", "isVisible"] }]), bl = (o, s, i, l) => {
    const f = o.bubble, m = f.offset, b = ((le, me, ke) => {
      const Re = (Qt, vn) => me[Qt].map((Mn) => {
        const Qn = Qt === "top" || Qt === "bottom", fo = Qn ? ke.top : ke.left, $o = (Qt === "left" || Qt === "top" ? Math.max : Math.min)(Mn, vn) + fo;
        return Qn ? Dc($o, le.y, le.bottom) : Dc($o, le.x, le.right);
      }).getOr(vn), qe = Re("left", le.x), mt = Re("top", le.y), bt = Re("right", le.right), St = Re("bottom", le.bottom);
      return Ws(qe, mt, bt - qe, St - mt);
    })(l, o.restriction, m), x = o.x + m.left, w = o.y + m.top, E = Ws(x, w, s, i), { originInBounds: O, sizeInBounds: A, visibleW: B, visibleH: $ } = ((le, me) => {
      const { x: ke, y: Re, right: qe, bottom: mt } = me, { x: bt, y: St, right: Qt, bottom: vn, width: Mn, height: Qn } = le;
      return { originInBounds: bt >= ke && bt <= qe && St >= Re && St <= mt, sizeInBounds: Qt <= qe && Qt >= ke && vn <= mt && vn >= Re, visibleW: Math.min(Mn, bt >= ke ? qe - bt : Qt - ke), visibleH: Math.min(Qn, St >= Re ? mt - St : vn - Re) };
    })(E, b), Z = O && A, oe = Z ? E : ((le, me) => {
      const { x: ke, y: Re, right: qe, bottom: mt } = me, { x: bt, y: St, width: Qt, height: vn } = le, Mn = Math.max(ke, qe - Qt), Qn = Math.max(Re, mt - vn), fo = Dc(bt, ke, Mn), $o = Dc(St, Re, Qn), Hs = Math.min(fo + Qt, qe) - fo, ga = Math.min($o + vn, mt) - $o;
      return Ws(fo, $o, Hs, ga);
    })(E, b), re = oe.width > 0 && oe.height > 0, { maxWidth: fe, maxHeight: ee } = ((le, me, ke) => {
      const Re = Ee(me.bottom - ke.y), qe = Ee(ke.bottom - me.y), mt = ((vn, Mn, Qn, fo) => vn.fold(Mn, Mn, fo, fo, Mn, fo, Qn, Qn))(le, qe, qe, Re), bt = Ee(me.right - ke.x), St = Ee(ke.right - me.x);
      return { maxWidth: ((vn, Mn, Qn, fo) => vn.fold(Mn, fo, Mn, fo, Qn, Qn, Mn, fo))(le, St, St, bt), maxHeight: mt };
    })(o.direction, oe, l), J = { rect: oe, maxHeight: ee, maxWidth: fe, direction: o.direction, placement: o.placement, classes: { on: f.classesOn, off: f.classesOff }, layout: o.label, testY: w };
    return Z || o.alwaysFit ? Km.fit(J) : Km.nofit(J, B, $, re);
  }, Ym = (o) => {
    const s = Ln(M.none()), i = () => s.get().each(o);
    return { clear: () => {
      i(), s.set(M.none());
    }, isSet: () => s.get().isSome(), get: () => s.get(), set: (l) => {
      i(), s.set(M.some(l));
    } };
  }, Lf = () => Ym((o) => o.unbind()), As = () => {
    const o = Ym(gt);
    return { ...o, on: (s) => o.get().each(s) };
  }, pm = un, sl = (o, s, i) => ((l, f, m, b) => Fd(l, f, m, b, !1))(o, s, pm, i), kg = (o, s, i) => ((l, f, m, b) => Fd(l, f, m, b, !0))(o, s, pm, i), fb = Eo, _g = ["top", "bottom", "right", "left"], gm = "data-alloy-transition-timer", mb = (o, s, i, l, f, m) => {
    const b = ((x, w, E) => E.exists((O) => {
      const A = x.mode;
      return A === "all" || O[A] !== w[A];
    }))(l, f, m);
    if (b || ((x, w) => ((E, O) => nc(O, (A) => _s(E, A)))(x, w.classes))(o, l)) {
      qn(o, "position", i.position);
      const x = bh(s, o), w = $y(s, { ...f, rect: x }), E = oo(_g, (O) => w[O]);
      ((O, A) => {
        const B = ($) => parseFloat($).toFixed(3);
        return ha(A, ($, Z) => !((oe, re, fe = Se) => fi(oe, re, fe).getOr(oe.isNone() && re.isNone()))(O[Z].map(B), $.map(B))).isSome();
      })(i, E) && (Yi(o, E), b && ((O, A) => {
        nl(O, A.classes), Sa(O, gm).each((B) => {
          clearTimeout(parseInt(B, 10)), ts(O, gm);
        }), ((B, $) => {
          const Z = Lf(), oe = Lf();
          let re;
          const fe = (me) => {
            var ke;
            const Re = (ke = me.raw.pseudoElement) !== null && ke !== void 0 ? ke : "";
            return tr(me.target, B) && Hr(Re) && Bn(_g, me.raw.propertyName);
          }, ee = (me) => {
            if (jt(me) || fe(me)) {
              Z.clear(), oe.clear();
              const ke = me == null ? void 0 : me.raw.type;
              (jt(ke) || ke === Ri()) && (clearTimeout(re), ts(B, gm), jc(B, $.classes));
            }
          }, J = sl(B, _u(), (me) => {
            fe(me) && (J.unbind(), Z.set(sl(B, Ri(), ee)), oe.set(sl(B, ws(), ee)));
          }), le = ((me) => {
            const ke = (bt) => {
              const St = Ts(me, bt).split(/\s*,\s*/);
              return Pn(St, oc);
            }, Re = (bt) => {
              if (ce(bt) && /^[\d.]+/.test(bt)) {
                const St = parseFloat(bt);
                return _l(bt, "ms") ? St : 1e3 * St;
              }
              return 0;
            }, qe = ke("transition-delay"), mt = ke("transition-duration");
            return K(mt, (bt, St, Qt) => {
              const vn = Re(qe[Qt]) + Re(St);
              return Math.max(bt, vn);
            }, 0);
          })(B);
          requestAnimationFrame(() => {
            re = setTimeout(ee, le + 17), eo(B, gm, re);
          });
        })(O, A);
      })(o, l), te(o));
    } else
      jc(o, l.classes);
  }, hm = (o, s) => {
    ((i, l) => {
      const f = Pe.max(i, l, ["margin-top", "border-top-width", "padding-top", "padding-bottom", "border-bottom-width", "margin-bottom"]);
      qn(i, "max-height", f + "px");
    })(o, Math.floor(s));
  }, Bp = Ee((o, s) => {
    hm(o, s), ac(o, { "overflow-x": "hidden", "overflow-y": "auto" });
  }), Lp = Ee((o, s) => {
    hm(o, s);
  }), pb = (o, s, i) => o[s] === void 0 ? i : o[s], gb = (o, s, i, l) => {
    const f = ((m, b, x, w) => {
      ar(b, "max-height"), ar(b, "max-width");
      const E = { width: Ba(O = b), height: Ft(O) };
      var O;
      return ((A, B, $, Z, oe, re) => {
        const fe = Z.width, ee = Z.height, J = (le, me, ke, Re, qe) => {
          const mt = le($, Z, oe, A, re), bt = bl(mt, fe, ee, re);
          return bt.fold(Ee(bt), (St, Qt, vn, Mn) => (qe === Mn ? vn > Re || Qt > ke : !qe && Mn) ? bt : Km.nofit(me, ke, Re, qe));
        };
        return K(B, (le, me) => {
          const ke = We(J, me);
          return le.fold(Ee(le), ke);
        }, Km.nofit({ rect: $, maxHeight: Z.height, maxWidth: Z.width, direction: uh(), placement: "southeast", classes: { on: [], off: [] }, layout: "none", testY: $.y }, -1, -1, !1)).fold(wt, wt);
      })(b, w.preference, m, E, x, w.bounds);
    })(o, s, i, l);
    return ((m, b, x) => {
      const w = $y(x.origin, b);
      x.transition.each((E) => {
        mb(m, x.origin, w, E, b, x.lastPlacement);
      }), db(m, w);
    })(s, f, l), ((m, b) => {
      ((x, w) => {
        eo(x, yh, w);
      })(m, b.placement);
    })(s, f), ((m, b) => {
      const x = b.classes;
      jc(m, x.off), nl(m, x.on);
    })(s, f), ((m, b, x) => {
      (0, x.maxHeightFunction)(m, b.maxHeight);
    })(s, f, l), ((m, b, x) => {
      (0, x.maxWidthFunction)(m, b.maxWidth);
    })(s, f, l), { layout: f.layout, placement: f.placement };
  }, gs = ["valignCentre", "alignLeft", "alignRight", "alignCentre", "top", "bottom", "left", "right", "inset"], Ii = (o, s, i, l = 1) => {
    const f = o * l, m = s * l, b = (w) => cn(i, w).getOr([]), x = (w, E, O) => {
      const A = cr(gs, O);
      return { offset: so(w, E), classesOn: Qr(O, b), classesOff: Qr(A, b) };
    };
    return { southeast: () => x(-o, s, ["top", "alignLeft"]), southwest: () => x(o, s, ["top", "alignRight"]), south: () => x(-o / 2, s, ["top", "alignCentre"]), northeast: () => x(-o, -s, ["bottom", "alignLeft"]), northwest: () => x(o, -s, ["bottom", "alignRight"]), north: () => x(-o / 2, -s, ["bottom", "alignCentre"]), east: () => x(o, -s / 2, ["valignCentre", "left"]), west: () => x(-o, -s / 2, ["valignCentre", "right"]), insetNortheast: () => x(f, m, ["top", "alignLeft", "inset"]), insetNorthwest: () => x(-f, m, ["top", "alignRight", "inset"]), insetNorth: () => x(-f / 2, m, ["top", "alignCentre", "inset"]), insetSoutheast: () => x(f, -m, ["bottom", "alignLeft", "inset"]), insetSouthwest: () => x(-f, -m, ["bottom", "alignRight", "inset"]), insetSouth: () => x(-f / 2, -m, ["bottom", "alignCentre", "inset"]), insetEast: () => x(-f, -m / 2, ["valignCentre", "right", "inset"]), insetWest: () => x(f, -m / 2, ["valignCentre", "left", "inset"]) };
  }, vh = () => Ii(0, 0, {}), bm = wt, Pf = (o, s) => (i) => jy(i) === "rtl" ? s : o, jy = (o) => Ts(o, "direction") === "rtl" ? "rtl" : "ltr";
  var Gl;
  (function(o) {
    o.TopToBottom = "toptobottom", o.BottomToTop = "bottomtotop";
  })(Gl || (Gl = {}));
  const Ja = "data-alloy-vertical-dir", X1 = (o) => ih(o, (s) => ra(s) && js(s, "data-alloy-vertical-dir") === Gl.BottomToTop), ym = () => Ol("layouts", [st("onLtr"), st("onRtl"), pr("onBottomLtr"), pr("onBottomRtl")]), Pp = (o, s, i, l, f, m, b) => {
    const x = b.map(X1).getOr(!1), w = s.layouts.map((B) => B.onLtr(o)), E = s.layouts.map((B) => B.onRtl(o)), O = x ? s.layouts.bind((B) => B.onBottomLtr.map(($) => $(o))).or(w).getOr(f) : w.getOr(i), A = x ? s.layouts.bind((B) => B.onBottomRtl.map(($) => $(o))).or(E).getOr(m) : E.getOr(l);
    return Pf(O, A)(o);
  };
  var Xm = [st("hotspot"), pr("bubble"), He("overrides", {}), ym(), ms("placement", (o, s, i) => {
    const l = s.hotspot, f = bh(i, l.element), m = Pp(o.element, s, xg(), gh(), nf(), Pi(), M.some(s.hotspot.element));
    return M.some(bm({ anchorBox: f, bubble: s.bubble.getOr(vh()), overrides: s.overrides, layouts: m }));
  })], hb = [st("x"), st("y"), He("height", 0), He("width", 0), He("bubble", vh()), He("overrides", {}), ym(), ms("placement", (o, s, i) => {
    const l = Hy(i, s.x, s.y), f = Ws(l.left, l.top, s.width, s.height), m = Pp(o.element, s, Py(), vg(), Py(), vg(), M.none());
    return M.some(bm({ anchorBox: f, bubble: s.bubble, overrides: s.overrides, layouts: m }));
  })];
  const bb = Fa([{ screen: ["point"] }, { absolute: ["point", "scrollLeft", "scrollTop"] }]), Zy = (o) => o.fold(wt, (s, i, l) => s.translate(-i, -l)), Cw = (o) => o.fold(wt, wt), Cg = (o) => K(o, (s, i) => s.translate(i.left, i.top), so(0, 0)), Wy = (o) => {
    const s = Ct(o, Cw);
    return Cg(s);
  }, J1 = bb.screen, Sw = bb.absolute, yb = (o, s, i) => {
    const l = ni(o.element), f = Ls(l), m = ((b, x, w) => {
      const E = Bd(w.root).dom;
      return M.from(E.frameElement).map(Xt).filter((O) => {
        const A = ni(O), B = ni(b.element);
        return tr(A, B);
      }).map($n);
    })(o, 0, i).getOr(f);
    return Sw(m, f.left, f.top);
  }, Rc = (o, s, i, l) => {
    const f = J1(so(o, s));
    return M.some(((m, b, x) => ({ point: m, width: b, height: x }))(f, i, l));
  }, Bl = (o, s, i, l, f) => o.map((m) => {
    const b = [s, m.point], x = (w = () => Wy(b), E = () => Wy(b), O = () => ((J) => {
      const le = Ct(J, Zy);
      return Cg(le);
    })(b), l.fold(w, E, O));
    var w, E, O;
    const A = (oe = x.left, re = x.top, fe = m.width, ee = m.height, { x: oe, y: re, width: fe, height: ee }), B = i.showAbove ? nf() : xg(), $ = i.showAbove ? Pi() : gh(), Z = Pp(f, i, B, $, B, $, M.none());
    var oe, re, fe, ee;
    return bm({ anchorBox: A, bubble: i.bubble.getOr(vh()), overrides: i.overrides, layouts: Z });
  });
  var vb = [st("node"), st("root"), pr("bubble"), ym(), He("overrides", {}), He("showAbove", !1), ms("placement", (o, s, i) => {
    const l = yb(o, 0, s);
    return s.node.filter(Rr).bind((f) => {
      const m = f.dom.getBoundingClientRect(), b = Rc(m.left, m.top, m.width, m.height), x = s.node.getOr(o.element);
      return Bl(b, l, s, i, x);
    });
  })];
  const xb = (o, s, i, l) => ({ start: o, soffset: s, finish: i, foffset: l }), sf = Fa([{ before: ["element"] }, { on: ["element", "offset"] }, { after: ["element"] }]), xh = (sf.before, sf.on, sf.after, (o) => o.fold(wt, wt, wt)), Ru = Fa([{ domRange: ["rng"] }, { relative: ["startSitu", "finishSitu"] }, { exact: ["start", "soffset", "finish", "foffset"] }]), If = { domRange: Ru.domRange, relative: Ru.relative, exact: Ru.exact, exactFromRange: (o) => Ru.exact(o.start, o.soffset, o.finish, o.foffset), getWin: (o) => {
    const s = ((i) => i.match({ domRange: (l) => Xt(l.startContainer), relative: (l, f) => xh(l), exact: (l, f, m, b) => l }))(o);
    return Bd(s);
  }, range: xb }, Jm = (o, s, i) => {
    const l = o.document.createRange();
    var f;
    return f = l, s.fold((m) => {
      f.setStartBefore(m.dom);
    }, (m, b) => {
      f.setStart(m.dom, b);
    }, (m) => {
      f.setStartAfter(m.dom);
    }), ((m, b) => {
      b.fold((x) => {
        m.setEndBefore(x.dom);
      }, (x, w) => {
        m.setEnd(x.dom, w);
      }, (x) => {
        m.setEndAfter(x.dom);
      });
    })(l, i), l;
  }, vm = (o, s, i, l, f) => {
    const m = o.document.createRange();
    return m.setStart(s.dom, i), m.setEnd(l.dom, f), m;
  }, xm = (o) => ({ left: o.left, top: o.top, right: o.right, bottom: o.bottom, width: o.width, height: o.height }), yd = Fa([{ ltr: ["start", "soffset", "finish", "foffset"] }, { rtl: ["start", "soffset", "finish", "foffset"] }]), Sg = (o, s, i) => s(Xt(i.startContainer), i.startOffset, Xt(i.endContainer), i.endOffset), wh = (o, s) => ((i, l) => {
    const f = ((m, b) => b.match({ domRange: (x) => ({ ltr: Ee(x), rtl: M.none }), relative: (x, w) => ({ ltr: ml(() => Jm(m, x, w)), rtl: ml(() => M.some(Jm(m, w, x))) }), exact: (x, w, E, O) => ({ ltr: ml(() => vm(m, x, w, E, O)), rtl: ml(() => M.some(vm(m, E, O, x, w))) }) }))(i, l);
    return ((m, b) => {
      const x = b.ltr();
      return x.collapsed ? b.rtl().filter((w) => w.collapsed === !1).map((w) => yd.rtl(Xt(w.endContainer), w.endOffset, Xt(w.startContainer), w.startOffset)).getOrThunk(() => Sg(0, yd.ltr, x)) : Sg(0, yd.ltr, x);
    })(0, f);
  })(o, s).match({ ltr: (i, l, f, m) => {
    const b = o.document.createRange();
    return b.setStart(i.dom, l), b.setEnd(f.dom, m), b;
  }, rtl: (i, l, f, m) => {
    const b = o.document.createRange();
    return b.setStart(f.dom, m), b.setEnd(i.dom, l), b;
  } });
  yd.ltr, yd.rtl;
  const wb = (o, s, i) => Pn(((l, f) => {
    const m = Rt(f) ? f : Xe;
    let b = l.dom;
    const x = [];
    for (; b.parentNode !== null && b.parentNode !== void 0; ) {
      const w = b.parentNode, E = Xt(w);
      if (x.push(E), m(E) === !0)
        break;
      b = w;
    }
    return x;
  })(o, i), s), Kl = (o, s) => ((i, l) => {
    const f = l === void 0 ? document : l.dom;
    return Nd(f) ? [] : Ct(f.querySelectorAll(i), Xt);
  })(s, o), qy = (o) => {
    if (o.rangeCount > 0) {
      const s = o.getRangeAt(0), i = o.getRangeAt(o.rangeCount - 1);
      return M.some(xb(Xt(s.startContainer), s.startOffset, Xt(i.endContainer), i.endOffset));
    }
    return M.none();
  }, Gy = (o) => {
    if (o.anchorNode === null || o.focusNode === null)
      return qy(o);
    {
      const s = Xt(o.anchorNode), i = Xt(o.focusNode);
      return ((l, f, m, b) => {
        const x = ((E, O, A, B) => {
          const $ = ni(E).dom.createRange();
          return $.setStart(E.dom, O), $.setEnd(A.dom, B), $;
        })(l, f, m, b), w = tr(l, m) && f === b;
        return x.collapsed && !w;
      })(s, o.anchorOffset, i, o.focusOffset) ? M.some(xb(s, o.anchorOffset, i, o.focusOffset)) : qy(o);
    }
  }, kb = (o, s) => ((i) => {
    const l = i.getClientRects(), f = l.length > 0 ? l[0] : i.getBoundingClientRect();
    return f.width > 0 || f.height > 0 ? M.some(f).map(xm) : M.none();
  })(wh(o, s)), kv = ((o, s) => {
    const i = (l) => o(l) ? M.from(l.dom.nodeValue) : M.none();
    return { get: (l) => {
      if (!o(l))
        throw new Error("Can only get text value of a text node");
      return i(l).getOr("");
    }, getOption: i, set: (l, f) => {
      if (!o(l))
        throw new Error("Can only set raw text value of a text node");
      l.dom.nodeValue = f;
    } };
  })(Gi), kh = (o, s) => ({ element: o, offset: s }), Ky = (o, s) => Gi(o) ? kh(o, s) : ((i, l) => {
    const f = _r(i);
    if (f.length === 0)
      return kh(i, l);
    if (l < f.length)
      return kh(f[l], 0);
    {
      const m = f[f.length - 1], b = Gi(m) ? ((x) => kv.get(x))(m).length : _r(m).length;
      return kh(m, b);
    }
  })(o, s), wm = (o) => o.foffset !== void 0, km = (o, s) => s.getSelection.getOrThunk(() => () => ((i) => ((l) => M.from(l.getSelection()))(i).filter((l) => l.rangeCount > 0).bind(Gy))(o))().map((i) => {
    if (wm(i)) {
      const l = Ky(i.start, i.soffset), f = Ky(i.finish, i.foffset);
      return If.range(l.element, l.offset, f.element, f.offset);
    }
    return i;
  });
  var Q1 = [pr("getSelection"), st("root"), pr("bubble"), ym(), He("overrides", {}), He("showAbove", !1), ms("placement", (o, s, i) => {
    const l = Bd(s.root).dom, f = yb(o, 0, s), m = km(l, s).bind((x) => {
      if (wm(x))
        return ((E, O) => ((A) => {
          const B = A.getBoundingClientRect();
          return B.width > 0 || B.height > 0 ? M.some(B).map(xm) : M.none();
        })(wh(E, O)))(l, If.exactFromRange(x)).orThunk(() => {
          const E = Xc("\uFEFF");
          td(x.start, E);
          const O = kb(l, If.exact(E, 0, E, 1));
          return ya(E), O;
        }).bind((E) => Rc(E.left, E.top, E.width, E.height));
      {
        const w = ho(x, (O) => O.dom.getBoundingClientRect()), E = { left: Math.min(w.firstCell.left, w.lastCell.left), right: Math.max(w.firstCell.right, w.lastCell.right), top: Math.min(w.firstCell.top, w.lastCell.top), bottom: Math.max(w.firstCell.bottom, w.lastCell.bottom) };
        return Rc(E.left, E.top, E.right - E.left, E.bottom - E.top);
      }
    }), b = km(l, s).bind((x) => wm(x) ? ra(x.start) ? M.some(x.start) : sa(x.start) : M.some(x.firstCell)).getOr(o.element);
    return Bl(m, f, s, i, b);
  })];
  const _b = "link-layout", Cb = (o) => o.x + o.width, _m = (o, s) => o.x - s.width, Qm = (o, s) => o.y - s.height + o.height, Sb = (o) => o.y, _h = (o, s, i) => ol(Cb(o), Sb(o), i.southeast(), uh(), "southeast", ki(o, { left: 0, top: 2 }), _b), ep = (o, s, i) => ol(_m(o, s), Sb(o), i.southwest(), dh(), "southwest", ki(o, { right: 1, top: 2 }), _b), tp = (o, s, i) => ol(Cb(o), Qm(o, s), i.northeast(), Ly(), "northeast", ki(o, { left: 0, bottom: 3 }), _b), Ip = (o, s, i) => ol(_m(o, s), Qm(o, s), i.northwest(), ib(), "northwest", ki(o, { right: 1, bottom: 3 }), _b), af = () => [_h, ep, tp, Ip], np = () => [ep, _h, Ip, tp];
  var _v = [st("item"), ym(), He("overrides", {}), ms("placement", (o, s, i) => {
    const l = bh(i, s.item.element), f = Pp(o.element, s, af(), np(), af(), np(), M.none());
    return M.some(bm({ anchorBox: l, bubble: vh(), overrides: s.overrides, layouts: f }));
  })], Ch = bi("type", { selection: Q1, node: vb, hotspot: Xm, submenu: _v, makeshift: hb });
  const op = [Ka("classes", xa), Fs("mode", "all", ["all", "layout", "placement"])], Fp = [He("useFixed", Xe), pr("getBounds")], Eb = [zl("anchor", Ch), Ol("transition", op)], Yy = (o, s, i, l, f, m) => {
    const b = Ta("placement.info", Nn(Eb), f), x = b.anchor, w = l.element, E = i.get(l.uid);
    Mp(() => {
      qn(w, "position", "fixed");
      const O = Xs(w, "visibility");
      qn(w, "visibility", "hidden");
      const A = s.useFixed() ? (() => {
        const B = document.documentElement;
        return Uy(0, 0, B.clientWidth, B.clientHeight);
      })() : ((B) => {
        const $ = $n(B.element), Z = B.element.dom.getBoundingClientRect();
        return Vy($.left, $.top, Z.width, Z.height);
      })(o);
      x.placement(o, x, A).each((B) => {
        const $ = m.orThunk(() => s.getBounds.map(jn)), Z = ((oe, re, fe, ee, J, le) => ((me, ke, Re, qe, mt, bt, St, Qt) => {
          const vn = pb(St, "maxHeightFunction", Bp()), Mn = pb(St, "maxWidthFunction", gt), Qn = me.anchorBox, fo = me.origin, $o = { bounds: wv(fo, bt), origin: fo, preference: qe, maxHeightFunction: vn, maxWidthFunction: Mn, lastPlacement: mt, transition: Qt };
          return gb(Qn, ke, Re, $o);
        })(((me, ke) => ((Re, qe) => ({ anchorBox: Re, origin: qe }))(me, ke))(re.anchorBox, oe), ee.element, re.bubble, re.layouts, J, fe, re.overrides, le))(A, B, $, l, E, b.transition);
        i.set(l.uid, Z);
      }), O.fold(() => {
        ar(w, "visibility");
      }, (B) => {
        qn(w, "visibility", B);
      }), Xs(w, "left").isNone() && Xs(w, "top").isNone() && Xs(w, "right").isNone() && Xs(w, "bottom").isNone() && Si(Xs(w, "position"), "fixed") && ar(w, "position");
    }, w);
  };
  var Xy = Object.freeze({ __proto__: null, position: (o, s, i, l, f) => {
    const m = M.none();
    Yy(o, s, i, l, f, m);
  }, positionWithinBounds: Yy, getMode: (o, s, i) => s.useFixed() ? "fixed" : "absolute", reset: (o, s, i, l) => {
    const f = l.element;
    tn(["position", "left", "right", "top", "bottom"], (m) => ar(f, m)), ((m) => {
      ts(m, yh);
    })(f), i.clear(l.uid);
  } });
  const Ll = _i({ fields: Fp, name: "positioning", active: xv, apis: Xy, state: Object.freeze({ __proto__: null, init: () => {
    let o = {};
    return as({ readState: () => o, clear: (s) => {
      it(s) ? delete o[s] : o = {};
    }, set: (s, i) => {
      o[s] = i;
    }, get: (s) => cn(o, s) });
  } }) }), Tb = (o) => o.getSystem().isConnected(), lf = (o) => {
    Io(o, Fm());
    const s = o.components();
    tn(s, lf);
  }, Nu = (o) => {
    const s = o.components();
    tn(s, Nu), Io(o, At());
  }, Jy = (o, s) => {
    o.getSystem().addToWorld(s), Rr(o.element) && Nu(s);
  }, Sh = (o) => {
    lf(o), o.getSystem().removeFromWorld(o);
  }, rp = (o, s) => {
    Zs(o.element, s.element);
  }, sp = (o, s) => {
    zb(o, s, Zs);
  }, zb = (o, s, i) => {
    o.getSystem().addToWorld(s), i(o.element, s.element), Rr(o.element) && Nu(s), o.syncComponents();
  }, Ob = (o) => {
    lf(o), ya(o.element), o.getSystem().removeFromWorld(o);
  }, Cm = (o) => {
    const s = cl(o.element).bind((i) => o.getSystem().getByDom(i).toOptional());
    Ob(o), s.each((i) => {
      i.syncComponents();
    });
  }, ap = (o) => {
    const s = o.components();
    tn(s, Ob), rm(o.element), o.syncComponents();
  }, Eh = (o, s) => {
    Th(o, s, Zs);
  }, ip = (o, s) => {
    Th(o, s, $d);
  }, Th = (o, s, i) => {
    i(o, s.element);
    const l = _r(s.element);
    tn(l, (f) => {
      s.getByDom(f).each(Nu);
    });
  }, zh = (o) => {
    const s = _r(o.element);
    tn(s, (i) => {
      o.getByDom(i).each(lf);
    }), ya(o.element);
  }, Eg = (o, s, i, l) => {
    i.get().each((b) => {
      ap(o);
    });
    const f = s.getAttachPoint(o);
    sp(f, o);
    const m = o.getSystem().build(l);
    return sp(o, m), i.set(m), m;
  }, Ab = (o, s, i, l) => {
    const f = Eg(o, s, i, l);
    return s.onOpen(o, f), f;
  }, $p = (o, s, i) => {
    i.get().each((l) => {
      ap(o), Cm(o), s.onClose(o, l), i.clear();
    });
  }, Ff = (o, s, i) => i.isOpen(), Sm = (o, s, i) => {
    const l = s.getAttachPoint(o);
    qn(o.element, "position", Ll.getMode(l)), ((f, m, b, x) => {
      Xs(f.element, m).fold(() => {
        ts(f.element, b);
      }, (w) => {
        eo(f.element, b, w);
      }), qn(f.element, m, "hidden");
    })(o, "visibility", s.cloakVisibilityAttr);
  }, Tg = (o, s, i) => {
    ((l) => jr(["top", "left", "right", "bottom"], (f) => Xs(l, f).isSome()))(o.element) || ar(o.element, "position"), ((l, f, m) => {
      Sa(l.element, m).fold(() => ar(l.element, f), (b) => qn(l.element, f, b));
    })(o, "visibility", s.cloakVisibilityAttr);
  };
  var Db = Object.freeze({ __proto__: null, cloak: Sm, decloak: Tg, open: Ab, openWhileCloaked: (o, s, i, l, f) => {
    Sm(o, s), Ab(o, s, i, l), f(), Tg(o, s);
  }, close: $p, isOpen: Ff, isPartOf: (o, s, i, l) => Ff(0, 0, i) && i.get().exists((f) => s.isPartOf(o, f, l)), getState: (o, s, i) => i.get(), setContent: (o, s, i, l) => i.get().map(() => Eg(o, s, i, l)) }), vd = Object.freeze({ __proto__: null, events: (o, s) => Bo([ft(Tp(), (i, l) => {
    $p(i, o, s);
  })]) }), Hp = [Vo("onOpen"), Vo("onClose"), st("isPartOf"), st("getAttachPoint"), He("cloakVisibilityAttr", "data-precloak-visibility")], zg = Object.freeze({ __proto__: null, init: () => {
    const o = As(), s = Ee("not-implemented");
    return as({ readState: s, isOpen: o.isSet, clear: o.clear, set: o.set, get: o.get });
  } });
  const zo = _i({ fields: Hp, name: "sandboxing", active: vd, apis: Db, state: zg }), Pl = Ee("dismiss.popups"), Og = Ee("reposition.popups"), nt = Ee("mouse.released"), Ag = hi([He("isExtraPart", Xe), Ol("fireEventInstead", [He("event", qd())])]), Rb = (o) => {
    const s = Ta("Dismissal", Ag, o);
    return { [Pl()]: { schema: hi([st("target")]), onReceive: (i, l) => {
      zo.isOpen(i) && (zo.isPartOf(i, l.target) || s.isExtraPart(i, l.target) || s.fireEventInstead.fold(() => zo.close(i), (f) => Io(i, f.event)));
    } } };
  }, e0 = hi([Ol("fireEventInstead", [He("event", Gd())]), Ia("doReposition")]), Dg = (o) => {
    const s = Ta("Reposition", e0, o);
    return { [Og()]: { onReceive: (i) => {
      zo.isOpen(i) && s.fireEventInstead.fold(() => s.doReposition(i), (l) => Io(i, l.event));
    } } };
  }, Mu = (o, s, i) => {
    s.store.manager.onLoad(o, s, i);
  }, Rg = (o, s, i) => {
    s.store.manager.onUnload(o, s, i);
  };
  var Nb = Object.freeze({ __proto__: null, onLoad: Mu, onUnload: Rg, setValue: (o, s, i, l) => {
    s.store.manager.setValue(o, s, i, l);
  }, getValue: (o, s, i) => s.store.manager.getValue(o, s, i), getState: (o, s, i) => i }), Qy = Object.freeze({ __proto__: null, events: (o, s) => {
    const i = o.resetOnDom ? [ss((l, f) => {
      Mu(l, o, s);
    }), ud((l, f) => {
      Rg(l, o, s);
    })] : [wg(o, s, Mu)];
    return Bo(i);
  } });
  const Oh = () => {
    const o = Ln(null);
    return as({ set: o.set, get: o.get, isNotSet: () => o.get() === null, clear: () => {
      o.set(null);
    }, readState: () => ({ mode: "memory", value: o.get() }) });
  }, Mb = () => {
    const o = Ln({}), s = Ln({});
    return as({ readState: () => ({ mode: "dataset", dataByValue: o.get(), dataByText: s.get() }), lookup: (i) => cn(o.get(), i).orThunk(() => cn(s.get(), i)), update: (i) => {
      const l = o.get(), f = s.get(), m = {}, b = {};
      tn(i, (x) => {
        m[x.value] = x, cn(x, "meta").each((w) => {
          cn(w, "text").each((E) => {
            b[E] = x;
          });
        });
      }), o.set({ ...l, ...m }), s.set({ ...f, ...b });
    }, clear: () => {
      o.set({}), s.set({});
    } });
  };
  var e1 = Object.freeze({ __proto__: null, memory: Oh, dataset: Mb, manual: () => as({ readState: gt }), init: (o) => o.store.manager.state(o) });
  const t0 = (o, s, i, l) => {
    const f = s.store;
    i.update([l]), f.setValue(o, l), s.onSetValue(o, l);
  };
  var Bb = [pr("initialValue"), st("getFallbackEntry"), st("getDataKey"), st("setValue"), ms("manager", { setValue: t0, getValue: (o, s, i) => {
    const l = s.store, f = l.getDataKey(o);
    return i.lookup(f).getOrThunk(() => l.getFallbackEntry(f));
  }, onLoad: (o, s, i) => {
    s.store.initialValue.each((l) => {
      t0(o, s, i, l);
    });
  }, onUnload: (o, s, i) => {
    i.clear();
  }, state: Mb })], n0 = [st("getValue"), He("setValue", gt), pr("initialValue"), ms("manager", { setValue: (o, s, i, l) => {
    s.store.setValue(o, l), s.onSetValue(o, l);
  }, getValue: (o, s, i) => s.store.getValue(o), onLoad: (o, s, i) => {
    s.store.initialValue.each((l) => {
      s.store.setValue(o, l);
    });
  }, onUnload: gt, state: fr.init })], xd = [pr("initialValue"), ms("manager", { setValue: (o, s, i, l) => {
    i.set(l), s.onSetValue(o, l);
  }, getValue: (o, s, i) => i.get(), onLoad: (o, s, i) => {
    s.store.initialValue.each((l) => {
      i.isNotSet() && i.set(l);
    });
  }, onUnload: (o, s, i) => {
    i.clear();
  }, state: Oh })], Cv = [za("store", { mode: "memory" }, bi("mode", { memory: xd, manual: n0, dataset: Bb })), Vo("onSetValue"), He("resetOnDom", !1)];
  const ln = _i({ fields: Cv, name: "representing", active: Qy, apis: Nb, extra: { setValueFrom: (o, s) => {
    const i = ln.getValue(s);
    ln.setValue(o, i);
  } }, state: e1 }), pa = (o, s) => im(o, {}, Ct(s, (i) => {
    return l = i.name(), f = "Cannot configure " + i.name() + " for " + o, Qs(l, l, { tag: "option", process: {} }, vt((m) => xu("The field: " + l + " is forbidden. " + f)));
    var l, f;
  }).concat([ua("dump", wt)])), ir = (o) => o.dump, Fi = (o, s) => ({ ...$t(s), ...o.dump }), $i = pa, Ua = Fi, Lb = "placeholder", wd = Fa([{ single: ["required", "valueThunk"] }, { multiple: ["required", "valueThunks"] }]), p = (o) => _n(o, "uiType"), y = (o, s, i, l) => ((f, m, b, x) => p(b) && b.uiType === Lb ? ((w, E, O, A) => w.exists((B) => B !== O.owner) ? wd.single(!0, Ee(O)) : cn(A, O.name).fold(() => {
    throw new Error("Unknown placeholder component: " + O.name + `
Known: [` + po(A) + `]
Namespace: ` + w.getOr("none") + `
Spec: ` + JSON.stringify(O, null, 2));
  }, (B) => B.replace()))(f, 0, b, x) : wd.single(!1, Ee(b)))(o, 0, i, l).fold((f, m) => {
    const b = p(i) ? m(s, i.config, i.validated) : m(s), x = cn(b, "components").getOr([]), w = Qr(x, (E) => y(o, s, E, l));
    return [{ ...b, components: w }];
  }, (f, m) => {
    if (p(i)) {
      const b = m(s, i.config, i.validated);
      return i.validated.preprocess.getOr(wt)(b);
    }
    return m(s);
  }), _ = wd.single, T = wd.multiple, P = Ee(Lb), I = Fa([{ required: ["data"] }, { external: ["data"] }, { optional: ["data"] }, { group: ["data"] }]), j = He("factory", { sketch: wt }), Y = He("schema", []), ne = st("name"), ve = Qs("pname", "pname", Ai((o) => "<alloy." + hn(o.name) + ">"), Pr()), Ce = ua("schema", () => [pr("preprocess")]), ge = He("defaults", Ee({})), Te = He("overrides", Ee({})), Ae = Nn([j, Y, ne, ve, ge, Te]), Ge = Nn([j, Y, ne, ge, Te]), $e = Nn([j, Y, ne, ve, ge, Te]), lt = Nn([j, Ce, ne, st("unit"), ve, ge, Te]), pt = (o) => o.fold(M.some, M.none, M.some, M.some), Bt = (o) => {
    const s = (i) => i.name;
    return o.fold(s, s, s, s);
  }, xt = (o, s) => (i) => {
    const l = Ta("Converting part type", s, i);
    return o(l);
  }, Lt = xt(I.required, Ae), Vt = xt(I.external, Ge), rn = xt(I.optional, $e), Vn = xt(I.group, lt), Un = Ee("entirety");
  var Do = Object.freeze({ __proto__: null, required: Lt, external: Vt, optional: rn, group: Vn, asNamedPart: pt, name: Bt, asCommon: (o) => o.fold(wt, wt, wt, wt), original: Un });
  const Gn = (o, s, i, l) => be(s.defaults(o, i, l), i, { uid: o.partUids[s.name] }, s.overrides(o, i, l)), Ro = (o, s) => {
    const i = {};
    return tn(s, (l) => {
      pt(l).each((f) => {
        const m = xo(o, f.pname);
        i[f.name] = (b) => {
          const x = Ta("Part: " + f.name + " in " + o, Nn(f.schema), b);
          return { ...m, config: b, validated: x };
        };
      });
    }), i;
  }, xo = (o, s) => ({ uiType: P(), owner: o, name: s }), zr = (o, s, i) => ({ uiType: P(), owner: o, name: s, config: i, validated: {} }), Wt = (o) => Qr(o, (s) => s.fold(M.none, M.some, M.none, M.none).map((i) => el(i.name, i.schema.concat([My(Un())]))).toArray()), Hi = (o) => Ct(o, Bt), ja = (o, s, i) => ((l, f, m) => {
    const b = {}, x = {};
    return tn(m, (w) => {
      w.fold((E) => {
        b[E.pname] = _(!0, (O, A, B) => E.factory.sketch(Gn(O, E, A, B)));
      }, (E) => {
        const O = f.parts[E.name];
        x[E.name] = Ee(E.factory.sketch(Gn(f, E, O[Un()]), O));
      }, (E) => {
        b[E.pname] = _(!1, (O, A, B) => E.factory.sketch(Gn(O, E, A, B)));
      }, (E) => {
        b[E.pname] = T(!0, (O, A, B) => {
          const $ = O[E.name];
          return Ct($, (Z) => E.factory.sketch(be(E.defaults(O, Z, B), Z, E.overrides(O, Z))));
        });
      });
    }), { internals: Ee(b), externals: Ee(x) };
  })(0, s, i), ai = (o, s, i) => ((l, f, m, b) => {
    const x = ho(b, (E, O) => ((A, B) => {
      let $ = !1;
      return { name: Ee(A), required: () => B.fold((Z, oe) => Z, (Z, oe) => Z), used: () => $, replace: () => {
        if ($)
          throw new Error("Trying to use the same placeholder more than once: " + A);
        return $ = !0, B;
      } };
    })(O, E)), w = ((E, O, A, B) => Qr(A, ($) => y(E, O, $, B)))(l, f, m, x);
    return Mr(x, (E) => {
      if (E.used() === !1 && E.required())
        throw new Error("Placeholder: " + E.name() + ` was not found in components list
Namespace: ` + l.getOr("none") + `
Components: ` + JSON.stringify(f.components, null, 2));
    }), w;
  })(M.some(o), s, s.components, i), Dn = (o, s, i) => {
    const l = s.partUids[i];
    return o.getSystem().getByUid(l).toOptional();
  }, ii = (o, s, i) => Dn(o, s, i).getOrDie("Could not find part: " + i), yl = (o, s, i) => {
    const l = {}, f = s.partUids, m = o.getSystem();
    return tn(i, (b) => {
      l[b] = Ee(m.getByUid(f[b]));
    }), l;
  }, Ng = (o, s) => {
    const i = o.getSystem();
    return ho(s.partUids, (l, f) => Ee(i.getByUid(l)));
  }, Ah = (o) => po(o.partUids), hs = (o, s, i) => {
    const l = {}, f = s.partUids, m = o.getSystem();
    return tn(i, (b) => {
      l[b] = Ee(m.getByUid(f[b]).getOrDie());
    }), l;
  }, Dh = (o, s) => {
    const i = Hi(s);
    return dr(Ct(i, (l) => ({ key: l, value: o + "-" + l })));
  }, li = (o) => Qs("partUids", "partUids", _f((s) => Dh(s.uid, o)), Pr());
  var Mg = Object.freeze({ __proto__: null, generate: Ro, generateOne: zr, schemas: Wt, names: Hi, substitutes: ja, components: ai, defaultUids: Dh, defaultUidsSchema: li, getAllParts: Ng, getAllPartNames: Ah, getPart: Dn, getPartOrDie: ii, getParts: yl, getPartsOrDie: hs });
  const Ew = (o, s, i, l, f) => {
    const m = ((b, x) => (b.length > 0 ? [el("parts", b)] : []).concat([st("uid"), He("dom", {}), He("components", []), My("originalSpec"), He("debug.sketcher", {})]).concat(x))(l, f);
    return Ta(o + " [SpecSchema]", hi(m.concat(s)), i);
  }, Sv = (o, s, i, l, f) => {
    const m = Tw(f), b = Wt(i), x = li(i), w = Ew(o, s, m, b, [x]), E = ja(0, w, i);
    return l(w, ai(o, w, E.internals()), m, E.externals());
  }, Tw = (o) => ((s) => _n(s, "uid"))(o) ? o : { ...o, uid: q("uid") }, J2 = hi([st("name"), st("factory"), st("configFields"), He("apis", {}), He("extraApis", {})]), Q2 = hi([st("name"), st("factory"), st("configFields"), st("partFields"), He("apis", {}), He("extraApis", {})]), Bu = (o) => {
    const s = Ta("Sketcher for " + o.name, J2, o), i = ho(s.apis, _o), l = ho(s.extraApis, (f, m) => on(f, m));
    return { name: s.name, configFields: s.configFields, sketch: (f) => ((m, b, x, w) => {
      const E = Tw(w);
      return x(Ew(m, b, E, [], []), E);
    })(s.name, s.configFields, s.factory, f), ...i, ...l };
  }, hc = (o) => {
    const s = Ta("Sketcher for " + o.name, Q2, o), i = Ro(s.name, s.partFields), l = ho(s.apis, _o), f = ho(s.extraApis, (m, b) => on(m, b));
    return { name: s.name, partFields: s.partFields, configFields: s.configFields, sketch: (m) => Sv(s.name, s.configFields, s.partFields, s.factory, m), parts: i, ...l, ...f };
  }, Pb = (o) => tm("input")(o) && js(o, "type") !== "radio" || tm("textarea")(o);
  var zw = Object.freeze({ __proto__: null, getCurrent: (o, s, i) => s.find(o) });
  const eC = [st("find")], rr = _i({ fields: eC, name: "composing", apis: zw }), tC = ["input", "button", "textarea", "select"], Ow = (o, s, i) => {
    (s.disabled() ? o0 : Yl)(o, s);
  }, t1 = (o, s) => s.useNative === !0 && Bn(tC, Ti(o.element)), nC = (o) => {
    eo(o.element, "disabled", "disabled");
  }, n1 = (o) => {
    ts(o.element, "disabled");
  }, Aw = (o) => {
    eo(o.element, "aria-disabled", "true");
  }, oC = (o) => {
    eo(o.element, "aria-disabled", "false");
  }, o0 = (o, s, i) => {
    s.disableClass.each((l) => {
      vr(o.element, l);
    }), (t1(o, s) ? nC : Aw)(o), s.onDisabled(o);
  }, Yl = (o, s, i) => {
    s.disableClass.each((l) => {
      $s(o.element, l);
    }), (t1(o, s) ? n1 : oC)(o), s.onEnabled(o);
  }, Lu = (o, s) => t1(o, s) ? ((i) => Ki(i.element, "disabled"))(o) : ((i) => js(i.element, "aria-disabled") === "true")(o);
  var rC = Object.freeze({ __proto__: null, enable: Yl, disable: o0, isDisabled: Lu, onLoad: Ow, set: (o, s, i, l) => {
    (l ? o0 : Yl)(o, s);
  } }), Dw = Object.freeze({ __proto__: null, exhibit: (o, s) => Xa({ classes: s.disabled() ? s.disableClass.toArray() : [] }), events: (o, s) => Bo([$a(gl(), (i, l) => Lu(i, o)), wg(o, s, Ow)]) }), sC = [fs("disabled", Xe), He("useNative", !0), pr("disableClass"), Vo("onDisabled"), Vo("onEnabled")];
  const Xn = _i({ fields: sC, name: "disabling", active: Dw, apis: rC }), Ev = (o, s, i, l) => {
    const f = Kl(o.element, "." + s.highlightClass);
    tn(f, (m) => {
      jr(l, (b) => tr(b.element, m)) || ($s(m, s.highlightClass), o.getSystem().getByDom(m).each((b) => {
        s.onDehighlight(o, b), Io(b, Sf());
      }));
    });
  }, o1 = (o, s, i, l) => {
    Ev(o, s, 0, [l]), Tv(o, s, i, l) || (vr(l.element, s.highlightClass), s.onHighlight(o, l), Io(l, Kr()));
  }, Tv = (o, s, i, l) => _s(l.element, s.highlightClass), r0 = (o, s, i) => fa(o.element, "." + s.itemClass).bind((l) => o.getSystem().getByDom(l).toOptional()), Rw = (o, s, i) => {
    const l = Kl(o.element, "." + s.itemClass);
    return (l.length > 0 ? M.some(l[l.length - 1]) : M.none()).bind((f) => o.getSystem().getByDom(f).toOptional());
  }, Rh = (o, s, i, l) => {
    const f = Kl(o.element, "." + s.itemClass);
    return Zi(f, (m) => _s(m, s.highlightClass)).bind((m) => {
      const b = tf(m, l, 0, f.length - 1);
      return o.getSystem().getByDom(f[b]).toOptional();
    });
  }, Nw = (o, s, i) => {
    const l = Kl(o.element, "." + s.itemClass);
    return Nt(Ct(l, (f) => o.getSystem().getByDom(f).toOptional()));
  };
  var s0 = Object.freeze({ __proto__: null, dehighlightAll: (o, s, i) => Ev(o, s, 0, []), dehighlight: (o, s, i, l) => {
    Tv(o, s, i, l) && ($s(l.element, s.highlightClass), s.onDehighlight(o, l), Io(l, Sf()));
  }, highlight: o1, highlightFirst: (o, s, i) => {
    r0(o, s).each((l) => {
      o1(o, s, i, l);
    });
  }, highlightLast: (o, s, i) => {
    Rw(o, s).each((l) => {
      o1(o, s, i, l);
    });
  }, highlightAt: (o, s, i, l) => {
    ((f, m, b, x) => {
      const w = Kl(f.element, "." + m.itemClass);
      return M.from(w[x]).fold(() => To.error(new Error("No element found with index " + x)), f.getSystem().getByDom);
    })(o, s, 0, l).fold((f) => {
      throw f;
    }, (f) => {
      o1(o, s, i, f);
    });
  }, highlightBy: (o, s, i, l) => {
    const f = Nw(o, s);
    Go(f, l).each((m) => {
      o1(o, s, i, m);
    });
  }, isHighlighted: Tv, getHighlighted: (o, s, i) => fa(o.element, "." + s.highlightClass).bind((l) => o.getSystem().getByDom(l).toOptional()), getFirst: r0, getLast: Rw, getPrevious: (o, s, i) => Rh(o, s, 0, -1), getNext: (o, s, i) => Rh(o, s, 0, 1), getCandidates: Nw }), Mw = [st("highlightClass"), st("itemClass"), Vo("onHighlight"), Vo("onDehighlight")];
  const mr = _i({ fields: Mw, name: "highlighting", apis: s0 }), aC = [8], Vp = [9], lp = [13], Up = [27], Pu = [32], Ib = [37], r1 = [38], a0 = [39], Fb = [40], Bw = (o, s, i) => {
    const l = So(o.slice(0, s)), f = So(o.slice(s + 1));
    return Go(l.concat(f), i);
  }, Lw = (o, s, i) => {
    const l = So(o.slice(0, s));
    return Go(l, i);
  }, iC = (o, s, i) => {
    const l = o.slice(0, s), f = o.slice(s + 1);
    return Go(f.concat(l), i);
  }, Pw = (o, s, i) => {
    const l = o.slice(s + 1);
    return Go(l, i);
  }, lr = (o) => (s) => {
    const i = s.raw;
    return Bn(o, i.which);
  }, $f = (o) => (s) => nc(o, (i) => i(s)), cp = (o) => o.raw.shiftKey === !0, lC = (o) => o.raw.ctrlKey === !0, s1 = Cn(cp), gr = (o, s) => ({ matches: o, classification: s }), Iw = (o, s, i) => {
    s.exists((l) => i.exists((f) => tr(f, l))) || pn(o, Dl(), { prevFocus: s, newFocus: i });
  }, i0 = () => {
    const o = (s) => iu(s.element);
    return { get: o, set: (s, i) => {
      const l = o(s);
      s.getSystem().triggerFocus(i, s.element);
      const f = o(s);
      Iw(s, l, f);
    } };
  }, cC = () => {
    const o = (s) => mr.getHighlighted(s).map((i) => i.element);
    return { get: o, set: (s, i) => {
      const l = o(s);
      s.getSystem().getByDom(i).fold(gt, (m) => {
        mr.highlight(s, m);
      });
      const f = o(s);
      Iw(s, l, f);
    } };
  };
  var $b;
  (function(o) {
    o.OnFocusMode = "onFocus", o.OnEnterOrSpaceMode = "onEnterOrSpace", o.OnApiMode = "onApi";
  })($b || ($b = {}));
  const Nh = (o, s, i, l, f) => {
    const m = (x, w, E, O, A) => {
      return (B = E(x, w, O, A), $ = w.event, Go(B, (Z) => Z.matches($)).map((Z) => Z.classification)).bind((Z) => Z(x, w, O, A));
      var B, $;
    }, b = { schema: () => o.concat([He("focusManager", i0()), za("focusInside", "onFocus", Tl((x) => Bn(["onFocus", "onEnterOrSpace", "onApi"], x) ? To.value(x) : To.error("Invalid value for focusInside"))), ms("handler", b), ms("state", s), ms("sendFocusIn", f)]), processKey: m, toEvents: (x, w) => {
      const E = x.focusInside !== $b.OnFocusMode ? M.none() : f(x).map((A) => ft(Mi(), (B, $) => {
        A(B, x, w), $.stop();
      })), O = [ft(bn(), (A, B) => {
        m(A, B, i, x, w).fold(() => {
          (($, Z) => {
            const oe = lr(Pu.concat(lp))(Z.event);
            x.focusInside === $b.OnEnterOrSpaceMode && oe && de($, Z) && f(x).each((re) => {
              re($, x, w), Z.stop();
            });
          })(A, B);
        }, ($) => {
          B.stop();
        });
      }), ft(ao(), (A, B) => {
        m(A, B, l, x, w).each(($) => {
          B.stop();
        });
      })];
      return Bo(E.toArray().concat(O));
    } };
    return b;
  }, Fw = (o) => {
    const s = [pr("onEscape"), pr("onEnter"), He("selector", '[data-alloy-tabstop="true"]:not(:disabled)'), He("firstTabstop", 0), He("useTabstopAt", un), pr("visibilitySelector")].concat([o]), i = (O, A) => {
      const B = O.visibilitySelector.bind(($) => Ou(A, $)).getOr(A);
      return Qe(B) > 0;
    }, l = (O, A) => A.focusManager.get(O).bind((B) => Ou(B, A.selector)), f = (O, A, B) => {
      (($, Z) => {
        const oe = Kl($.element, Z.selector), re = Pn(oe, (fe) => i(Z, fe));
        return M.from(re[Z.firstTabstop]);
      })(O, A).each(($) => {
        A.focusManager.set(O, $);
      });
    }, m = (O, A, B, $) => {
      const Z = Kl(O.element, B.selector);
      return l(O, B).bind((oe) => Zi(Z, We(tr, oe)).bind((re) => ((fe, ee, J, le, me) => me(ee, J, (ke) => ((Re, qe) => i(Re, qe) && Re.useTabstopAt(qe))(le, ke)).fold(() => le.cyclic ? M.some(!0) : M.none(), (ke) => (le.focusManager.set(fe, ke), M.some(!0))))(O, Z, re, B, $)));
    }, b = (O, A, B) => {
      const $ = B.cyclic ? Bw : Lw;
      return m(O, 0, B, $);
    }, x = (O, A, B) => {
      const $ = B.cyclic ? iC : Pw;
      return m(O, 0, B, $);
    }, w = Ee([gr($f([cp, lr(Vp)]), b), gr(lr(Vp), x), gr($f([s1, lr(lp)]), (O, A, B) => B.onEnter.bind(($) => $(O, A)))]), E = Ee([gr(lr(Up), (O, A, B) => B.onEscape.bind(($) => $(O, A))), gr(lr(Vp), (O, A, B) => l(O, B).filter(($) => !B.useTabstopAt($)).bind(($) => (((Z) => ((oe) => cl(oe))(Z).bind(El).exists((oe) => tr(oe, Z)))($) ? b : x)(O, A, B)))]);
    return Nh(s, fr.init, w, E, () => M.some(f));
  };
  var uC = Fw(ua("cyclic", Xe)), dC = Fw(ua("cyclic", un));
  const a1 = (o, s, i) => Pb(i) && lr(Pu)(s.event) ? M.none() : ((l, f, m) => (zp(l, m, gl()), M.some(!0)))(o, 0, i), Hb = (o, s) => M.some(!0), l0 = [He("execute", a1), He("useSpace", !1), He("useEnter", !0), He("useControlEnter", !1), He("useDown", !1)], $w = (o, s, i) => i.execute(o, s, o.element);
  var fC = Nh(l0, fr.init, (o, s, i, l) => {
    const f = i.useSpace && !Pb(o.element) ? Pu : [], m = i.useEnter ? lp : [], b = i.useDown ? Fb : [], x = f.concat(m).concat(b);
    return [gr(lr(x), $w)].concat(i.useControlEnter ? [gr($f([lC, lr(lp)]), $w)] : []);
  }, (o, s, i, l) => i.useSpace && !Pb(o.element) ? [gr(lr(Pu), Hb)] : [], () => M.none());
  const Hw = () => {
    const o = As();
    return as({ readState: () => o.get().map((s) => ({ numRows: String(s.numRows), numColumns: String(s.numColumns) })).getOr({ numRows: "?", numColumns: "?" }), setGridSize: (s, i) => {
      o.set({ numRows: s, numColumns: i });
    }, getNumRows: () => o.get().map((s) => s.numRows), getNumColumns: () => o.get().map((s) => s.numColumns) });
  };
  var mC = Object.freeze({ __proto__: null, flatgrid: Hw, init: (o) => o.state(o) });
  const Vw = (o) => (s, i, l, f) => {
    const m = o(s.element);
    return Ov(m, s, i, l, f);
  }, zv = (o, s) => {
    const i = Pf(o, s);
    return Vw(i);
  }, i1 = (o, s) => {
    const i = Pf(s, o);
    return Vw(i);
  }, c0 = (o) => (s, i, l, f) => Ov(o, s, i, l, f), Ov = (o, s, i, l, f) => l.focusManager.get(s).bind((m) => o(s.element, m, l, f)).map((m) => (l.focusManager.set(s, m), !0)), Uw = c0, jw = c0, u0 = c0, l1 = (o) => !((s) => s.offsetWidth <= 0 && s.offsetHeight <= 0)(o.dom), Zw = (o, s, i) => {
    const l = Kl(o, i);
    return ((f, m) => Zi(f, (b) => tr(b, s)).map((b) => ({ index: b, candidates: f })))(Pn(l, l1));
  }, Ww = (o, s) => Zi(o, (i) => tr(s, i)), qw = (o, s, i, l) => l(Math.floor(s / i), s % i).bind((f) => {
    const m = f.row * i + f.column;
    return m >= 0 && m < o.length ? M.some(o[m]) : M.none();
  }), Iu = (o, s, i, l, f) => qw(o, s, l, (m, b) => {
    const x = m === i - 1 ? o.length - m * l : l, w = tf(b, f, 0, x - 1);
    return M.some({ row: m, column: w });
  }), Vb = (o, s, i, l, f) => qw(o, s, l, (m, b) => {
    const x = tf(m, f, 0, i - 1), w = x === i - 1 ? o.length - x * l : l, E = Dc(b, 0, w - 1);
    return M.some({ row: x, column: E });
  }), pC = [st("selector"), He("execute", a1), fc("onEscape"), He("captureTab", !1), By()], gC = (o, s, i) => {
    fa(o.element, s.selector).each((l) => {
      s.focusManager.set(o, l);
    });
  }, d0 = (o) => (s, i, l, f) => Zw(s, i, l.selector).bind((m) => o(m.candidates, m.index, f.getNumRows().getOr(l.initSize.numRows), f.getNumColumns().getOr(l.initSize.numColumns))), Gw = (o, s, i) => i.captureTab ? M.some(!0) : M.none(), f0 = d0((o, s, i, l) => Iu(o, s, i, l, -1)), Av = d0((o, s, i, l) => Iu(o, s, i, l, 1)), Dv = d0((o, s, i, l) => Vb(o, s, i, l, -1)), hC = d0((o, s, i, l) => Vb(o, s, i, l, 1)), bC = Ee([gr(lr(Ib), zv(f0, Av)), gr(lr(a0), i1(f0, Av)), gr(lr(r1), Uw(Dv)), gr(lr(Fb), jw(hC)), gr($f([cp, lr(Vp)]), Gw), gr($f([s1, lr(Vp)]), Gw), gr(lr(Pu.concat(lp)), (o, s, i, l) => ((f, m) => m.focusManager.get(f).bind((b) => Ou(b, m.selector)))(o, i).bind((f) => i.execute(o, s, f)))]), yC = Ee([gr(lr(Up), (o, s, i) => i.onEscape(o, s)), gr(lr(Pu), Hb)]);
  var Rv = Nh(pC, Hw, bC, yC, () => M.some(gC));
  const Nv = (o, s, i, l, f) => {
    const m = (b, x, w) => f(b, x, l, 0, w.length - 1, w[x], (E) => {
      return O = w[E], Ti(O) === "button" && js(O, "disabled") === "disabled" ? m(b, E, w) : M.from(w[E]);
      var O;
    });
    return Zw(o, i, s).bind((b) => {
      const x = b.index, w = b.candidates;
      return m(x, x, w);
    });
  }, Mv = (o, s, i, l) => Nv(o, s, i, l, (f, m, b, x, w, E, O) => {
    const A = Dc(m + b, x, w);
    return A === f ? M.from(E) : O(A);
  }), c1 = (o, s, i, l) => Nv(o, s, i, l, (f, m, b, x, w, E, O) => {
    const A = tf(m, b, x, w);
    return A === f ? M.none() : O(A);
  }), Kw = [st("selector"), He("getInitial", M.none), He("execute", a1), fc("onEscape"), He("executeOnMove", !1), He("allowVertical", !0), He("allowHorizontal", !0), He("cycles", !0)], Ub = (o, s, i) => ((l, f) => f.focusManager.get(l).bind((m) => Ou(m, f.selector)))(o, i).bind((l) => i.execute(o, s, l)), m0 = (o, s, i) => {
    s.getInitial(o).orThunk(() => fa(o.element, s.selector)).each((l) => {
      s.focusManager.set(o, l);
    });
  }, Yw = (o, s, i) => (i.cycles ? c1 : Mv)(o, i.selector, s, -1), Xw = (o, s, i) => (i.cycles ? c1 : Mv)(o, i.selector, s, 1), Jw = (o) => (s, i, l, f) => o(s, i, l, f).bind(() => l.executeOnMove ? Ub(s, i, l) : M.some(!0)), vC = Ee([gr(lr(Pu), Hb), gr(lr(Up), (o, s, i) => i.onEscape(o, s))]);
  var xC = Nh(Kw, fr.init, (o, s, i, l) => {
    const f = [...i.allowHorizontal ? Ib : []].concat(i.allowVertical ? r1 : []), m = [...i.allowHorizontal ? a0 : []].concat(i.allowVertical ? Fb : []);
    return [gr(lr(f), Jw(zv(Yw, Xw))), gr(lr(m), Jw(i1(Yw, Xw))), gr(lr(lp), Ub), gr(lr(Pu), Ub)];
  }, vC, () => M.some(m0));
  const up = (o, s, i) => M.from(o[s]).bind((l) => M.from(l[i]).map((f) => ({ rowIndex: s, columnIndex: i, cell: f }))), Qw = (o, s, i, l) => {
    const f = o[s].length, m = tf(i, l, 0, f - 1);
    return up(o, s, m);
  }, ek = (o, s, i, l) => {
    const f = tf(i, l, 0, o.length - 1), m = o[f].length, b = Dc(s, 0, m - 1);
    return up(o, f, b);
  }, tk = (o, s, i, l) => {
    const f = o[s].length, m = Dc(i + l, 0, f - 1);
    return up(o, s, m);
  }, nk = (o, s, i, l) => {
    const f = Dc(i + l, 0, o.length - 1), m = o[f].length, b = Dc(s, 0, m - 1);
    return up(o, f, b);
  }, ok = [el("selectors", [st("row"), st("cell")]), He("cycles", !0), He("previousSelector", M.none), He("execute", a1)], wC = (o, s, i) => {
    s.previousSelector(o).orThunk(() => {
      const l = s.selectors;
      return fa(o.element, l.cell);
    }).each((l) => {
      s.focusManager.set(o, l);
    });
  }, p0 = (o, s) => (i, l, f) => {
    const m = f.cycles ? o : s;
    return Ou(l, f.selectors.row).bind((b) => {
      const x = Kl(b, f.selectors.cell);
      return Ww(x, l).bind((w) => {
        const E = Kl(i, f.selectors.row);
        return Ww(E, b).bind((O) => {
          const A = ((B, $) => Ct(B, (Z) => Kl(Z, $.selectors.cell)))(E, f);
          return m(A, O, w).map((B) => B.cell);
        });
      });
    });
  }, Bv = p0((o, s, i) => Qw(o, s, i, -1), (o, s, i) => tk(o, s, i, -1)), jb = p0((o, s, i) => Qw(o, s, i, 1), (o, s, i) => tk(o, s, i, 1)), u1 = p0((o, s, i) => ek(o, i, s, -1), (o, s, i) => nk(o, i, s, -1)), kC = p0((o, s, i) => ek(o, i, s, 1), (o, s, i) => nk(o, i, s, 1)), Lv = Ee([gr(lr(Ib), zv(Bv, jb)), gr(lr(a0), i1(Bv, jb)), gr(lr(r1), Uw(u1)), gr(lr(Fb), jw(kC)), gr(lr(Pu.concat(lp)), (o, s, i) => iu(o.element).bind((l) => i.execute(o, s, l)))]), _C = Ee([gr(lr(Pu), Hb)]);
  var rk = Nh(ok, fr.init, Lv, _C, () => M.some(wC));
  const sk = [st("selector"), He("execute", a1), He("moveOnTab", !1)], u = (o, s, i) => i.focusManager.get(o).bind((l) => i.execute(o, s, l)), g = (o, s, i) => {
    fa(o.element, s.selector).each((l) => {
      s.focusManager.set(o, l);
    });
  }, S = (o, s, i) => c1(o, i.selector, s, -1), V = (o, s, i) => c1(o, i.selector, s, 1), Q = Ee([gr(lr(r1), u0(S)), gr(lr(Fb), u0(V)), gr($f([cp, lr(Vp)]), (o, s, i, l) => i.moveOnTab ? u0(S)(o, s, i, l) : M.none()), gr($f([s1, lr(Vp)]), (o, s, i, l) => i.moveOnTab ? u0(V)(o, s, i, l) : M.none()), gr(lr(lp), u), gr(lr(Pu), u)]), we = Ee([gr(lr(Pu), Hb)]);
  var Be = Nh(sk, fr.init, Q, we, () => M.some(g));
  const Ve = [fc("onSpace"), fc("onEnter"), fc("onShiftEnter"), fc("onLeft"), fc("onRight"), fc("onTab"), fc("onShiftTab"), fc("onUp"), fc("onDown"), fc("onEscape"), He("stopSpaceKeyup", !1), pr("focusIn")];
  var ot = Nh(Ve, fr.init, (o, s, i) => [gr(lr(Pu), i.onSpace), gr($f([s1, lr(lp)]), i.onEnter), gr($f([cp, lr(lp)]), i.onShiftEnter), gr($f([cp, lr(Vp)]), i.onShiftTab), gr($f([s1, lr(Vp)]), i.onTab), gr(lr(r1), i.onUp), gr(lr(Fb), i.onDown), gr(lr(Ib), i.onLeft), gr(lr(a0), i.onRight), gr(lr(Pu), i.onSpace)], (o, s, i) => [...i.stopSpaceKeyup ? [gr(lr(Pu), Hb)] : [], gr(lr(Up), i.onEscape)], (o) => o.focusIn);
  const Yt = uC.schema(), Kt = dC.schema(), dn = xC.schema(), Kn = Rv.schema(), No = rk.schema(), sr = fC.schema(), Or = Be.schema(), Wo = ot.schema(), Jt = Gm({ branchKey: "mode", branches: Object.freeze({ __proto__: null, acyclic: Yt, cyclic: Kt, flow: dn, flatgrid: Kn, matrix: No, execution: sr, menu: Or, special: Wo }), name: "keying", active: { events: (o, s) => o.handler.toEvents(o, s) }, apis: { focusIn: (o, s, i) => {
    s.sendFocusIn(s).fold(() => {
      o.getSystem().triggerFocus(o.element, o.element);
    }, (l) => {
      l(o, s, i);
    });
  }, setGridSize: (o, s, i, l, f) => {
    ((m) => Ys(m, "setGridSize"))(i) ? i.setGridSize(l, f) : console.error("Layout does not support setGridSize");
  } }, state: mC }), bs = (o, s) => {
    Mp(() => {
      ((i, l, f) => {
        const m = i.components();
        ((w) => {
          tn(w.components(), (E) => ya(E.element)), rm(w.element), w.syncComponents();
        })(i);
        const b = f(l), x = cr(m, b);
        tn(x, (w) => {
          lf(w), i.getSystem().removeFromWorld(w);
        }), tn(b, (w) => {
          Tb(w) ? rp(i, w) : (i.getSystem().addToWorld(w), rp(i, w), Rr(i.element) && Nu(w));
        }), i.syncComponents();
      })(o, s, () => Ct(s, o.getSystem().build));
    }, o.element);
  }, Nc = (o, s) => {
    Mp(() => {
      ((i, l, f) => {
        const m = i.components(), b = Qr(l, (E) => ks(E).toArray());
        tn(m, (E) => {
          Bn(b, E) || Sh(E);
        });
        const x = ((E, O, A) => fm(E, O, (B, $) => Af(E, $, B, A)))(o.element, s, o.getSystem().buildOrPatch), w = cr(m, x);
        tn(w, (E) => {
          Tb(E) && Sh(E);
        }), tn(x, (E) => {
          Tb(E) || Jy(i, E);
        }), i.syncComponents();
      })(o, s);
    }, o.element);
  }, Mc = (o, s, i, l) => {
    Sh(s);
    const f = Af(o.element, i, l, o.getSystem().buildOrPatch);
    Jy(o, f), o.syncComponents();
  }, Fu = (o, s, i) => {
    const l = o.getSystem().build(i);
    zb(o, l, s);
  }, al = (o, s, i, l) => {
    Cm(s), Fu(o, (f, m) => ((b, x, w) => {
      Dr(b, w).fold(() => {
        Zs(b, x);
      }, (E) => {
        td(E, x);
      });
    })(f, m, i), l);
  }, Wc = (o, s) => o.components(), _a = (o, s, i, l, f) => {
    const m = Wc(o);
    return M.from(m[l]).map((b) => (f.fold(() => Cm(b), (x) => {
      (s.reuseDom ? Mc : al)(o, b, l, x);
    }), b));
  };
  var ak = Object.freeze({ __proto__: null, append: (o, s, i, l) => {
    Fu(o, Zs, l);
  }, prepend: (o, s, i, l) => {
    Fu(o, Ji, l);
  }, remove: (o, s, i, l) => {
    const f = Wc(o);
    Go(f, (b) => tr(l.element, b.element)).each(Cm);
  }, replaceAt: _a, replaceBy: (o, s, i, l, f) => {
    const m = Wc(o);
    return Zi(m, l).bind((b) => _a(o, s, 0, b, f));
  }, set: (o, s, i, l) => (s.reuseDom ? Nc : bs)(o, l), contents: Wc });
  const Jn = _i({ fields: [rs("reuseDom", !0)], name: "replacing", apis: ak }), wo = (o, s) => {
    const i = ((l, f) => {
      const m = Bo(f);
      return _i({ fields: [st("enabled")], name: l, active: { events: Ee(m) } });
    })(o, s);
    return { key: o, value: { config: {}, me: i, configAsRaw: Ee({}), initialConfig: {}, state: fr } };
  }, ik = (o, s) => {
    s.ignore || (gc(o.element), s.onFocus(o));
  };
  var g0 = Object.freeze({ __proto__: null, focus: ik, blur: (o, s) => {
    s.ignore || ub(o.element);
  }, isFocused: (o) => mm(o.element) }), kT = Object.freeze({ __proto__: null, exhibit: (o, s) => {
    const i = s.ignore ? {} : { attributes: { tabindex: "-1" } };
    return Xa(i);
  }, events: (o) => Bo([ft(Mi(), (s, i) => {
    ik(s, o), i.stop();
  })].concat(o.stopMousedown ? [ft(da(), (s, i) => {
    i.event.prevent();
  })] : [])) }), lk = [Vo("onFocus"), He("stopMousedown", !1), He("ignore", !1)];
  const io = _i({ fields: lk, name: "focusing", active: kT, apis: g0 }), h0 = (o, s, i, l) => {
    const f = i.get();
    i.set(l), ((m, b, x) => {
      b.toggleClass.each((w) => {
        x.get() ? vr(m.element, w) : $s(m.element, w);
      });
    })(o, s, i), ((m, b, x) => {
      const w = b.aria;
      w.update(m, w, x.get());
    })(o, s, i), f !== l && s.onToggled(o, l);
  }, CC = (o, s, i) => {
    h0(o, s, i, !i.get());
  }, _T = (o, s, i) => {
    h0(o, s, i, s.selected);
  };
  var SC = Object.freeze({ __proto__: null, onLoad: _T, toggle: CC, isOn: (o, s, i) => i.get(), on: (o, s, i) => {
    h0(o, s, i, !0);
  }, off: (o, s, i) => {
    h0(o, s, i, !1);
  }, set: h0 }), Bg = Object.freeze({ __proto__: null, exhibit: () => Xa({}), events: (o, s) => {
    const i = (l = o, f = s, m = CC, hl((x) => {
      m(x, l, f);
    }));
    var l, f, m;
    const b = wg(o, s, _T);
    return Bo(er([o.toggleOnExecute ? [i] : [], [b]]));
  } });
  const CT = (o, s, i) => {
    eo(o.element, "aria-expanded", i);
  };
  var U5 = [He("selected", !1), pr("toggleClass"), He("toggleOnExecute", !0), Vo("onToggled"), za("aria", { mode: "none" }, bi("mode", { pressed: [He("syncWithExpanded", !1), ms("update", (o, s, i) => {
    eo(o.element, "aria-pressed", i), s.syncWithExpanded && CT(o, 0, i);
  })], checked: [ms("update", (o, s, i) => {
    eo(o.element, "aria-checked", i);
  })], expanded: [ms("update", CT)], selected: [ms("update", (o, s, i) => {
    eo(o.element, "aria-selected", i);
  })], none: [ms("update", gt)] }))];
  const Lo = _i({ fields: U5, name: "toggling", active: Bg, apis: SC, state: { init: () => {
    const o = Ln(!1);
    return { get: () => o.get(), set: (s) => o.set(s), clear: () => o.set(!1), readState: () => o.get() };
  } } }), EC = () => {
    const o = (s, i) => {
      i.stop(), Kd(s);
    };
    return [ft(yr(), o), ft(Ul(), o), Su(Yo()), Su(da())];
  }, Pv = (o) => Bo(er([o.map((s) => hl((i, l) => {
    s(i), l.stop();
  })).toArray(), EC()])), ST = "alloy.item-hover", ET = "alloy.item-focus", Hf = "alloy.item-toggled", d1 = (o) => {
    (iu(o.element).isNone() || io.isFocused(o)) && (io.isFocused(o) || io.focus(o), pn(o, ST, { item: o }));
  }, TC = (o) => {
    pn(o, ET, { item: o });
  }, f1 = Ee(ST), kd = Ee(ET), cf = Ee(Hf), lu = (o) => o.toggling.map((s) => s.exclusive ? "menuitemradio" : "menuitemcheckbox").getOr("menuitem"), dp = [st("data"), st("components"), st("dom"), He("hasSubmenu", !1), pr("toggling"), $i("itemBehaviours", [Lo, io, Jt, ln]), He("ignoreFocus", !1), He("domModification", {}), ms("builder", (o) => ({ dom: o.dom, domModification: { ...o.domModification, attributes: { role: lu(o), ...o.domModification.attributes, "aria-haspopup": o.hasSubmenu, ...o.hasSubmenu ? { "aria-expanded": !1 } : {} } }, behaviours: Ua(o.itemBehaviours, [o.toggling.fold(Lo.revoke, (s) => Lo.config(((i) => ({ aria: { mode: "checked" }, ...$r(i, (l, f) => f !== "exclusive"), onToggled: (l, f) => {
    Rt(i.onToggled) && i.onToggled(l, f), ((m, b) => {
      pn(m, Hf, { item: m, state: b });
    })(l, f);
  } }))(s))), io.config({ ignore: o.ignoreFocus, stopMousedown: o.ignoreFocus, onFocus: (s) => {
    TC(s);
  } }), Jt.config({ mode: "execution" }), ln.config({ store: { mode: "memory", initialValue: o.data } }), wo("item-type-events", [...EC(), ft(_e(), d1), ft(Vc(), io.focus)])]), components: o.components, eventOrder: o.eventOrder })), He("eventOrder", {})], zC = [st("dom"), st("components"), ms("builder", (o) => ({ dom: o.dom, components: o.components, events: Bo([jl(Vc())]) }))], uf = Ee("item-widget"), Mh = Ee([Lt({ name: "widget", overrides: (o) => ({ behaviours: $t([ln.config({ store: { mode: "manual", getValue: (s) => o.data, setValue: gt } })]) }) })]), j5 = [st("uid"), st("data"), st("components"), st("dom"), He("autofocus", !1), He("ignoreFocus", !1), $i("widgetBehaviours", [ln, io, Jt]), He("domModification", {}), li(Mh()), ms("builder", (o) => {
    const s = ja(uf(), o, Mh()), i = ai(uf(), o, s.internals()), l = (m) => Dn(m, o, "widget").map((b) => (Jt.focusIn(b), b)), f = (m, b) => (Pb(b.event.target) || o.autofocus && b.setSource(m.element), M.none());
    return { dom: o.dom, components: i, domModification: o.domModification, events: Bo([hl((m, b) => {
      l(m).each((x) => {
        b.stop();
      });
    }), ft(_e(), d1), ft(Vc(), (m, b) => {
      o.autofocus ? l(m) : io.focus(m);
    })]), behaviours: Ua(o.widgetBehaviours, [ln.config({ store: { mode: "memory", initialValue: o.data } }), io.config({ ignore: o.ignoreFocus, onFocus: (m) => {
      TC(m);
    } }), Jt.config({ mode: "special", focusIn: o.autofocus ? (m) => {
      l(m);
    } : of(), onLeft: f, onRight: f, onEscape: (m, b) => io.isFocused(m) || o.autofocus ? (o.autofocus && b.setSource(m.element), M.none()) : (io.focus(m), M.some(!0)) })]) };
  })], Z5 = bi("type", { widget: j5, item: dp, separator: zC }), W5 = Ee([Vn({ factory: { sketch: (o) => {
    const s = Ta("menu.spec item", Z5, o);
    return s.builder(s);
  } }, name: "items", unit: "item", defaults: (o, s) => _n(s, "uid") ? s : { ...s, uid: q("item") }, overrides: (o, s) => ({ type: s.type, ignoreFocus: o.fakeFocus, domModification: { classes: [o.markers.item] } }) })]), TT = Ee([st("value"), st("items"), st("dom"), st("components"), He("eventOrder", {}), pa("menuBehaviours", [mr, ln, rr, Jt]), za("movement", { mode: "menu", moveOnTab: !0 }, bi("mode", { grid: [By(), ms("config", (o, s) => ({ mode: "flatgrid", selector: "." + o.markers.item, initSize: { numColumns: s.initSize.numColumns, numRows: s.initSize.numRows }, focusManager: o.focusManager }))], matrix: [ms("config", (o, s) => ({ mode: "matrix", selectors: { row: s.rowSelector, cell: "." + o.markers.item }, previousSelector: s.previousSelector, focusManager: o.focusManager })), st("rowSelector"), He("previousSelector", M.none)], menu: [He("moveOnTab", !0), ms("config", (o, s) => ({ mode: "menu", selector: "." + o.markers.item, moveOnTab: s.moveOnTab, focusManager: o.focusManager }))] })), zl("markers", gg()), He("fakeFocus", !1), He("focusManager", i0()), Vo("onHighlight"), Vo("onDehighlight")]), OC = Ee("alloy.menu-focus"), Lg = hc({ name: "Menu", configFields: TT(), partFields: W5(), factory: (o, s, i, l) => ({ uid: o.uid, dom: o.dom, markers: o.markers, behaviours: Fi(o.menuBehaviours, [mr.config({ highlightClass: o.markers.selectedItem, itemClass: o.markers.item, onHighlight: o.onHighlight, onDehighlight: o.onDehighlight }), ln.config({ store: { mode: "memory", initialValue: o.value } }), rr.config({ find: M.some }), Jt.config(o.movement.config(o, o.movement))]), events: Bo([ft(kd(), (f, m) => {
    const b = m.event;
    f.getSystem().getByDom(b.target).each((x) => {
      mr.highlight(f, x), m.stop(), pn(f, OC(), { menu: f, item: x });
    });
  }), ft(f1(), (f, m) => {
    const b = m.event.item;
    mr.highlight(f, b);
  }), ft(cf(), (f, m) => {
    const { item: b, state: x } = m.event;
    x && js(b.element, "role") === "menuitemradio" && ((w, E) => {
      const O = Kl(w.element, '[role="menuitemradio"][aria-checked="true"]');
      tn(O, (A) => {
        tr(A, E.element) || w.getSystem().getByDom(A).each((B) => {
          Lo.off(B);
        });
      });
    })(f, b);
  })]), components: s, eventOrder: o.eventOrder, domModification: { attributes: { role: "menu" } } }) }), AC = (o, s, i, l) => cn(i, l).bind((f) => cn(o, f).bind((m) => {
    const b = AC(o, s, i, m);
    return M.some([m].concat(b));
  })).getOr([]), zT = (o) => o.type === "prepared" ? M.some(o.menu) : M.none(), q5 = () => {
    const o = Ln({}), s = Ln({}), i = Ln({}), l = As(), f = Ln({}), m = (w) => b(w).bind(zT), b = (w) => cn(s.get(), w), x = (w) => cn(o.get(), w);
    return { setMenuBuilt: (w, E) => {
      s.set({ ...s.get(), [w]: { type: "prepared", menu: E } });
    }, setContents: (w, E, O, A) => {
      l.set(w), o.set(O), s.set(E), f.set(A);
      const B = (($, Z) => {
        const oe = {};
        Mr($, (J, le) => {
          tn(J, (me) => {
            oe[me] = le;
          });
        });
        const re = Z, fe = Ns(Z, (J, le) => ({ k: J, v: le })), ee = ho(fe, (J, le) => [le].concat(AC(oe, re, fe, le)));
        return ho(oe, (J) => cn(ee, J).getOr([J]));
      })(A, O);
      i.set(B);
    }, expand: (w) => cn(o.get(), w).map((E) => {
      const O = cn(i.get(), w).getOr([]);
      return [E].concat(O);
    }), refresh: (w) => cn(i.get(), w), collapse: (w) => cn(i.get(), w).bind((E) => E.length > 1 ? M.some(E.slice(1)) : M.none()), lookupMenu: b, lookupItem: x, otherMenus: (w) => {
      const E = f.get();
      return cr(po(E), w);
    }, getPrimary: () => l.get().bind(m), getMenus: () => s.get(), clear: () => {
      o.set({}), s.set({}), i.set({}), l.clear();
    }, isClear: () => l.get().isNone(), getTriggeringPath: (w, E) => {
      const O = Pn(x(w).toArray(), (A) => m(A).isSome());
      return cn(i.get(), w).bind((A) => {
        const B = So(O.concat(A));
        return (($) => {
          const Z = [];
          for (let oe = 0; oe < $.length; oe++) {
            const re = $[oe];
            if (!re.isSome())
              return M.none();
            Z.push(re.getOrDie());
          }
          return M.some(Z);
        })(Qr(B, ($, Z) => ((oe, re, fe) => m(oe).bind((ee) => ((J) => ha(o.get(), (le, me) => le === J))(oe).bind((J) => re(J).map((le) => ({ triggeredMenu: ee, triggeringItem: le, triggeringPath: fe })))))($, E, B.slice(0, Z + 1)).fold(() => Si(l.get(), $) ? [] : [M.none()], (oe) => [M.some(oe)])));
      });
    } };
  }, G5 = zT, OT = hn("tiered-menu-item-highlight"), DC = hn("tiered-menu-item-dehighlight");
  var cu;
  (function(o) {
    o[o.HighlightMenuAndItem = 0] = "HighlightMenuAndItem", o[o.HighlightJustMenu = 1] = "HighlightJustMenu", o[o.HighlightNone = 2] = "HighlightNone";
  })(cu || (cu = {}));
  const RC = Ee("collapse-item"), Zb = Bu({ name: "TieredMenu", configFields: [bg("onExecute"), bg("onEscape"), bd("onOpenMenu"), bd("onOpenSubmenu"), Vo("onRepositionMenu"), Vo("onCollapseMenu"), He("highlightOnOpen", cu.HighlightMenuAndItem), el("data", [st("primary"), st("menus"), st("expansions")]), He("fakeFocus", !1), Vo("onHighlightItem"), Vo("onDehighlightItem"), Vo("onHover"), hg(), st("dom"), He("navigateOnHover", !0), He("stayInDom", !1), pa("tmenuBehaviours", [Jt, mr, rr, Jn]), He("eventOrder", {})], apis: { collapseMenu: (o, s) => {
    o.collapseMenu(s);
  }, highlightPrimary: (o, s) => {
    o.highlightPrimary(s);
  }, repositionMenus: (o, s) => {
    o.repositionMenus(s);
  } }, factory: (o, s) => {
    const i = As(), l = q5(), f = (J) => ln.getValue(J).value, m = (J) => ho(o.data.menus, (le, me) => Qr(le.items, (ke) => ke.type === "separator" ? [] : [ke.data.value])), b = mr.highlight, x = (J, le) => {
      b(J, le), mr.getHighlighted(le).orThunk(() => mr.getFirst(le)).each((me) => {
        o.fakeFocus ? mr.highlight(le, me) : zp(J, me.element, Vc());
      });
    }, w = (J, le) => Nt(Ct(le, (me) => J.lookupMenu(me).bind((ke) => ke.type === "prepared" ? M.some(ke.menu) : M.none()))), E = (J, le, me) => {
      const ke = w(le, le.otherMenus(me));
      tn(ke, (Re) => {
        jc(Re.element, [o.markers.backgroundMenu]), o.stayInDom || Jn.remove(J, Re);
      });
    }, O = (J, le) => {
      const me = ((ke) => i.get().getOrThunk(() => {
        const Re = {}, qe = Kl(ke.element, `.${o.markers.item}`), mt = Pn(qe, (bt) => js(bt, "aria-haspopup") === "true");
        return tn(mt, (bt) => {
          ke.getSystem().getByDom(bt).each((St) => {
            const Qt = f(St);
            Re[Qt] = St;
          });
        }), i.set(Re), Re;
      }))(J);
      Mr(me, (ke, Re) => {
        const qe = Bn(le, Re);
        eo(ke.element, "aria-expanded", qe);
      });
    }, A = (J, le, me) => M.from(me[0]).bind((ke) => le.lookupMenu(ke).bind((Re) => {
      if (Re.type === "notbuilt")
        return M.none();
      {
        const qe = Re.menu, mt = w(le, me.slice(1));
        return tn(mt, (bt) => {
          vr(bt.element, o.markers.backgroundMenu);
        }), Rr(qe.element) || Jn.append(J, Yr(qe)), jc(qe.element, [o.markers.backgroundMenu]), x(J, qe), E(J, le, me), M.some(qe);
      }
    }));
    let B;
    (function(J) {
      J[J.HighlightSubmenu = 0] = "HighlightSubmenu", J[J.HighlightParent = 1] = "HighlightParent";
    })(B || (B = {}));
    const $ = (J, le, me = B.HighlightSubmenu) => {
      if (le.hasConfigured(Xn) && Xn.isDisabled(le))
        return M.some(le);
      {
        const ke = f(le);
        return l.expand(ke).bind((Re) => (O(J, Re), M.from(Re[0]).bind((qe) => l.lookupMenu(qe).bind((mt) => {
          const bt = ((St, Qt, vn) => {
            if (vn.type === "notbuilt") {
              const Mn = St.getSystem().build(vn.nbMenu());
              return l.setMenuBuilt(Qt, Mn), Mn;
            }
            return vn.menu;
          })(J, qe, mt);
          return Rr(bt.element) || Jn.append(J, Yr(bt)), o.onOpenSubmenu(J, le, bt, So(Re)), me === B.HighlightSubmenu ? (mr.highlightFirst(bt), A(J, l, Re)) : (mr.dehighlightAll(bt), M.some(le));
        }))));
      }
    }, Z = (J, le) => {
      const me = f(le);
      return l.collapse(me).bind((ke) => (O(J, ke), A(J, l, ke).map((Re) => (o.onCollapseMenu(J, le, Re), Re))));
    }, oe = (J) => (le, me) => Ou(me.getSource(), `.${o.markers.item}`).bind((ke) => le.getSystem().getByDom(ke).toOptional().bind((Re) => J(le, Re).map(un))), re = Bo([ft(OC(), (J, le) => {
      const me = le.event.item;
      l.lookupItem(f(me)).each(() => {
        const ke = le.event.menu;
        mr.highlight(J, ke);
        const Re = f(le.event.item);
        l.refresh(Re).each((qe) => E(J, l, qe));
      });
    }), hl((J, le) => {
      const me = le.event.target;
      J.getSystem().getByDom(me).each((ke) => {
        f(ke).indexOf("collapse-item") === 0 && Z(J, ke), $(J, ke, B.HighlightSubmenu).fold(() => {
          o.onExecute(J, ke);
        }, gt);
      });
    }), ss((J, le) => {
      ((me) => {
        const ke = ((qe, mt, bt) => ho(bt, (St, Qt) => {
          const vn = () => Lg.sketch({ ...St, value: Qt, markers: o.markers, fakeFocus: o.fakeFocus, onHighlight: (Mn, Qn) => {
            pn(Mn, OT, { menuComp: Mn, itemComp: Qn });
          }, onDehighlight: (Mn, Qn) => {
            pn(Mn, DC, { menuComp: Mn, itemComp: Qn });
          }, focusManager: o.fakeFocus ? cC() : i0() });
          return Qt === mt ? { type: "prepared", menu: qe.getSystem().build(vn()) } : { type: "notbuilt", nbMenu: vn };
        }))(me, o.data.primary, o.data.menus), Re = m();
        return l.setContents(o.data.primary, ke, o.data.expansions, Re), l.getPrimary();
      })(J).each((me) => {
        Jn.append(J, Yr(me)), o.onOpenMenu(J, me), o.highlightOnOpen === cu.HighlightMenuAndItem ? x(J, me) : o.highlightOnOpen === cu.HighlightJustMenu && b(J, me);
      });
    }), ft(OT, (J, le) => {
      o.onHighlightItem(J, le.event.menuComp, le.event.itemComp);
    }), ft(DC, (J, le) => {
      o.onDehighlightItem(J, le.event.menuComp, le.event.itemComp);
    }), ...o.navigateOnHover ? [ft(f1(), (J, le) => {
      const me = le.event.item;
      ((ke, Re) => {
        const qe = f(Re);
        l.refresh(qe).bind((mt) => (O(ke, mt), A(ke, l, mt)));
      })(J, me), $(J, me, B.HighlightParent), o.onHover(J, me);
    })] : []]), fe = (J) => mr.getHighlighted(J).bind(mr.getHighlighted), ee = { collapseMenu: (J) => {
      fe(J).each((le) => {
        Z(J, le);
      });
    }, highlightPrimary: (J) => {
      l.getPrimary().each((le) => {
        x(J, le);
      });
    }, repositionMenus: (J) => {
      l.getPrimary().bind((me) => fe(J).bind((ke) => {
        const Re = f(ke), qe = ro(l.getMenus()), mt = Nt(Ct(qe, G5));
        return l.getTriggeringPath(Re, (bt) => ((St, Qt, vn) => Ko(Qt, (Mn) => {
          if (!Mn.getSystem().isConnected())
            return M.none();
          const Qn = mr.getCandidates(Mn);
          return Go(Qn, (fo) => f(fo) === vn);
        }))(0, mt, bt));
      }).map((ke) => ({ primary: me, triggeringPath: ke }))).fold(() => {
        ((me) => M.from(me.components()[0]).filter((ke) => js(ke.element, "role") === "menu"))(J).each((me) => {
          o.onRepositionMenu(J, me, []);
        });
      }, ({ primary: me, triggeringPath: ke }) => {
        o.onRepositionMenu(J, me, ke);
      });
    } };
    return { uid: o.uid, dom: o.dom, markers: o.markers, behaviours: Fi(o.tmenuBehaviours, [Jt.config({ mode: "special", onRight: oe((J, le) => Pb(le.element) ? M.none() : $(J, le, B.HighlightSubmenu)), onLeft: oe((J, le) => Pb(le.element) ? M.none() : Z(J, le)), onEscape: oe((J, le) => Z(J, le).orThunk(() => o.onEscape(J, le).map(() => J))), focusIn: (J, le) => {
      l.getPrimary().each((me) => {
        zp(J, me.element, Vc());
      });
    } }), mr.config({ highlightClass: o.markers.selectedMenu, itemClass: o.markers.menu }), rr.config({ find: (J) => mr.getHighlighted(J) }), Jn.config({})]), eventOrder: o.eventOrder, apis: ee, events: re };
  }, extraApis: { tieredData: (o, s, i) => ({ primary: o, menus: s, expansions: i }), singleData: (o, s) => ({ primary: o, menus: yi(o, s), expansions: {} }), collapseItem: (o) => ({ value: hn(RC()), meta: { text: o } }) } }), Oa = Bu({ name: "InlineView", configFields: [st("lazySink"), Vo("onShow"), Vo("onHide"), Vl("onEscape"), pa("inlineBehaviours", [zo, ln, pc]), Ol("fireDismissalEventInstead", [He("event", qd())]), Ol("fireRepositionEventInstead", [He("event", Gd())]), He("getRelated", M.none), He("isExtraPart", Xe), He("eventOrder", M.none)], factory: (o, s) => {
    const i = (b, x, w, E) => {
      const O = o.lazySink(b).getOrDie();
      zo.openWhileCloaked(b, x, () => Ll.positionWithinBounds(O, b, w, E())), ln.setValue(b, M.some({ mode: "position", config: w, getBounds: E }));
    }, l = (b, x, w, E) => {
      const O = ((A, B, $, Z, oe) => {
        const re = () => A.lazySink(B), fe = Z.type === "horizontal" ? { layouts: { onLtr: () => xg(), onRtl: () => gh() } } : {}, ee = (J) => ((le) => le.length === 2)(J) ? fe : {};
        return Zb.sketch({ dom: { tag: "div" }, data: Z.data, markers: Z.menu.markers, highlightOnOpen: Z.menu.highlightOnOpen, fakeFocus: Z.menu.fakeFocus, onEscape: () => (zo.close(B), A.onEscape.map((J) => J(B)), M.some(!0)), onExecute: () => M.some(!0), onOpenMenu: (J, le) => {
          Ll.positionWithinBounds(re().getOrDie(), le, $, oe());
        }, onOpenSubmenu: (J, le, me, ke) => {
          const Re = re().getOrDie();
          Ll.position(Re, me, { anchor: { type: "submenu", item: le, ...ee(ke) } });
        }, onRepositionMenu: (J, le, me) => {
          const ke = re().getOrDie();
          Ll.positionWithinBounds(ke, le, $, oe()), tn(me, (Re) => {
            const qe = ee(Re.triggeringPath);
            Ll.position(ke, Re.triggeredMenu, { anchor: { type: "submenu", item: Re.triggeringItem, ...qe } });
          });
        } });
      })(o, b, x, w, E);
      zo.open(b, O), ln.setValue(b, M.some({ mode: "menu", menu: O }));
    }, f = (b) => {
      zo.isOpen(b) && ln.getValue(b).each((x) => {
        switch (x.mode) {
          case "menu":
            zo.getState(b).each(Zb.repositionMenus);
            break;
          case "position":
            const w = o.lazySink(b).getOrDie();
            Ll.positionWithinBounds(w, b, x.config, x.getBounds());
        }
      });
    }, m = { setContent: (b, x) => {
      zo.setContent(b, x);
    }, showAt: (b, x, w) => {
      const E = M.none;
      i(b, x, w, E);
    }, showWithinBounds: i, showMenuAt: (b, x, w) => {
      l(b, x, w, M.none);
    }, showMenuWithinBounds: l, hide: (b) => {
      zo.isOpen(b) && (ln.setValue(b, M.none()), zo.close(b));
    }, getContent: (b) => zo.getState(b), reposition: f, isOpen: zo.isOpen };
    return { uid: o.uid, dom: o.dom, behaviours: Fi(o.inlineBehaviours, [zo.config({ isPartOf: (b, x, w) => wi(x, w) || ((E, O) => o.getRelated(E).exists((A) => wi(A, O)))(b, w), getAttachPoint: (b) => o.lazySink(b).getOrDie(), onOpen: (b) => {
      o.onShow(b);
    }, onClose: (b) => {
      o.onHide(b);
    } }), ln.config({ store: { mode: "memory", initialValue: M.none() } }), pc.config({ channels: { ...Rb({ isExtraPart: s.isExtraPart, ...o.fireDismissalEventInstead.map((b) => ({ fireEventInstead: { event: b.event } })).getOr({}) }), ...Dg({ ...o.fireRepositionEventInstead.map((b) => ({ fireEventInstead: { event: b.event } })).getOr({}), doReposition: f }) } })]), eventOrder: o.eventOrder, apis: m };
  }, apis: { showAt: (o, s, i, l) => {
    o.showAt(s, i, l);
  }, showWithinBounds: (o, s, i, l, f) => {
    o.showWithinBounds(s, i, l, f);
  }, showMenuAt: (o, s, i, l) => {
    o.showMenuAt(s, i, l);
  }, showMenuWithinBounds: (o, s, i, l, f) => {
    o.showMenuWithinBounds(s, i, l, f);
  }, hide: (o, s) => {
    o.hide(s);
  }, isOpen: (o, s) => o.isOpen(s), getContent: (o, s) => o.getContent(s), setContent: (o, s, i) => {
    o.setContent(s, i);
  }, reposition: (o, s) => {
    o.reposition(s);
  } } });
  var ck = tinymce.util.Tools.resolve("tinymce.util.Delay");
  const bc = Bu({ name: "Button", factory: (o) => {
    const s = Pv(o.action), i = o.dom.tag, l = (f) => cn(o.dom, "attributes").bind((m) => cn(m, f));
    return { uid: o.uid, dom: o.dom, components: o.components, events: s, behaviours: Ua(o.buttonBehaviours, [io.config({}), Jt.config({ mode: "execution", useSpace: !0, useEnter: !0 })]), domModification: { attributes: i === "button" ? { type: l("type").getOr("button"), ...l("role").map((f) => ({ role: f })).getOr({}) } : { role: o.role.getOr(l("role").getOr("button")) } }, eventOrder: o.eventOrder };
  }, configFields: [He("uid", void 0), st("dom"), He("components", []), $i("buttonBehaviours", [io, Jt]), pr("action"), pr("role"), He("eventOrder", {})] }), Bh = (o) => {
    const s = Ei(o), i = _r(s), l = ((b) => {
      const x = b.dom.attributes !== void 0 ? b.dom.attributes : [];
      return K(x, (w, E) => E.name === "class" ? w : { ...w, [E.name]: E.value }, {});
    })(s), f = ((b) => Array.prototype.slice.call(b.dom.classList, 0))(s), m = i.length === 0 ? {} : { innerHtml: Hm(s) };
    return { tag: Ti(s), classes: f, attributes: l, ...m };
  }, Ur = (o) => {
    const s = ((i) => i.uid !== void 0)(o) && Ys(o, "uid") ? o.uid : q("memento");
    return { get: (i) => i.getSystem().getByUid(s).getOrDie(), getOpt: (i) => i.getSystem().getByUid(s).toOptional(), asSpec: () => ({ ...o, uid: s }) };
  }, { entries: AT, setPrototypeOf: Vf, isFrozen: N8, getPrototypeOf: uk, getOwnPropertyDescriptor: b0 } = Object;
  let { freeze: $u, seal: Uf, create: DT } = Object, { apply: NC, construct: MC } = typeof Reflect < "u" && Reflect;
  $u || ($u = function(o) {
    return o;
  }), Uf || (Uf = function(o) {
    return o;
  }), NC || (NC = function(o, s, i) {
    return o.apply(s, i);
  }), MC || (MC = function(o, s) {
    return new o(...s);
  });
  const dk = Hu(Array.prototype.forEach), BC = Hu(Array.prototype.pop), Pg = Hu(Array.prototype.push), Wb = Hu(String.prototype.toLowerCase), LC = Hu(String.prototype.toString), RT = Hu(String.prototype.match), y0 = Hu(String.prototype.replace), PC = Hu(String.prototype.indexOf), IC = Hu(String.prototype.trim), Em = Hu(Object.prototype.hasOwnProperty), uu = Hu(RegExp.prototype.test), m1 = (FC = TypeError, function() {
    for (var o = arguments.length, s = new Array(o), i = 0; i < o; i++)
      s[i] = arguments[i];
    return MC(FC, s);
  });
  var FC;
  function Hu(o) {
    return function(s) {
      for (var i = arguments.length, l = new Array(i > 1 ? i - 1 : 0), f = 1; f < i; f++)
        l[f - 1] = arguments[f];
      return NC(o, s, l);
    };
  }
  function ys(o, s) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Wb;
    Vf && // Make 'in' and truthy checks like Boolean(set.constructor)
    // independent of any properties defined on Object.prototype.
    // Prevent prototype setters from intercepting set as a this value.
    Vf(o, null);
    let l = s.length;
    for (; l--; ) {
      let f = s[l];
      if (typeof f == "string") {
        const m = i(f);
        m !== f && // Config presets (e.g. tags.js, attrs.js) are immutable.
        (N8(s) || (s[l] = m), f = m);
      }
      o[f] = !0;
    }
    return o;
  }
  function K5(o) {
    for (let s = 0; s < o.length; s++)
      Em(o, s) || (o[s] = null);
    return o;
  }
  function qb(o) {
    const s = DT(null);
    for (const [i, l] of AT(o))
      Em(o, i) && (Array.isArray(l) ? s[i] = K5(l) : l && typeof l == "object" && l.constructor === Object ? s[i] = qb(l) : s[i] = l);
    return s;
  }
  function Iv(o, s) {
    for (; o !== null; ) {
      const i = b0(o, s);
      if (i) {
        if (i.get)
          return Hu(i.get);
        if (typeof i.value == "function")
          return Hu(i.value);
      }
      o = uk(o);
    }
    return function() {
      return null;
    };
  }
  const $C = $u(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), Fv = $u(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), Gb = $u(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), HC = $u(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), VC = $u(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), Y5 = $u(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), UC = $u(["#text"]), Lh = $u(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), $v = $u(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), fk = $u(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), p1 = $u(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), NT = Uf(/\{\{[\w\W]*|[\w\W]*\}\}/gm), mk = Uf(/<%[\w\W]*|[\w\W]*%>/gm), jC = Uf(/\${[\w\W]*}/gm), X5 = Uf(/^data-[\-\w.\u00B7-\uFFFF]/), J5 = Uf(/^aria-[\-\w]+$/), jp = Uf(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), Q5 = Uf(/^(?:\w+script|data):/i), eM = Uf(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), jf = Uf(/^html$/i), Xl = Uf(/^[a-z][.\w]*(-[.\w]+)+$/i);
  var MT = Object.freeze({ __proto__: null, MUSTACHE_EXPR: NT, ERB_EXPR: mk, TMPLIT_EXPR: jC, DATA_ATTR: X5, ARIA_ATTR: J5, IS_ALLOWED_URI: jp, IS_SCRIPT_OR_DATA: Q5, ATTR_WHITESPACE: eM, DOCTYPE_NAME: jf, CUSTOM_ELEMENT: Xl });
  const ZC = function() {
    return typeof window > "u" ? null : window;
  };
  var tM = function o() {
    let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ZC();
    const i = (Ue) => o(Ue);
    if (i.version = "3.1.7", /**
           * Array of elements that DOMPurify removed during sanitation.
           * Empty if nothing was removed.
           */
    i.removed = [], !s || !s.document || s.document.nodeType !== 9)
      return i.isSupported = !1, i;
    let { document: l } = s;
    const f = l, m = f.currentScript, { DocumentFragment: b, HTMLTemplateElement: x, Node: w, Element: E, NodeFilter: O, NamedNodeMap: A = s.NamedNodeMap || s.MozNamedAttrMap, HTMLFormElement: B, DOMParser: $, trustedTypes: Z } = s, oe = E.prototype, re = Iv(oe, "cloneNode"), fe = Iv(oe, "remove"), ee = Iv(oe, "nextSibling"), J = Iv(oe, "childNodes"), le = Iv(oe, "parentNode");
    if (typeof x == "function") {
      const Ue = l.createElement("template");
      Ue.content && Ue.content.ownerDocument && (l = Ue.content.ownerDocument);
    }
    let me, ke = "";
    const { implementation: Re, createNodeIterator: qe, createDocumentFragment: mt, getElementsByTagName: bt } = l, { importNode: St } = f;
    let Qt = {};
    i.isSupported = typeof AT == "function" && typeof le == "function" && Re && Re.createHTMLDocument !== void 0;
    const { MUSTACHE_EXPR: vn, ERB_EXPR: Mn, TMPLIT_EXPR: Qn, DATA_ATTR: fo, ARIA_ATTR: $o, IS_SCRIPT_OR_DATA: Hs, ATTR_WHITESPACE: ga, CUSTOM_ELEMENT: Xo } = MT;
    let { IS_ALLOWED_URI: Fl } = MT, go = null;
    const ui = ys({}, [...$C, ...Fv, ...Gb, ...VC, ...UC]);
    let qs = null;
    const qu = ys({}, [...Lh, ...$v, ...fk, ...p1]);
    let Er = Object.seal(DT(null, { tagNameCheck: { writable: !0, configurable: !1, enumerable: !0, value: null }, attributeNameCheck: { writable: !0, configurable: !1, enumerable: !0, value: null }, allowCustomizedBuiltInElements: { writable: !0, configurable: !1, enumerable: !0, value: !1 } })), Ui = null, Gu = null, iv = !0, V1 = !0, R2 = !1, ow = !0, _y = !1, Cy = !0, Kg = !1, U1 = !1, j1 = !1, Yg = !1, qh = !1, lv = !1, rw = !0, sw = !1, cv = !0, is = !1, vp = {}, gf = null;
    const NN = ys({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    let U3 = null;
    const j3 = ys({}, ["audio", "video", "img", "source", "image", "track"]);
    let Z3 = null;
    const MN = ys({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), aw = "http://www.w3.org/1998/Math/MathML", N2 = "http://www.w3.org/2000/svg", Gh = "http://www.w3.org/1999/xhtml";
    let to = Gh, Z1 = !1, M2 = null;
    const BN = ys({}, [aw, N2, Gh], LC);
    let uv = null;
    const LN = ["application/xhtml+xml", "text/html"];
    let Kc = null, iw = null;
    const lw = l.createElement("form"), PN = function(Ue) {
      return Ue instanceof RegExp || Ue instanceof Function;
    }, B2 = function() {
      let Ue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!iw || iw !== Ue) {
        if (
          /* Shield configuration object from tampering */
          Ue && typeof Ue == "object" || (Ue = {}), Ue = qb(Ue), uv = // eslint-disable-next-line unicorn/prefer-includes
          LN.indexOf(Ue.PARSER_MEDIA_TYPE) === -1 ? "text/html" : Ue.PARSER_MEDIA_TYPE, // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
          Kc = uv === "application/xhtml+xml" ? LC : Wb, /* Set configuration parameters */
          go = Em(Ue, "ALLOWED_TAGS") ? ys({}, Ue.ALLOWED_TAGS, Kc) : ui, qs = Em(Ue, "ALLOWED_ATTR") ? ys({}, Ue.ALLOWED_ATTR, Kc) : qu, M2 = Em(Ue, "ALLOWED_NAMESPACES") ? ys({}, Ue.ALLOWED_NAMESPACES, LC) : BN, Z3 = Em(Ue, "ADD_URI_SAFE_ATTR") ? ys(
            qb(MN),
            // eslint-disable-line indent
            Ue.ADD_URI_SAFE_ATTR,
            // eslint-disable-line indent
            Kc
          ) : MN, U3 = Em(Ue, "ADD_DATA_URI_TAGS") ? ys(
            qb(j3),
            // eslint-disable-line indent
            Ue.ADD_DATA_URI_TAGS,
            // eslint-disable-line indent
            Kc
          ) : j3, gf = Em(Ue, "FORBID_CONTENTS") ? ys({}, Ue.FORBID_CONTENTS, Kc) : NN, Ui = Em(Ue, "FORBID_TAGS") ? ys({}, Ue.FORBID_TAGS, Kc) : {}, Gu = Em(Ue, "FORBID_ATTR") ? ys({}, Ue.FORBID_ATTR, Kc) : {}, vp = !!Em(Ue, "USE_PROFILES") && Ue.USE_PROFILES, iv = Ue.ALLOW_ARIA_ATTR !== !1, // Default true
          V1 = Ue.ALLOW_DATA_ATTR !== !1, // Default true
          R2 = Ue.ALLOW_UNKNOWN_PROTOCOLS || !1, // Default false
          ow = Ue.ALLOW_SELF_CLOSE_IN_ATTR !== !1, // Default true
          _y = Ue.SAFE_FOR_TEMPLATES || !1, // Default false
          Cy = Ue.SAFE_FOR_XML !== !1, // Default true
          Kg = Ue.WHOLE_DOCUMENT || !1, // Default false
          Yg = Ue.RETURN_DOM || !1, // Default false
          qh = Ue.RETURN_DOM_FRAGMENT || !1, // Default false
          lv = Ue.RETURN_TRUSTED_TYPE || !1, // Default false
          j1 = Ue.FORCE_BODY || !1, // Default false
          rw = Ue.SANITIZE_DOM !== !1, // Default true
          sw = Ue.SANITIZE_NAMED_PROPS || !1, // Default false
          cv = Ue.KEEP_CONTENT !== !1, // Default true
          is = Ue.IN_PLACE || !1, // Default false
          Fl = Ue.ALLOWED_URI_REGEXP || jp, to = Ue.NAMESPACE || Gh, Er = Ue.CUSTOM_ELEMENT_HANDLING || {}, Ue.CUSTOM_ELEMENT_HANDLING && PN(Ue.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Er.tagNameCheck = Ue.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Ue.CUSTOM_ELEMENT_HANDLING && PN(Ue.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Er.attributeNameCheck = Ue.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Ue.CUSTOM_ELEMENT_HANDLING && typeof Ue.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Er.allowCustomizedBuiltInElements = Ue.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), _y && (V1 = !1), qh && (Yg = !0), vp && (go = ys({}, UC), qs = [], vp.html === !0 && (ys(go, $C), ys(qs, Lh)), vp.svg === !0 && (ys(go, Fv), ys(qs, $v), ys(qs, p1)), vp.svgFilters === !0 && (ys(go, Gb), ys(qs, $v), ys(qs, p1)), vp.mathMl === !0 && (ys(go, VC), ys(qs, fk), ys(qs, p1))), Ue.ADD_TAGS && (go === ui && (go = qb(go)), ys(go, Ue.ADD_TAGS, Kc)), Ue.ADD_ATTR && (qs === qu && (qs = qb(qs)), ys(qs, Ue.ADD_ATTR, Kc)), Ue.ADD_URI_SAFE_ATTR && ys(Z3, Ue.ADD_URI_SAFE_ATTR, Kc), Ue.FORBID_CONTENTS && (gf === NN && (gf = qb(gf)), ys(gf, Ue.FORBID_CONTENTS, Kc)), cv && (go["#text"] = !0), Kg && ys(go, ["html", "head", "body"]), go.table && (ys(go, ["tbody"]), delete Ui.tbody), Ue.TRUSTED_TYPES_POLICY
        ) {
          if (typeof Ue.TRUSTED_TYPES_POLICY.createHTML != "function")
            throw m1('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
          if (typeof Ue.TRUSTED_TYPES_POLICY.createScriptURL != "function")
            throw m1('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
          me = Ue.TRUSTED_TYPES_POLICY, // Sign local variables required by `sanitize`.
          ke = me.createHTML("");
        } else
          me === void 0 && (me = function(Ho, mo) {
            if (typeof Ho != "object" || typeof Ho.createPolicy != "function")
              return null;
            let Gs = null;
            const Da = "data-tt-policy-suffix";
            mo && mo.hasAttribute(Da) && (Gs = mo.getAttribute(Da));
            const Cs = "dompurify" + (Gs ? "#" + Gs : "");
            try {
              return Ho.createPolicy(Cs, { createHTML: (Bc) => Bc, createScriptURL: (Bc) => Bc });
            } catch {
              return console.warn("TrustedTypes policy " + Cs + " could not be created."), null;
            }
          }(Z, m)), // If creating the internal policy succeeded sign internal variables.
          me !== null && typeof ke == "string" && (ke = me.createHTML(""));
        $u && $u(Ue), iw = Ue;
      }
    }, IN = ys({}, ["mi", "mo", "mn", "ms", "mtext"]), FN = ys({}, ["annotation-xml"]), hP = ys({}, ["title", "style", "font", "a", "script"]), W3 = ys({}, [...Fv, ...Gb, ...HC]), L2 = ys({}, [...VC, ...Y5]), Qp = function(Ue) {
      Pg(i.removed, { element: Ue });
      try {
        le(Ue).removeChild(Ue);
      } catch {
        fe(Ue);
      }
    }, cw = function(Ue, Ho) {
      try {
        Pg(i.removed, { attribute: Ho.getAttributeNode(Ue), from: Ho });
      } catch {
        Pg(i.removed, { attribute: null, from: Ho });
      }
      if (Ho.removeAttribute(Ue), Ue === "is" && !qs[Ue])
        if (Yg || qh)
          try {
            Qp(Ho);
          } catch {
          }
        else
          try {
            Ho.setAttribute(Ue, "");
          } catch {
          }
    }, $N = function(Ue) {
      let Ho = null, mo = null;
      if (j1)
        Ue = "<remove></remove>" + Ue;
      else {
        const Cs = RT(Ue, /^[\r\n\t ]+/);
        mo = Cs && Cs[0];
      }
      uv === "application/xhtml+xml" && to === Gh && // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
      (Ue = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Ue + "</body></html>");
      const Gs = me ? me.createHTML(Ue) : Ue;
      if (to === Gh)
        try {
          Ho = new $().parseFromString(Gs, uv);
        } catch {
        }
      if (!Ho || !Ho.documentElement) {
        Ho = Re.createDocument(to, "template", null);
        try {
          Ho.documentElement.innerHTML = Z1 ? ke : Gs;
        } catch {
        }
      }
      const Da = Ho.body || Ho.documentElement;
      return Ue && mo && Da.insertBefore(l.createTextNode(mo), Da.childNodes[0] || null), to === Gh ? bt.call(Ho, Kg ? "html" : "body")[0] : Kg ? Ho.documentElement : Da;
    }, HN = function(Ue) {
      return qe.call(
        Ue.ownerDocument || Ue,
        Ue,
        // eslint-disable-next-line no-bitwise
        O.SHOW_ELEMENT | O.SHOW_COMMENT | O.SHOW_TEXT | O.SHOW_PROCESSING_INSTRUCTION | O.SHOW_CDATA_SECTION,
        null
      );
    }, VN = function(Ue) {
      return Ue instanceof B && (typeof Ue.nodeName != "string" || typeof Ue.textContent != "string" || typeof Ue.removeChild != "function" || !(Ue.attributes instanceof A) || typeof Ue.removeAttribute != "function" || typeof Ue.setAttribute != "function" || typeof Ue.namespaceURI != "string" || typeof Ue.insertBefore != "function" || typeof Ue.hasChildNodes != "function");
    }, UN = function(Ue) {
      return typeof w == "function" && Ue instanceof w;
    }, Xg = function(Ue, Ho, mo) {
      Qt[Ue] && dk(Qt[Ue], (Gs) => {
        Gs.call(i, Ho, mo, iw);
      });
    }, jN = function(Ue) {
      let Ho = null;
      if (Xg("beforeSanitizeElements", Ue, null), VN(Ue))
        return Qp(Ue), !0;
      const mo = Kc(Ue.nodeName);
      if (Xg("uponSanitizeElement", Ue, { tagName: mo, allowedTags: go }), Ue.hasChildNodes() && !UN(Ue.firstElementChild) && uu(/<[/\w]/g, Ue.innerHTML) && uu(/<[/\w]/g, Ue.textContent) || Ue.nodeType === 7 || Cy && Ue.nodeType === 8 && uu(/<[/\w]/g, Ue.data))
        return Qp(Ue), !0;
      if (!go[mo] || Ui[mo]) {
        if (!Ui[mo] && WN(mo) && (Er.tagNameCheck instanceof RegExp && uu(Er.tagNameCheck, mo) || Er.tagNameCheck instanceof Function && Er.tagNameCheck(mo)))
          return !1;
        if (cv && !gf[mo]) {
          const Gs = le(Ue) || Ue.parentNode, Da = J(Ue) || Ue.childNodes;
          if (Da && Gs)
            for (let Cs = Da.length - 1; Cs >= 0; --Cs) {
              const Bc = re(Da[Cs], !0);
              Bc.__removalCount = (Ue.__removalCount || 0) + 1, Gs.insertBefore(Bc, ee(Ue));
            }
        }
        return Qp(Ue), !0;
      }
      return Ue instanceof E && !function(Gs) {
        let Da = le(Gs);
        Da && Da.tagName || (Da = { namespaceURI: to, tagName: "template" });
        const Cs = Wb(Gs.tagName), Bc = Wb(Da.tagName);
        return !!M2[Gs.namespaceURI] && (Gs.namespaceURI === N2 ? (
          // The only way to switch from HTML namespace to SVG
          // is via <svg>. If it happens via any other tag, then
          // it should be killed.
          Da.namespaceURI === Gh ? Cs === "svg" : (
            // The only way to switch from MathML to SVG is via`
            // svg if parent is either <annotation-xml> or MathML
            // text integration points.
            Da.namespaceURI === aw ? Cs === "svg" && (Bc === "annotation-xml" || IN[Bc]) : !!W3[Cs]
          )
        ) : Gs.namespaceURI === aw ? (
          // The only way to switch from HTML namespace to MathML
          // is via <math>. If it happens via any other tag, then
          // it should be killed.
          Da.namespaceURI === Gh ? Cs === "math" : (
            // The only way to switch from SVG to MathML is via
            // <math> and HTML integration points
            Da.namespaceURI === N2 ? Cs === "math" && FN[Bc] : !!L2[Cs]
          )
        ) : Gs.namespaceURI === Gh ? (
          // The only way to switch from SVG to HTML is via
          // HTML integration points, and from MathML to HTML
          // is via MathML text integration points
          !(Da.namespaceURI === N2 && !FN[Bc]) && !(Da.namespaceURI === aw && !IN[Bc]) && !L2[Cs] && (hP[Cs] || !W3[Cs])
        ) : !(uv !== "application/xhtml+xml" || !M2[Gs.namespaceURI]));
      }(Ue) ? (Qp(Ue), !0) : (
        /* Make sure that older browsers don't get fallback-tag mXSS */
        mo !== "noscript" && mo !== "noembed" && mo !== "noframes" || !uu(/<\/no(script|embed|frames)/i, Ue.innerHTML) ? (
          /* Sanitize element content to be template-safe */
          (_y && Ue.nodeType === 3 && /* Get the element's text content */
          (Ho = Ue.textContent, dk([vn, Mn, Qn], (Gs) => {
            Ho = y0(Ho, Gs, " ");
          }), Ue.textContent !== Ho && (Pg(i.removed, { element: Ue.cloneNode() }), Ue.textContent = Ho)), Xg("afterSanitizeElements", Ue, null), !1)
        ) : (Qp(Ue), !0)
      );
    }, ZN = function(Ue, Ho, mo) {
      if (rw && (Ho === "id" || Ho === "name") && (mo in l || mo in lw))
        return !1;
      if (!(V1 && !Gu[Ho] && uu(fo, Ho))) {
        if (!(iv && uu($o, Ho))) {
          if (!qs[Ho] || Gu[Ho]) {
            if (
              // First condition does a very basic check if a) it's basically a valid custom element tagname AND
              // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
              !(WN(Ue) && (Er.tagNameCheck instanceof RegExp && uu(Er.tagNameCheck, Ue) || Er.tagNameCheck instanceof Function && Er.tagNameCheck(Ue)) && (Er.attributeNameCheck instanceof RegExp && uu(Er.attributeNameCheck, Ho) || Er.attributeNameCheck instanceof Function && Er.attributeNameCheck(Ho)) || // Alternative, second condition checks if it's an `is`-attribute, AND
              // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              Ho === "is" && Er.allowCustomizedBuiltInElements && (Er.tagNameCheck instanceof RegExp && uu(Er.tagNameCheck, mo) || Er.tagNameCheck instanceof Function && Er.tagNameCheck(mo)))
            )
              return !1;
          } else if (!Z3[Ho]) {
            if (!uu(Fl, y0(mo, ga, ""))) {
              if ((Ho !== "src" && Ho !== "xlink:href" && Ho !== "href" || Ue === "script" || PC(mo, "data:") !== 0 || !U3[Ue]) && !(R2 && !uu(Hs, y0(mo, ga, "")))) {
                if (mo)
                  return !1;
              }
            }
          }
        }
      }
      return !0;
    }, WN = function(Ue) {
      return Ue !== "annotation-xml" && RT(Ue, Xo);
    }, qN = function(Ue) {
      Xg("beforeSanitizeAttributes", Ue, null);
      const { attributes: Ho } = Ue;
      if (!Ho)
        return;
      const mo = { attrName: "", attrValue: "", keepAttr: !0, allowedAttributes: qs };
      let Gs = Ho.length;
      for (; Gs--; ) {
        const Da = Ho[Gs], { name: Cs, namespaceURI: Bc, value: Kh } = Da, Jg = Kc(Cs);
        let Ku = Cs === "value" ? Kh : IC(Kh);
        const yP = Ku;
        if (mo.attrName = Jg, mo.attrValue = Ku, mo.keepAttr = !0, mo.forceKeepAttr = void 0, // Allows developers to see this is a property they can set
        Xg("uponSanitizeAttribute", Ue, mo), Ku = mo.attrValue, mo.forceKeepAttr)
          continue;
        if (!mo.keepAttr) {
          cw(Cs, Ue);
          continue;
        }
        if (!ow && uu(/\/>/i, Ku)) {
          cw(Cs, Ue);
          continue;
        }
        _y && dk([vn, Mn, Qn], (KN) => {
          Ku = y0(Ku, KN, " ");
        });
        const GN = Kc(Ue.nodeName);
        if (ZN(GN, Jg, Ku))
          if (
            /* Full DOM Clobbering protection via namespace isolation,
                       * Prefix id and name attributes with `user-content-`
                       */
            !sw || Jg !== "id" && Jg !== "name" || // Remove the attribute with this value
            (cw(Cs, Ue), // Prefix the value and later re-create the attribute with the sanitized value
            Ku = "user-content-" + Ku), Cy && uu(/((--!?|])>)|<\/(style|title)/i, Ku)
          )
            cw(Cs, Ue);
          else {
            if (me && typeof Z == "object" && typeof Z.getAttributeType == "function" && !Bc)
              switch (Z.getAttributeType(GN, Jg)) {
                case "TrustedHTML":
                  Ku = me.createHTML(Ku);
                  break;
                case "TrustedScriptURL":
                  Ku = me.createScriptURL(Ku);
              }
            if (Ku !== yP)
              try {
                Bc ? Ue.setAttributeNS(Bc, Cs, Ku) : (
                  /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
                  Ue.setAttribute(Cs, Ku)
                ), VN(Ue) ? Qp(Ue) : BC(i.removed);
              } catch {
              }
          }
        else
          cw(Cs, Ue);
      }
      Xg("afterSanitizeAttributes", Ue, null);
    }, bP = function Ue(Ho) {
      let mo = null;
      const Gs = HN(Ho);
      for (Xg("beforeSanitizeShadowDOM", Ho, null); mo = Gs.nextNode(); )
        Xg("uponSanitizeShadowNode", mo, null), /* Sanitize tags and elements */
        jN(mo) || /* Deep shadow DOM detected */
        (mo.content instanceof b && Ue(mo.content), qN(mo));
      Xg("afterSanitizeShadowDOM", Ho, null);
    };
    return i.sanitize = function(Ue) {
      let Ho = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, mo = null, Gs = null, Da = null, Cs = null;
      if (
        /* Make sure we have a string to sanitize.
                  DO NOT return early, as this will return the wrong type if
                  the user has requested a DOM object rather than a string */
        Z1 = !Ue, Z1 && (Ue = "<!-->"), typeof Ue != "string" && !UN(Ue)
      ) {
        if (typeof Ue.toString != "function")
          throw m1("toString is not a function");
        if (typeof (Ue = Ue.toString()) != "string")
          throw m1("dirty is not a string, aborting");
      }
      if (!i.isSupported)
        return Ue;
      if (U1 || B2(Ho), i.removed = [], /* Check if dirty is correctly typed for IN_PLACE */
      typeof Ue == "string" && (is = !1), is) {
        if (Ue.nodeName) {
          const Jg = Kc(Ue.nodeName);
          if (!go[Jg] || Ui[Jg])
            throw m1("root node is forbidden and cannot be sanitized in-place");
        }
      } else if (Ue instanceof w)
        mo = $N("<!---->"), Gs = mo.ownerDocument.importNode(Ue, !0), Gs.nodeType === 1 && Gs.nodeName === "BODY" || Gs.nodeName === "HTML" ? (
          /* Node is already a body, use as is */
          mo = Gs
        ) : (
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          mo.appendChild(Gs)
        );
      else {
        if (!Yg && !_y && !Kg && // eslint-disable-next-line unicorn/prefer-includes
        Ue.indexOf("<") === -1)
          return me && lv ? me.createHTML(Ue) : Ue;
        if (mo = $N(Ue), !mo)
          return Yg ? null : lv ? ke : "";
      }
      mo && j1 && Qp(mo.firstChild);
      const Bc = HN(is ? Ue : mo);
      for (; Da = Bc.nextNode(); )
        jN(Da) || /* Shadow DOM detected, sanitize it */
        (Da.content instanceof b && bP(Da.content), qN(Da));
      if (is)
        return Ue;
      if (Yg) {
        if (qh)
          for (Cs = mt.call(mo.ownerDocument); mo.firstChild; )
            Cs.appendChild(mo.firstChild);
        else
          Cs = mo;
        return (qs.shadowroot || qs.shadowrootmode) && /*
                      AdoptNode() is not used because internal state is not reset
                      (e.g. the past names map of a HTMLFormElement), this is safe
                      in theory but we would rather not risk another attack vector.
                      The state that is cloned by importNode() is explicitly defined
                      by the specs.
                    */
        (Cs = St.call(f, Cs, !0)), Cs;
      }
      let Kh = Kg ? mo.outerHTML : mo.innerHTML;
      return Kg && go["!doctype"] && mo.ownerDocument && mo.ownerDocument.doctype && mo.ownerDocument.doctype.name && uu(jf, mo.ownerDocument.doctype.name) && (Kh = "<!DOCTYPE " + mo.ownerDocument.doctype.name + `>
` + Kh), _y && dk([vn, Mn, Qn], (Jg) => {
        Kh = y0(Kh, Jg, " ");
      }), me && lv ? me.createHTML(Kh) : Kh;
    }, /**
           * Public method to set the configuration once
           * setConfig
           *
           * @param {Object} cfg configuration object
           */
    i.setConfig = function() {
      B2(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}), U1 = !0;
    }, /**
           * Public method to remove the configuration
           * clearConfig
           *
           */
    i.clearConfig = function() {
      iw = null, U1 = !1;
    }, /**
           * Public method to check if an attribute value is valid.
           * Uses last set config, if any. Otherwise, uses config defaults.
           * isValidAttribute
           *
           * @param  {String} tag Tag name of containing element.
           * @param  {String} attr Attribute name.
           * @param  {String} value Attribute value.
           * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
           */
    i.isValidAttribute = function(Ue, Ho, mo) {
      iw || B2({});
      const Gs = Kc(Ue), Da = Kc(Ho);
      return ZN(Gs, Da, mo);
    }, /**
           * AddHook
           * Public method to add DOMPurify hooks
           *
           * @param {String} entryPoint entry point for the hook to add
           * @param {Function} hookFunction function to execute
           */
    i.addHook = function(Ue, Ho) {
      typeof Ho == "function" && (Qt[Ue] = Qt[Ue] || [], Pg(Qt[Ue], Ho));
    }, /**
           * RemoveHook
           * Public method to remove a DOMPurify hook at a given entryPoint
           * (pops it from the stack of hooks if more are present)
           *
           * @param {String} entryPoint entry point for the hook to remove
           * @return {Function} removed(popped) hook
           */
    i.removeHook = function(Ue) {
      if (Qt[Ue])
        return BC(Qt[Ue]);
    }, /**
           * RemoveHooks
           * Public method to remove all DOMPurify hooks at a given entryPoint
           *
           * @param  {String} entryPoint entry point for the hooks to remove
           */
    i.removeHooks = function(Ue) {
      Qt[Ue] && (Qt[Ue] = []);
    }, /**
           * RemoveAllHooks
           * Public method to remove all DOMPurify hooks
           */
    i.removeAllHooks = function() {
      Qt = {};
    }, i;
  }();
  const WC = (o) => tM().sanitize(o);
  var _d = tinymce.util.Tools.resolve("tinymce.util.I18n");
  const v0 = { indent: !0, outdent: !0, "table-insert-column-after": !0, "table-insert-column-before": !0, "paste-column-after": !0, "paste-column-before": !0, "unordered-list": !0, "list-bull-circle": !0, "list-bull-default": !0, "list-bull-square": !0 }, qC = "temporary-placeholder", pk = (o) => () => cn(o, qC).getOr("!not found!"), GC = (o, s) => {
    const i = o.toLowerCase();
    if (_d.isRtl()) {
      const l = ((f, m) => _l(f, m) ? f : ((b, x) => b + x)(f, m))(i, "-rtl");
      return _n(s, l) ? l : i;
    }
    return i;
  }, BT = (o, s) => cn(s, GC(o, s)), KC = (o, s) => {
    const i = s();
    return BT(o, i).getOrThunk(pk(i));
  }, gk = () => wo("add-focusable", [ss((o) => {
    hd(o.element, "svg").each((s) => eo(s, "focusable", "false"));
  })]), LT = (o, s, i, l) => {
    var f, m;
    const b = ((w) => !!_d.isRtl() && _n(v0, w))(s) ? ["tox-icon--flip"] : [], x = cn(i, GC(s, i)).or(l).getOrThunk(pk(i));
    return { dom: { tag: o.tag, attributes: (f = o.attributes) !== null && f !== void 0 ? f : {}, classes: o.classes.concat(b), innerHtml: x }, behaviours: $t([...(m = o.behaviours) !== null && m !== void 0 ? m : [], gk()]) };
  }, fp = (o, s, i, l = M.none()) => LT(s, o, i(), l), PT = { success: "checkmark", error: "warning", err: "error", warning: "warning", warn: "warning", info: "info" }, hk = Bu({ name: "Notification", factory: (o) => {
    const s = Ur({ dom: Bh(`<p>${WC(o.translationProvider(o.text))}</p>`), behaviours: $t([Jn.config({})]) }), i = (O) => ({ dom: { tag: "div", classes: ["tox-bar"], styles: { width: `${O}%` } } }), l = (O) => ({ dom: { tag: "div", classes: ["tox-text"], innerHtml: `${O}%` } }), f = Ur({ dom: { tag: "div", classes: o.progress ? ["tox-progress-bar", "tox-progress-indicator"] : ["tox-progress-bar"] }, components: [{ dom: { tag: "div", classes: ["tox-bar-container"] }, components: [i(0)] }, l(0)], behaviours: $t([Jn.config({})]) }), m = { updateProgress: (O, A) => {
      O.getSystem().isConnected() && f.getOpt(O).each((B) => {
        Jn.set(B, [{ dom: { tag: "div", classes: ["tox-bar-container"] }, components: [i(A)] }, l(A)]);
      });
    }, updateText: (O, A) => {
      if (O.getSystem().isConnected()) {
        const B = s.get(O);
        Jn.set(B, [Os(A)]);
      }
    } }, b = er([o.icon.toArray(), o.level.toArray(), o.level.bind((O) => M.from(PT[O])).toArray()]), x = Ur(bc.sketch({ dom: { tag: "button", classes: ["tox-notification__dismiss", "tox-button", "tox-button--naked", "tox-button--icon"] }, components: [fp("close", { tag: "span", classes: ["tox-icon"], attributes: { "aria-label": o.translationProvider("Close") } }, o.iconProvider)], action: (O) => {
      o.onAction(O);
    } })), w = ((O, A, B) => {
      const $ = B(), Z = Go(O, (oe) => _n($, GC(oe, $)));
      return LT({ tag: "div", classes: ["tox-notification__icon"] }, Z.getOr(qC), $, M.none());
    })(b, 0, o.iconProvider), E = [w, { dom: { tag: "div", classes: ["tox-notification__body"] }, components: [s.asSpec()], behaviours: $t([Jn.config({})]) }];
    return { uid: o.uid, dom: { tag: "div", attributes: { role: "alert" }, classes: o.level.map((O) => ["tox-notification", "tox-notification--in", `tox-notification--${O}`]).getOr(["tox-notification", "tox-notification--in"]) }, behaviours: $t([io.config({}), wo("notification-events", [ft(Oe(), (O) => {
      x.getOpt(O).each(io.focus);
    })])]), components: E.concat(o.progress ? [f.asSpec()] : []).concat(o.closeButton ? [x.asSpec()] : []), apis: m };
  }, configFields: [pr("level"), st("progress"), pr("icon"), st("onAction"), st("text"), st("iconProvider"), st("translationProvider"), rs("closeButton", !0)], apis: { updateProgress: (o, s, i) => {
    o.updateProgress(s, i);
  }, updateText: (o, s, i) => {
    o.updateText(s, i);
  } } });
  var Zf, x0, Ph = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), IT = tinymce.util.Tools.resolve("tinymce.EditorManager"), mp = tinymce.util.Tools.resolve("tinymce.Env");
  (function(o) {
    o.default = "wrap", o.floating = "floating", o.sliding = "sliding", o.scrolling = "scrolling";
  })(Zf || (Zf = {})), function(o) {
    o.auto = "auto", o.top = "top", o.bottom = "bottom";
  }(x0 || (x0 = {}));
  const Xr = (o) => (s) => s.options.get(o), Hv = (o) => (s) => M.from(o(s)), FT = (o) => {
    const s = mp.deviceType.isPhone(), i = mp.deviceType.isTablet() || s, l = o.options.register, f = (b) => ce(b) || b === !1, m = (b) => ce(b) || en(b);
    l("skin", { processor: (b) => ce(b) || b === !1, default: "oxide" }), l("skin_url", { processor: "string" }), l("height", { processor: m, default: Math.max(o.getElement().offsetHeight, 400) }), l("width", { processor: m, default: Ph.DOM.getStyle(o.getElement(), "width") }), l("min_height", { processor: "number", default: 100 }), l("min_width", { processor: "number" }), l("max_height", { processor: "number" }), l("max_width", { processor: "number" }), l("style_formats", { processor: "object[]" }), l("style_formats_merge", { processor: "boolean", default: !1 }), l("style_formats_autohide", { processor: "boolean", default: !1 }), l("line_height_formats", { processor: "string", default: "1 1.1 1.2 1.3 1.4 1.5 2" }), l("font_family_formats", { processor: "string", default: "Andale Mono=andale mono,monospace;Arial=arial,helvetica,sans-serif;Arial Black=arial black,sans-serif;Book Antiqua=book antiqua,palatino,serif;Comic Sans MS=comic sans ms,sans-serif;Courier New=courier new,courier,monospace;Georgia=georgia,palatino,serif;Helvetica=helvetica,arial,sans-serif;Impact=impact,sans-serif;Symbol=symbol;Tahoma=tahoma,arial,helvetica,sans-serif;Terminal=terminal,monaco,monospace;Times New Roman=times new roman,times,serif;Trebuchet MS=trebuchet ms,geneva,sans-serif;Verdana=verdana,geneva,sans-serif;Webdings=webdings;Wingdings=wingdings,zapf dingbats" }), l("font_size_formats", { processor: "string", default: "8pt 10pt 12pt 14pt 18pt 24pt 36pt" }), l("font_size_input_default_unit", { processor: "string", default: "pt" }), l("block_formats", { processor: "string", default: "Paragraph=p;Heading 1=h1;Heading 2=h2;Heading 3=h3;Heading 4=h4;Heading 5=h5;Heading 6=h6;Preformatted=pre" }), l("content_langs", { processor: "object[]" }), l("removed_menuitems", { processor: "string", default: "" }), l("menubar", { processor: (b) => ce(b) || Ye(b), default: !s }), l("menu", { processor: "object", default: {} }), l("toolbar", { processor: (b) => Ye(b) || ce(b) || Me(b) ? { value: b, valid: !0 } : { valid: !1, message: "Must be a boolean, string or array." }, default: !0 }), Tt(9, (b) => {
      l("toolbar" + (b + 1), { processor: "string" });
    }), l("toolbar_mode", { processor: "string", default: i ? "scrolling" : "floating" }), l("toolbar_groups", { processor: "object", default: {} }), l("toolbar_location", { processor: "string", default: x0.auto }), l("toolbar_persist", { processor: "boolean", default: !1 }), l("toolbar_sticky", { processor: "boolean", default: o.inline }), l("toolbar_sticky_offset", { processor: "number", default: 0 }), l("fixed_toolbar_container", { processor: "string", default: "" }), l("fixed_toolbar_container_target", { processor: "object" }), l("ui_mode", { processor: "string", default: "combined" }), l("file_picker_callback", { processor: "function" }), l("file_picker_validator_handler", { processor: "function" }), l("file_picker_types", { processor: "string" }), l("typeahead_urls", { processor: "boolean", default: !0 }), l("anchor_top", { processor: f, default: "#top" }), l("anchor_bottom", { processor: f, default: "#bottom" }), l("draggable_modal", { processor: "boolean", default: !1 }), l("statusbar", { processor: "boolean", default: !0 }), l("elementpath", { processor: "boolean", default: !0 }), l("branding", { processor: "boolean", default: !0 }), l("promotion", { processor: "boolean", default: !0 }), l("resize", { processor: (b) => b === "both" || Ye(b), default: !mp.deviceType.isTouch() }), l("sidebar_show", { processor: "string" }), l("help_accessibility", { processor: "boolean", default: o.hasPlugin("help") }), l("default_font_stack", { processor: "string[]", default: [] });
  }, $T = Xr("readonly"), YC = Xr("height"), bk = Xr("width"), XC = Hv(Xr("min_width")), yk = Hv(Xr("min_height")), vk = Hv(Xr("max_width")), JC = Hv(Xr("max_height")), QC = Hv(Xr("style_formats")), w0 = Xr("style_formats_merge"), eS = Xr("style_formats_autohide"), HT = Xr("content_langs"), VT = Xr("removed_menuitems"), k0 = Xr("toolbar_mode"), UT = Xr("toolbar_groups"), tS = Xr("toolbar_location"), nM = Xr("fixed_toolbar_container"), oM = Xr("fixed_toolbar_container_target"), jT = Xr("toolbar_persist"), ZT = Xr("toolbar_sticky_offset"), WT = Xr("menubar"), xk = Xr("toolbar"), nS = Xr("file_picker_callback"), oS = Xr("file_picker_validator_handler"), rS = Xr("font_size_input_default_unit"), qT = Xr("file_picker_types"), sS = Xr("typeahead_urls"), GT = Xr("anchor_top"), aS = Xr("anchor_bottom"), KT = Xr("draggable_modal"), YT = Xr("statusbar"), XT = Xr("elementpath"), iS = Xr("branding"), JT = Xr("resize"), lS = Xr("paste_as_text"), QT = Xr("sidebar_show"), yn = Xr("promotion"), Kb = Xr("help_accessibility"), ez = Xr("default_font_stack"), wk = (o) => o.options.get("skin") === !1, g1 = (o) => o.options.get("menubar") !== !1, _0 = (o) => {
    const s = o.options.get("skin_url");
    if (wk(o))
      return s;
    if (s)
      return o.documentBaseURI.toAbsolute(s);
    {
      const i = o.options.get("skin");
      return IT.baseURL + "/skins/ui/" + i;
    }
  }, kk = (o) => M.from(o.options.get("skin_url")), cS = (o) => o.options.get("line_height_formats").split(" "), _k = (o) => {
    const s = xk(o), i = ce(s), l = Me(s) && s.length > 0;
    return !C0(o) && (l || i || s === !0);
  }, uS = (o) => {
    const s = Tt(9, (l) => o.options.get("toolbar" + (l + 1))), i = Pn(s, ce);
    return mi(i.length > 0, i);
  }, C0 = (o) => uS(o).fold(() => {
    const s = xk(o);
    return Gt(s, ce) && s.length > 0;
  }, un), Vv = (o) => tS(o) === x0.bottom, S0 = (o) => {
    var s;
    if (!o.inline)
      return M.none();
    const i = (s = nM(o)) !== null && s !== void 0 ? s : "";
    if (i.length > 0)
      return fa(Wa(), i);
    const l = oM(o);
    return it(l) ? M.some(Xt(l)) : M.none();
  }, h1 = (o) => o.inline && S0(o).isSome(), dS = (o) => S0(o).getOrThunk(() => Ma(us(Xt(o.getElement())))), fS = (o) => o.inline && !g1(o) && !_k(o) && !C0(o), Uv = (o) => (o.options.get("toolbar_sticky") || o.inline) && !h1(o) && !fS(o), b1 = (o) => !h1(o) && o.options.get("ui_mode") === "split", mS = (o) => {
    const s = o.options.get("menu");
    return ho(s, (i) => ({ ...i, items: i.items }));
  };
  var rM = Object.freeze({ __proto__: null, get ToolbarMode() {
    return Zf;
  }, get ToolbarLocation() {
    return x0;
  }, register: FT, getSkinUrl: _0, getSkinUrlOption: kk, isReadOnly: $T, isSkinDisabled: wk, getHeightOption: YC, getWidthOption: bk, getMinWidthOption: XC, getMinHeightOption: yk, getMaxWidthOption: vk, getMaxHeightOption: JC, getUserStyleFormats: QC, shouldMergeStyleFormats: w0, shouldAutoHideStyleFormats: eS, getLineHeightFormats: cS, getContentLanguages: HT, getRemovedMenuItems: VT, isMenubarEnabled: g1, isMultipleToolbars: C0, isToolbarEnabled: _k, isToolbarPersist: jT, getMultipleToolbarsOption: uS, getUiContainer: dS, useFixedContainer: h1, isSplitUiMode: b1, getToolbarMode: k0, isDraggableModal: KT, isDistractionFree: fS, isStickyToolbar: Uv, getStickyToolbarOffset: ZT, getToolbarLocation: tS, isToolbarLocationBottom: Vv, getToolbarGroups: UT, getMenus: mS, getMenubar: WT, getToolbar: xk, getFilePickerCallback: nS, getFilePickerTypes: qT, useTypeaheadUrls: sS, getAnchorTop: GT, getAnchorBottom: aS, getFilePickerValidatorHandler: oS, getFontSizeInputDefaultUnit: rS, useStatusBar: YT, useElementPath: XT, promotionEnabled: yn, useBranding: iS, getResize: JT, getPasteAsText: lS, getSidebarShow: QT, useHelpAccessibility: Kb, getDefaultFontStack: ez });
  const tz = "[data-mce-autocompleter]", nz = (o) => Ou(o, tz);
  var pS;
  (function(o) {
    o[o.CLOSE_ON_EXECUTE = 0] = "CLOSE_ON_EXECUTE", o[o.BUBBLE_TO_SANDBOX = 1] = "BUBBLE_TO_SANDBOX";
  })(pS || (pS = {}));
  var Tm = pS;
  const gS = "tox-menu-nav__js", Ck = "tox-collection__item", oz = "tox-swatch", sM = { normal: gS, color: oz }, rz = "tox-collection__item--enabled", Ig = "tox-collection__item-icon", E0 = "tox-collection__item-label", sz = "tox-collection__item-caret", jv = "tox-collection__item--active", az = "tox-collection__item-container", iz = "tox-collection__item-container--row", lz = (o) => cn(sM, o).getOr(gS), aM = (o) => o === "color" ? "tox-swatches" : "tox-menu", hS = (o) => ({ backgroundMenu: "tox-background-menu", selectedMenu: "tox-selected-menu", selectedItem: "tox-collection__item--active", hasIcons: "tox-menu--has-icons", menu: aM(o), tieredMenu: "tox-tiered-menu" }), pp = (o) => {
    const s = hS(o);
    return { backgroundMenu: s.backgroundMenu, selectedMenu: s.selectedMenu, menu: s.menu, selectedItem: s.selectedItem, item: lz(o) };
  }, Sk = (o, s, i) => {
    const l = hS(i);
    return { tag: "div", classes: er([[l.menu, `tox-menu-${s}-column`], o ? [l.hasIcons] : []]) };
  }, iM = [Lg.parts.items({})], Zv = (o, s, i) => {
    const l = hS(i);
    return { dom: { tag: "div", classes: er([[l.tieredMenu]]) }, markers: pp(i) };
  }, cz = Ee([pr("data"), He("inputAttributes", {}), He("inputStyles", {}), He("tag", "input"), He("inputClasses", []), Vo("onSetValue"), He("styles", {}), He("eventOrder", {}), pa("inputBehaviours", [ln, io]), He("selectOnFocus", !0)]), Ek = (o) => $t([io.config({ onFocus: o.selectOnFocus ? (s) => {
    const i = s.element, l = zu(i);
    i.dom.setSelectionRange(0, l.length);
  } : gt })]), lM = (o) => ({ ...Ek(o), ...Fi(o.inputBehaviours, [ln.config({ store: { mode: "manual", ...o.data.map((s) => ({ initialValue: s })).getOr({}), getValue: (s) => zu(s.element), setValue: (s, i) => {
    zu(s.element) !== i && dm(s.element, i);
  } }, onSetValue: o.onSetValue })]) }), uz = (o) => ({ tag: o.tag, attributes: { type: "text", ...o.inputAttributes }, styles: o.inputStyles, classes: o.inputClasses }), Yb = Bu({ name: "Input", configFields: cz(), factory: (o, s) => ({ uid: o.uid, dom: uz(o), components: [], behaviours: lM(o), eventOrder: o.eventOrder }) }), Tk = hn("refetch-trigger-event"), dz = hn("redirect-menu-item-interaction"), bS = "tox-menu__searcher", zk = (o) => fa(o.element, `.${bS}`).bind((s) => o.getSystem().getByDom(s).toOptional()), fz = zk, yS = (o) => ({ fetchPattern: ln.getValue(o), selectionStart: o.element.dom.selectionStart, selectionEnd: o.element.dom.selectionEnd }), cM = (o) => {
    const s = (f, m) => (m.cut(), M.none()), i = (f, m) => {
      const b = { interactionEvent: m.event, eventType: m.event.raw.type };
      return pn(f, dz, b), M.some(!0);
    }, l = "searcher-events";
    return { dom: { tag: "div", classes: [Ck] }, components: [Yb.sketch({ inputClasses: [bS, "tox-textfield"], inputAttributes: { ...o.placeholder.map((f) => ({ placeholder: o.i18n(f) })).getOr({}), type: "search", "aria-autocomplete": "list" }, inputBehaviours: $t([wo(l, [ft(Hn(), (f) => {
      Io(f, Tk);
    }), ft(bn(), (f, m) => {
      m.event.raw.key === "Escape" && m.stop();
    })]), Jt.config({ mode: "special", onLeft: s, onRight: s, onSpace: s, onEnter: i, onEscape: i, onUp: i, onDown: i })]), eventOrder: { keydown: [l, Jt.name()] } })] };
  }, Ok = "tox-collection--results__js", Ak = (o) => {
    var s;
    return o.dom ? { ...o, dom: { ...o.dom, attributes: { ...(s = o.dom.attributes) !== null && s !== void 0 ? s : {}, id: hn("aria-item-search-result-id"), "aria-selected": "false" } } } : o;
  }, Dk = (o, s) => (i) => {
    const l = yo(i, s);
    return Ct(l, (f) => ({ dom: o, components: f }));
  }, Wv = (o, s) => {
    const i = [];
    let l = [];
    return tn(o, (f, m) => {
      s(f, m) ? (l.length > 0 && i.push(l), l = [], (_n(f.dom, "innerHtml") || f.components && f.components.length > 0) && l.push(f)) : l.push(f);
    }), l.length > 0 && i.push(l), Ct(i, (f) => ({ dom: { tag: "div", classes: ["tox-collection__group"] }, components: f }));
  }, T0 = (o, s, i) => Lg.parts.items({ preprocess: (l) => {
    const f = Ct(l, i);
    return o !== "auto" && o > 1 ? Dk({ tag: "div", classes: ["tox-collection__group"] }, o)(f) : Wv(f, (m, b) => s[b].type === "separator");
  } }), qv = (o, s, i = !0) => ({ dom: { tag: "div", classes: ["tox-menu", "tox-collection"].concat(o === 1 ? ["tox-collection--list"] : ["tox-collection--grid"]) }, components: [T0(o, s, wt)] }), Fg = (o) => jr(o, (s) => "icon" in s && s.icon !== void 0), Xb = (o) => (console.error(nu(o)), console.log(o), M.none()), uM = (o, s, i, l, f) => {
    const m = (b = i, { dom: { tag: "div", classes: ["tox-collection", "tox-collection--horizontal"] }, components: [Lg.parts.items({ preprocess: (x) => Wv(x, (w, E) => b[E].type === "separator") })] });
    var b;
    return { value: o, dom: m.dom, components: m.components, items: i };
  }, vS = (o, s, i, l, f) => {
    if (f.menuType === "color") {
      const m = ((b) => ({ dom: { tag: "div", classes: ["tox-menu", "tox-swatches-menu"] }, components: [{ dom: { tag: "div", classes: ["tox-swatches"] }, components: [Lg.parts.items({ preprocess: b !== "auto" ? Dk({ tag: "div", classes: ["tox-swatches__row"] }, b) : wt })] }] }))(l);
      return { value: o, dom: m.dom, components: m.components, items: i };
    }
    if (f.menuType === "normal" && l === "auto") {
      const m = qv(l, i);
      return { value: o, dom: m.dom, components: m.components, items: i };
    }
    if (f.menuType === "normal" || f.menuType === "searchable") {
      const m = f.menuType !== "searchable" ? qv(l, i) : f.searchMode.searchMode === "search-with-field" ? ((b, x, w) => {
        const E = hn("aria-controls-search-results");
        return { dom: { tag: "div", classes: ["tox-menu", "tox-collection"].concat(b === 1 ? ["tox-collection--list"] : ["tox-collection--grid"]) }, components: [cM({ i18n: _d.translate, placeholder: w.placeholder }), { dom: { tag: "div", classes: [...b === 1 ? ["tox-collection--list"] : ["tox-collection--grid"], Ok], attributes: { id: E } }, components: [T0(b, x, Ak)] }] };
      })(l, i, f.searchMode) : ((b, x, w = !0) => {
        const E = hn("aria-controls-search-results");
        return { dom: { tag: "div", classes: ["tox-menu", "tox-collection", Ok].concat(b === 1 ? ["tox-collection--list"] : ["tox-collection--grid"]), attributes: { id: E } }, components: [T0(b, x, Ak)] };
      })(l, i);
      return { value: o, dom: m.dom, components: m.components, items: i };
    }
    if (f.menuType === "listpreview" && l !== "auto") {
      const m = ((b) => ({ dom: { tag: "div", classes: ["tox-menu", "tox-collection", "tox-collection--toolbar", "tox-collection--toolbar-lg"] }, components: [Lg.parts.items({ preprocess: Dk({ tag: "div", classes: ["tox-collection__group"] }, b) })] }))(l);
      return { value: o, dom: m.dom, components: m.components, items: i };
    }
    return { value: o, dom: Sk(s, l, f.menuType), components: iM, items: i };
  }, ci = Is("type"), Rk = Is("name"), xS = Is("label"), Jb = Is("text"), dM = Is("title"), mz = Is("icon"), Gv = Is("value"), wS = Ia("fetch"), fM = Ia("getSubmenuItems"), z0 = Ia("onAction"), mM = Ia("onItemAction"), Qb = fs("onSetup", () => gt), pM = Nr("name"), ey = Nr("text"), Wf = Nr("icon"), Kv = Nr("tooltip"), kS = Nr("label"), pz = Nr("shortcut"), gM = Vl("select"), O0 = rs("active", !1), gz = rs("borderless", !1), zm = rs("enabled", !0), Yv = rs("primary", !1), hz = (o) => He("columns", o), _S = He("meta", {}), CS = fs("onAction", gt), y1 = (o) => Al("type", o), SS = (o) => Qs("name", "name", Ai(() => hn(`${o}-name`)), xa), A0 = Nn([ci, ey]), bz = Nn([y1("autocompleteitem"), O0, zm, _S, Gv, ey, Wf]), D0 = [zm, Kv, Wf, ey, Qb], ES = Nn([ci, z0].concat(D0)), yz = (o) => Gr("toolbarbutton", ES, o), Nk = [O0].concat(D0), hM = Nn(Nk.concat([ci, z0])), TS = (o) => Gr("ToggleButton", hM, o), zS = [fs("predicate", Xe), Fs("scope", "node", ["node", "editor"]), Fs("position", "selection", ["node", "selection", "line"])], bM = D0.concat([y1("contextformbutton"), Yv, z0, ua("original", wt)]), yM = Nk.concat([y1("contextformbutton"), Yv, z0, ua("original", wt)]), vM = D0.concat([y1("contextformbutton")]), xM = Nk.concat([y1("contextformtogglebutton")]), wM = bi("type", { contextformbutton: bM, contextformtogglebutton: yM }), kM = Nn([y1("contextform"), fs("initValue", Ee("")), kS, Ka("commands", wM), Hl("launch", bi("type", { contextformbutton: vM, contextformtogglebutton: xM }))].concat(zS)), OS = Nn([y1("contexttoolbar"), Is("items")].concat(zS)), AS = [ci, Is("src"), Nr("alt"), Ir("classes", [], xa)], _M = Nn(AS), M8 = [ci, Jb, pM, Ir("classes", ["tox-collection__item-label"], xa)], vz = Nn(M8), xz = Br(() => ku("type", { cardimage: _M, cardtext: vz, cardcontainer: CM })), CM = Nn([ci, Al("direction", "horizontal"), Al("align", "left"), Al("valign", "middle"), Ka("items", xz)]), du = [zm, ey, pz, Qs("value", "value", Ai(() => hn("menuitem-value")), Pr()), _S], SM = Nn([ci, kS, Ka("items", xz), Qb, CS].concat(du)), EM = Nn([ci, O0, Wf].concat(du)), wz = [ci, Is("fancytype"), CS], TM = [He("initData", {})].concat(wz), zM = [Vl("select"), im("initData", {}, [rs("allowCustomColors", !0), Al("storageKey", "default"), Ya("colors", Pr())])].concat(wz), R0 = bi("fancytype", { inserttable: TM, colorswatch: zM }), DS = Nn([ci, Qb, CS, Wf].concat(du)), OM = Nn([ci, fM, Qb, Wf].concat(du)), RS = Nn([ci, Wf, O0, Qb, z0].concat(du)), N0 = (o, s, i) => {
    const l = Kl(o.element, "." + i);
    if (l.length > 0) {
      const f = Zi(l, (m) => {
        const b = m.dom.getBoundingClientRect().top, x = l[0].dom.getBoundingClientRect().top;
        return Math.abs(b - x) > s;
      }).getOr(l.length);
      return M.some({ numColumns: f, numRows: Math.ceil(l.length / f) });
    }
    return M.none();
  }, v1 = (o) => ((s, i) => $t([wo(s, i)]))(hn("unnamed-events"), o), kz = hn("tooltip.exclusive"), Xv = hn("tooltip.show"), Jv = hn("tooltip.hide"), _z = (o, s, i) => {
    o.getSystem().broadcastOn([kz], {});
  };
  var AM = Object.freeze({ __proto__: null, hideAllExclusive: _z, setComponents: (o, s, i, l) => {
    i.getTooltip().each((f) => {
      f.getSystem().isConnected() && Jn.set(f, l);
    });
  } }), DM = Object.freeze({ __proto__: null, events: (o, s) => {
    const i = (l) => {
      s.getTooltip().each((f) => {
        Cm(f), o.onHide(l, f), s.clearTooltip();
      }), s.clearTimer();
    };
    return Bo(er([[ft(Xv, (l) => {
      s.resetTimer(() => {
        ((f) => {
          if (!s.isShowing()) {
            _z(f);
            const m = o.lazySink(f).getOrDie(), b = f.getSystem().build({ dom: o.tooltipDom, components: o.tooltipComponents, events: Bo(o.mode === "normal" ? [ft(_e(), (x) => {
              Io(f, Xv);
            }), ft(F(), (x) => {
              Io(f, Jv);
            })] : []), behaviours: $t([Jn.config({})]) });
            s.setTooltip(b), sp(m, b), o.onShow(f, b), Ll.position(m, b, { anchor: o.anchor(f) });
          }
        })(l);
      }, o.delay);
    }), ft(Jv, (l) => {
      s.resetTimer(() => {
        i(l);
      }, o.delay);
    }), ft(ta(), (l, f) => {
      const m = f;
      m.universal || Bn(m.channels, kz) && i(l);
    }), ud((l) => {
      i(l);
    })], o.mode === "normal" ? [ft(Oe(), (l) => {
      Io(l, Xv);
    }), ft(Im(), (l) => {
      Io(l, Jv);
    }), ft(_e(), (l) => {
      Io(l, Xv);
    }), ft(F(), (l) => {
      Io(l, Jv);
    })] : [ft(Kr(), (l, f) => {
      Io(l, Xv);
    }), ft(Sf(), (l) => {
      Io(l, Jv);
    })]]));
  } }), Cz = [st("lazySink"), st("tooltipDom"), He("exclusive", !0), He("tooltipComponents", []), He("delay", 300), Fs("mode", "normal", ["normal", "follow-highlight"]), He("anchor", (o) => ({ type: "hotspot", hotspot: o, layouts: { onLtr: Ee([ma, Zl, Bi, rl, Tr, ps]), onRtl: Ee([ma, Zl, Bi, rl, Tr, ps]) } })), Vo("onHide"), Vo("onShow")], NS = Object.freeze({ __proto__: null, init: () => {
    const o = As(), s = As(), i = () => {
      o.on(clearTimeout);
    }, l = Ee("not-implemented");
    return as({ getTooltip: s.get, isShowing: s.isSet, setTooltip: s.set, clearTooltip: s.clear, clearTimer: i, resetTimer: (f, m) => {
      i(), o.set(setTimeout(f, m));
    }, readState: l });
  } });
  const Sz = _i({ fields: Cz, name: "tooltipping", active: DM, state: NS, apis: AM }), Ez = "silver.readonly", RM = Nn([zl("readonly", $c)]), Mk = (o, s) => {
    const i = o.mainUi.outerContainer.element, l = [o.mainUi.mothership, ...o.uiMotherships];
    s && tn(l, (f) => {
      f.broadcastOn([Pl()], { target: i });
    }), tn(l, (f) => {
      f.broadcastOn([Ez], { readonly: s });
    });
  }, ty = (o, s) => {
    o.on("init", () => {
      o.mode.isReadOnly() && Mk(s, !0);
    }), o.on("SwitchMode", () => Mk(s, o.mode.isReadOnly())), $T(o) && o.mode.set("readonly");
  }, il = () => pc.config({ channels: { [Ez]: { schema: RM, onReceive: (o, s) => {
    Xn.set(o, s.readonly);
  } } } }), M0 = (o) => Xn.config({ disabled: o }), Bk = (o) => Xn.config({ disabled: o, disableClass: "tox-tbtn--disabled" }), MS = (o) => Xn.config({ disabled: o, disableClass: "tox-tbtn--disabled", useNative: !1 }), Qv = (o, s) => {
    const i = o.getApi(s);
    return (l) => {
      l(i);
    };
  }, Ih = (o, s) => ss((i) => {
    Qv(o, i)((l) => {
      const f = o.onSetup(l);
      Rt(f) && s.set(f);
    });
  }), Fh = (o, s) => ud((i) => Qv(o, i)(s.get())), Tz = (o, s) => hl((i, l) => {
    Qv(o, i)(o.onAction), o.triggersSubmenu || s !== Tm.CLOSE_ON_EXECUTE || (i.getSystem().isConnected() && Io(i, Tp()), l.stop());
  }), zz = { [gl()]: ["disabling", "alloy.base.behaviour", "toggling", "item-events"] }, B0 = Nt, L0 = (o, s, i, l) => {
    const f = Ln(gt);
    return { type: "item", dom: s.dom, components: B0(s.optComponents), data: o.data, eventOrder: zz, hasSubmenu: o.triggersSubmenu, itemBehaviours: $t([wo("item-events", [Tz(o, i), Ih(o, f), Fh(o, f)]), (m = () => !o.enabled || l.isDisabled(), Xn.config({ disabled: m, disableClass: "tox-collection__item--state-disabled" })), il(), Jn.config({})].concat(o.itemBehaviours)) };
    var m;
  }, P0 = (o) => ({ value: o.value, meta: { text: o.text.getOr(""), ...o.meta } }), Lk = (o) => {
    const s = mp.os.isMacOS() || mp.os.isiOS(), i = s ? { alt: "⌥", ctrl: "⌃", shift: "⇧", meta: "⌘", access: "⌃⌥" } : { meta: "Ctrl", access: "Shift+Alt" }, l = o.split("+"), f = Ct(l, (m) => {
      const b = m.toLowerCase().trim();
      return _n(i, b) ? i[b] : m;
    });
    return s ? f.join("") : f.join("+");
  }, BS = (o, s, i = [Ig]) => fp(o, { tag: "div", classes: i }, s), Oz = (o) => ({ dom: { tag: "div", classes: [E0] }, components: [Os(_d.translate(o))] }), Az = (o, s) => ({ dom: { tag: "div", classes: s, innerHtml: o } }), NM = (o, s) => ({ dom: { tag: "div", classes: [E0] }, components: [{ dom: { tag: o.tag, styles: o.styles }, components: [Os(_d.translate(s))] }] }), Dz = (o) => ({ dom: { tag: "div", classes: ["tox-collection__item-accessory"] }, components: [Os(Lk(o))] }), Rz = (o) => BS("checkmark", o, ["tox-collection__item-checkmark"]), Nz = (o) => {
    const s = o.map((i) => ({ attributes: { title: _d.translate(i), id: hn("menu-item") } })).getOr({});
    return { tag: "div", classes: [gS, Ck], ...s };
  }, ex = (o, s, i, l = M.none()) => o.presets === "color" ? ((f, m, b) => {
    const x = f.ariaLabel, w = f.value, E = f.iconContent.map((O) => ((A, B, $) => {
      const Z = B();
      return BT(A, Z).or($).getOrThunk(pk(Z));
    })(O, m.icons, b));
    return { dom: (() => {
      const O = oz, A = E.getOr(""), B = x.map((Z) => ({ title: m.translate(Z) })).getOr({}), $ = { tag: "div", attributes: B, classes: [O] };
      return w === "custom" ? { ...$, tag: "button", classes: [...$.classes, "tox-swatches__picker-btn"], innerHtml: A } : w === "remove" ? { ...$, classes: [...$.classes, "tox-swatch--remove"], innerHtml: A } : it(w) ? { ...$, attributes: { ...$.attributes, "data-mce-color": w }, styles: { "background-color": w }, innerHtml: A } : $;
    })(), optComponents: [] };
  })(o, s, l) : ((f, m, b, x) => {
    const w = { tag: "div", classes: [Ig] }, E = b ? f.iconContent.map(($) => fp($, w, m.icons, x)).orThunk(() => M.some({ dom: w })) : M.none(), O = f.checkMark, A = M.from(f.meta).fold(() => Oz, ($) => _n($, "style") ? We(NM, $.style) : Oz), B = f.htmlContent.fold(() => f.textContent.map(A), ($) => M.some(Az($, [E0])));
    return { dom: Nz(f.ariaLabel), optComponents: [E, B, f.shortcutContent.map(Dz), O, f.caret] };
  })(o, s, i, l), LS = (o, s) => cn(o, "tooltipWorker").map((i) => [Sz.config({ lazySink: s.getSink, tooltipDom: { tag: "div", classes: ["tox-tooltip-worker-container"] }, tooltipComponents: [], anchor: (l) => ({ type: "submenu", item: l, overrides: { maxHeightFunction: Lp } }), mode: "follow-highlight", onShow: (l, f) => {
    i((m) => {
      Sz.setComponents(l, [nb({ element: Xt(m) })]);
    });
  } })]).getOr([]), Mz = (o, s) => {
    const i = ((l) => Ph.DOM.encode(l))(_d.translate(o));
    if (s.length > 0) {
      const l = new RegExp(((f) => f.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"))(s), "gi");
      return i.replace(l, (f) => `<span class="tox-autocompleter-highlight">${f}</span>`);
    }
    return i;
  }, Bz = (o, s) => Ct(o, (i) => {
    switch (i.type) {
      case "cardcontainer":
        return ((m, b) => {
          const x = m.direction === "vertical" ? "tox-collection__item-container--column" : iz, w = m.align === "left" ? "tox-collection__item-container--align-left" : "tox-collection__item-container--align-right";
          return { dom: { tag: "div", classes: [az, x, w, (() => {
            switch (m.valign) {
              case "top":
                return "tox-collection__item-container--valign-top";
              case "middle":
                return "tox-collection__item-container--valign-middle";
              case "bottom":
                return "tox-collection__item-container--valign-bottom";
            }
          })()] }, components: b };
        })(i, Bz(i.items, s));
      case "cardimage":
        return ((m, b, x) => ({ dom: { tag: "img", classes: b, attributes: { src: m, alt: x.getOr("") } } }))(i.src, i.classes, i.alt);
      case "cardtext":
        const l = i.name.exists((m) => Bn(s.cardText.highlightOn, m)), f = l ? M.from(s.cardText.matchText).getOr("") : "";
        return Az(Mz(i.text, f), i.classes);
    }
  }), PS = Ro(uf(), Mh()), Lz = (o) => ({ value: IS(o) }), Pz = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, tx = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, Iz = (o) => Pz.test(o) || tx.test(o), IS = (o) => Qu(o, "#").toUpperCase(), qc = (o) => {
    const s = o.toString(16);
    return (s.length === 1 ? "0" + s : s).toUpperCase();
  }, nx = (o) => {
    const s = qc(o.red) + qc(o.green) + qc(o.blue);
    return Lz(s);
  }, FS = Math.min, $S = Math.max, Pk = Math.round, Fz = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i, $z = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i, ny = (o, s, i, l) => ({ red: o, green: s, blue: i, alpha: l }), HS = (o) => {
    const s = parseInt(o, 10);
    return s.toString() === o && s >= 0 && s <= 255;
  }, Hz = (o) => {
    let s, i, l;
    const f = (o.hue || 0) % 360;
    let m = o.saturation / 100, b = o.value / 100;
    if (m = $S(0, FS(m, 1)), b = $S(0, FS(b, 1)), m === 0)
      return s = i = l = Pk(255 * b), ny(s, i, l, 1);
    const x = f / 60, w = b * m, E = w * (1 - Math.abs(x % 2 - 1)), O = b - w;
    switch (Math.floor(x)) {
      case 0:
        s = w, i = E, l = 0;
        break;
      case 1:
        s = E, i = w, l = 0;
        break;
      case 2:
        s = 0, i = w, l = E;
        break;
      case 3:
        s = 0, i = E, l = w;
        break;
      case 4:
        s = E, i = 0, l = w;
        break;
      case 5:
        s = w, i = 0, l = E;
        break;
      default:
        s = i = l = 0;
    }
    return s = Pk(255 * (s + O)), i = Pk(255 * (i + O)), l = Pk(255 * (l + O)), ny(s, i, l, 1);
  }, ox = (o) => {
    const s = ((m) => {
      const b = ((w) => ({ value: w.value.replace(Pz, (O, A, B, $) => A + A + B + B + $ + $) }))(m), x = tx.exec(b.value);
      return x === null ? ["FFFFFF", "FF", "FF", "FF"] : x;
    })(o), i = parseInt(s[1], 16), l = parseInt(s[2], 16), f = parseInt(s[3], 16);
    return ny(i, l, f, 1);
  }, VS = (o, s, i, l) => {
    const f = parseInt(o, 10), m = parseInt(s, 10), b = parseInt(i, 10), x = parseFloat(l);
    return ny(f, m, b, x);
  }, US = (o) => {
    if (o === "transparent")
      return M.some(ny(0, 0, 0, 0));
    const s = Fz.exec(o);
    if (s !== null)
      return M.some(VS(s[1], s[2], s[3], "1"));
    const i = $z.exec(o);
    return i !== null ? M.some(VS(i[1], i[2], i[3], i[4])) : M.none();
  }, Vz = (o) => `rgba(${o.red},${o.green},${o.blue},${o.alpha})`, jS = ny(255, 0, 0, 1), Ik = (o, s) => {
    o.dispatch("ResizeContent", s);
  }, ZS = (o, s) => {
    o.dispatch("TextColorChange", s);
  }, MM = (o, s) => o.dispatch("ResolveName", { name: s.nodeName.toLowerCase(), target: s }), Fk = (o, s) => () => {
    o(), s();
  }, fu = (o) => oy(o, "NodeChange", (s) => {
    s.setEnabled(o.selection.isEditable());
  }), $k = (o, s) => (i) => {
    const l = fu(o)(i), f = ((m, b) => (x) => {
      const w = Lf(), E = () => {
        x.setActive(m.formatter.match(b));
        const O = m.formatter.formatChanged(b, x.setActive);
        w.set(O);
      };
      return m.initialized ? E() : m.once("init", E), () => {
        m.off("init", E), w.clear();
      };
    })(o, s)(i);
    return () => {
      l(), f();
    };
  }, oy = (o, s, i) => (l) => {
    const f = () => i(l), m = () => {
      i(l), o.on(s, f);
    };
    return o.initialized ? m() : o.once("init", m), () => {
      o.off("init", m), o.off(s, f);
    };
  }, WS = (o) => (s) => () => {
    o.undoManager.transact(() => {
      o.focus(), o.execCommand("mceToggleFormat", !1, s.format);
    });
  }, Jl = (o, s) => () => o.execCommand(s);
  var ry = tinymce.util.Tools.resolve("tinymce.util.LocalStorage");
  const qS = {}, Hk = (o) => cn(qS, o).getOrThunk(() => {
    const s = `tinymce-custom-colors-${o}`, i = ry.getItem(s);
    if (jt(i)) {
      const f = ry.getItem("tinymce-custom-colors");
      ry.setItem(s, it(f) ? f : "[]");
    }
    const l = ((f, m = 10) => {
      const b = ry.getItem(f), x = ce(b) ? JSON.parse(b) : [], w = m - (E = x).length < 0 ? E.slice(0, m) : E;
      var E;
      const O = (A) => {
        w.splice(A, 1);
      };
      return { add: (A) => {
        dt(w, A).each(O), w.unshift(A), w.length > m && w.pop(), ry.setItem(f, JSON.stringify(w));
      }, state: () => w.slice(0) };
    })(s, 10);
    return qS[o] = l, l;
  }), Uz = (o, s) => {
    Hk(o).add(s);
  }, rx = (o, s, i) => ({ hue: o, saturation: s, value: i }), GS = (o) => {
    let s = 0, i = 0, l = 0;
    const f = o.red / 255, m = o.green / 255, b = o.blue / 255, x = Math.min(f, Math.min(m, b)), w = Math.max(f, Math.max(m, b));
    return x === w ? (l = x, rx(0, 0, 100 * l)) : (s = f === x ? 3 : b === x ? 1 : 5, s = 60 * (s - (f === x ? m - b : b === x ? f - m : b - f) / (w - x)), i = (w - x) / w, l = w, rx(Math.round(s), Math.round(100 * i), Math.round(100 * l)));
  }, jz = (o) => nx(Hz(o)), Zz = (o) => {
    return (s = o, Iz(s) ? M.some({ value: IS(s) }) : M.none()).orThunk(() => US(o).map(nx)).getOrThunk(() => {
      const i = document.createElement("canvas");
      i.height = 1, i.width = 1;
      const l = i.getContext("2d");
      l.clearRect(0, 0, i.width, i.height), l.fillStyle = "#FFFFFF", l.fillStyle = o, l.fillRect(0, 0, 1, 1);
      const f = l.getImageData(0, 0, 1, 1).data, m = f[0], b = f[1], x = f[2], w = f[3];
      return nx(ny(m, b, x, w));
    });
    var s;
  }, sx = "forecolor", ax = "hilitecolor", BM = (o) => {
    const s = [];
    for (let i = 0; i < o.length; i += 2)
      s.push({ text: o[i + 1], value: "#" + Zz(o[i]).value, icon: "checkmark", type: "choiceitem" });
    return s;
  }, Vu = (o) => (s) => s.options.get(o), Vk = "#000000", ix = (o, s) => s === sx && o.options.isSet("color_map_foreground") ? Vu("color_map_foreground")(o) : s === ax && o.options.isSet("color_map_background") ? Vu("color_map_background")(o) : Vu("color_map")(o), KS = (o, s = "default") => Math.max(5, Math.ceil(Math.sqrt(ix(o, s).length))), Wz = (o, s) => {
    const i = Vu("color_cols")(o), l = KS(o, s);
    return i === KS(o) ? l : i;
  }, I0 = (o, s = "default") => Math.round(s === sx ? Vu("color_cols_foreground")(o) : s === ax ? Vu("color_cols_background")(o) : Vu("color_cols")(o)), F0 = Vu("custom_colors"), qz = Vu("color_default_foreground"), Gz = Vu("color_default_background"), $h = (o, s) => {
    const i = Xt(o.selection.getStart()), l = s === "hilitecolor" ? lc(i, (f) => {
      if (ra(f)) {
        const m = Ts(f, "background-color");
        return mi(US(m).exists((b) => b.alpha !== 0), m);
      }
      return M.none();
    }).getOr("rgba(0, 0, 0, 0)") : Ts(i, "color");
    return US(l).map((f) => "#" + nx(f).value);
  }, Hh = (o) => {
    const s = "choiceitem", i = { type: s, text: "Remove color", icon: "color-swatch-remove-color", value: "remove" };
    return o ? [i, { type: s, text: "Custom color", icon: "color-picker", value: "custom" }] : [i];
  }, YS = (o, s, i, l) => {
    i === "custom" ? Zk(o)((f) => {
      f.each((m) => {
        Uz(s, m), o.execCommand("mceApplyTextcolor", s, m), l(m);
      });
    }, $h(o, s).getOr(Vk)) : i === "remove" ? (l(""), o.execCommand("mceRemoveTextcolor", s)) : (l(i), o.execCommand("mceApplyTextcolor", s, i));
  }, XS = (o, s, i) => o.concat(((l) => Ct(Hk(l).state(), (f) => ({ type: "choiceitem", text: f, icon: "checkmark", value: f })))(s).concat(Hh(i))), JS = (o, s, i) => (l) => {
    l(XS(o, s, i));
  }, Zp = (o, s, i) => {
    const l = s === "forecolor" ? "tox-icon-text-color__color" : "tox-icon-highlight-bg-color__color";
    o.setIconFill(l, i);
  }, Uk = (o, s) => {
    o.setTooltip(s);
  }, Kz = (o, s) => (i) => {
    const l = $h(o, s);
    return Si(l, i.toUpperCase());
  }, jk = (o, s, i) => {
    if (Hr(i))
      return s === "forecolor" ? "Text color" : "Background color";
    const l = s === "forecolor" ? "Text color {0}" : "Background color {0}", f = XS(ix(o, s), s, !1), m = Go(f, (b) => b.value === i).getOr({ text: "" }).text;
    return o.translate([l, o.translate(m)]);
  }, QS = (o, s, i, l) => {
    o.ui.registry.addSplitButton(s, { tooltip: jk(o, i, l.get()), presets: "color", icon: s === "forecolor" ? "text-color" : "highlight-bg-color", select: Kz(o, i), columns: I0(o, i), fetch: JS(ix(o, i), i, F0(o)), onAction: (f) => {
      YS(o, i, l.get(), gt);
    }, onItemAction: (f, m) => {
      YS(o, i, m, (b) => {
        l.set(b), ZS(o, { name: s, color: b });
      });
    }, onSetup: (f) => {
      Zp(f, s, l.get());
      const m = (b) => {
        b.name === s && (Zp(f, b.name, b.color), Uk(f, jk(o, i, b.color)));
      };
      return o.on("TextColorChange", m), Fk(fu(o)(f), () => {
        o.off("TextColorChange", m);
      });
    } });
  }, eE = (o, s, i, l, f) => {
    o.ui.registry.addNestedMenuItem(s, { text: l, icon: s === "forecolor" ? "text-color" : "highlight-bg-color", onSetup: (m) => (Uk(m, jk(o, i, f.get())), Zp(m, s, f.get()), fu(o)(m)), getSubmenuItems: () => [{ type: "fancymenuitem", fancytype: "colorswatch", select: Kz(o, i), initData: { storageKey: i }, onAction: (m) => {
      YS(o, i, m.value, (b) => {
        f.set(b), ZS(o, { name: s, color: b });
      });
    } }] });
  }, Zk = (o) => (s, i) => {
    let l = !1;
    const f = { colorpicker: i };
    o.windowManager.open({ title: "Color Picker", size: "normal", body: { type: "panel", items: [{ type: "colorpicker", name: "colorpicker", label: "Color" }] }, buttons: [{ type: "cancel", name: "cancel", text: "Cancel" }, { type: "submit", name: "save", text: "Save", primary: !0 }], initialData: f, onAction: (m, b) => {
      b.name === "hex-valid" && (l = b.value);
    }, onSubmit: (m) => {
      const b = m.getData().colorpicker;
      l ? (s(M.from(b)), m.close()) : o.windowManager.alert(o.translate(["Invalid hex color code: {0}", b]));
    }, onClose: gt, onCancel: () => {
      s(M.none());
    } });
  }, Wk = (o, s, i, l, f, m, b, x) => {
    const w = Fg(s), E = LM(s, i, l, f !== "color" ? "normal" : "color", m, b, x);
    return vS(o, w, E, l, { menuType: f });
  }, LM = (o, s, i, l, f, m, b) => Nt(Ct(o, (x) => {
    return x.type === "choiceitem" ? (w = x, Gr("choicemenuitem", EM, w)).fold(Xb, (E) => M.some(((O, A, B, $, Z, oe, re, fe = !0) => {
      const ee = ex({ presets: B, textContent: A ? O.text : M.none(), htmlContent: M.none(), ariaLabel: O.text, iconContent: O.icon, shortcutContent: A ? O.shortcut : M.none(), checkMark: A ? M.some(Rz(re.icons)) : M.none(), caret: M.none(), value: O.value }, re, fe);
      return be(L0({ data: P0(O), enabled: O.enabled, getApi: (J) => ({ setActive: (le) => {
        Lo.set(J, le);
      }, isActive: () => Lo.isOn(J), isEnabled: () => !Xn.isDisabled(J), setEnabled: (le) => Xn.set(J, !le) }), onAction: (J) => $(O.value), onSetup: (J) => (J.setActive(Z), gt), triggersSubmenu: !1, itemBehaviours: [] }, ee, oe, re), { toggling: { toggleClass: rz, toggleOnExecute: !1, selected: O.active, exclusive: !0 } });
    })(E, i === 1, l, s, m(E.value), f, b, Fg(o)))) : M.none();
    var w;
  })), qk = (o, s) => {
    const i = pp(s);
    return o === 1 ? { mode: "menu", moveOnTab: !0 } : o === "auto" ? { mode: "grid", selector: "." + i.item, initSize: { numColumns: 1, numRows: 1 } } : { mode: "matrix", rowSelector: "." + (s === "color" ? "tox-swatches__row" : "tox-collection__group"), previousSelector: (l) => s === "color" ? fa(l.element, "[aria-checked=true]") : M.none() };
  }, Yz = hn("cell-over"), lx = hn("cell-execute"), tE = (o, s, i) => {
    const l = (m) => pn(m, lx, { row: o, col: s }), f = (m, b) => {
      b.stop(), l(m);
    };
    return Nl({ dom: { tag: "div", attributes: { role: "button", "aria-label": i } }, behaviours: $t([wo("insert-table-picker-cell", [ft(_e(), io.focus), ft(gl(), l), ft(yr(), f), ft(Ul(), f)]), Lo.config({ toggleClass: "tox-insert-table-picker__selected", toggleOnExecute: !1 }), io.config({ onFocus: (m) => pn(m, Yz, { row: o, col: s }) })]) });
  }, nE = (o) => Qr(o, (s) => Ct(s, Yr)), Xz = (o, s) => Os(`${s}x${o}`), PM = { inserttable: (o, s) => {
    const i = ((b) => (x, w) => b.shared.providers.translate(["{0} columns, {1} rows", w, x]))(s), l = ((b, x, w) => {
      const E = [];
      for (let O = 0; O < 10; O++) {
        const A = [];
        for (let B = 0; B < 10; B++) {
          const $ = b(O + 1, B + 1);
          A.push(tE(O, B, $));
        }
        E.push(A);
      }
      return E;
    })(i), f = Xz(0, 0), m = Ur({ dom: { tag: "span", classes: ["tox-insert-table-picker__label"] }, components: [f], behaviours: $t([Jn.config({})]) });
    return { type: "widget", data: { value: hn("widget-id") }, dom: { tag: "div", classes: ["tox-fancymenuitem"] }, autofocus: !0, components: [PS.widget({ dom: { tag: "div", classes: ["tox-insert-table-picker"] }, components: nE(l).concat(m.asSpec()), behaviours: $t([wo("insert-table-picker", [ss((b) => {
      Jn.set(m.get(b), [f]);
    }), Yd(Yz, (b, x, w) => {
      const { row: E, col: O } = w.event;
      ((A, B, $, Z, oe) => {
        for (let re = 0; re < 10; re++)
          for (let fe = 0; fe < 10; fe++)
            Lo.set(A[re][fe], re <= B && fe <= $);
      })(l, E, O), Jn.set(m.get(b), [Xz(E + 1, O + 1)]);
    }), Yd(lx, (b, x, w) => {
      const { row: E, col: O } = w.event;
      o.onAction({ numRows: E + 1, numColumns: O + 1 }), Io(b, Tp());
    })]), Jt.config({ initSize: { numRows: 10, numColumns: 10 }, mode: "flatgrid", selector: '[role="button"]' })]) })] };
  }, colorswatch: (o, s) => {
    const i = ((b, x) => {
      const w = b.initData.allowCustomColors && x.colorinput.hasCustomColors();
      return b.initData.colors.fold(() => XS(x.colorinput.getColors(b.initData.storageKey), b.initData.storageKey, w), (E) => E.concat(Hh(w)));
    })(o, s), l = s.colorinput.getColorCols(o.initData.storageKey), f = "color", m = { ...Wk(hn("menu-value"), i, (b) => {
      o.onAction({ value: b });
    }, l, f, Tm.CLOSE_ON_EXECUTE, o.select.getOr(Xe), s.shared.providers), markers: pp(f), movement: qk(l, f) };
    return { type: "widget", data: { value: hn("widget-id") }, dom: { tag: "div", classes: ["tox-fancymenuitem"] }, autofocus: !0, components: [PS.widget(Lg.sketch(m))] };
  } }, oE = (o) => ({ type: "separator", dom: { tag: "div", classes: [Ck, "tox-collection__group-heading"] }, components: o.text.map(Os).toArray() });
  var Jz = Object.freeze({ __proto__: null, getCoupled: (o, s, i, l) => i.getOrCreate(o, s, l), getExistingCoupled: (o, s, i, l) => i.getExisting(o, s, l) }), Qz = [zl("others", pl(To.value, Pr()))], eO = Object.freeze({ __proto__: null, init: () => {
    const o = {}, s = (l, f) => {
      if (po(l.others).length === 0)
        throw new Error("Cannot find any known coupled components");
      return cn(o, f);
    }, i = Ee({});
    return as({ readState: i, getExisting: (l, f, m) => s(f, m).orThunk(() => (cn(f.others, m).getOrDie("No information found for coupled component: " + m), M.none())), getOrCreate: (l, f, m) => s(f, m).getOrThunk(() => {
      const b = cn(f.others, m).getOrDie("No information found for coupled component: " + m)(l), x = l.getSystem().build(b);
      return o[m] = x, x;
    }) });
  } });
  const Qa = _i({ fields: Qz, name: "coupling", apis: Jz, state: eO }), cx = (o) => {
    let s = M.none(), i = [];
    const l = (b) => {
      f() ? m(b) : i.push(b);
    }, f = () => s.isSome(), m = (b) => {
      s.each((x) => {
        setTimeout(() => {
          b(x);
        }, 0);
      });
    };
    return o((b) => {
      f() || (s = M.some(b), tn(i, m), i = []);
    }), { get: l, map: (b) => cx((x) => {
      l((w) => {
        x(b(w));
      });
    }), isReady: f };
  }, IM = { nu: cx, pure: (o) => cx((s) => {
    s(o);
  }) }, FM = (o) => {
    setTimeout(() => {
      throw o;
    }, 0);
  }, $0 = (o) => {
    const s = (i) => {
      o().then(i, FM);
    };
    return { map: (i) => $0(() => o().then(i)), bind: (i) => $0(() => o().then((l) => i(l).toPromise())), anonBind: (i) => $0(() => o().then(() => i.toPromise())), toLazy: () => IM.nu(s), toCached: () => {
      let i = null;
      return $0(() => (i === null && (i = o()), i));
    }, toPromise: o, get: s };
  }, sy = (o) => $0(() => new Promise(o)), $g = (o) => $0(() => Promise.resolve(o)), tO = Ee("sink"), nO = Ee(rn({ name: tO(), overrides: Ee({ dom: { tag: "div" }, behaviours: $t([Ll.config({ useFixed: un })]), events: Bo([Su(bn()), Su(da()), Su(yr())]) }) })), rE = (o, s) => {
    const i = o.getHotspot(s).getOr(s), l = "hotspot", f = o.getAnchorOverrides();
    return o.layouts.fold(() => ({ type: l, hotspot: i, overrides: f }), (m) => ({ type: l, hotspot: i, overrides: f, layouts: m }));
  }, ay = (o, s, i, l, f, m, b) => ((w, E, O, A, B, $, Z) => {
    const oe = ((fe, ee, J) => (0, fe.fetch)(J).map(ee))(w, E, A), re = Gk(A, w);
    return oe.map((fe) => fe.bind((ee) => M.from(Zb.sketch({ ...$.menu(), uid: q(""), data: ee, highlightOnOpen: Z, onOpenMenu: (J, le) => {
      const me = re().getOrDie();
      Ll.position(me, le, { anchor: O }), zo.decloak(B);
    }, onOpenSubmenu: (J, le, me) => {
      const ke = re().getOrDie();
      Ll.position(ke, me, { anchor: { type: "submenu", item: le } }), zo.decloak(B);
    }, onRepositionMenu: (J, le, me) => {
      const ke = re().getOrDie();
      Ll.position(ke, le, { anchor: O }), tn(me, (Re) => {
        Ll.position(ke, Re.triggeredMenu, { anchor: { type: "submenu", item: Re.triggeringItem } });
      });
    }, onEscape: () => (io.focus(A), zo.close(B), M.some(!0)) }))));
  })(o, s, rE(o, i), i, l, f, b).map((w) => (w.fold(() => {
    zo.isOpen(l) && zo.close(l);
  }, (E) => {
    zo.cloak(l), zo.open(l, E), m(l);
  }), l)), $M = (o, s, i, l, f, m, b) => (zo.close(l), $g(l)), x1 = (o, s, i, l, f, m) => {
    const b = Qa.getCoupled(i, "sandbox");
    return (zo.isOpen(b) ? $M : ay)(o, s, i, b, l, f, m);
  }, Gk = (o, s) => o.getSystem().getByUid(s.uid + "-" + tO()).map((i) => () => To.value(i)).getOrThunk(() => s.lazySink.fold(() => () => To.error(new Error("No internal sink is specified, nor could an external sink be found")), (i) => () => i(o))), sE = (o) => {
    zo.getState(o).each((s) => {
      Zb.repositionMenus(s);
    });
  }, Kk = (o, s, i) => {
    const l = Qd(), f = Gk(s, o);
    return { dom: { tag: "div", classes: o.sandboxClasses, attributes: { id: l.id, role: "listbox" } }, behaviours: Ua(o.sandboxBehaviours, [ln.config({ store: { mode: "memory", initialValue: s } }), zo.config({ onOpen: (m, b) => {
      const x = rE(o, s);
      l.link(s.element), o.matchWidth && ((w, E, O) => {
        const A = rr.getCurrent(E).getOr(E), B = Wr(w.element);
        O ? qn(A.element, "min-width", B + "px") : (($, Z) => {
          Cr.set($, Z);
        })(A.element, B);
      })(x.hotspot, b, o.useMinWidth), o.onOpen(x, m, b), i !== void 0 && i.onOpen !== void 0 && i.onOpen(m, b);
    }, onClose: (m, b) => {
      l.unlink(s.element), i !== void 0 && i.onClose !== void 0 && i.onClose(m, b);
    }, isPartOf: (m, b, x) => wi(b, x) || wi(s, x), getAttachPoint: () => f().getOrDie() }), rr.config({ find: (m) => zo.getState(m).bind((b) => rr.getCurrent(b)) }), pc.config({ channels: { ...Rb({ isExtraPart: Xe }), ...Dg({ doReposition: sE }) } })]) };
  }, oO = (o) => {
    const s = Qa.getCoupled(o, "sandbox");
    sE(s);
  }, aE = () => [He("sandboxClasses", []), $i("sandboxBehaviours", [rr, pc, zo, ln])], rO = Ee([st("dom"), st("fetch"), Vo("onOpen"), fc("onExecute"), He("getHotspot", M.some), He("getAnchorOverrides", Ee({})), ym(), pa("dropdownBehaviours", [Lo, Qa, Jt, io]), st("toggleClass"), He("eventOrder", {}), pr("lazySink"), He("matchWidth", !1), He("useMinWidth", !1), pr("role")].concat(aE())), HM = Ee([Vt({ schema: [hg(), He("fakeFocus", !1)], name: "menu", defaults: (o) => ({ onExecute: o.onExecute }) }), nO()]), qf = hc({ name: "Dropdown", configFields: rO(), partFields: HM(), factory: (o, s, i, l) => {
    const f = (w) => {
      zo.getState(w).each((E) => {
        Zb.highlightPrimary(E);
      });
    }, m = (w, E, O) => x1(o, wt, w, l, E, O), b = { expand: (w) => {
      Lo.isOn(w) || m(w, gt, cu.HighlightNone).get(gt);
    }, open: (w) => {
      Lo.isOn(w) || m(w, gt, cu.HighlightMenuAndItem).get(gt);
    }, refetch: (w) => Qa.getExistingCoupled(w, "sandbox").fold(() => m(w, gt, cu.HighlightMenuAndItem).map(gt), (E) => ay(o, wt, w, E, l, gt, cu.HighlightMenuAndItem).map(gt)), isOpen: Lo.isOn, close: (w) => {
      Lo.isOn(w) && m(w, gt, cu.HighlightMenuAndItem).get(gt);
    }, repositionMenus: (w) => {
      Lo.isOn(w) && oO(w);
    } }, x = (w, E) => (Kd(w), M.some(!0));
    return { uid: o.uid, dom: o.dom, components: s, behaviours: Fi(o.dropdownBehaviours, [Lo.config({ toggleClass: o.toggleClass, aria: { mode: "expanded" } }), Qa.config({ others: { sandbox: (w) => Kk(o, w, { onOpen: () => Lo.on(w), onClose: () => Lo.off(w) }) } }), Jt.config({ mode: "special", onSpace: x, onEnter: x, onDown: (w, E) => {
      if (qf.isOpen(w)) {
        const O = Qa.getCoupled(w, "sandbox");
        f(O);
      } else
        qf.open(w);
      return M.some(!0);
    }, onEscape: (w, E) => qf.isOpen(w) ? (qf.close(w), M.some(!0)) : M.none() }), io.config({})]), events: Pv(M.some((w) => {
      m(w, f, cu.HighlightMenuAndItem).get(gt);
    })), eventOrder: { ...o.eventOrder, [gl()]: ["disabling", "toggling", "alloy.base.behaviour"] }, apis: b, domModification: { attributes: { "aria-haspopup": "true", ...o.role.fold(() => ({}), (w) => ({ role: w })), ...o.dom.tag === "button" ? { type: cn(o.dom, "attributes").bind((w) => cn(w, "type")).getOr("button") } : {} } } };
  }, apis: { open: (o, s) => o.open(s), refetch: (o, s) => o.refetch(s), expand: (o, s) => o.expand(s), close: (o, s) => o.close(s), isOpen: (o, s) => o.isOpen(s), repositionMenus: (o, s) => o.repositionMenus(s) } }), sO = (o, s, i) => {
    fz(o).each((l) => {
      var f;
      ((m, b) => {
        Sa(b.element, "id").each((x) => eo(m.element, "aria-activedescendant", x));
      })(l, i), (_s((f = s).element, Ok) ? M.some(f.element) : fa(f.element, "." + Ok)).each((m) => {
        Sa(m, "id").each((b) => eo(l.element, "aria-controls", b));
      });
    }), eo(i.element, "aria-selected", "true");
  }, VM = (o, s, i) => {
    eo(i.element, "aria-selected", "false");
  }, aO = (o) => Qa.getExistingCoupled(o, "sandbox").bind(zk).map(yS).map((s) => s.fetchPattern).getOr("");
  var w1;
  (function(o) {
    o[o.ContentFocus = 0] = "ContentFocus", o[o.UiFocus = 1] = "UiFocus";
  })(w1 || (w1 = {}));
  const iE = (o, s, i, l, f) => {
    const m = i.shared.providers, b = (w) => f ? { ...w, shortcut: M.none(), icon: w.text.isSome() ? M.none() : w.icon } : w;
    switch (o.type) {
      case "menuitem":
        return (x = o, Gr("menuitem", DS, x)).fold(Xb, (w) => M.some(((E, O, A, B = !0) => {
          const $ = ex({ presets: "normal", iconContent: E.icon, textContent: E.text, htmlContent: M.none(), ariaLabel: E.text, caret: M.none(), checkMark: M.none(), shortcutContent: E.shortcut }, A, B);
          return L0({ data: P0(E), getApi: (Z) => ({ isEnabled: () => !Xn.isDisabled(Z), setEnabled: (oe) => Xn.set(Z, !oe) }), enabled: E.enabled, onAction: E.onAction, onSetup: E.onSetup, triggersSubmenu: !1, itemBehaviours: [] }, $, O, A);
        })(b(w), s, m, l)));
      case "nestedmenuitem":
        return ((w) => Gr("nestedmenuitem", OM, w))(o).fold(Xb, (w) => M.some(((E, O, A, B = !0, $ = !1) => {
          const Z = $ ? (oe = A.icons, BS("chevron-down", oe, [sz])) : ((fe) => BS("chevron-right", fe, [sz]))(A.icons);
          var oe;
          const re = ex({ presets: "normal", iconContent: E.icon, textContent: E.text, htmlContent: M.none(), ariaLabel: E.text, caret: M.some(Z), checkMark: M.none(), shortcutContent: E.shortcut }, A, B);
          return L0({ data: P0(E), getApi: (fe) => ({ isEnabled: () => !Xn.isDisabled(fe), setEnabled: (ee) => Xn.set(fe, !ee), setIconFill: (ee, J) => {
            fa(fe.element, `svg path[class="${ee}"], rect[class="${ee}"]`).each((le) => {
              eo(le, "fill", J);
            });
          }, setTooltip: (ee) => {
            const J = A.translate(ee);
            gi(fe.element, { "aria-label": J, title: J });
          } }), enabled: E.enabled, onAction: gt, onSetup: E.onSetup, triggersSubmenu: !0, itemBehaviours: [] }, re, O, A);
        })(b(w), s, m, l, f)));
      case "togglemenuitem":
        return ((w) => Gr("togglemenuitem", RS, w))(o).fold(Xb, (w) => M.some(((E, O, A, B = !0) => {
          const $ = ex({ iconContent: E.icon, textContent: E.text, htmlContent: M.none(), ariaLabel: E.text, checkMark: M.some(Rz(A.icons)), caret: M.none(), shortcutContent: E.shortcut, presets: "normal", meta: E.meta }, A, B);
          return be(L0({ data: P0(E), enabled: E.enabled, getApi: (Z) => ({ setActive: (oe) => {
            Lo.set(Z, oe);
          }, isActive: () => Lo.isOn(Z), isEnabled: () => !Xn.isDisabled(Z), setEnabled: (oe) => Xn.set(Z, !oe) }), onAction: E.onAction, onSetup: E.onSetup, triggersSubmenu: !1, itemBehaviours: [] }, $, O, A), { toggling: { toggleClass: rz, toggleOnExecute: !1, selected: E.active } });
        })(b(w), s, m, l)));
      case "separator":
        return ((w) => Gr("separatormenuitem", A0, w))(o).fold(Xb, (w) => M.some(oE(w)));
      case "fancymenuitem":
        return ((w) => Gr("fancymenuitem", R0, w))(o).fold(Xb, (w) => ((E, O) => cn(PM, E.fancytype).map((A) => A(E, O)))(w, i));
      default:
        return console.error("Unknown item in general menu", o), M.none();
    }
    var x;
  }, lE = (o, s, i, l, f, m, b) => {
    const x = l === 1, w = !x || Fg(o);
    return Nt(Ct(o, (E) => {
      switch (E.type) {
        case "separator":
          return (O = E, Gr("Autocompleter.Separator", A0, O)).fold(Xb, (A) => M.some(oE(A)));
        case "cardmenuitem":
          return ((A) => Gr("cardmenuitem", SM, A))(E).fold(Xb, (A) => M.some(((B, $, Z, oe) => {
            const re = { dom: Nz(B.label), optComponents: [M.some({ dom: { tag: "div", classes: [az, iz] }, components: Bz(B.items, oe) })] };
            return L0({ data: P0({ text: M.none(), ...B }), enabled: B.enabled, getApi: (fe) => ({ isEnabled: () => !Xn.isDisabled(fe), setEnabled: (ee) => {
              Xn.set(fe, !ee), tn(Kl(fe.element, "*"), (J) => {
                fe.getSystem().getByDom(J).each((le) => {
                  le.hasConfigured(Xn) && Xn.set(le, !ee);
                });
              });
            } }), onAction: B.onAction, onSetup: B.onSetup, triggersSubmenu: !1, itemBehaviours: M.from(oe.itemBehaviours).getOr([]) }, re, $, Z.providers);
          })({ ...A, onAction: (B) => {
            A.onAction(B), i(A.value, A.meta);
          } }, f, m, { itemBehaviours: LS(A.meta, m), cardText: { matchText: s, highlightOn: b } })));
        default:
          return ((A) => Gr("Autocompleter.Item", bz, A))(E).fold(Xb, (A) => M.some(((B, $, Z, oe, re, fe, ee, J = !0) => {
            const le = ex({ presets: oe, textContent: M.none(), htmlContent: Z ? B.text.map((me) => Mz(me, $)) : M.none(), ariaLabel: B.text, iconContent: B.icon, shortcutContent: M.none(), checkMark: M.none(), caret: M.none(), value: B.value }, ee.providers, J, B.icon);
            return L0({ data: P0(B), enabled: B.enabled, getApi: Ee({}), onAction: (me) => re(B.value, B.meta), onSetup: Ee(gt), triggersSubmenu: !1, itemBehaviours: LS(B.meta, ee) }, le, fe, ee.providers);
          })(A, s, x, "normal", i, f, m, w)));
      }
      var O;
    }));
  }, iO = (o, s, i, l, f, m) => {
    const b = Fg(s), x = Nt(Ct(s, (E) => {
      const O = (A) => iE(A, i, l, ((B) => f ? !_n(B, "text") : b)(A), f);
      return E.type === "nestedmenuitem" && E.getSubmenuItems().length <= 0 ? O({ ...E, enabled: !1 }) : O(E);
    })), w = ((E) => E.searchMode === "no-search" ? { menuType: "normal" } : { menuType: "searchable", searchMode: E })(m);
    return (f ? uM : vS)(o, b, x, 1, w);
  }, cE = (o) => Zb.singleData(o.value, o), UM = (o, s) => {
    const i = hn("autocompleter"), l = Ln(!1), f = Ln(!1), m = Nl(Oa.sketch({ dom: { tag: "div", classes: ["tox-autocompleter"], attributes: { id: i } }, components: [], fireDismissalEventInstead: {}, inlineBehaviours: $t([wo("dismissAutocompleter", [ft(qd(), () => O()), ft(Kr(), ($, Z) => {
      Sa(Z.event.target, "id").each((oe) => eo(Xt(o.getBody()), "aria-activedescendant", oe));
    })])]), lazySink: s.getSink })), b = () => Oa.isOpen(m), x = f.get, w = () => {
      if (b()) {
        Oa.hide(m), o.dom.remove(i, !1);
        const $ = Xt(o.getBody());
        Sa($, "aria-owns").filter((Z) => Z === i).each(() => {
          ts($, "aria-owns"), ts($, "aria-activedescendant");
        });
      }
    }, E = () => Oa.getContent(m).bind(($) => It($.components(), 0)), O = () => o.execCommand("mceAutocompleterClose"), A = ($) => {
      const Z = ((oe) => {
        const re = Ko(oe, (fe) => M.from(fe.columns)).getOr(1);
        return Qr(oe, (fe) => {
          const ee = fe.items;
          return lE(ee, fe.matchText, (J, le) => {
            const me = o.selection.getRng();
            ((ke, Re) => nz(Xt(Re.startContainer)).map((qe) => {
              const mt = ke.createRng();
              return mt.selectNode(qe.dom), mt;
            }))(o.dom, me).each((ke) => {
              const Re = { hide: () => O(), reload: (qe) => {
                w(), o.execCommand("mceAutocompleterReload", !1, { fetchOptions: qe });
              } };
              l.set(!0), fe.onAction(Re, ke, J, le), l.set(!1);
            });
          }, re, Tm.BUBBLE_TO_SANDBOX, s, fe.highlightOn);
        });
      })($);
      Z.length > 0 ? (((oe, re) => {
        var fe;
        (fe = Xt(o.getBody()), fa(fe, tz)).each((ee) => {
          const J = Ko(oe, (le) => M.from(le.columns)).getOr(1);
          Oa.showMenuAt(m, { anchor: { type: "node", root: Xt(o.getBody()), node: M.from(ee) } }, ((le, me, ke, Re) => {
            const qe = qk(me, Re), mt = pp(Re);
            return { data: cE({ ...le, movement: qe, menuBehaviours: v1(me !== "auto" ? [] : [ss((bt, St) => {
              N0(bt, 4, mt.item).each(({ numColumns: Qt, numRows: vn }) => {
                Jt.setGridSize(bt, vn, Qt);
              });
            })]) }), menu: { markers: pp(Re), fakeFocus: ke === w1.ContentFocus } };
          })(vS("autocompleter-value", !0, re, J, { menuType: "normal" }), J, w1.ContentFocus, "normal"));
        }), E().each(mr.highlightFirst);
      })($, Z), eo(Xt(o.getBody()), "aria-owns", i), o.inline || B()) : w();
    }, B = () => {
      o.dom.get(i) && o.dom.remove(i, !1);
      const $ = o.getDoc().documentElement, Z = o.selection.getNode(), oe = ((re) => cm(re, !0))(m.element);
      ac(oe, { border: "0", clip: "rect(0 0 0 0)", height: "1px", margin: "-1px", overflow: "hidden", padding: "0", position: "absolute", width: "1px", top: `${Z.offsetTop}px`, left: `${Z.offsetLeft}px` }), o.dom.add($, oe.dom), fa(oe, '[role="menu"]').each((re) => {
        ar(re, "position"), ar(re, "max-height");
      });
    };
    o.on("AutocompleterStart", ({ lookupData: $ }) => {
      f.set(!0), l.set(!1), A($);
    }), o.on("AutocompleterUpdate", ({ lookupData: $ }) => A($)), o.on("AutocompleterEnd", () => {
      w(), f.set(!1), l.set(!1);
    }), (($, Z) => {
      const oe = (fe, ee) => {
        pn(fe, bn(), { raw: ee });
      }, re = () => $.getMenu().bind(mr.getHighlighted);
      Z.on("keydown", (fe) => {
        const ee = fe.which;
        $.isActive() && ($.isMenuOpen() ? ee === 13 ? (re().each(Kd), fe.preventDefault()) : ee === 40 ? (re().fold(() => {
          $.getMenu().each(mr.highlightFirst);
        }, (J) => {
          oe(J, fe);
        }), fe.preventDefault(), fe.stopImmediatePropagation()) : ee !== 37 && ee !== 38 && ee !== 39 || re().each((J) => {
          oe(J, fe), fe.preventDefault(), fe.stopImmediatePropagation();
        }) : ee !== 13 && ee !== 38 && ee !== 40 || $.cancelIfNecessary());
      }), Z.on("NodeChange", (fe) => {
        $.isActive() && !$.isProcessingAction() && nz(Xt(fe.element)).isNone() && $.cancelIfNecessary();
      });
    })({ cancelIfNecessary: O, isMenuOpen: b, isActive: x, isProcessingAction: l.get, getMenu: E }, o);
  }, jM = ["visible", "hidden", "clip"], uE = (o) => Wi(o).length > 0 && !Bn(jM, o), dE = (o) => {
    if (pi(o)) {
      const s = Ts(o, "overflow-x"), i = Ts(o, "overflow-y");
      return uE(s) || uE(i);
    }
    return !1;
  }, k1 = (o, s) => b1(o) ? ((i) => {
    const l = wb(i, dE), f = l.length === 0 ? Us(i).map(dl).map((m) => wb(m, dE)).getOr([]) : l;
    return ct(f).map((m) => ({ element: m, others: f.slice(1) }));
  })(s) : M.none(), H0 = (o) => {
    const s = [...Ct(o.others, va), os()];
    return ((i, l) => K(l, (f, m) => od(f, m), i))(va(o.element), s);
  }, ux = (o, s, i) => Ou(o, s, i).isSome(), lO = (o, s) => {
    let i = null;
    return { cancel: () => {
      i !== null && (clearTimeout(i), i = null);
    }, schedule: (...l) => {
      i = setTimeout(() => {
        o.apply(null, l), i = null;
      }, s);
    } };
  }, cO = (o) => {
    const s = o.raw;
    return s.touches === void 0 || s.touches.length !== 1 ? M.none() : M.some(s.touches[0]);
  }, ZM = (o, s) => {
    const i = { stopBackspace: !0, ...s }, l = ((A) => {
      const B = As(), $ = Ln(!1), Z = lO((re) => {
        A.triggerEvent(Zd(), re), $.set(!0);
      }, 400), oe = dr([{ key: Yo(), value: (re) => (cO(re).each((fe) => {
        Z.cancel();
        const ee = { x: fe.clientX, y: fe.clientY, target: re.target };
        Z.schedule(re), $.set(!1), B.set(ee);
      }), M.none()) }, { key: id(), value: (re) => (Z.cancel(), cO(re).each((fe) => {
        B.on((ee) => {
          ((J, le) => {
            const me = Math.abs(J.clientX - le.x), ke = Math.abs(J.clientY - le.y);
            return me > 5 || ke > 5;
          })(fe, ee) && B.clear();
        });
      }), M.none()) }, { key: Ac(), value: (re) => (Z.cancel(), B.get().filter((fe) => tr(fe.target, re.target)).map((fe) => $.get() ? (re.prevent(), !1) : A.triggerEvent(Ul(), re))) }]);
      return { fireIfReady: (re, fe) => cn(oe, fe).bind((ee) => ee(re)) };
    })(i), f = Ct(["touchstart", "touchmove", "touchend", "touchcancel", "gesturestart", "mousedown", "mouseup", "mouseover", "mousemove", "mouseout", "click"].concat(["selectstart", "input", "contextmenu", "change", "transitionend", "transitioncancel", "drag", "dragstart", "dragend", "dragenter", "dragleave", "dragover", "drop", "keyup"]), (A) => sl(o, A, (B) => {
      l.fireIfReady(B, A).each(($) => {
        $ && B.kill();
      }), i.triggerEvent(A, B) && B.kill();
    })), m = As(), b = sl(o, "paste", (A) => {
      l.fireIfReady(A, "paste").each((B) => {
        B && A.kill();
      }), i.triggerEvent("paste", A) && A.kill(), m.set(setTimeout(() => {
        i.triggerEvent(wn(), A);
      }, 0));
    }), x = sl(o, "keydown", (A) => {
      i.triggerEvent("keydown", A) ? A.kill() : i.stopBackspace && ((B) => B.raw.which === aC[0] && !Bn(["input", "textarea"], Ti(B.target)) && !ux(B.target, '[contenteditable="true"]'))(A) && A.prevent();
    }), w = sl(o, "focusin", (A) => {
      i.triggerEvent("focusin", A) && A.kill();
    }), E = As(), O = sl(o, "focusout", (A) => {
      i.triggerEvent("focusout", A) && A.kill(), E.set(setTimeout(() => {
        i.triggerEvent(Im(), A);
      }, 0));
    });
    return { unbind: () => {
      tn(f, (A) => {
        A.unbind();
      }), x.unbind(), w.unbind(), O.unbind(), b.unbind(), m.on(clearTimeout), E.on(clearTimeout);
    } };
  }, fE = (o, s) => {
    const i = cn(o, "target").getOr(s);
    return Ln(i);
  }, dx = Fa([{ stopped: [] }, { resume: ["element"] }, { complete: [] }]), uO = (o, s, i, l, f, m) => {
    const b = o(s, l), x = ((w, E) => {
      const O = Ln(!1), A = Ln(!1);
      return { stop: () => {
        O.set(!0);
      }, cut: () => {
        A.set(!0);
      }, isStopped: O.get, isCut: A.get, event: w, setSource: E.set, getSource: E.get };
    })(i, f);
    return b.fold(() => (m.logEventNoHandlers(s, l), dx.complete()), (w) => {
      const E = w.descHandler;
      return su(E)(x), x.isStopped() ? (m.logEventStopped(s, w.element, E.purpose), dx.stopped()) : x.isCut() ? (m.logEventCut(s, w.element, E.purpose), dx.complete()) : cl(w.element).fold(() => (m.logNoParent(s, w.element, E.purpose), dx.complete()), (O) => (m.logEventResponse(s, w.element, E.purpose), dx.resume(O)));
    });
  }, dO = (o, s, i, l, f, m) => uO(o, s, i, l, f, m).fold(un, (b) => dO(o, s, i, b, f, m), Xe), fO = (o, s, i, l, f) => {
    const m = fE(i, l);
    return dO(o, s, i, l, m, f);
  }, WM = () => {
    const o = (() => {
      const l = {};
      return { registerId: (f, m, b) => {
        Mr(b, (x, w) => {
          const E = l[w] !== void 0 ? l[w] : {};
          E[m] = ((O, A) => ({ cHandler: We.apply(void 0, [O.handler].concat(A)), purpose: O.purpose }))(x, f), l[w] = E;
        });
      }, unregisterId: (f) => {
        Mr(l, (m, b) => {
          _n(m, f) && delete m[f];
        });
      }, filterByType: (f) => cn(l, f).map((m) => Po(m, (b, x) => ((w, E) => ({ id: w, descHandler: E }))(x, b))).getOr([]), find: (f, m, b) => cn(l, m).bind((x) => lc(b, (w) => ((E, O) => R(O).bind((A) => cn(E, A)).map((A) => ((B, $) => ({ element: B, descHandler: $ }))(O, A)))(x, w), f)) };
    })(), s = {}, i = (l) => {
      R(l.element).each((f) => {
        delete s[f], o.unregisterId(f);
      });
    };
    return { find: (l, f, m) => o.find(l, f, m), filter: (l) => o.filterByType(l), register: (l) => {
      const f = ((b) => {
        const x = b.element;
        return R(x).getOrThunk(() => ((w, E) => {
          const O = hn(zf + "uid-");
          return C(E, O), O;
        })(0, b.element));
      })(l);
      Ys(s, f) && ((b, x) => {
        const w = s[x];
        if (w !== b)
          throw new Error('The tagId "' + x + '" is already used by: ' + Eu(w.element) + `
Cannot use it for: ` + Eu(b.element) + `
The conflicting element is` + (Rr(w.element) ? " " : " not ") + "already in the DOM");
        i(b);
      })(l, f);
      const m = [l];
      o.registerId(m, f, l.events), s[f] = l;
    }, unregister: i, getById: (l) => cn(s, l) };
  }, Uu = Bu({ name: "Container", factory: (o) => {
    const { attributes: s, ...i } = o.dom;
    return { uid: o.uid, dom: { tag: "div", attributes: { role: "presentation", ...s }, ...i }, components: o.components, behaviours: ir(o.containerBehaviours), events: o.events, domModification: o.domModification, eventOrder: o.eventOrder };
  }, configFields: [He("components", []), pa("containerBehaviours", []), He("events", {}), He("domModification", {}), He("eventOrder", {})] }), mE = (o) => {
    const s = (re) => cl(o.element).fold(un, (fe) => tr(re, fe)), i = WM(), l = (re, fe) => i.find(s, re, fe), f = ZM(o.element, { triggerEvent: (re, fe) => Wm(re, fe.target, (ee) => ((J, le, me, ke) => fO(J, le, me, me.target, ke))(l, re, fe, ee)) }), m = { debugInfo: Ee("real"), triggerEvent: (re, fe, ee) => {
      Wm(re, fe, (J) => fO(l, re, ee, fe, J));
    }, triggerFocus: (re, fe) => {
      R(re).fold(() => {
        gc(re);
      }, (ee) => {
        Wm(Mi(), re, (J) => (((le, me, ke, Re, qe) => {
          const mt = fE(ke, Re);
          uO(le, me, ke, Re, mt, qe);
        })(l, Mi(), { originator: fe, kill: gt, prevent: gt, target: re }, re, J), !1));
      });
    }, triggerEscape: (re, fe) => {
      m.triggerEvent("keydown", re.element, fe.event);
    }, getByUid: (re) => Z(re), getByDom: (re) => oe(re), build: Nl, buildOrPatch: rb, addToGui: (re) => {
      w(re);
    }, removeFromGui: (re) => {
      E(re);
    }, addToWorld: (re) => {
      b(re);
    }, removeFromWorld: (re) => {
      x(re);
    }, broadcast: (re) => {
      A(re);
    }, broadcastOn: (re, fe) => {
      B(re, fe);
    }, broadcastEvent: (re, fe) => {
      $(re, fe);
    }, isConnected: un }, b = (re) => {
      re.connect(m), Gi(re.element) || (i.register(re), tn(re.components(), b), m.triggerEvent(ru(), re.element, { target: re.element }));
    }, x = (re) => {
      Gi(re.element) || (tn(re.components(), x), i.unregister(re)), re.disconnect();
    }, w = (re) => {
      sp(o, re);
    }, E = (re) => {
      Cm(re);
    }, O = (re) => {
      const fe = i.filter(ta());
      tn(fe, (ee) => {
        const J = ee.descHandler;
        su(J)(re);
      });
    }, A = (re) => {
      O({ universal: !0, data: re });
    }, B = (re, fe) => {
      O({ universal: !1, channels: re, data: fe });
    }, $ = (re, fe) => ((ee, J, le) => {
      const me = ((ke) => {
        const Re = Ln(!1);
        return { stop: () => {
          Re.set(!0);
        }, cut: gt, isStopped: Re.get, isCut: Xe, event: ke, setSource: ko("Cannot set source of a broadcasted event"), getSource: ko("Cannot get source of a broadcasted event") };
      })(J);
      return tn(ee, (ke) => {
        const Re = ke.descHandler;
        su(Re)(me);
      }), me.isStopped();
    })(i.filter(re), fe), Z = (re) => i.getById(re).fold(() => To.error(new Error('Could not find component with uid: "' + re + '" in system.')), To.value), oe = (re) => {
      const fe = R(re).getOr("not found");
      return Z(fe);
    };
    return b(o), { root: o, element: o.element, destroy: () => {
      f.unbind(), ya(o.element);
    }, add: w, remove: E, getByUid: Z, getByDom: oe, addToWorld: b, removeFromWorld: x, broadcast: A, broadcastOn: B, broadcastEvent: $ };
  }, qM = Ee([He("prefix", "form-field"), pa("fieldBehaviours", [rr, ln])]), _1 = Ee([rn({ schema: [st("dom")], name: "label" }), rn({ factory: { sketch: (o) => ({ uid: o.uid, dom: { tag: "span", styles: { display: "none" }, attributes: { "aria-hidden": "true" }, innerHtml: o.text } }) }, schema: [st("text")], name: "aria-descriptor" }), Lt({ factory: { sketch: (o) => {
    const s = ((i, l) => {
      const f = {};
      return Mr(i, (m, b) => {
        Bn(l, b) || (f[b] = m);
      }), f;
    })(o, ["factory"]);
    return o.factory.sketch(s);
  } }, schema: [st("factory")], name: "field" })]), Fr = hc({ name: "FormField", configFields: qM(), partFields: _1(), factory: (o, s, i, l) => {
    const f = Fi(o.fieldBehaviours, [rr.config({ find: (x) => Dn(x, o, "field") }), ln.config({ store: { mode: "manual", getValue: (x) => rr.getCurrent(x).bind(ln.getValue), setValue: (x, w) => {
      rr.getCurrent(x).each((E) => {
        ln.setValue(E, w);
      });
    } } })]), m = Bo([ss((x, w) => {
      const E = yl(x, o, ["label", "field", "aria-descriptor"]);
      E.field().each((O) => {
        const A = hn(o.prefix);
        E.label().each((B) => {
          eo(B.element, "for", A), eo(O.element, "id", A);
        }), E["aria-descriptor"]().each((B) => {
          const $ = hn(o.prefix);
          eo(B.element, "id", $), eo(O.element, "aria-describedby", $);
        });
      });
    })]), b = { getField: (x) => Dn(x, o, "field"), getLabel: (x) => Dn(x, o, "label") };
    return { uid: o.uid, dom: o.dom, components: s, behaviours: f, events: m, apis: b };
  }, apis: { getField: (o, s) => o.getField(s), getLabel: (o, s) => o.getLabel(s) } });
  var GM = Object.freeze({ __proto__: null, exhibit: (o, s) => Xa({ attributes: dr([{ key: s.tabAttr, value: "true" }]) }) }), iy = [He("tabAttr", "data-alloy-tabstop")];
  const Aa = _i({ fields: iy, name: "tabstopping", active: GM });
  var KM = tinymce.util.Tools.resolve("tinymce.html.Entities");
  const ju = (o, s, i, l) => {
    const f = mO(o, s, i, l);
    return Fr.sketch(f);
  }, mO = (o, s, i, l) => ({ dom: pE(i), components: o.toArray().concat([s]), fieldBehaviours: $t(l) }), pE = (o) => ({ tag: "div", classes: ["tox-form__group"].concat(o) }), Vh = (o, s) => Fr.parts.label({ dom: { tag: "label", classes: ["tox-label"] }, components: [Os(s.translate(o))] }), df = hn("form-component-change"), C1 = hn("form-close"), ly = hn("form-cancel"), Hg = hn("form-action"), fx = hn("form-submit"), V0 = hn("form-block"), mx = hn("form-unblock"), gE = hn("form-tabchange"), hE = hn("form-resize"), pO = (o, s, i) => {
    const l = o.label.map((A) => Vh(A, s)), f = s.icons(), m = (A) => (B, $) => {
      Ou($.event.target, "[data-collection-item-value]").each((Z) => {
        A(B, $, Z, js(Z, "data-collection-item-value"));
      });
    }, b = m((A, B, $, Z) => {
      B.stop(), s.isDisabled() || pn(A, Hg, { name: o.name, value: Z });
    }), x = [ft(_e(), m((A, B, $) => {
      gc($);
    })), ft(yr(), b), ft(Ul(), b), ft(Oe(), m((A, B, $) => {
      fa(A.element, "." + jv).each((Z) => {
        $s(Z, jv);
      }), vr($, jv);
    })), ft(zt(), m((A) => {
      fa(A.element, "." + jv).each((B) => {
        $s(B, jv);
      });
    })), hl(m((A, B, $, Z) => {
      pn(A, Hg, { name: o.name, value: Z });
    }))], w = (A, B) => Ct(Kl(A.element, ".tox-collection__item"), B), E = Fr.parts.field({ dom: { tag: "div", classes: ["tox-collection"].concat(o.columns !== 1 ? ["tox-collection--grid"] : ["tox-collection--list"]) }, components: [], factory: { sketch: wt }, behaviours: $t([Xn.config({ disabled: s.isDisabled, onDisabled: (A) => {
      w(A, (B) => {
        vr(B, "tox-collection__item--state-disabled"), eo(B, "aria-disabled", !0);
      });
    }, onEnabled: (A) => {
      w(A, (B) => {
        $s(B, "tox-collection__item--state-disabled"), ts(B, "aria-disabled");
      });
    } }), il(), Jn.config({}), ln.config({ store: { mode: "memory", initialValue: i.getOr([]) }, onSetValue: (A, B) => {
      (($, Z) => {
        const oe = Ct(Z, (ee) => {
          const J = _d.translate(ee.text), le = o.columns === 1 ? `<div class="tox-collection__item-label">${J}</div>` : "", me = `<div class="tox-collection__item-icon">${((qe) => {
            var mt;
            return (mt = f[qe]) !== null && mt !== void 0 ? mt : qe;
          })(ee.icon)}</div>`, ke = { _: " ", " - ": " ", "-": " " }, Re = J.replace(/\_| \- |\-/g, (qe) => ke[qe]);
          return `<div class="tox-collection__item${s.isDisabled() ? " tox-collection__item--state-disabled" : ""}" tabindex="-1" data-collection-item-value="${KM.encodeAllRaw(ee.value)}" title="${Re}" aria-label="${Re}">${me}${le}</div>`;
        }), re = o.columns !== "auto" && o.columns > 1 ? yo(oe, o.columns) : [oe], fe = Ct(re, (ee) => `<div class="tox-collection__group">${ee.join("")}</div>`);
        tl($.element, fe.join(""));
      })(A, B), o.columns === "auto" && N0(A, 5, "tox-collection__item").each(({ numRows: $, numColumns: Z }) => {
        Jt.setGridSize(A, $, Z);
      }), Io(A, hE);
    } }), Aa.config({}), Jt.config((O = o.columns, O === 1 ? { mode: "menu", moveOnTab: !1, selector: ".tox-collection__item" } : O === "auto" ? { mode: "flatgrid", selector: ".tox-collection__item", initSize: { numColumns: 1, numRows: 1 } } : { mode: "matrix", selectors: { row: ".tox-collection__group", cell: `.${Ck}` } })), wo("collection-events", x)]), eventOrder: { [gl()]: ["disabling", "alloy.base.behaviour", "collection-events"] } });
    var O;
    return ju(l, E, ["tox-form__group--collection"], []);
  }, YM = ["input", "textarea"], gO = (o) => {
    const s = Ti(o);
    return Bn(YM, s);
  }, bE = (o, s) => {
    const i = s.getRoot(o).getOr(o.element);
    $s(i, s.invalidClass), s.notify.each((l) => {
      gO(o.element) && eo(o.element, "aria-invalid", !1), l.getContainer(o).each((f) => {
        tl(f, l.validHtml);
      }), l.onValid(o);
    });
  }, hO = (o, s, i, l) => {
    const f = s.getRoot(o).getOr(o.element);
    vr(f, s.invalidClass), s.notify.each((m) => {
      gO(o.element) && eo(o.element, "aria-invalid", !0), m.getContainer(o).each((b) => {
        tl(b, l);
      }), m.onInvalid(o, l);
    });
  }, Yk = (o, s, i) => s.validator.fold(() => $g(To.value(!0)), (l) => l.validate(o)), Xk = (o, s, i) => (s.notify.each((l) => {
    l.onValidate(o);
  }), Yk(o, s).map((l) => o.getSystem().isConnected() ? l.fold((f) => (hO(o, s, 0, f), To.error(f)), (f) => (bE(o, s), To.value(f))) : To.error("No longer in system")));
  var XM = Object.freeze({ __proto__: null, markValid: bE, markInvalid: hO, query: Yk, run: Xk, isInvalid: (o, s) => {
    const i = s.getRoot(o).getOr(o.element);
    return _s(i, s.invalidClass);
  } }), JM = Object.freeze({ __proto__: null, events: (o, s) => o.validator.map((i) => Bo([ft(i.onEvent, (l) => {
    Xk(l, o).get(wt);
  })].concat(i.validateOnLoad ? [ss((l) => {
    Xk(l, o).get(gt);
  })] : []))).getOr({}) }), QM = [st("invalidClass"), He("getRoot", M.none), Ol("notify", [He("aria", "alert"), He("getContainer", M.none), He("validHtml", ""), Vo("onValid"), Vo("onInvalid"), Vo("onValidate")]), Ol("validator", [st("validate"), He("onEvent", "input"), He("validateOnLoad", !0)])];
  const gp = _i({ fields: QM, name: "invalidating", active: JM, apis: XM, extra: { validation: (o) => (s) => {
    const i = ln.getValue(s);
    return $g(o(i));
  } } }), px = _i({ fields: [], name: "unselecting", active: Object.freeze({ __proto__: null, events: () => Bo([$a(Ni(), un)]), exhibit: () => Xa({ styles: { "-webkit-user-select": "none", "user-select": "none", "-ms-user-select": "none", "-moz-user-select": "-moz-none" }, attributes: { unselectable: "on" } }) }) }), U0 = hn("color-input-change"), gx = hn("color-swatch-change"), yE = hn("color-picker-cancel"), bO = rn({ schema: [st("dom")], name: "label" }), cy = (o) => rn({ name: o + "-edge", overrides: (s) => s.model.manager.edgeActions[o].fold(() => ({}), (i) => ({ events: Bo([dc(Yo(), (l, f, m) => i(l, m), [s]), dc(da(), (l, f, m) => i(l, m), [s]), dc(z(), (l, f, m) => {
    m.mouseIsDown.get() && i(l, m);
  }, [s])]) })) }), eB = cy("top-left"), tB = cy("top"), nB = cy("top-right"), vE = cy("right"), yO = cy("bottom-right"), vO = cy("bottom"), xE = cy("bottom-left"), oB = cy("left"), xO = Lt({ name: "thumb", defaults: Ee({ dom: { styles: { position: "absolute" } } }), overrides: (o) => ({ events: Bo([cd(Yo(), o, "spectrum"), cd(id(), o, "spectrum"), cd(Ac(), o, "spectrum"), cd(da(), o, "spectrum"), cd(z(), o, "spectrum"), cd(X(), o, "spectrum")]) }) }), Jk = (o) => cp(o.event);
  var rB = [bO, oB, vE, tB, vO, eB, nB, xE, yO, xO, Lt({ schema: [ua("mouseIsDown", () => Ln(!1))], name: "spectrum", overrides: (o) => {
    const s = o.model.manager, i = (l, f) => s.getValueFromEvent(f).map((m) => s.setValueFrom(l, o, m));
    return { behaviours: $t([Jt.config({ mode: "special", onLeft: (l, f) => s.onLeft(l, o, Jk(f)), onRight: (l, f) => s.onRight(l, o, Jk(f)), onUp: (l, f) => s.onUp(l, o, Jk(f)), onDown: (l, f) => s.onDown(l, o, Jk(f)) }), Aa.config({}), io.config({})]), events: Bo([ft(Yo(), i), ft(id(), i), ft(da(), i), ft(z(), (l, f) => {
      o.mouseIsDown.get() && i(l, f);
    })]) };
  } })];
  const hx = Ee("slider.change.value"), Qk = (o) => {
    const s = o.event.raw;
    if (((i) => i.type.indexOf("touch") !== -1)(s)) {
      const i = s;
      return i.touches !== void 0 && i.touches.length === 1 ? M.some(i.touches[0]).map((l) => so(l.clientX, l.clientY)) : M.none();
    }
    {
      const i = s;
      return i.clientX !== void 0 ? M.some(i).map((l) => so(l.clientX, l.clientY)) : M.none();
    }
  }, S1 = (o) => o.model.minX, E1 = (o) => o.model.minY, j0 = (o) => o.model.minX - 1, bx = (o) => o.model.minY - 1, uy = (o) => o.model.maxX, T1 = (o) => o.model.maxY, Z0 = (o) => o.model.maxX + 1, e_ = (o) => o.model.maxY + 1, wO = (o, s, i) => s(o) - i(o), wE = (o) => wO(o, uy, S1), kE = (o) => wO(o, T1, E1), kO = (o) => wE(o) / 2, _E = (o) => kE(o) / 2, dy = (o, s) => s ? o.stepSize * o.speedMultiplier : o.stepSize, _O = (o) => o.snapToGrid, yx = (o) => o.snapStart, CO = (o) => o.rounded, t_ = (o, s) => o[s + "-edge"] !== void 0, SO = (o) => t_(o, "left"), EO = (o) => t_(o, "right"), TO = (o) => t_(o, "top"), zO = (o) => t_(o, "bottom"), Vg = (o) => o.model.value.get(), fy = (o, s) => ({ x: o, y: s }), hp = (o, s) => {
    pn(o, hx(), { value: s });
  }, vx = (o, s, i, l) => o < s ? o : o > i ? i : o === s ? s - 1 : Math.max(s, o - l), Uh = (o, s, i, l) => o > i ? o : o < s ? s : o === i ? i + 1 : Math.min(i, o + l), OO = (o, s, i) => Math.max(s, Math.min(i, o)), AO = (o) => {
    const { min: s, max: i, range: l, value: f, step: m, snap: b, snapStart: x, rounded: w, hasMinEdge: E, hasMaxEdge: O, minBound: A, maxBound: B, screenRange: $ } = o, Z = E ? s - 1 : s, oe = O ? i + 1 : i;
    if (f < A)
      return Z;
    if (f > B)
      return oe;
    {
      const re = ((ee, J, le) => Math.min(le, Math.max(ee, J)) - J)(f, A, B), fe = OO(re / $ * l + s, Z, oe);
      return b && fe >= s && fe <= i ? ((ee, J, le, me, ke) => ke.fold(() => {
        const Re = ee - J, qe = Math.round(Re / me) * me;
        return OO(J + qe, J - 1, le + 1);
      }, (Re) => {
        const qe = (ee - Re) % me, mt = Math.round(qe / me), bt = Math.floor((ee - Re) / me), St = Math.floor((le - Re) / me), Qt = Re + Math.min(St, bt + mt) * me;
        return Math.max(Re, Qt);
      }))(fe, s, i, m, x) : w ? Math.round(fe) : fe;
    }
  }, n_ = (o) => {
    const { min: s, max: i, range: l, value: f, hasMinEdge: m, hasMaxEdge: b, maxBound: x, maxOffset: w, centerMinEdge: E, centerMaxEdge: O } = o;
    return f < s ? m ? 0 : E : f > i ? b ? x : O : (f - s) / l * w;
  }, o_ = "top", DO = "right", RO = "bottom", r_ = "left", Ug = (o) => o.element.dom.getBoundingClientRect(), Om = (o, s) => o[s], xx = (o) => {
    const s = Ug(o);
    return Om(s, r_);
  }, s_ = (o) => {
    const s = Ug(o);
    return Om(s, DO);
  }, a_ = (o) => {
    const s = Ug(o);
    return Om(s, o_);
  }, CE = (o) => {
    const s = Ug(o);
    return Om(s, RO);
  }, NO = (o) => {
    const s = Ug(o);
    return Om(s, "width");
  }, W0 = (o) => {
    const s = Ug(o);
    return Om(s, "height");
  }, MO = (o, s, i) => (o + s) / 2 - i, BO = (o, s) => {
    const i = Ug(o), l = Ug(s), f = Om(i, r_), m = Om(i, DO), b = Om(l, r_);
    return MO(f, m, b);
  }, i_ = (o, s) => {
    const i = Ug(o), l = Ug(s), f = Om(i, o_), m = Om(i, RO), b = Om(l, o_);
    return MO(f, m, b);
  }, q0 = (o, s) => {
    pn(o, hx(), { value: s });
  }, SE = (o, s, i) => {
    const l = { min: S1(s), max: uy(s), range: wE(s), value: i, step: dy(s), snap: _O(s), snapStart: yx(s), rounded: CO(s), hasMinEdge: SO(s), hasMaxEdge: EO(s), minBound: xx(o), maxBound: s_(o), screenRange: NO(o) };
    return AO(l);
  }, l_ = (o) => (s, i, l) => ((f, m, b, x) => {
    const w = (f > 0 ? Uh : vx)(Vg(b), S1(b), uy(b), dy(b, x));
    return q0(m, w), M.some(w);
  })(o, s, i, l).map(un), EE = (o, s, i, l, f, m) => {
    const b = ((x, w, E, O, A) => {
      const B = NO(x), $ = O.bind((re) => M.some(BO(re, x))).getOr(0), Z = A.bind((re) => M.some(BO(re, x))).getOr(B), oe = { min: S1(w), max: uy(w), range: wE(w), value: E, hasMinEdge: SO(w), hasMaxEdge: EO(w), minBound: xx(x), minOffset: 0, maxBound: s_(x), maxOffset: B, centerMinEdge: $, centerMaxEdge: Z };
      return n_(oe);
    })(s, m, i, l, f);
    return xx(s) - xx(o) + b;
  }, sB = l_(-1), TE = l_(1), aB = M.none, iB = M.none, lB = { "top-left": M.none(), top: M.none(), "top-right": M.none(), right: M.some((o, s) => {
    hp(o, Z0(s));
  }), "bottom-right": M.none(), bottom: M.none(), "bottom-left": M.none(), left: M.some((o, s) => {
    hp(o, j0(s));
  }) };
  var cB = Object.freeze({ __proto__: null, setValueFrom: (o, s, i) => {
    const l = SE(o, s, i);
    return q0(o, l), l;
  }, setToMin: (o, s) => {
    const i = S1(s);
    q0(o, i);
  }, setToMax: (o, s) => {
    const i = uy(s);
    q0(o, i);
  }, findValueOfOffset: SE, getValueFromEvent: (o) => Qk(o).map((s) => s.left), findPositionOfValue: EE, setPositionFromValue: (o, s, i, l) => {
    const f = Vg(i), m = EE(o, l.getSpectrum(o), f, l.getLeftEdge(o), l.getRightEdge(o), i), b = Wr(s.element) / 2;
    qn(s.element, "left", m - b + "px");
  }, onLeft: sB, onRight: TE, onUp: aB, onDown: iB, edgeActions: lB });
  const c_ = (o, s) => {
    pn(o, hx(), { value: s });
  }, zE = (o, s, i) => {
    const l = { min: E1(s), max: T1(s), range: kE(s), value: i, step: dy(s), snap: _O(s), snapStart: yx(s), rounded: CO(s), hasMinEdge: TO(s), hasMaxEdge: zO(s), minBound: a_(o), maxBound: CE(o), screenRange: W0(o) };
    return AO(l);
  }, LO = (o) => (s, i, l) => ((f, m, b, x) => {
    const w = (f > 0 ? Uh : vx)(Vg(b), E1(b), T1(b), dy(b, x));
    return c_(m, w), M.some(w);
  })(o, s, i, l).map(un), OE = (o, s, i, l, f, m) => {
    const b = ((x, w, E, O, A) => {
      const B = W0(x), $ = O.bind((re) => M.some(i_(re, x))).getOr(0), Z = A.bind((re) => M.some(i_(re, x))).getOr(B), oe = { min: E1(w), max: T1(w), range: kE(w), value: E, hasMinEdge: TO(w), hasMaxEdge: zO(w), minBound: a_(x), minOffset: 0, maxBound: CE(x), maxOffset: B, centerMinEdge: $, centerMaxEdge: Z };
      return n_(oe);
    })(s, m, i, l, f);
    return a_(s) - a_(o) + b;
  }, uB = M.none, dB = M.none, fB = LO(-1), mB = LO(1), AE = { "top-left": M.none(), top: M.some((o, s) => {
    hp(o, bx(s));
  }), "top-right": M.none(), right: M.none(), "bottom-right": M.none(), bottom: M.some((o, s) => {
    hp(o, e_(s));
  }), "bottom-left": M.none(), left: M.none() };
  var pB = Object.freeze({ __proto__: null, setValueFrom: (o, s, i) => {
    const l = zE(o, s, i);
    return c_(o, l), l;
  }, setToMin: (o, s) => {
    const i = E1(s);
    c_(o, i);
  }, setToMax: (o, s) => {
    const i = T1(s);
    c_(o, i);
  }, findValueOfOffset: zE, getValueFromEvent: (o) => Qk(o).map((s) => s.top), findPositionOfValue: OE, setPositionFromValue: (o, s, i, l) => {
    const f = Vg(i), m = OE(o, l.getSpectrum(o), f, l.getTopEdge(o), l.getBottomEdge(o), i), b = Qe(s.element) / 2;
    qn(s.element, "top", m - b + "px");
  }, onLeft: uB, onRight: dB, onUp: fB, onDown: mB, edgeActions: AE });
  const u_ = (o, s) => {
    pn(o, hx(), { value: s });
  }, d_ = (o, s) => ({ x: o, y: s }), wx = (o, s) => (i, l, f) => ((m, b, x, w, E) => {
    const O = m > 0 ? Uh : vx, A = b ? Vg(w).x : O(Vg(w).x, S1(w), uy(w), dy(w, E)), B = b ? O(Vg(w).y, E1(w), T1(w), dy(w, E)) : Vg(w).y;
    return u_(x, d_(A, B)), M.some(A);
  })(o, s, i, l, f).map(un), gB = wx(-1, !1), hB = wx(1, !1), bB = wx(-1, !0), yB = wx(1, !0), vB = { "top-left": M.some((o, s) => {
    hp(o, fy(j0(s), bx(s)));
  }), top: M.some((o, s) => {
    hp(o, fy(kO(s), bx(s)));
  }), "top-right": M.some((o, s) => {
    hp(o, fy(Z0(s), bx(s)));
  }), right: M.some((o, s) => {
    hp(o, fy(Z0(s), _E(s)));
  }), "bottom-right": M.some((o, s) => {
    hp(o, fy(Z0(s), e_(s)));
  }), bottom: M.some((o, s) => {
    hp(o, fy(kO(s), e_(s)));
  }), "bottom-left": M.some((o, s) => {
    hp(o, fy(j0(s), e_(s)));
  }), left: M.some((o, s) => {
    hp(o, fy(j0(s), _E(s)));
  }) };
  var xB = Object.freeze({ __proto__: null, setValueFrom: (o, s, i) => {
    const l = SE(o, s, i.left), f = zE(o, s, i.top), m = d_(l, f);
    return u_(o, m), m;
  }, setToMin: (o, s) => {
    const i = S1(s), l = E1(s);
    u_(o, d_(i, l));
  }, setToMax: (o, s) => {
    const i = uy(s), l = T1(s);
    u_(o, d_(i, l));
  }, getValueFromEvent: (o) => Qk(o), setPositionFromValue: (o, s, i, l) => {
    const f = Vg(i), m = EE(o, l.getSpectrum(o), f.x, l.getLeftEdge(o), l.getRightEdge(o), i), b = OE(o, l.getSpectrum(o), f.y, l.getTopEdge(o), l.getBottomEdge(o), i), x = Wr(s.element) / 2, w = Qe(s.element) / 2;
    qn(s.element, "left", m - x + "px"), qn(s.element, "top", b - w + "px");
  }, onLeft: gB, onRight: hB, onUp: bB, onDown: yB, edgeActions: vB });
  const Gf = hc({ name: "Slider", configFields: [He("stepSize", 1), He("speedMultiplier", 10), He("onChange", gt), He("onChoose", gt), He("onInit", gt), He("onDragStart", gt), He("onDragEnd", gt), He("snapToGrid", !1), He("rounded", !0), pr("snapStart"), zl("model", bi("mode", { x: [He("minX", 0), He("maxX", 100), ua("value", (o) => Ln(o.mode.minX)), st("getInitialValue"), ms("manager", cB)], y: [He("minY", 0), He("maxY", 100), ua("value", (o) => Ln(o.mode.minY)), st("getInitialValue"), ms("manager", pB)], xy: [He("minX", 0), He("maxX", 100), He("minY", 0), He("maxY", 100), ua("value", (o) => Ln({ x: o.mode.minX, y: o.mode.minY })), st("getInitialValue"), ms("manager", xB)] })), pa("sliderBehaviours", [Jt, ln]), ua("mouseIsDown", () => Ln(!1))], partFields: rB, factory: (o, s, i, l) => {
    const f = (ee) => ii(ee, o, "thumb"), m = (ee) => ii(ee, o, "spectrum"), b = (ee) => Dn(ee, o, "left-edge"), x = (ee) => Dn(ee, o, "right-edge"), w = (ee) => Dn(ee, o, "top-edge"), E = (ee) => Dn(ee, o, "bottom-edge"), O = o.model, A = O.manager, B = (ee, J) => {
      A.setPositionFromValue(ee, J, o, { getLeftEdge: b, getRightEdge: x, getTopEdge: w, getBottomEdge: E, getSpectrum: m });
    }, $ = (ee, J) => {
      O.value.set(J);
      const le = f(ee);
      B(ee, le);
    }, Z = (ee) => {
      const J = o.mouseIsDown.get();
      o.mouseIsDown.set(!1), J && Dn(ee, o, "thumb").each((le) => {
        const me = O.value.get();
        o.onChoose(ee, le, me);
      });
    }, oe = (ee, J) => {
      J.stop(), o.mouseIsDown.set(!0), o.onDragStart(ee, f(ee));
    }, re = (ee, J) => {
      J.stop(), o.onDragEnd(ee, f(ee)), Z(ee);
    }, fe = (ee) => {
      Dn(ee, o, "spectrum").map(Jt.focusIn);
    };
    return { uid: o.uid, dom: o.dom, components: s, behaviours: Fi(o.sliderBehaviours, [Jt.config({ mode: "special", focusIn: fe }), ln.config({ store: { mode: "manual", getValue: (ee) => O.value.get(), setValue: $ } }), pc.config({ channels: { [nt()]: { onReceive: Z } } })]), events: Bo([ft(hx(), (ee, J) => {
      ((le, me) => {
        $(le, me);
        const ke = f(le);
        o.onChange(le, ke, me);
      })(ee, J.event.value);
    }), ss((ee, J) => {
      const le = O.getInitialValue();
      O.value.set(le);
      const me = f(ee);
      B(ee, me);
      const ke = m(ee);
      o.onInit(ee, me, ke, O.value.get());
    }), ft(Yo(), oe), ft(Ac(), re), ft(da(), (ee, J) => {
      fe(ee), oe(ee, J);
    }), ft(X(), re)]), apis: { resetToMin: (ee) => {
      A.setToMin(ee, o);
    }, resetToMax: (ee) => {
      A.setToMax(ee, o);
    }, setValue: $, refresh: B }, domModification: { styles: { position: "relative" } } };
  }, apis: { setValue: (o, s, i) => {
    o.setValue(s, i);
  }, resetToMin: (o, s) => {
    o.resetToMin(s);
  }, resetToMax: (o, s) => {
    o.resetToMax(s);
  }, refresh: (o, s) => {
    o.refresh(s);
  } } }), DE = hn("rgb-hex-update"), PO = hn("slider-update"), IO = hn("palette-update"), FO = "form", wB = [pa("formBehaviours", [ln])], $O = (o) => "<alloy.field." + o + ">", kB = (o, s) => ({ uid: o.uid, dom: o.dom, components: s, behaviours: Fi(o.formBehaviours, [ln.config({ store: { mode: "manual", getValue: (i) => {
    const l = Ng(i, o);
    return ho(l, (f, m) => f().bind((b) => {
      return x = rr.getCurrent(b), w = new Error(`Cannot find a current component to extract the value from for form part '${m}': ` + Eu(b.element)), x.fold(() => To.error(w), To.value);
      var x, w;
    }).map(ln.getValue));
  }, setValue: (i, l) => {
    Mr(l, (f, m) => {
      Dn(i, o, m).each((b) => {
        rr.getCurrent(b).each((x) => {
          ln.setValue(x, f);
        });
      });
    });
  } } })]), apis: { getField: (i, l) => Dn(i, o, l).bind(rr.getCurrent) } }), G0 = { getField: _o((o, s, i) => o.getField(s, i)), sketch: (o) => {
    const s = (() => {
      const m = [];
      return { field: (b, x) => (m.push(b), zr(FO, $O(b), x)), record: Ee(m) };
    })(), i = o(s), l = s.record(), f = Ct(l, (m) => Lt({ name: m, pname: $O(m) }));
    return Sv(FO, wB, f, kB, i);
  } }, HO = hn("valid-input"), VO = hn("invalid-input"), UO = hn("validating-input"), RE = "colorcustom.rgb.", _B = (o, s, i, l) => {
    const f = (O, A) => gp.config({ invalidClass: s("invalid"), notify: { onValidate: (B) => {
      pn(B, UO, { type: O });
    }, onValid: (B) => {
      pn(B, HO, { type: O, value: ln.getValue(B) });
    }, onInvalid: (B) => {
      pn(B, VO, { type: O, value: ln.getValue(B) });
    } }, validator: { validate: (B) => {
      const $ = ln.getValue(B), Z = A($) ? To.value(!0) : To.error(o("aria.input.invalid"));
      return $g(Z);
    }, validateOnLoad: !1 } }), m = (O, A, B, $, Z) => {
      const oe = o(RE + "range"), re = Fr.parts.label({ dom: { tag: "label", attributes: { "aria-label": $ } }, components: [Os(B)] }), fe = Fr.parts.field({ data: Z, factory: Yb, inputAttributes: { type: "text", ...A === "hex" ? { "aria-live": "polite" } : {} }, inputClasses: [s("textfield")], inputBehaviours: $t([f(A, O), Aa.config({})]), onSetValue: (le) => {
        gp.isInvalid(le) && gp.run(le).get(gt);
      } }), ee = [re, fe], J = A !== "hex" ? [Fr.parts["aria-descriptor"]({ text: oe })] : [];
      return { dom: { tag: "div", attributes: { role: "presentation" } }, components: ee.concat(J) };
    }, b = (O, A) => {
      const B = A.red, $ = A.green, Z = A.blue;
      ln.setValue(O, { red: B, green: $, blue: Z });
    }, x = Ur({ dom: { tag: "div", classes: [s("rgba-preview")], styles: { "background-color": "white" }, attributes: { role: "presentation" } } }), w = (O, A) => {
      x.getOpt(O).each((B) => {
        qn(B.element, "background-color", "#" + A.value);
      });
    };
    return Bu({ factory: () => {
      const O = { red: Ln(M.some(255)), green: Ln(M.some(255)), blue: Ln(M.some(255)), hex: Ln(M.some("ffffff")) }, A = (me) => O[me].get(), B = (me, ke) => {
        O[me].set(ke);
      }, $ = (me) => {
        const ke = me.red, Re = me.green, qe = me.blue;
        B("red", M.some(ke)), B("green", M.some(Re)), B("blue", M.some(qe));
      }, Z = (me, ke) => {
        const Re = ke.event;
        Re.type !== "hex" ? B(Re.type, M.none()) : l(me);
      }, oe = (me, ke) => {
        const Re = ke.event;
        ((qe) => qe.type === "hex")(Re) ? ((qe, mt) => {
          i(qe);
          const bt = Lz(mt);
          B("hex", M.some(bt.value));
          const St = ox(bt);
          b(qe, St), $(St), pn(qe, DE, { hex: bt }), w(qe, bt);
        })(me, Re.value) : ((qe, mt, bt) => {
          const St = parseInt(bt, 10);
          B(mt, M.some(St)), A("red").bind((Qt) => A("green").bind((vn) => A("blue").map((Mn) => ny(Qt, vn, Mn, 1)))).each((Qt) => {
            const vn = ((Mn, Qn) => {
              const fo = nx(Qn);
              return G0.getField(Mn, "hex").each(($o) => {
                io.isFocused($o) || ln.setValue(Mn, { hex: fo.value });
              }), fo;
            })(qe, Qt);
            pn(qe, DE, { hex: vn }), w(qe, vn);
          });
        })(me, Re.type, Re.value);
      }, re = (me) => ({ label: o(RE + me + ".label"), description: o(RE + me + ".description") }), fe = re("red"), ee = re("green"), J = re("blue"), le = re("hex");
      return be(G0.sketch((me) => ({ dom: { tag: "form", classes: [s("rgb-form")], attributes: { "aria-label": o("aria.color.picker") } }, components: [me.field("red", Fr.sketch(m(HS, "red", fe.label, fe.description, 255))), me.field("green", Fr.sketch(m(HS, "green", ee.label, ee.description, 255))), me.field("blue", Fr.sketch(m(HS, "blue", J.label, J.description, 255))), me.field("hex", Fr.sketch(m(Iz, "hex", le.label, le.description, "ffffff"))), x.asSpec()], formBehaviours: $t([gp.config({ invalidClass: s("form-invalid") }), wo("rgb-form-events", [ft(HO, oe), ft(VO, Z), ft(UO, Z)])]) })), { apis: { updateHex: (me, ke) => {
        ln.setValue(me, { hex: ke.value }), ((Re, qe) => {
          const mt = ox(qe);
          b(Re, mt), $(mt);
        })(me, ke), w(me, ke);
      } } });
    }, name: "RgbForm", configFields: [], apis: { updateHex: (O, A, B) => {
      O.updateHex(A, B);
    } }, extraApis: {} });
  }, f_ = (o, s) => Bu({ name: "ColourPicker", configFields: [st("dom"), He("onValidHex", gt), He("onInvalidHex", gt)], factory: (l) => {
    const f = _B(o, s, l.onValidHex, l.onInvalidHex), m = ((oe, re) => {
      const fe = Gf.parts.spectrum({ dom: { tag: "canvas", attributes: { role: "presentation" }, classes: [re("sv-palette-spectrum")] } }), ee = Gf.parts.thumb({ dom: { tag: "div", attributes: { role: "presentation" }, classes: [re("sv-palette-thumb")], innerHtml: `<div class=${re("sv-palette-inner-thumb")} role="presentation"></div>` } }), J = (le, me) => {
        const { width: ke, height: Re } = le, qe = le.getContext("2d");
        if (qe === null)
          return;
        qe.fillStyle = me, qe.fillRect(0, 0, ke, Re);
        const mt = qe.createLinearGradient(0, 0, ke, 0);
        mt.addColorStop(0, "rgba(255,255,255,1)"), mt.addColorStop(1, "rgba(255,255,255,0)"), qe.fillStyle = mt, qe.fillRect(0, 0, ke, Re);
        const bt = qe.createLinearGradient(0, 0, 0, Re);
        bt.addColorStop(0, "rgba(0,0,0,0)"), bt.addColorStop(1, "rgba(0,0,0,1)"), qe.fillStyle = bt, qe.fillRect(0, 0, ke, Re);
      };
      return Bu({ factory: (le) => {
        const me = Ee({ x: 0, y: 0 }), ke = $t([rr.config({ find: M.some }), io.config({})]);
        return Gf.sketch({ dom: { tag: "div", attributes: { role: "slider", "aria-valuetext": oe(["Saturation {0}%, Brightness {1}%", 0, 0]) }, classes: [re("sv-palette")] }, model: { mode: "xy", getInitialValue: me }, rounded: !1, components: [fe, ee], onChange: (Re, qe, mt) => {
          en(mt) || eo(Re.element, "aria-valuetext", oe(["Saturation {0}%, Brightness {1}%", Math.floor(mt.x), Math.floor(100 - mt.y)])), pn(Re, IO, { value: mt });
        }, onInit: (Re, qe, mt, bt) => {
          J(mt.element.dom, Vz(jS));
        }, sliderBehaviours: ke });
      }, name: "SaturationBrightnessPalette", configFields: [], apis: { setHue: (le, me, ke) => {
        ((Re, qe) => {
          const mt = Re.components()[0].element.dom, bt = rx(qe, 100, 100), St = Hz(bt);
          J(mt, Vz(St));
        })(me, ke);
      }, setThumb: (le, me, ke) => {
        ((Re, qe) => {
          const mt = GS(ox(qe));
          Gf.setValue(Re, { x: mt.saturation, y: 100 - mt.value }), eo(Re.element, "aria-valuetext", oe(["Saturation {0}%, Brightness {1}%", mt.saturation, mt.value]));
        })(me, ke);
      } }, extraApis: {} });
    })(o, s), b = { paletteRgba: Ln(jS), paletteHue: Ln(0) }, x = Ur(((oe, re) => {
      const fe = Gf.parts.spectrum({ dom: { tag: "div", classes: [re("hue-slider-spectrum")], attributes: { role: "presentation" } } }), ee = Gf.parts.thumb({ dom: { tag: "div", classes: [re("hue-slider-thumb")], attributes: { role: "presentation" } } });
      return Gf.sketch({ dom: { tag: "div", classes: [re("hue-slider")], attributes: { role: "slider", "aria-valuemin": 0, "aria-valuemax": 360, "aria-valuenow": 120 } }, rounded: !1, model: { mode: "y", getInitialValue: Ee(0) }, components: [fe, ee], sliderBehaviours: $t([io.config({})]), onChange: (J, le, me) => {
        eo(J.element, "aria-valuenow", Math.floor(360 - 3.6 * me)), pn(J, PO, { value: me });
      } });
    })(0, s)), w = Ur(m.sketch({})), E = Ur(f.sketch({})), O = (oe, re, fe) => {
      w.getOpt(oe).each((ee) => {
        m.setHue(ee, fe);
      });
    }, A = (oe, re) => {
      E.getOpt(oe).each((fe) => {
        f.updateHex(fe, re);
      });
    }, B = (oe, re, fe) => {
      x.getOpt(oe).each((ee) => {
        Gf.setValue(ee, ((J) => 100 - J / 360 * 100)(fe));
      });
    }, $ = (oe, re) => {
      w.getOpt(oe).each((fe) => {
        m.setThumb(fe, re);
      });
    }, Z = (oe, re, fe, ee) => {
      ((J, le) => {
        const me = ox(J);
        b.paletteRgba.set(me), b.paletteHue.set(le);
      })(re, fe), tn(ee, (J) => {
        J(oe, re, fe);
      });
    };
    return { uid: l.uid, dom: l.dom, components: [w.asSpec(), x.asSpec(), E.asSpec()], behaviours: $t([wo("colour-picker-events", [ft(DE, (() => {
      const oe = [O, B, $];
      return (re, fe) => {
        const ee = fe.event.hex, J = ((le) => GS(ox(le)))(ee);
        Z(re, ee, J.hue, oe);
      };
    })()), ft(IO, (() => {
      const oe = [A];
      return (re, fe) => {
        const ee = fe.event.value, J = b.paletteHue.get(), le = rx(J, ee.x, 100 - ee.y), me = jz(le);
        Z(re, me, J, oe);
      };
    })()), ft(PO, (() => {
      const oe = [O, A];
      return (re, fe) => {
        const ee = ((Re) => (100 - Re) / 100 * 360)(fe.event.value), J = b.paletteRgba.get(), le = GS(J), me = rx(ee, le.saturation, le.value), ke = jz(me);
        Z(re, ke, ee, oe);
      };
    })())]), rr.config({ find: (oe) => E.getOpt(oe) }), Jt.config({ mode: "acyclic" })]) };
  } }), my = () => rr.config({ find: M.some }), kx = (o) => rr.config({ find: (s) => Dr(s.element, o).bind((i) => s.getSystem().getByDom(i).toOptional()) }), CB = Nn([He("preprocess", wt), He("postprocess", wt)]), SB = (o, s) => {
    const i = Ta("RepresentingConfigs.memento processors", CB, s);
    return ln.config({ store: { mode: "manual", getValue: (l) => {
      const f = o.get(l), m = ln.getValue(f);
      return i.postprocess(m);
    }, setValue: (l, f) => {
      const m = i.preprocess(f), b = o.get(l);
      ln.setValue(b, m);
    } } });
  }, z1 = (o, s, i) => ln.config({ store: { mode: "manual", ...o.map((l) => ({ initialValue: l })).getOr({}), getValue: s, setValue: i } }), NE = (o, s, i) => z1(o, (l) => s(l.element), (l, f) => i(l.element, f)), m_ = (o) => ln.config({ store: { mode: "memory", initialValue: o } }), ME = { "colorcustom.rgb.red.label": "R", "colorcustom.rgb.red.description": "Red component", "colorcustom.rgb.green.label": "G", "colorcustom.rgb.green.description": "Green component", "colorcustom.rgb.blue.label": "B", "colorcustom.rgb.blue.description": "Blue component", "colorcustom.rgb.hex.label": "#", "colorcustom.rgb.hex.description": "Hex color code", "colorcustom.rgb.range": "Range 0 to 255", "aria.color.picker": "Color Picker", "aria.input.invalid": "Invalid input" };
  var BE = tinymce.util.Tools.resolve("tinymce.Resource"), jg = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const _x = (o, s) => {
    let i = null;
    const l = () => {
      Ze(i) || (clearTimeout(i), i = null);
    };
    return { cancel: l, throttle: (...f) => {
      l(), i = setTimeout(() => {
        i = null, o.apply(null, f);
      }, s);
    } };
  }, K0 = hn("alloy-fake-before-tabstop"), p_ = hn("alloy-fake-after-tabstop"), Wp = (o) => ({ dom: { tag: "div", styles: { width: "1px", height: "1px", outline: "none" }, attributes: { tabindex: "0" }, classes: o }, behaviours: $t([io.config({ ignore: !0 }), Aa.config({})]) }), g_ = (o, s) => ({ dom: { tag: "div", classes: ["tox-navobj", ...o.getOr([])] }, components: [Wp([K0]), s, Wp([p_])], behaviours: $t([kx(1)]) }), jO = (o, s) => {
    pn(o, bn(), { raw: { which: 9, shiftKey: s } });
  }, EB = (o, s) => {
    const i = s.element;
    _s(i, K0) ? jO(o, !0) : _s(i, p_) && jO(o, !1);
  }, Cx = (o) => ux(o, ["." + K0, "." + p_].join(","), Xe), h_ = hn("update-dialog"), Y0 = hn("update-title"), ZO = hn("update-body"), LE = hn("update-footer"), b_ = hn("body-send-message"), y_ = hn("dialog-focus-shifted"), Sx = Ic().browser, O1 = Sx.isSafari(), TB = Sx.isFirefox(), PE = O1 || TB, WO = Sx.isChromium(), zB = ({ scrollTop: o, scrollHeight: s, clientHeight: i }) => Math.ceil(o) + i >= s, qO = (o, s) => o.scrollTo(0, s === "bottom" ? 99999999 : s), GO = (o, s, i) => {
    const l = o.dom;
    M.from(l.contentDocument).fold(i, (f) => {
      let m = 0;
      const b = ((w, E) => {
        const O = w.body;
        return M.from(!/^<!DOCTYPE (html|HTML)/.test(E) && (!WO && !O1 || it(O) && (O.scrollTop !== 0 || Math.abs(O.scrollHeight - O.clientHeight) > 1)) ? O : w.documentElement);
      })(f, s).map((w) => (m = w.scrollTop, w)).forall(zB), x = () => {
        const w = l.contentWindow;
        it(w) && (b ? qO(w, "bottom") : !b && PE && m !== 0 && qO(w, m));
      };
      O1 && l.addEventListener("load", x, { once: !0 }), f.open(), f.write(s), f.close(), O1 || x();
    });
  }, OB = mi(PE, O1 ? 500 : 200).map((o) => ((s, i) => {
    let l = null, f = null;
    return { cancel: () => {
      Ze(l) || (clearTimeout(l), l = null, f = null);
    }, throttle: (...m) => {
      f = m, Ze(l) && (l = setTimeout(() => {
        const b = f;
        l = null, f = null, s.apply(null, b);
      }, i));
    } };
  })(GO, o)), KO = hn("toolbar.button.execute"), A1 = hn("common-button-display-events"), IE = { [gl()]: ["disabling", "alloy.base.behaviour", "toggling", "toolbar-button-events"], [At()]: ["toolbar-button-events", A1], [da()]: ["focusing", "alloy.base.behaviour", A1] }, v_ = (o) => qn(o.element, "width", Ts(o.element, "width")), YO = (o, s, i) => fp(o, { tag: "span", classes: ["tox-icon", "tox-tbtn__icon-wrap"], behaviours: i }, s), x_ = (o, s) => YO(o, s, []), bp = (o, s) => YO(o, s, [Jn.config({})]), FE = (o, s, i) => ({ dom: { tag: "span", classes: [`${s}__select-label`] }, components: [Os(i.translate(o))], behaviours: $t([Jn.config({})]) }), Am = hn("update-menu-text"), D1 = hn("update-menu-icon"), w_ = (o, s, i) => {
    const l = Ln(gt), f = o.text.map((B) => Ur(FE(B, s, i.providers))), m = o.icon.map((B) => Ur(bp(B, i.providers.icons))), b = (B, $) => {
      const Z = ln.getValue(B);
      return io.focus(Z), pn(Z, "keydown", { raw: $.event.raw }), qf.close(Z), M.some(!0);
    }, x = o.role.fold(() => ({}), (B) => ({ role: B })), w = o.tooltip.fold(() => ({}), (B) => {
      const $ = i.providers.translate(B);
      return { title: $, "aria-label": $ };
    }), E = fp("chevron-down", { tag: "div", classes: [`${s}__select-chevron`] }, i.providers.icons), O = hn("common-button-display-events");
    return Ur(qf.sketch({ ...o.uid ? { uid: o.uid } : {}, ...x, dom: { tag: "button", classes: [s, `${s}--select`].concat(Ct(o.classes, (B) => `${s}--${B}`)), attributes: { ...w } }, components: B0([m.map((B) => B.asSpec()), f.map((B) => B.asSpec()), M.some(E)]), matchWidth: !0, useMinWidth: !0, onOpen: (B, $, Z) => {
      o.searchable && ((oe) => {
        fz(oe).each((re) => io.focus(re));
      })(Z);
    }, dropdownBehaviours: $t([...o.dropdownBehaviours, M0(() => o.disabled || i.providers.isDisabled()), il(), px.config({}), Jn.config({}), wo("dropdown-events", [Ih(o, l), Fh(o, l)]), wo(O, [ss((B, $) => v_(B))]), wo("menubutton-update-display-text", [ft(Am, (B, $) => {
      f.bind((Z) => Z.getOpt(B)).each((Z) => {
        Jn.set(Z, [Os(i.providers.translate($.event.text))]);
      });
    }), ft(D1, (B, $) => {
      m.bind((Z) => Z.getOpt(B)).each((Z) => {
        Jn.set(Z, [bp($.event.icon, i.providers.icons)]);
      });
    })])]), eventOrder: be(IE, { mousedown: ["focusing", "alloy.base.behaviour", "item-type-events", "normal-dropdown-events"], [At()]: ["toolbar-button-events", "dropdown-events", O] }), sandboxBehaviours: $t([Jt.config({ mode: "special", onLeft: b, onRight: b }), wo("dropdown-sandbox-events", [ft(Tk, (B, $) => {
      ((Z) => {
        const oe = ln.getValue(Z), re = zk(Z).map(yS);
        qf.refetch(oe).get(() => {
          const fe = Qa.getCoupled(oe, "sandbox");
          re.each((ee) => zk(fe).each((J) => ((le, me) => {
            ln.setValue(le, me.fetchPattern), le.element.dom.selectionStart = me.selectionStart, le.element.dom.selectionEnd = me.selectionEnd;
          })(J, ee)));
        });
      })(B), $.stop();
    }), ft(dz, (B, $) => {
      ((Z, oe) => {
        ((re) => zo.getState(re).bind(mr.getHighlighted).bind(mr.getHighlighted))(Z).each((re) => {
          ((fe, ee, J, le) => {
            const me = { ...le, target: ee };
            fe.getSystem().triggerEvent(J, ee, me);
          })(Z, re.element, oe.event.eventType, oe.event.interactionEvent);
        });
      })(B, $), $.stop();
    })])]), lazySink: i.getSink, toggleClass: `${s}--active`, parts: { menu: { ...Zv(0, o.columns, o.presets), fakeFocus: o.searchable, onHighlightItem: sO, onCollapseMenu: (B, $, Z) => {
      mr.getHighlighted(Z).each((oe) => {
        sO(B, Z, oe);
      });
    }, onDehighlightItem: VM } }, getAnchorOverrides: () => ({ maxHeightFunction: (B, $) => {
      Bp()(B, $ - 10);
    } }), fetch: (B) => sy(We(o.fetch, B)) })).asSpec();
  }, XO = (o) => o.type === "separator", AB = { type: "separator" }, $E = (o, s) => {
    const i = ((l, f) => {
      const m = K(l, (b, x) => ((w) => ce(w))(x) ? x === "" ? b : x === "|" ? b.length > 0 && !XO(b[b.length - 1]) ? b.concat([AB]) : b : _n(f, x.toLowerCase()) ? b.concat([f[x.toLowerCase()]]) : b : b.concat([x]), []);
      return m.length > 0 && XO(m[m.length - 1]) && m.pop(), m;
    })(ce(o) ? o.split(" ") : o, s);
    return Mo(i, (l, f) => {
      if (((m) => _n(m, "getSubmenuItems"))(f)) {
        const m = ((x) => {
          const w = cn(x, "value").getOrThunk(() => hn("generated-menu-item"));
          return be({ value: w }, x);
        })(f), b = ((x, w) => {
          const E = x.getSubmenuItems(), O = $E(E, w);
          return { item: x, menus: be(O.menus, { [x.value]: O.items }), expansions: be(O.expansions, { [x.value]: x.value }) };
        })(m, s);
        return { menus: be(l.menus, b.menus), items: [b.item, ...l.items], expansions: be(l.expansions, b.expansions) };
      }
      return { ...l, items: [f, ...l.items] };
    }, { menus: {}, expansions: {}, items: [] });
  }, R1 = (o, s, i, l) => {
    const f = hn("primary-menu"), m = $E(o, i.shared.providers.menuItems());
    if (m.items.length === 0)
      return M.none();
    const b = ((A) => A.search.fold(() => ({ searchMode: "no-search" }), (B) => ({ searchMode: "search-with-field", placeholder: B.placeholder })))(l), x = iO(f, m.items, s, i, l.isHorizontalMenu, b), w = ((A) => A.search.fold(() => ({ searchMode: "no-search" }), (B) => ({ searchMode: "search-with-results" })))(l), E = ho(m.menus, (A, B) => iO(B, A, s, i, !1, w)), O = be(E, yi(f, x));
    return M.from(Zb.tieredData(f, O, m.expansions));
  }, k_ = (o) => !_n(o, "items"), HE = "data-value", JO = (o, s, i, l) => Ct(i, (f) => k_(f) ? { type: "togglemenuitem", text: f.text, value: f.value, active: f.value === l, onAction: () => {
    ln.setValue(o, f.value), pn(o, df, { name: s }), io.focus(o);
  } } : { type: "nestedmenuitem", text: f.text, getSubmenuItems: () => JO(o, s, f.items, l) }), VE = (o, s) => Ko(o, (i) => k_(i) ? mi(i.value === s, i) : VE(i.items, s)), QO = Bu({ name: "HtmlSelect", configFields: [st("options"), pa("selectBehaviours", [io, ln]), He("selectClasses", []), He("selectAttributes", {}), pr("data")], factory: (o, s) => {
    const i = Ct(o.options, (f) => ({ dom: { tag: "option", value: f.value, innerHtml: f.text } })), l = o.data.map((f) => yi("initialValue", f)).getOr({});
    return { uid: o.uid, dom: { tag: "select", classes: o.selectClasses, attributes: o.selectAttributes }, components: i, behaviours: Fi(o.selectBehaviours, [io.config({}), ln.config({ store: { mode: "manual", getValue: (f) => zu(f.element), setValue: (f, m) => {
      const b = ct(o.options);
      Go(o.options, (x) => x.value === m).isSome() ? dm(f.element, m) : f.element.dom.selectedIndex === -1 && m === "" && b.each((x) => dm(f.element, x.value));
    }, ...l } })]) };
  } }), UE = Ee([He("field1Name", "field1"), He("field2Name", "field2"), bd("onLockedChange"), Au(["lockClass"]), He("locked", !1), $i("coupledFieldBehaviours", [rr, ln])]), __ = (o, s) => Lt({ factory: Fr, name: o, overrides: (i) => ({ fieldBehaviours: $t([wo("coupled-input-behaviour", [ft(Hn(), (l) => {
    ((f, m, b) => Dn(f, m, b).bind(rr.getCurrent))(l, i, s).each((f) => {
      Dn(l, i, "lock").each((m) => {
        Lo.isOn(m) && i.onLockedChange(l, f, m);
      });
    });
  })])]) }) }), eA = Ee([__("field1", "field2"), __("field2", "field1"), Lt({ factory: bc, schema: [st("dom")], name: "lock", overrides: (o) => ({ buttonBehaviours: $t([Lo.config({ selected: o.locked, toggleClass: o.markers.lockClass, aria: { mode: "pressed" } })]) }) })]), ff = hc({ name: "FormCoupledInputs", configFields: UE(), partFields: eA(), factory: (o, s, i, l) => ({ uid: o.uid, dom: o.dom, components: s, behaviours: Ua(o.coupledFieldBehaviours, [rr.config({ find: M.some }), ln.config({ store: { mode: "manual", getValue: (f) => {
    const m = hs(f, o, ["field1", "field2"]);
    return { [o.field1Name]: ln.getValue(m.field1()), [o.field2Name]: ln.getValue(m.field2()) };
  }, setValue: (f, m) => {
    const b = hs(f, o, ["field1", "field2"]);
    Ys(m, o.field1Name) && ln.setValue(b.field1(), m[o.field1Name]), Ys(m, o.field2Name) && ln.setValue(b.field2(), m[o.field2Name]);
  } } })]), apis: { getField1: (f) => Dn(f, o, "field1"), getField2: (f) => Dn(f, o, "field2"), getLock: (f) => Dn(f, o, "lock") } }), apis: { getField1: (o, s) => o.getField1(s), getField2: (o, s) => o.getField2(s), getLock: (o, s) => o.getLock(s) } }), C_ = (o) => {
    const s = /^\s*(\d+(?:\.\d+)?)\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\s*$/.exec(o);
    if (s !== null) {
      const i = parseFloat(s[1]), l = s[2];
      return To.value({ value: i, unit: l });
    }
    return To.error(o);
  }, tA = (o, s) => {
    const i = { "": 96, px: 96, pt: 72, cm: 2.54, pc: 12, mm: 25.4, in: 1 }, l = (f) => _n(i, f);
    return o.unit === s ? M.some(o.value) : l(o.unit) && l(s) ? i[o.unit] === i[s] ? M.some(o.value) : M.some(o.value / i[o.unit] * i[s]) : M.none();
  }, Ex = (o) => M.none(), nA = (o, s) => {
    const i = o.label.map((O) => Vh(O, s)), l = [Xn.config({ disabled: () => o.disabled || s.isDisabled() }), il(), Jt.config({ mode: "execution", useEnter: o.multiline !== !0, useControlEnter: o.multiline === !0, execute: (O) => (Io(O, fx), M.some(!0)) }), wo("textfield-change", [ft(Hn(), (O, A) => {
      pn(O, df, { name: o.name });
    }), ft(wn(), (O, A) => {
      pn(O, df, { name: o.name });
    })]), Aa.config({})], f = o.validation.map((O) => gp.config({ getRoot: (A) => sa(A.element), invalidClass: "tox-invalid", validator: { validate: (A) => {
      const B = ln.getValue(A), $ = O.validator(B);
      return $g($ === !0 ? To.value(B) : To.error($));
    }, validateOnLoad: O.validateOnLoad } })).toArray(), m = { ...o.placeholder.fold(Ee({}), (O) => ({ placeholder: s.translate(O) })), ...o.inputMode.fold(Ee({}), (O) => ({ inputmode: O })) }, b = Fr.parts.field({ tag: o.multiline === !0 ? "textarea" : "input", ...o.data.map((O) => ({ data: O })).getOr({}), inputAttributes: m, inputClasses: [o.classname], inputBehaviours: $t(er([l, f])), selectOnFocus: !1, factory: Yb }), x = o.multiline ? { dom: { tag: "div", classes: ["tox-textarea-wrap"] }, components: [b] } : b, w = (o.flex ? ["tox-form__group--stretched"] : []).concat(o.maximized ? ["tox-form-group--maximize"] : []), E = [Xn.config({ disabled: () => o.disabled || s.isDisabled(), onDisabled: (O) => {
      Fr.getField(O).each(Xn.disable);
    }, onEnabled: (O) => {
      Fr.getField(O).each(Xn.enable);
    } }), il()];
    return ju(i, x, w, E);
  }, X0 = (o, s) => s.getAnimationRoot.fold(() => o.element, (i) => i(o)), Zg = (o) => o.dimension.property, Dm = (o, s) => o.dimension.getDimension(s), S_ = (o, s) => {
    const i = X0(o, s);
    jc(i, [s.shrinkingClass, s.growingClass]);
  }, Tx = (o, s) => {
    $s(o.element, s.openClass), vr(o.element, s.closedClass), qn(o.element, Zg(s), "0px"), te(o.element);
  }, J0 = (o, s) => {
    $s(o.element, s.closedClass), vr(o.element, s.openClass), ar(o.element, Zg(s));
  }, oA = (o, s, i, l) => {
    i.setCollapsed(), qn(o.element, Zg(s), Dm(s, o.element)), S_(o, s), Tx(o, s), s.onStartShrink(o), s.onShrunk(o);
  }, rA = (o, s, i, l) => {
    const f = l.getOrThunk(() => Dm(s, o.element));
    i.setCollapsed(), qn(o.element, Zg(s), f), te(o.element);
    const m = X0(o, s);
    $s(m, s.growingClass), vr(m, s.shrinkingClass), Tx(o, s), s.onStartShrink(o);
  }, jE = (o, s, i) => {
    const l = Dm(s, o.element);
    (l === "0px" ? oA : rA)(o, s, i, M.some(l));
  }, ZE = (o, s, i) => {
    const l = X0(o, s), f = _s(l, s.shrinkingClass), m = Dm(s, o.element);
    J0(o, s);
    const b = Dm(s, o.element);
    (f ? () => {
      qn(o.element, Zg(s), m), te(o.element);
    } : () => {
      Tx(o, s);
    })(), $s(l, s.shrinkingClass), vr(l, s.growingClass), J0(o, s), qn(o.element, Zg(s), b), i.setExpanded(), s.onStartGrow(o);
  }, E_ = (o, s, i) => {
    const l = X0(o, s);
    return _s(l, s.growingClass) === !0;
  }, WE = (o, s, i) => {
    const l = X0(o, s);
    return _s(l, s.shrinkingClass) === !0;
  };
  var DB = Object.freeze({ __proto__: null, refresh: (o, s, i) => {
    if (i.isExpanded()) {
      ar(o.element, Zg(s));
      const l = Dm(s, o.element);
      qn(o.element, Zg(s), l);
    }
  }, grow: (o, s, i) => {
    i.isExpanded() || ZE(o, s, i);
  }, shrink: (o, s, i) => {
    i.isExpanded() && jE(o, s, i);
  }, immediateShrink: (o, s, i) => {
    i.isExpanded() && oA(o, s, i);
  }, hasGrown: (o, s, i) => i.isExpanded(), hasShrunk: (o, s, i) => i.isCollapsed(), isGrowing: E_, isShrinking: WE, isTransitioning: (o, s, i) => E_(o, s) || WE(o, s), toggleGrow: (o, s, i) => {
    (i.isExpanded() ? jE : ZE)(o, s, i);
  }, disableTransitions: S_, immediateGrow: (o, s, i) => {
    i.isExpanded() || (J0(o, s), qn(o.element, Zg(s), Dm(s, o.element)), S_(o, s), i.setExpanded(), s.onStartGrow(o), s.onGrown(o));
  } }), sA = Object.freeze({ __proto__: null, exhibit: (o, s, i) => {
    const l = s.expanded;
    return Xa(l ? { classes: [s.openClass], styles: {} } : { classes: [s.closedClass], styles: yi(s.dimension.property, "0px") });
  }, events: (o, s) => Bo([Xd(Ri(), (i, l) => {
    l.event.raw.propertyName === o.dimension.property && (S_(i, o), s.isExpanded() && ar(i.element, o.dimension.property), (s.isExpanded() ? o.onGrown : o.onShrunk)(i));
  })]) }), aA = [st("closedClass"), st("openClass"), st("shrinkingClass"), st("growingClass"), pr("getAnimationRoot"), Vo("onShrunk"), Vo("onStartShrink"), Vo("onGrown"), Vo("onStartGrow"), He("expanded", !1), zl("dimension", bi("property", { width: [ms("property", "width"), ms("getDimension", (o) => Wr(o) + "px")], height: [ms("property", "height"), ms("getDimension", (o) => Qe(o) + "px")] }))];
  const Cd = _i({ fields: aA, name: "sliding", active: sA, apis: DB, state: Object.freeze({ __proto__: null, init: (o) => {
    const s = Ln(o.expanded);
    return as({ isExpanded: () => s.get() === !0, isCollapsed: () => s.get() === !1, setCollapsed: We(s.set, !1), setExpanded: We(s.set, !0), readState: () => "expanded: " + s.get() });
  } }) }), qE = (o) => ({ isEnabled: () => !Xn.isDisabled(o), setEnabled: (s) => Xn.set(o, !s), setActive: (s) => {
    const i = o.element;
    s ? (vr(i, "tox-tbtn--enabled"), eo(i, "aria-pressed", !0)) : ($s(i, "tox-tbtn--enabled"), ts(i, "aria-pressed"));
  }, isActive: () => _s(o.element, "tox-tbtn--enabled"), setText: (s) => {
    pn(o, Am, { text: s });
  }, setIcon: (s) => pn(o, D1, { icon: s }) }), zx = (o, s, i, l, f = !0) => w_({ text: o.text, icon: o.icon, tooltip: o.tooltip, searchable: o.search.isSome(), role: l, fetch: (m, b) => {
    const x = { pattern: o.search.isSome() ? aO(m) : "" };
    o.fetch((w) => {
      b(R1(w, Tm.CLOSE_ON_EXECUTE, i, { isHorizontalMenu: !1, search: o.search }));
    }, x, qE(m));
  }, onSetup: o.onSetup, getApi: qE, columns: 1, presets: "normal", classes: [], dropdownBehaviours: [...f ? [Aa.config({})] : []] }, s, i.shared), iA = (o, s, i) => {
    const l = (m) => (b) => {
      const x = !b.isActive();
      b.setActive(x), m.storage.set(x), i.shared.getSink().each((w) => {
        s().getOpt(w).each((E) => {
          gc(E.element), pn(E, Hg, { name: m.name, value: m.storage.get() });
        });
      });
    }, f = (m) => (b) => {
      b.setActive(m.storage.get());
    };
    return (m) => {
      m(Ct(o, (b) => {
        const x = b.text.fold(() => ({}), (w) => ({ text: w }));
        return { type: b.type, active: !1, ...x, onAction: l(b), onSetup: f(b) };
      }));
    };
  }, lA = (o) => ({ dom: { tag: "span", classes: ["tox-tree__label"], attributes: { title: o, "aria-label": o } }, components: [Os(o)] }), cA = hn("leaf-label-event-id"), GE = ({ leaf: o, onLeafAction: s, visible: i, treeId: l, selectedId: f, backstage: m }) => {
    const b = o.menu.map((w) => zx(w, "tox-mbtn", m, M.none(), i)), x = [lA(o.title)];
    return b.each((w) => x.push(w)), bc.sketch({ dom: { tag: "div", classes: ["tox-tree--leaf__label", "tox-trbtn"].concat(i ? ["tox-tree--leaf__label--visible"] : []) }, components: x, role: "treeitem", action: (w) => {
      s(o.id), w.getSystem().broadcastOn([`update-active-item-${l}`], { value: o.id });
    }, eventOrder: { [bn()]: [cA, "keying"] }, buttonBehaviours: $t([...i ? [Aa.config({})] : [], Lo.config({ toggleClass: "tox-trbtn--enabled", toggleOnExecute: !1, aria: { mode: "selected" } }), pc.config({ channels: { [`update-active-item-${l}`]: { onReceive: (w, E) => {
      (E.value === o.id ? Lo.on : Lo.off)(w);
    } } } }), wo(cA, [ss((w, E) => {
      f.each((O) => {
        (O === o.id ? Lo.on : Lo.off)(w);
      });
    }), ft(bn(), (w, E) => {
      const O = E.event.raw.code === "ArrowLeft", A = E.event.raw.code === "ArrowRight";
      O ? (Va(w.element, ".tox-tree--directory").each((B) => {
        w.getSystem().getByDom(B).each(($) => {
          hd(B, ".tox-tree--directory__label").each((Z) => {
            $.getSystem().getByDom(Z).each(io.focus);
          });
        });
      }), E.stop()) : A && E.stop();
    })])]) });
  }, uA = hn("directory-label-event-id"), dA = ({ directory: o, visible: s, noChildren: i, backstage: l }) => {
    const f = o.menu.map((E) => zx(E, "tox-mbtn", l, M.none())), m = [{ dom: { tag: "div", classes: ["tox-chevron"] }, components: [(b = "chevron-right", x = l.shared.providers.icons, ((E, O, A) => fp(E, { tag: "span", classes: ["tox-tree__icon-wrap", "tox-icon"], behaviours: [] }, O))(b, x))] }, lA(o.title)];
    var b, x;
    f.each((E) => {
      m.push(E);
    });
    const w = (E) => {
      Va(E.element, ".tox-tree--directory").each((O) => {
        E.getSystem().getByDom(O).each((A) => {
          const B = !Lo.isOn(A);
          Lo.toggle(A), pn(E, "expand-tree-node", { expanded: B, node: o.id });
        });
      });
    };
    return bc.sketch({ dom: { tag: "div", classes: ["tox-tree--directory__label", "tox-trbtn"].concat(s ? ["tox-tree--directory__label--visible"] : []) }, components: m, action: w, eventOrder: { [bn()]: [uA, "keying"] }, buttonBehaviours: $t([...s ? [Aa.config({})] : [], wo(uA, [ft(bn(), (E, O) => {
      const A = O.event.raw.code === "ArrowRight", B = O.event.raw.code === "ArrowLeft";
      A && i && O.stop(), (A || B) && Va(E.element, ".tox-tree--directory").each(($) => {
        E.getSystem().getByDom($).each((Z) => {
          !Lo.isOn(Z) && A || Lo.isOn(Z) && B ? (w(E), O.stop()) : B && !Lo.isOn(Z) && (Va(Z.element, ".tox-tree--directory").each((oe) => {
            hd(oe, ".tox-tree--directory__label").each((re) => {
              Z.getSystem().getByDom(re).each(io.focus);
            });
          }), O.stop());
        });
      });
    })])]) });
  }, Ox = ({ children: o, onLeafAction: s, visible: i, treeId: l, expandedIds: f, selectedId: m, backstage: b }) => ({ dom: { tag: "div", classes: ["tox-tree--directory__children"] }, components: o.map((x) => x.type === "leaf" ? GE({ leaf: x, selectedId: m, onLeafAction: s, visible: i, treeId: l, backstage: b }) : KE({ directory: x, expandedIds: f, selectedId: m, onLeafAction: s, labelTabstopping: i, treeId: l, backstage: b })), behaviours: $t([Cd.config({ dimension: { property: "height" }, closedClass: "tox-tree--directory__children--closed", openClass: "tox-tree--directory__children--open", growingClass: "tox-tree--directory__children--growing", shrinkingClass: "tox-tree--directory__children--shrinking", expanded: i }), Jn.config({})]) }), fA = hn("directory-event-id"), KE = ({ directory: o, onLeafAction: s, labelTabstopping: i, treeId: l, backstage: f, expandedIds: m, selectedId: b }) => {
    const { children: x } = o, w = Ln(m), E = m.includes(o.id);
    return { dom: { tag: "div", classes: ["tox-tree--directory"], attributes: { role: "treeitem" } }, components: [dA({ directory: o, visible: i, noChildren: o.children.length === 0, backstage: f }), Ox({ children: x, expandedIds: m, selectedId: b, onLeafAction: s, visible: E, treeId: l, backstage: f })], behaviours: $t([wo(fA, [ss((O, A) => {
      Lo.set(O, E);
    }), ft("expand-tree-node", (O, A) => {
      const { expanded: B, node: $ } = A.event;
      w.set(B ? [...w.get(), $] : w.get().filter((Z) => Z !== $));
    })]), Lo.config({ ...o.children.length > 0 ? { aria: { mode: "expanded" } } : {}, toggleClass: "tox-tree--directory--expanded", onToggled: (O, A) => {
      const B = O.components()[1], $ = (Z = A, x.map((oe) => oe.type === "leaf" ? GE({ leaf: oe, selectedId: b, onLeafAction: s, visible: Z, treeId: l, backstage: f }) : KE({ directory: oe, expandedIds: w.get(), selectedId: b, onLeafAction: s, labelTabstopping: Z, treeId: l, backstage: f })));
      var Z;
      A ? Cd.grow(B) : Cd.shrink(B), Jn.set(B, $);
    } })]) };
  }, RB = hn("tree-event-id");
  var NB = Object.freeze({ __proto__: null, events: (o, s) => {
    const i = o.stream.streams.setup(o, s);
    return Bo([ft(o.event, i), ud(() => s.cancel())].concat(o.cancelEvent.map((l) => [ft(l, () => s.cancel())]).getOr([])));
  } });
  const mA = (o) => {
    const s = Ln(null);
    return as({ readState: () => ({ timer: s.get() !== null ? "set" : "unset" }), setTimer: (i) => {
      s.set(i);
    }, cancel: () => {
      const i = s.get();
      i !== null && i.cancel();
    } });
  };
  var MB = Object.freeze({ __proto__: null, throttle: mA, init: (o) => o.stream.streams.state(o) }), T_ = [zl("stream", bi("mode", { throttle: [st("delay"), He("stopEvent", !0), ms("streams", { setup: (o, s) => {
    const i = o.stream, l = _x(o.onStream, i.delay);
    return s.setTimer(l), (f, m) => {
      l.throttle(f, m), i.stopEvent && m.stop();
    };
  }, state: mA })] })), He("event", "input"), pr("cancelEvent"), bd("onStream")];
  const YE = _i({ fields: T_, name: "streaming", active: NB, state: MB }), Ax = (o, s, i) => {
    const l = ln.getValue(i);
    ln.setValue(s, l), XE(s);
  }, pA = (o, s) => {
    const i = o.element, l = zu(i), f = i.dom;
    js(i, "type") !== "number" && s(f, l);
  }, XE = (o) => {
    pA(o, (s, i) => s.setSelectionRange(i.length, i.length));
  }, z_ = Ee("alloy.typeahead.itemexecute"), BB = Ee([pr("lazySink"), st("fetch"), He("minChars", 5), He("responseTime", 1e3), Vo("onOpen"), He("getHotspot", M.some), He("getAnchorOverrides", Ee({})), He("layouts", M.none()), He("eventOrder", {}), im("model", {}, [He("getDisplayText", (o) => o.meta !== void 0 && o.meta.text !== void 0 ? o.meta.text : o.value), He("selectsOver", !0), He("populateFromBrowse", !0)]), Vo("onSetValue"), fc("onExecute"), Vo("onItemExecute"), He("inputClasses", []), He("inputAttributes", {}), He("inputStyles", {}), He("matchWidth", !0), He("useMinWidth", !1), He("dismissOnBlur", !0), Au(["openClass"]), pr("initialData"), pa("typeaheadBehaviours", [io, ln, YE, Jt, Lo, Qa]), ua("lazyTypeaheadComp", () => Ln(M.none)), ua("previewing", () => Ln(!0))].concat(cz()).concat(aE())), gA = Ee([Vt({ schema: [hg()], name: "menu", overrides: (o) => ({ fakeFocus: !0, onHighlightItem: (s, i, l) => {
    o.previewing.get() ? o.lazyTypeaheadComp.get().each((f) => {
      ((m, b, x) => {
        if (m.selectsOver) {
          const w = ln.getValue(b), E = m.getDisplayText(w), O = ln.getValue(x);
          return m.getDisplayText(O).indexOf(E) === 0 ? M.some(() => {
            Ax(0, b, x), ((A, B) => {
              pA(A, ($, Z) => $.setSelectionRange(B, Z.length));
            })(b, E.length);
          }) : M.none();
        }
        return M.none();
      })(o.model, f, l).fold(() => {
        o.model.selectsOver ? (mr.dehighlight(i, l), o.previewing.set(!0)) : o.previewing.set(!1);
      }, (m) => {
        m(), o.previewing.set(!1);
      });
    }) : o.lazyTypeaheadComp.get().each((f) => {
      o.model.populateFromBrowse && Ax(o.model, f, l), Sa(l.element, "id").each((m) => eo(f.element, "aria-activedescendant", m));
    });
  }, onExecute: (s, i) => o.lazyTypeaheadComp.get().map((l) => (pn(l, z_(), { item: i }), !0)), onHover: (s, i) => {
    o.previewing.set(!1), o.lazyTypeaheadComp.get().each((l) => {
      o.model.populateFromBrowse && Ax(o.model, l, i);
    });
  } }) })]), hA = hc({ name: "Typeahead", configFields: BB(), partFields: gA(), factory: (o, s, i, l) => {
    const f = (A, B, $) => {
      o.previewing.set(!1);
      const Z = Qa.getCoupled(A, "sandbox");
      if (zo.isOpen(Z))
        rr.getCurrent(Z).each((oe) => {
          mr.getHighlighted(oe).fold(() => {
            $(oe);
          }, () => {
            uc(Z, oe.element, "keydown", B);
          });
        });
      else {
        const oe = (re) => {
          rr.getCurrent(re).each($);
        };
        ay(o, b(A), A, Z, l, oe, cu.HighlightMenuAndItem).get(gt);
      }
    }, m = Ek(o), b = (A) => (B) => B.map(($) => {
      const Z = ro($.menus), oe = Qr(Z, (re) => Pn(re.items, (fe) => fe.type === "item"));
      return ln.getState(A).update(Ct(oe, (re) => re.data)), $;
    }), x = (A) => rr.getCurrent(A), w = "typeaheadevents", E = [io.config({}), ln.config({ onSetValue: o.onSetValue, store: { mode: "dataset", getDataKey: (A) => zu(A.element), getFallbackEntry: (A) => ({ value: A, meta: {} }), setValue: (A, B) => {
      dm(A.element, o.model.getDisplayText(B));
    }, ...o.initialData.map((A) => yi("initialValue", A)).getOr({}) } }), YE.config({ stream: { mode: "throttle", delay: o.responseTime, stopEvent: !1 }, onStream: (A, B) => {
      const $ = Qa.getCoupled(A, "sandbox");
      if (io.isFocused(A) && zu(A.element).length >= o.minChars) {
        const Z = x($).bind((re) => mr.getHighlighted(re).map(ln.getValue));
        o.previewing.set(!0);
        const oe = (re) => {
          x($).each((fe) => {
            Z.fold(() => {
              o.model.selectsOver && mr.highlightFirst(fe);
            }, (ee) => {
              mr.highlightBy(fe, (J) => ln.getValue(J).value === ee.value), mr.getHighlighted(fe).orThunk(() => (mr.highlightFirst(fe), M.none()));
            });
          });
        };
        ay(o, b(A), A, $, l, oe, cu.HighlightJustMenu).get(gt);
      }
    }, cancelEvent: ug() }), Jt.config({ mode: "special", onDown: (A, B) => (f(A, B, mr.highlightFirst), M.some(!0)), onEscape: (A) => {
      const B = Qa.getCoupled(A, "sandbox");
      return zo.isOpen(B) ? (zo.close(B), M.some(!0)) : M.none();
    }, onUp: (A, B) => (f(A, B, mr.highlightLast), M.some(!0)), onEnter: (A) => {
      const B = Qa.getCoupled(A, "sandbox"), $ = zo.isOpen(B);
      if ($ && !o.previewing.get())
        return x(B).bind((Z) => mr.getHighlighted(Z)).map((Z) => (pn(A, z_(), { item: Z }), !0));
      {
        const Z = ln.getValue(A);
        return Io(A, ug()), o.onExecute(B, A, Z), $ && zo.close(B), M.some(!0);
      }
    } }), Lo.config({ toggleClass: o.markers.openClass, aria: { mode: "expanded" } }), Qa.config({ others: { sandbox: (A) => Kk(o, A, { onOpen: () => Lo.on(A), onClose: () => {
      o.lazyTypeaheadComp.get().each((B) => ts(B.element, "aria-activedescendant")), Lo.off(A);
    } }) } }), wo(w, [ss((A) => {
      o.lazyTypeaheadComp.set(M.some(A));
    }), ud((A) => {
      o.lazyTypeaheadComp.set(M.none());
    }), hl((A) => {
      const B = gt;
      x1(o, b(A), A, l, B, cu.HighlightMenuAndItem).get(gt);
    }), ft(z_(), (A, B) => {
      const $ = Qa.getCoupled(A, "sandbox");
      Ax(o.model, A, B.event.item), Io(A, ug()), o.onItemExecute(A, $, B.event.item, ln.getValue(A)), zo.close($), XE(A);
    })].concat(o.dismissOnBlur ? [ft(Im(), (A) => {
      const B = Qa.getCoupled(A, "sandbox");
      iu(B.element).isNone() && zo.close(B);
    })] : []))], O = { [Fm()]: [ln.name(), YE.name(), w], ...o.eventOrder };
    return { uid: o.uid, dom: uz(be(o, { inputAttributes: { role: "combobox", "aria-autocomplete": "list", "aria-haspopup": "true" } })), behaviours: { ...m, ...Fi(o.typeaheadBehaviours, E) }, eventOrder: O };
  } }), py = (o) => ({ ...o, toCached: () => py(o.toCached()), bindFuture: (s) => py(o.bind((i) => i.fold((l) => $g(To.error(l)), (l) => s(l)))), bindResult: (s) => py(o.map((i) => i.bind(s))), mapResult: (s) => py(o.map((i) => i.map(s))), mapError: (s) => py(o.map((i) => i.mapError(s))), foldResult: (s, i) => o.map((l) => l.fold(s, i)), withTimeout: (s, i) => py(sy((l) => {
    let f = !1;
    const m = setTimeout(() => {
      f = !0, l(To.error(i()));
    }, s);
    o.get((b) => {
      f || (clearTimeout(m), l(b));
    });
  })) }), bA = (o) => py(sy(o)), O_ = (o, s, i = [], l, f, m) => {
    const b = s.fold(() => ({}), (E) => ({ action: E })), x = { buttonBehaviours: $t([M0(() => !o.enabled || m.isDisabled()), il(), Aa.config({}), wo("button press", [$m("click"), $m("mousedown")])].concat(i)), eventOrder: { click: ["button press", "alloy.base.behaviour"], mousedown: ["button press", "alloy.base.behaviour"] }, ...b }, w = be(x, { dom: l });
    return be(w, { components: f });
  }, LB = (o, s, i, l = []) => {
    const f = { tag: "button", classes: ["tox-tbtn"], attributes: o.tooltip.map((x) => ({ "aria-label": i.translate(x), title: i.translate(x) })).getOr({}) }, m = o.icon.map((x) => x_(x, i.icons)), b = B0([m]);
    return O_(o, s, l, f, b, i);
  }, JE = (o) => {
    switch (o) {
      case "primary":
        return ["tox-button"];
      case "toolbar":
        return ["tox-tbtn"];
      default:
        return ["tox-button", "tox-button--secondary"];
    }
  }, yA = (o, s, i, l = [], f = []) => {
    const m = i.translate(o.text), b = o.icon.map((O) => x_(O, i.icons)), x = [b.getOrThunk(() => Os(m))], w = o.buttonType.getOr(o.primary || o.borderless ? "primary" : "secondary"), E = [...JE(w), ...b.isSome() ? ["tox-button--icon"] : [], ...o.borderless ? ["tox-button--naked"] : [], ...f];
    return O_(o, s, l, { tag: "button", classes: E, attributes: { title: m } }, x, i);
  }, QE = (o, s, i, l = [], f = []) => {
    const m = yA(o, M.some(s), i, l, f);
    return bc.sketch(m);
  }, e4 = (o, s) => (i) => {
    s === "custom" ? pn(i, Hg, { name: o, value: {} }) : s === "submit" ? Io(i, fx) : s === "cancel" ? Io(i, ly) : console.error("Unknown button type: ", s);
  }, A_ = (o, s, i) => {
    if (((l, f) => f === "menu")(0, s)) {
      const l = () => b, f = o, m = { ...o, type: "menubutton", search: M.none(), onSetup: (x) => (x.setEnabled(o.enabled), gt), fetch: iA(f.items, l, i) }, b = Ur(zx(m, "tox-tbtn", i, M.none()));
      return b.asSpec();
    }
    if (((l, f) => f === "custom" || f === "cancel" || f === "submit")(0, s)) {
      const l = e4(o.name, s), f = { ...o, borderless: !1 };
      return QE(f, l, i.shared.providers, []);
    }
    if (((l, f) => f === "togglebutton")(0, s))
      return ((l, f) => {
        var m, b;
        const x = l.icon.map((ee) => bp(ee, f.icons)).map(Ur), w = l.buttonType.getOr(l.primary ? "primary" : "secondary"), E = { ...l, name: (m = l.name) !== null && m !== void 0 ? m : "", primary: w === "primary", tooltip: M.from(l.tooltip), enabled: (b = l.enabled) !== null && b !== void 0 && b, borderless: !1 }, O = E.tooltip.map((ee) => ({ "aria-label": f.translate(ee), title: f.translate(ee) })).getOr({}), A = JE(w ?? "secondary"), B = l.icon.isSome() && l.text.isSome(), $ = { tag: "button", classes: [...A.concat(l.icon.isSome() ? ["tox-button--icon"] : []), ...l.active ? ["tox-button--enabled"] : [], ...B ? ["tox-button--icon-and-text"] : []], attributes: O }, Z = f.translate(l.text.getOr("")), oe = Os(Z), re = [...B0([x.map((ee) => ee.asSpec())]), ...l.text.isSome() ? [oe] : []], fe = O_(E, M.some((ee) => {
          pn(ee, Hg, { name: l.name, value: { setIcon: (J) => {
            x.map((le) => le.getOpt(ee).each((me) => {
              Jn.set(me, [bp(J, f.icons)]);
            }));
          } } });
        }), [], $, re, f);
        return bc.sketch(fe);
      })(o, i.shared.providers);
    throw console.error("Unknown footer button type: ", s), new Error("Unknown footer button type");
  }, PB = { type: "separator" }, IB = (o) => ({ type: "menuitem", value: o.url, text: o.title, meta: { attach: o.attach }, onAction: gt }), t4 = (o, s) => ({ type: "menuitem", value: s, text: o, meta: { attach: void 0 }, onAction: gt }), vA = (o, s) => ((i) => Ct(i, IB))(((i, l) => Pn(l, (f) => f.type === i))(o, s)), xA = (o) => vA("header", o.targets), FB = (o) => vA("anchor", o.targets), $B = (o) => M.from(o.anchorTop).map((s) => t4("<top>", s)).toArray(), n4 = (o) => M.from(o.anchorBottom).map((s) => t4("<bottom>", s)).toArray(), D_ = (o, s) => {
    const i = o.toLowerCase();
    return Pn(s, (l) => {
      var f;
      const m = l.meta !== void 0 && l.meta.text !== void 0 ? l.meta.text : l.text, b = (f = l.value) !== null && f !== void 0 ? f : "";
      return ba(m.toLowerCase(), i) || ba(b.toLowerCase(), i);
    });
  }, wA = hn("aria-invalid"), HB = (o, s) => {
    o.dom.checked = s;
  }, kA = (o) => o.dom.checked, vl = (o) => (s, i, l, f) => cn(i, "name").fold(() => o(i, f, M.none()), (m) => s.field(m, o(i, f, cn(l, m)))), VB = { bar: vl((o, s) => ((i, l) => ({ dom: { tag: "div", classes: ["tox-bar", "tox-form__controls-h-stack"] }, components: Ct(i.items, l.interpreter) }))(o, s.shared)), collection: vl((o, s, i) => pO(o, s.shared.providers, i)), alertbanner: vl((o, s) => ((i, l) => {
    const f = KC(i.icon, l.icons);
    return Uu.sketch({ dom: { tag: "div", attributes: { role: "alert" }, classes: ["tox-notification", "tox-notification--in", `tox-notification--${i.level}`] }, components: [{ dom: { tag: "div", classes: ["tox-notification__icon"], innerHtml: i.url ? void 0 : f }, components: i.url ? [bc.sketch({ dom: { tag: "button", classes: ["tox-button", "tox-button--naked", "tox-button--icon"], innerHtml: f, attributes: { title: l.translate(i.iconTooltip) } }, action: (m) => pn(m, Hg, { name: "alert-banner", value: i.url }), buttonBehaviours: $t([gk()]) })] : void 0 }, { dom: { tag: "div", classes: ["tox-notification__body"], innerHtml: l.translate(i.text) } }] });
  })(o, s.shared.providers)), input: vl((o, s, i) => ((l, f, m) => nA({ name: l.name, multiline: !1, label: l.label, inputMode: l.inputMode, placeholder: l.placeholder, flex: !1, disabled: !l.enabled, classname: "tox-textfield", validation: M.none(), maximized: l.maximized, data: m }, f))(o, s.shared.providers, i)), textarea: vl((o, s, i) => ((l, f, m) => nA({ name: l.name, multiline: !0, label: l.label, inputMode: M.none(), placeholder: l.placeholder, flex: !0, disabled: !l.enabled, classname: "tox-textarea", validation: M.none(), maximized: l.maximized, data: m }, f))(o, s.shared.providers, i)), label: vl((o, s) => ((i, l) => {
    const f = "tox-label";
    return { dom: { tag: "div", classes: ["tox-form__group"] }, components: [{ dom: { tag: "label", classes: [f, ...i.align === "center" ? [`${f}--center`] : [], ...i.align === "end" ? [`${f}--end`] : []] }, components: [Os(l.providers.translate(i.label))] }, ...Ct(i.items, l.interpreter)], behaviours: $t([my(), Jn.config({}), (m = M.none(), NE(m, Hm, tl)), Jt.config({ mode: "acyclic" })]) };
    var m;
  })(o, s.shared)), iframe: (y4 = (o, s, i) => ((l, f, m) => {
    const b = "tox-dialog__iframe", x = l.transparent ? [] : [`${b}--opaque`], w = l.border ? ["tox-navobj-bordered"] : [], E = { ...l.label.map(($) => ({ title: $ })).getOr({}), ...m.map(($) => ({ srcdoc: $ })).getOr({}), ...l.sandboxed ? { sandbox: "allow-scripts allow-same-origin" } : {} }, O = (($, Z) => {
      const oe = Ln($.getOr(""));
      return { getValue: (re) => oe.get(), setValue: (re, fe) => {
        if (oe.get() !== fe) {
          const ee = re.element, J = () => eo(ee, "srcdoc", fe);
          Z ? OB.fold(Ee(GO), (le) => le.throttle)(ee, fe, J) : J();
        }
        oe.set(fe);
      } };
    })(m, l.streamContent), A = l.label.map(($) => Vh($, f)), B = Fr.parts.field({ factory: { sketch: ($) => g_(M.from(w), { uid: $.uid, dom: { tag: "iframe", attributes: E, classes: [b, ...x] }, behaviours: $t([Aa.config({}), io.config({}), z1(m, O.getValue, O.setValue), pc.config({ channels: { [y_]: { onReceive: (Z, oe) => {
      oe.newFocus.each((re) => {
        sa(Z.element).each((fe) => {
          (tr(Z.element, re) ? vr : $s)(fe, "tox-navobj-bordered-focus");
        });
      });
    } } } })]) }) } });
    return ju(A, B, ["tox-form__group--stretched"], []);
  })(o, s.shared.providers, i), (o, s, i, l) => {
    const f = be(s, { source: "dynamic" });
    return vl(y4)(o, f, i, l);
  }), button: vl((o, s) => ((i, l) => {
    const f = e4(i.name, "custom");
    return m = M.none(), b = Fr.parts.field({ factory: bc, ...yA(i, M.some(f), l, [m_(""), my()]) }), ju(m, b, [], []);
    var m, b;
  })(o, s.shared.providers)), checkbox: vl((o, s, i) => ((l, f, m) => {
    const b = (A) => (A.element.dom.click(), M.some(!0)), x = Fr.parts.field({ factory: { sketch: wt }, dom: { tag: "input", classes: ["tox-checkbox__input"], attributes: { type: "checkbox" } }, behaviours: $t([my(), Xn.config({ disabled: () => !l.enabled || f.isDisabled(), onDisabled: (A) => {
      sa(A.element).each((B) => vr(B, "tox-checkbox--disabled"));
    }, onEnabled: (A) => {
      sa(A.element).each((B) => $s(B, "tox-checkbox--disabled"));
    } }), Aa.config({}), io.config({}), NE(m, kA, HB), Jt.config({ mode: "special", onEnter: b, onSpace: b, stopSpaceKeyup: !0 }), wo("checkbox-events", [ft(En(), (A, B) => {
      pn(A, df, { name: l.name });
    })])]) }), w = Fr.parts.label({ dom: { tag: "span", classes: ["tox-checkbox__label"] }, components: [Os(f.translate(l.label))], behaviours: $t([px.config({})]) }), E = (A) => fp(A === "checked" ? "selected" : "unselected", { tag: "span", classes: ["tox-icon", "tox-checkbox-icon__" + A] }, f.icons), O = Ur({ dom: { tag: "div", classes: ["tox-checkbox__icons"] }, components: [E("checked"), E("unchecked")] });
    return Fr.sketch({ dom: { tag: "label", classes: ["tox-checkbox"] }, components: [x, O.asSpec(), w], fieldBehaviours: $t([Xn.config({ disabled: () => !l.enabled || f.isDisabled() }), il()]) });
  })(o, s.shared.providers, i)), colorinput: vl((o, s, i) => ((l, f, m, b) => {
    const x = Fr.parts.field({ factory: Yb, inputClasses: ["tox-textfield"], data: b, onSetValue: (A) => gp.run(A).get(gt), inputBehaviours: $t([Xn.config({ disabled: f.providers.isDisabled }), il(), Aa.config({}), gp.config({ invalidClass: "tox-textbox-field-invalid", getRoot: (A) => sa(A.element), notify: { onValid: (A) => {
      const B = ln.getValue(A);
      pn(A, U0, { color: B });
    } }, validator: { validateOnLoad: !1, validate: (A) => {
      const B = ln.getValue(A);
      if (B.length === 0)
        return $g(To.value(!0));
      {
        const $ = Cl("span");
        qn($, "background-color", B);
        const Z = Xs($, "background-color").fold(() => To.error("blah"), (oe) => To.value(B));
        return $g(Z);
      }
    } } })]), selectOnFocus: !1 }), w = l.label.map((A) => Vh(A, f.providers)), E = (A, B) => {
      pn(A, gx, { value: B });
    }, O = Ur(((A, B) => qf.sketch({ dom: A.dom, components: A.components, toggleClass: "mce-active", dropdownBehaviours: $t([M0(B.providers.isDisabled), il(), px.config({}), Aa.config({})]), layouts: A.layouts, sandboxClasses: ["tox-dialog__popups"], lazySink: B.getSink, fetch: ($) => sy((Z) => A.fetch(Z)).map((Z) => M.from(cE(be(Wk(hn("menu-value"), Z, (oe) => {
      A.onItemAction($, oe);
    }, A.columns, A.presets, Tm.CLOSE_ON_EXECUTE, Xe, B.providers), { movement: qk(A.columns, A.presets) })))), parts: { menu: Zv(0, 0, A.presets) } }))({ dom: { tag: "span", attributes: { "aria-label": f.providers.translate("Color swatch") } }, layouts: { onRtl: () => [Tr, Bi, ma], onLtr: () => [Bi, Tr, ma] }, components: [], fetch: JS(m.getColors(l.storageKey), l.storageKey, m.hasCustomColors()), columns: m.getColorCols(l.storageKey), presets: "color", onItemAction: (A, B) => {
      O.getOpt(A).each(($) => {
        B === "custom" ? m.colorPicker((Z) => {
          Z.fold(() => Io($, yE), (oe) => {
            E($, oe), Uz(l.storageKey, oe);
          });
        }, "#ffffff") : E($, B === "remove" ? "" : B);
      });
    } }, f));
    return Fr.sketch({ dom: { tag: "div", classes: ["tox-form__group"] }, components: w.toArray().concat([{ dom: { tag: "div", classes: ["tox-color-input"] }, components: [x, O.asSpec()] }]), fieldBehaviours: $t([wo("form-field-events", [ft(U0, (A, B) => {
      O.getOpt(A).each(($) => {
        qn($.element, "background-color", B.event.color);
      }), pn(A, df, { name: l.name });
    }), ft(gx, (A, B) => {
      Fr.getField(A).each(($) => {
        ln.setValue($, B.event.value), rr.getCurrent(A).each(io.focus);
      });
    }), ft(yE, (A, B) => {
      Fr.getField(A).each(($) => {
        rr.getCurrent(A).each(io.focus);
      });
    })])]) });
  })(o, s.shared, s.colorinput, i)), colorpicker: vl((o, s, i) => ((l, f, m) => {
    const b = (E) => "tox-" + E, x = f_(((E) => (O) => ce(O) ? E.translate(ME[O]) : E.translate(O))(f), b), w = Ur(x.sketch({ dom: { tag: "div", classes: [b("color-picker-container")], attributes: { role: "presentation" } }, onValidHex: (E) => {
      pn(E, Hg, { name: "hex-valid", value: !0 });
    }, onInvalidHex: (E) => {
      pn(E, Hg, { name: "hex-valid", value: !1 });
    } }));
    return { dom: { tag: "div" }, components: [w.asSpec()], behaviours: $t([z1(m, (E) => {
      const O = w.get(E);
      return rr.getCurrent(O).bind((A) => ln.getValue(A).hex).map((A) => "#" + Qu(A, "#")).getOr("");
    }, (E, O) => {
      const A = M.from(/^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/.exec(O)).bind(($) => It($, 1)), B = w.get(E);
      rr.getCurrent(B).fold(() => {
        console.log("Can not find form");
      }, ($) => {
        ln.setValue($, { hex: A.getOr("") }), G0.getField($, "hex").each((Z) => {
          Io(Z, Hn());
        });
      });
    }), my()]) };
  })(0, s.shared.providers, i)), dropzone: vl((o, s, i) => ((l, f, m) => {
    const b = (Z, oe) => {
      oe.stop();
    }, x = (Z) => (oe, re) => {
      tn(Z, (fe) => {
        fe(oe, re);
      });
    }, w = (Z, oe) => {
      var re;
      if (!Xn.isDisabled(Z)) {
        const fe = oe.event.raw;
        O(Z, (re = fe.dataTransfer) === null || re === void 0 ? void 0 : re.files);
      }
    }, E = (Z, oe) => {
      const re = oe.event.raw.target;
      O(Z, re.files);
    }, O = (Z, oe) => {
      oe && (ln.setValue(Z, ((re, fe) => {
        const ee = jg.explode(fe.getOption("images_file_types"));
        return Pn(co(re), (J) => jr(ee, (le) => _l(J.name.toLowerCase(), `.${le.toLowerCase()}`)));
      })(oe, f)), pn(Z, df, { name: l.name }));
    }, A = Ur({ dom: { tag: "input", attributes: { type: "file", accept: "image/*" }, styles: { display: "none" } }, behaviours: $t([wo("input-file-events", [Su(yr()), Su(Ul())])]) }), B = l.label.map((Z) => Vh(Z, f)), $ = Fr.parts.field({ factory: { sketch: (Z) => ({ uid: Z.uid, dom: { tag: "div", classes: ["tox-dropzone-container"] }, behaviours: $t([m_(m.getOr([])), my(), Xn.config({}), Lo.config({ toggleClass: "dragenter", toggleOnExecute: !1 }), wo("dropzone-events", [ft("dragenter", x([b, Lo.toggle])), ft("dragleave", x([b, Lo.toggle])), ft("dragover", b), ft("drop", x([b, w])), ft(En(), E)])]), components: [{ dom: { tag: "div", classes: ["tox-dropzone"], styles: {} }, components: [{ dom: { tag: "p" }, components: [Os(f.translate("Drop an image here"))] }, bc.sketch({ dom: { tag: "button", styles: { position: "relative" }, classes: ["tox-button", "tox-button--secondary"] }, components: [Os(f.translate("Browse for an image")), A.asSpec()], action: (oe) => {
      A.get(oe).element.dom.click();
    }, buttonBehaviours: $t([Aa.config({}), M0(f.isDisabled), il()]) })] }] }) } });
    return ju(B, $, ["tox-form__group--stretched"], []);
  })(o, s.shared.providers, i)), grid: vl((o, s) => ((i, l) => ({ dom: { tag: "div", classes: ["tox-form__grid", `tox-form__grid--${i.columns}col`] }, components: Ct(i.items, l.interpreter) }))(o, s.shared)), listbox: vl((o, s, i) => ((l, f, m) => {
    const b = f.shared.providers, x = m.bind((A) => VE(l.items, A)).orThunk(() => ct(l.items).filter(k_)), w = l.label.map((A) => Vh(A, b)), E = Fr.parts.field({ dom: {}, factory: { sketch: (A) => w_({ uid: A.uid, text: x.map((B) => B.text), icon: M.none(), tooltip: l.label, role: M.none(), fetch: (B, $) => {
      const Z = JO(B, l.name, l.items, ln.getValue(B));
      $(R1(Z, Tm.CLOSE_ON_EXECUTE, f, { isHorizontalMenu: !1, search: M.none() }));
    }, onSetup: Ee(gt), getApi: Ee({}), columns: 1, presets: "normal", classes: [], dropdownBehaviours: [Aa.config({}), z1(x.map((B) => B.value), (B) => js(B.element, HE), (B, $) => {
      VE(l.items, $).each((Z) => {
        eo(B.element, HE, Z.value), pn(B, Am, { text: Z.text });
      });
    })] }, "tox-listbox", f.shared) } }), O = { dom: { tag: "div", classes: ["tox-listboxfield"] }, components: [E] };
    return Fr.sketch({ dom: { tag: "div", classes: ["tox-form__group"] }, components: er([w.toArray(), [O]]), fieldBehaviours: $t([Xn.config({ disabled: Ee(!l.enabled), onDisabled: (A) => {
      Fr.getField(A).each(Xn.disable);
    }, onEnabled: (A) => {
      Fr.getField(A).each(Xn.enable);
    } })]) });
  })(o, s, i)), selectbox: vl((o, s, i) => ((l, f, m) => {
    const b = Ct(l.items, (A) => ({ text: f.translate(A.text), value: A.value })), x = l.label.map((A) => Vh(A, f)), w = Fr.parts.field({ dom: {}, ...m.map((A) => ({ data: A })).getOr({}), selectAttributes: { size: l.size }, options: b, factory: QO, selectBehaviours: $t([Xn.config({ disabled: () => !l.enabled || f.isDisabled() }), Aa.config({}), wo("selectbox-change", [ft(En(), (A, B) => {
      pn(A, df, { name: l.name });
    })])]) }), E = l.size > 1 ? M.none() : M.some(fp("chevron-down", { tag: "div", classes: ["tox-selectfield__icon-js"] }, f.icons)), O = { dom: { tag: "div", classes: ["tox-selectfield"] }, components: er([[w], E.toArray()]) };
    return Fr.sketch({ dom: { tag: "div", classes: ["tox-form__group"] }, components: er([x.toArray(), [O]]), fieldBehaviours: $t([Xn.config({ disabled: () => !l.enabled || f.isDisabled(), onDisabled: (A) => {
      Fr.getField(A).each(Xn.disable);
    }, onEnabled: (A) => {
      Fr.getField(A).each(Xn.enable);
    } }), il()]) });
  })(o, s.shared.providers, i)), sizeinput: vl((o, s) => ((i, l) => {
    let f = Ex;
    const m = hn("ratio-event"), b = ($) => fp($, { tag: "span", classes: ["tox-icon", "tox-lock-icon__" + $] }, l.icons), x = ff.parts.lock({ dom: { tag: "button", classes: ["tox-lock", "tox-button", "tox-button--naked", "tox-button--icon"], attributes: { title: l.translate(i.label.getOr("Constrain proportions")) } }, components: [b("lock"), b("unlock")], buttonBehaviours: $t([Xn.config({ disabled: () => !i.enabled || l.isDisabled() }), il(), Aa.config({})]) }), w = ($) => ({ dom: { tag: "div", classes: ["tox-form__group"] }, components: $ }), E = ($) => Fr.parts.field({ factory: Yb, inputClasses: ["tox-textfield"], inputBehaviours: $t([Xn.config({ disabled: () => !i.enabled || l.isDisabled() }), il(), Aa.config({}), wo("size-input-events", [ft(Oe(), (Z, oe) => {
      pn(Z, m, { isField1: $ });
    }), ft(En(), (Z, oe) => {
      pn(Z, df, { name: i.name });
    })])]), selectOnFocus: !1 }), O = ($) => ({ dom: { tag: "label", classes: ["tox-label"] }, components: [Os(l.translate($))] }), A = ff.parts.field1(w([Fr.parts.label(O("Width")), E(!0)])), B = ff.parts.field2(w([Fr.parts.label(O("Height")), E(!1)]));
    return ff.sketch({ dom: { tag: "div", classes: ["tox-form__group"] }, components: [{ dom: { tag: "div", classes: ["tox-form__controls-h-stack"] }, components: [A, B, w([O(" "), x])] }], field1Name: "width", field2Name: "height", locked: !0, markers: { lockClass: "tox-locked" }, onLockedChange: ($, Z, oe) => {
      C_(ln.getValue($)).each((re) => {
        f(re).each((fe) => {
          ln.setValue(Z, ((ee) => {
            const J = { "": 0, px: 0, pt: 1, mm: 1, pc: 2, ex: 2, em: 2, ch: 2, rem: 2, cm: 3, in: 4, "%": 4 };
            let le = ee.value.toFixed((me = ee.unit) in J ? J[me] : 1);
            var me;
            return le.indexOf(".") !== -1 && (le = le.replace(/\.?0*$/, "")), le + ee.unit;
          })(fe));
        });
      });
    }, coupledFieldBehaviours: $t([Xn.config({ disabled: () => !i.enabled || l.isDisabled(), onDisabled: ($) => {
      ff.getField1($).bind(Fr.getField).each(Xn.disable), ff.getField2($).bind(Fr.getField).each(Xn.disable), ff.getLock($).each(Xn.disable);
    }, onEnabled: ($) => {
      ff.getField1($).bind(Fr.getField).each(Xn.enable), ff.getField2($).bind(Fr.getField).each(Xn.enable), ff.getLock($).each(Xn.enable);
    } }), il(), wo("size-input-events2", [ft(m, ($, Z) => {
      const oe = Z.event.isField1, re = oe ? ff.getField1($) : ff.getField2($), fe = oe ? ff.getField2($) : ff.getField1($), ee = re.map(ln.getValue).getOr(""), J = fe.map(ln.getValue).getOr("");
      f = ((le, me) => {
        const ke = C_(le).toOptional(), Re = C_(me).toOptional();
        return fi(ke, Re, (qe, mt) => tA(qe, mt.unit).map((bt) => mt.value / bt).map((bt) => {
          return St = bt, Qt = mt.unit, (vn) => tA(vn, Qt).map((Mn) => ({ value: Mn * St, unit: Qt }));
          var St, Qt;
        }).getOr(Ex)).getOr(Ex);
      })(ee, J);
    })])]) });
  })(o, s.shared.providers)), slider: vl((o, s, i) => ((l, f, m) => {
    const b = Gf.parts.label({ dom: { tag: "label", classes: ["tox-label"] }, components: [Os(f.translate(l.label))] }), x = Gf.parts.spectrum({ dom: { tag: "div", classes: ["tox-slider__rail"], attributes: { role: "presentation" } } }), w = Gf.parts.thumb({ dom: { tag: "div", classes: ["tox-slider__handle"], attributes: { role: "presentation" } } });
    return Gf.sketch({ dom: { tag: "div", classes: ["tox-slider"], attributes: { role: "presentation" } }, model: { mode: "x", minX: l.min, maxX: l.max, getInitialValue: Ee(m.getOrThunk(() => (Math.abs(l.max) - Math.abs(l.min)) / 2)) }, components: [b, x, w], sliderBehaviours: $t([my(), io.config({})]), onChoose: (E, O, A) => {
      pn(E, df, { name: l.name, value: A });
    } });
  })(o, s.shared.providers, i)), urlinput: vl((o, s, i) => ((l, f, m, b) => {
    const x = f.shared.providers, w = (ee) => {
      const J = ln.getValue(ee);
      m.addToHistory(J.value, l.filetype);
    }, E = { ...b.map((ee) => ({ initialData: ee })).getOr({}), dismissOnBlur: !0, inputClasses: ["tox-textfield"], sandboxClasses: ["tox-dialog__popups"], inputAttributes: { "aria-errormessage": wA, type: "url" }, minChars: 0, responseTime: 0, fetch: (ee) => {
      const J = ((me, ke, Re) => {
        var qe, mt;
        const bt = ln.getValue(ke), St = (mt = (qe = bt == null ? void 0 : bt.meta) === null || qe === void 0 ? void 0 : qe.text) !== null && mt !== void 0 ? mt : bt.value;
        return Re.getLinkInformation().fold(() => [], (Qt) => {
          const vn = D_(St, ((Qn) => Ct(Qn, (fo) => t4(fo, fo)))(Re.getHistory(me)));
          return me === "file" ? (Mn = [vn, D_(St, xA(Qt)), D_(St, er([$B(Qt), FB(Qt), n4(Qt)]))], K(Mn, (Qn, fo) => Qn.length === 0 || fo.length === 0 ? Qn.concat(fo) : Qn.concat(PB, fo), [])) : vn;
          var Mn;
        });
      })(l.filetype, ee, m), le = R1(J, Tm.BUBBLE_TO_SANDBOX, f, { isHorizontalMenu: !1, search: M.none() });
      return $g(le);
    }, getHotspot: (ee) => re.getOpt(ee), onSetValue: (ee, J) => {
      ee.hasConfigured(gp) && gp.run(ee).get(gt);
    }, typeaheadBehaviours: $t([...m.getValidationHandler().map((ee) => gp.config({ getRoot: (J) => sa(J.element), invalidClass: "tox-control-wrap--status-invalid", notify: { onInvalid: (J, le) => {
      B.getOpt(J).each((me) => {
        eo(me.element, "title", x.translate(le));
      });
    } }, validator: { validate: (J) => {
      const le = ln.getValue(J);
      return bA((me) => {
        ee({ type: l.filetype, url: le.value }, (ke) => {
          if (ke.status === "invalid") {
            const Re = To.error(ke.message);
            me(Re);
          } else {
            const Re = To.value(ke.message);
            me(Re);
          }
        });
      });
    }, validateOnLoad: !1 } })).toArray(), Xn.config({ disabled: () => !l.enabled || x.isDisabled() }), Aa.config({}), wo("urlinput-events", [ft(Hn(), (ee) => {
      const J = zu(ee.element), le = J.trim();
      le !== J && dm(ee.element, le), l.filetype === "file" && pn(ee, df, { name: l.name });
    }), ft(En(), (ee) => {
      pn(ee, df, { name: l.name }), w(ee);
    }), ft(wn(), (ee) => {
      pn(ee, df, { name: l.name }), w(ee);
    })])]), eventOrder: { [Hn()]: ["streaming", "urlinput-events", "invalidating"] }, model: { getDisplayText: (ee) => ee.value, selectsOver: !1, populateFromBrowse: !1 }, markers: { openClass: "tox-textfield--popup-open" }, lazySink: f.shared.getSink, parts: { menu: Zv(0, 0, "normal") }, onExecute: (ee, J, le) => {
      pn(J, fx, {});
    }, onItemExecute: (ee, J, le, me) => {
      w(ee), pn(ee, df, { name: l.name });
    } }, O = Fr.parts.field({ ...E, factory: hA }), A = l.label.map((ee) => Vh(ee, x)), B = Ur(((ee, J, le = ee, me = ee) => fp(le, { tag: "div", classes: ["tox-icon", "tox-control-wrap__status-icon-" + ee], attributes: { title: x.translate(me), "aria-live": "polite", ...J.fold(() => ({}), (ke) => ({ id: ke })) } }, x.icons))("invalid", M.some(wA), "warning")), $ = Ur({ dom: { tag: "div", classes: ["tox-control-wrap__status-icon-wrap"] }, components: [B.asSpec()] }), Z = m.getUrlPicker(l.filetype), oe = hn("browser.url.event"), re = Ur({ dom: { tag: "div", classes: ["tox-control-wrap"] }, components: [O, $.asSpec()], behaviours: $t([Xn.config({ disabled: () => !l.enabled || x.isDisabled() })]) }), fe = Ur(QE({ name: l.name, icon: M.some("browse"), text: l.picker_text.or(l.label).getOr(""), enabled: l.enabled, primary: !1, buttonType: M.none(), borderless: !0 }, (ee) => Io(ee, oe), x, [], ["tox-browse-url"]));
    return Fr.sketch({ dom: pE([]), components: A.toArray().concat([{ dom: { tag: "div", classes: ["tox-form__controls-h-stack"] }, components: er([[re.asSpec()], Z.map(() => fe.asSpec()).toArray()]) }]), fieldBehaviours: $t([Xn.config({ disabled: () => !l.enabled || x.isDisabled(), onDisabled: (ee) => {
      Fr.getField(ee).each(Xn.disable), fe.getOpt(ee).each(Xn.disable);
    }, onEnabled: (ee) => {
      Fr.getField(ee).each(Xn.enable), fe.getOpt(ee).each(Xn.enable);
    } }), il(), wo("url-input-events", [ft(oe, (ee) => {
      rr.getCurrent(ee).each((J) => {
        const le = ln.getValue(J), me = { fieldname: l.name, ...le };
        Z.each((ke) => {
          ke(me).get((Re) => {
            ln.setValue(J, Re), pn(ee, df, { name: l.name });
          });
        });
      });
    })])]) });
  })(o, s, s.urlinput, i)), customeditor: vl((o) => {
    const s = As(), i = Ur({ dom: { tag: o.tag } }), l = As();
    return { dom: { tag: "div", classes: ["tox-custom-editor"] }, behaviours: $t([wo("custom-editor-events", [ss((f) => {
      i.getOpt(f).each((m) => {
        (((b) => _n(b, "init"))(o) ? o.init(m.element.dom) : BE.load(o.scriptId, o.scriptUrl).then((b) => b(m.element.dom, o.settings))).then((b) => {
          l.on((x) => {
            b.setValue(x);
          }), l.clear(), s.set(b);
        });
      });
    })]), z1(M.none(), () => s.get().fold(() => l.get().getOr(""), (f) => f.getValue()), (f, m) => {
      s.get().fold(() => l.set(m), (b) => b.setValue(m));
    }), my()]), components: [i.asSpec()] };
  }), htmlpanel: vl((o) => o.presets === "presentation" ? Uu.sketch({ dom: { tag: "div", classes: ["tox-form__group"], innerHtml: o.html } }) : Uu.sketch({ dom: { tag: "div", classes: ["tox-form__group"], innerHtml: o.html, attributes: { role: "document" } }, containerBehaviours: $t([Aa.config({}), io.config({})]) })), imagepreview: vl((o, s, i) => ((l, f) => {
    const m = Ln(f.getOr({ url: "" })), b = Ur({ dom: { tag: "img", classes: ["tox-imagepreview__image"], attributes: f.map((O) => ({ src: O.url })).getOr({}) } }), x = Ur({ dom: { tag: "div", classes: ["tox-imagepreview__container"], attributes: { role: "presentation" } }, components: [b.asSpec()] }), w = {};
    l.height.each((O) => w.height = O);
    const E = f.map((O) => ({ url: O.url, zoom: M.from(O.zoom), cachedWidth: M.from(O.cachedWidth), cachedHeight: M.from(O.cachedHeight) }));
    return { dom: { tag: "div", classes: ["tox-imagepreview"], styles: w, attributes: { role: "presentation" } }, components: [x.asSpec()], behaviours: $t([my(), z1(E, () => m.get(), (O, A) => {
      const B = { url: A.url };
      A.zoom.each((Z) => B.zoom = Z), A.cachedWidth.each((Z) => B.cachedWidth = Z), A.cachedHeight.each((Z) => B.cachedHeight = Z), m.set(B);
      const $ = () => {
        const { cachedWidth: Z, cachedHeight: oe, zoom: re } = B;
        if (!yt(Z) && !yt(oe)) {
          if (yt(re)) {
            const ee = ((J, le, me) => {
              const ke = Wr(J), Re = Qe(J);
              return Math.min(ke / le, Re / me, 1);
            })(O.element, Z, oe);
            B.zoom = ee;
          }
          const fe = ((ee, J, le, me, ke) => {
            const Re = le * ke, qe = me * ke, mt = Math.max(0, ee / 2 - Re / 2), bt = Math.max(0, J / 2 - qe / 2);
            return { left: mt.toString() + "px", top: bt.toString() + "px", width: Re.toString() + "px", height: qe.toString() + "px" };
          })(Wr(O.element), Qe(O.element), Z, oe, B.zoom);
          x.getOpt(O).each((ee) => {
            ac(ee.element, fe);
          });
        }
      };
      b.getOpt(O).each((Z) => {
        const oe = Z.element;
        var re;
        A.url !== js(oe, "src") && (eo(oe, "src", A.url), $s(O.element, "tox-imagepreview__loaded")), $(), (re = oe, new Promise((fe, ee) => {
          const J = () => {
            me(), fe(re);
          }, le = [sl(re, "load", J), sl(re, "error", () => {
            me(), ee("Unable to load data from image: " + re.dom.src);
          })], me = () => tn(le, (ke) => ke.unbind());
          re.dom.complete && J();
        })).then((fe) => {
          O.getSystem().isConnected() && (vr(O.element, "tox-imagepreview__loaded"), B.cachedWidth = fe.dom.naturalWidth, B.cachedHeight = fe.dom.naturalHeight, $());
        });
      });
    })]) };
  })(o, i)), table: vl((o, s) => ((i, l) => {
    const f = (x) => ({ dom: { tag: "td", innerHtml: l.translate(x) } });
    return { dom: { tag: "table", classes: ["tox-dialog__table"] }, components: [(b = i.header, { dom: { tag: "thead" }, components: [{ dom: { tag: "tr" }, components: Ct(b, (x) => ({ dom: { tag: "th", innerHtml: l.translate(x) } })) }] }), (m = i.cells, { dom: { tag: "tbody" }, components: Ct(m, (x) => ({ dom: { tag: "tr" }, components: Ct(x, f) })) })], behaviours: $t([Aa.config({}), io.config({})]) };
    var m, b;
  })(o, s.shared.providers)), tree: vl((o, s) => ((i, l) => {
    const f = i.onLeafAction.getOr(gt), m = i.onToggleExpand.getOr(gt), b = i.defaultExpandedIds, x = Ln(b), w = Ln(i.defaultSelectedId), E = hn("tree-id"), O = (A, B) => i.items.map(($) => $.type === "leaf" ? GE({ leaf: $, selectedId: A, onLeafAction: f, visible: !0, treeId: E, backstage: l }) : KE({ directory: $, selectedId: A, onLeafAction: f, expandedIds: B, labelTabstopping: !0, treeId: E, backstage: l }));
    return { dom: { tag: "div", classes: ["tox-tree"], attributes: { role: "tree" } }, components: O(w.get(), x.get()), behaviours: $t([Jt.config({ mode: "flow", selector: ".tox-tree--leaf__label--visible, .tox-tree--directory__label--visible", cycles: !1 }), wo(RB, [ft("expand-tree-node", (A, B) => {
      const { expanded: $, node: Z } = B.event;
      x.set($ ? [...x.get(), Z] : x.get().filter((oe) => oe !== Z)), m(x.get(), { expanded: $, node: Z });
    })]), pc.config({ channels: { [`update-active-item-${E}`]: { onReceive: (A, B) => {
      w.set(M.some(B.value)), Jn.set(A, O(M.some(B.value), x.get()));
    } } } }), Jn.config({})]) };
  })(o, s)), panel: vl((o, s) => ((i, l) => ({ dom: { tag: "div", classes: i.classes }, components: Ct(i.items, l.shared.interpreter) }))(o, s)) }, _A = { field: (o, s) => s, record: Ee([]) }, o4 = (o, s, i, l) => {
    const f = be(l, { shared: { interpreter: (m) => R_(o, m, i, f) } });
    return R_(o, s, i, f);
  }, R_ = (o, s, i, l) => cn(VB, s.type).fold(() => (console.error(`Unknown factory type "${s.type}", defaulting to container: `, s), s), (f) => f(o, s, i, l)), CA = (o, s, i) => R_(_A, o, s, i), gy = "layout-inset", r4 = (o) => o.x, SA = (o, s) => o.x + o.width / 2 - s.width / 2, Dx = (o, s) => o.x + o.width - s.width, s4 = (o) => o.y, a4 = (o, s) => o.y + o.height - s.height, i4 = (o, s) => o.y + o.height / 2 - s.height / 2, Rx = (o, s, i) => ol(Dx(o, s), a4(o, s), i.insetSouthwest(), ib(), "southwest", ki(o, { right: 0, bottom: 3 }), gy), N_ = (o, s, i) => ol(r4(o), a4(o, s), i.insetSoutheast(), Ly(), "southeast", ki(o, { left: 1, bottom: 3 }), gy), Nx = (o, s, i) => ol(Dx(o, s), s4(o), i.insetNorthwest(), dh(), "northwest", ki(o, { right: 0, top: 2 }), gy), Mx = (o, s, i) => ol(r4(o), s4(o), i.insetNortheast(), uh(), "northeast", ki(o, { left: 1, top: 2 }), gy), Vi = (o, s, i) => ol(SA(o, s), s4(o), i.insetNorth(), K1(), "north", ki(o, { top: 2 }), gy), Sd = (o, s, i) => ol(SA(o, s), a4(o, s), i.insetSouth(), lb(), "south", ki(o, { bottom: 3 }), gy), l4 = (o, s, i) => ol(Dx(o, s), i4(o, s), i.insetEast(), Np(), "east", ki(o, { right: 0 }), gy), M_ = (o, s, i) => ol(r4(o), i4(o, s), i.insetWest(), Nf(), "west", ki(o, { left: 1 }), gy), c4 = (o) => {
    switch (o) {
      case "north":
        return Vi;
      case "northeast":
        return Mx;
      case "northwest":
        return Nx;
      case "south":
        return Sd;
      case "southeast":
        return N_;
      case "southwest":
        return Rx;
      case "east":
        return l4;
      case "west":
        return M_;
    }
  }, Bx = (o, s, i, l, f) => Y1(l).map(c4).getOr(Vi)(o, s, i, l, f), EA = (o) => {
    switch (o) {
      case "north":
        return Sd;
      case "northeast":
        return N_;
      case "northwest":
        return Rx;
      case "south":
        return Vi;
      case "southeast":
        return Mx;
      case "southwest":
        return Nx;
      case "east":
        return M_;
      case "west":
        return l4;
    }
  }, Lx = (o, s, i, l, f) => Y1(l).map(EA).getOr(Vi)(o, s, i, l, f), hy = { valignCentre: [], alignCentre: [], alignLeft: [], alignRight: [], right: [], left: [], bottom: [], top: [] }, u4 = (o, s, i) => {
    const l = { maxHeightFunction: Lp() };
    return () => i() ? { type: "node", root: Ma(us(o())), node: M.from(o()), bubble: Ii(12, 12, hy), layouts: { onRtl: () => [Mx], onLtr: () => [Nx] }, overrides: l } : { type: "hotspot", hotspot: s(), bubble: Ii(-12, 12, hy), layouts: { onRtl: () => [Bi, Tr, ma], onLtr: () => [Tr, Bi, ma] }, overrides: l };
  }, TA = (o, s, i, l) => {
    const f = { maxHeightFunction: Lp() };
    return () => l() ? { type: "node", root: Ma(us(s())), node: M.from(s()), bubble: Ii(12, 12, hy), layouts: { onRtl: () => [Vi], onLtr: () => [Vi] }, overrides: f } : o ? { type: "node", root: Ma(us(s())), node: M.from(s()), bubble: Ii(0, -Ft(s()), hy), layouts: { onRtl: () => [Zl], onLtr: () => [Zl] }, overrides: f } : { type: "hotspot", hotspot: i(), bubble: Ii(0, 0, hy), layouts: { onRtl: () => [Zl], onLtr: () => [Zl] }, overrides: f };
  }, Px = (o, s, i) => () => i() ? { type: "node", root: Ma(us(o())), node: M.from(o()), layouts: { onRtl: () => [Vi], onLtr: () => [Vi] } } : { type: "hotspot", hotspot: s(), layouts: { onRtl: () => [ma], onLtr: () => [ma] } }, UB = (o, s) => () => ({ type: "selection", root: s(), getSelection: () => {
    const i = o.selection.getRng(), l = o.model.table.getSelectedCells();
    if (l.length > 1) {
      const f = l[0], m = l[l.length - 1], b = { firstCell: Xt(f), lastCell: Xt(m) };
      return M.some(b);
    }
    return M.some(If.range(Xt(i.startContainer), i.startOffset, Xt(i.endContainer), i.endOffset));
  } }), jB = (o) => (s) => ({ type: "node", root: o(), node: s }), qp = (o, s, i, l) => {
    const f = h1(o), m = () => Xt(o.getBody()), b = () => Xt(o.getContentAreaContainer()), x = () => f || !l();
    return { inlineDialog: u4(b, s, x), inlineBottomDialog: TA(o.inline, b, i, x), banner: Px(b, s, x), cursor: UB(o, m), node: jB(m) };
  }, mf = (o) => (s, i) => {
    Zk(o)(s, i);
  }, Ix = (o) => () => F0(o), Rm = (o) => (s) => ix(o, s), ZB = (o) => (s) => I0(o, s), Ds = (o) => () => KT(o), zA = (o) => Ys(o, "items"), by = (o) => Ys(o, "format"), Q0 = [{ title: "Headings", items: [{ title: "Heading 1", format: "h1" }, { title: "Heading 2", format: "h2" }, { title: "Heading 3", format: "h3" }, { title: "Heading 4", format: "h4" }, { title: "Heading 5", format: "h5" }, { title: "Heading 6", format: "h6" }] }, { title: "Inline", items: [{ title: "Bold", format: "bold" }, { title: "Italic", format: "italic" }, { title: "Underline", format: "underline" }, { title: "Strikethrough", format: "strikethrough" }, { title: "Superscript", format: "superscript" }, { title: "Subscript", format: "subscript" }, { title: "Code", format: "code" }] }, { title: "Blocks", items: [{ title: "Paragraph", format: "p" }, { title: "Blockquote", format: "blockquote" }, { title: "Div", format: "div" }, { title: "Pre", format: "pre" }] }, { title: "Align", items: [{ title: "Left", format: "alignleft" }, { title: "Center", format: "aligncenter" }, { title: "Right", format: "alignright" }, { title: "Justify", format: "alignjustify" }] }], d4 = (o) => K(o, (s, i) => {
    if (_n(i, "items")) {
      const l = d4(i.items);
      return { customFormats: s.customFormats.concat(l.customFormats), formats: s.formats.concat([{ title: i.title, items: l.formats }]) };
    }
    if (_n(i, "inline") || ((l) => _n(l, "block"))(i) || ((l) => _n(l, "selector"))(i)) {
      const l = `custom-${ce(i.name) ? i.name : i.title.toLowerCase()}`;
      return { customFormats: s.customFormats.concat([{ name: l, format: i }]), formats: s.formats.concat([{ title: i.title, format: l, icon: i.icon }]) };
    }
    return { ...s, formats: s.formats.concat(i) };
  }, { customFormats: [], formats: [] }), B_ = (o) => QC(o).map((s) => {
    const i = ((l, f) => {
      const m = d4(f), b = (x) => {
        tn(x, (w) => {
          l.formatter.has(w.name) || l.formatter.register(w.name, w.format);
        });
      };
      return l.formatter ? b(m.customFormats) : l.on("init", () => {
        b(m.customFormats);
      }), m.formats;
    })(o, s);
    return w0(o) ? Q0.concat(i) : i;
  }).getOr(Q0), L_ = (o, s, i) => ({ ...o, type: "formatter", isSelected: s(o.format), getStylePreview: i(o.format) }), OA = (o, s, i, l) => {
    const f = (m) => Ct(m, (b) => zA(b) ? ((x) => {
      const w = f(x.items);
      return { ...x, type: "submenu", getStyleItems: Ee(w) };
    })(b) : by(b) ? ((x) => L_(x, i, l))(b) : ((x) => {
      const w = po(x);
      return w.length === 1 && Bn(w, "title");
    })(b) ? { ...b, type: "separator" } : ((x) => {
      const w = ce(x.name) ? x.name : hn(x.title), E = `custom-${w}`, O = { ...x, type: "formatter", format: E, isSelected: i(E), getStylePreview: l(E) };
      return o.formatter.register(w, O), O;
    })(b));
    return f(s);
  }, f4 = jg.trim, AA = (o) => (s) => !!(((i) => it(i) && i.nodeType === 1)(s) && (s.contentEditable === o || s.getAttribute("data-mce-contenteditable") === o)), DA = AA("true"), RA = AA("false"), P_ = (o, s, i, l, f) => ({ type: o, title: s, url: i, level: l, attach: f }), m4 = (o) => o.innerText || o.textContent, I_ = (o) => ((s) => s && s.nodeName === "A" && (s.id || s.name) !== void 0)(o) && MA(o), NA = (o) => o && /^(H[1-6])$/.test(o.nodeName), MA = (o) => ((s) => {
    let i = s;
    for (; i = i.parentNode; ) {
      const l = i.contentEditable;
      if (l && l !== "inherit")
        return DA(i);
    }
    return !1;
  })(o) && !RA(o), WB = (o) => NA(o) && MA(o), qB = (o) => {
    var s;
    const i = ((l) => l.id ? l.id : hn("h"))(o);
    return P_("header", (s = m4(o)) !== null && s !== void 0 ? s : "", "#" + i, ((l) => NA(l) ? parseInt(l.nodeName.substr(1), 10) : 0)(o), () => {
      o.id = i;
    });
  }, GB = (o) => {
    const s = o.id || o.name, i = m4(o);
    return P_("anchor", i || "#" + s, "#" + s, 0, gt);
  }, BA = (o) => f4(o.title).length > 0, KB = (o) => {
    const s = ((i) => Ct(Kl(Xt(i), "h1,h2,h3,h4,h5,h6,a:not([href])"), (f) => f.dom))(o);
    return Pn(((i) => Ct(Pn(i, WB), qB))(s).concat(((i) => Ct(Pn(i, I_), GB))(s)), BA);
  }, F_ = "tinymce-url-history", p4 = (o) => ce(o) && /^https?/.test(o), LA = (o) => he(o) && ha(o, (s) => {
    return !(Me(i = s) && i.length <= 5 && nc(i, p4));
    var i;
  }).isNone(), g4 = () => {
    const o = ry.getItem(F_);
    if (o === null)
      return {};
    let s;
    try {
      s = JSON.parse(o);
    } catch (i) {
      if (i instanceof SyntaxError)
        return console.log("Local storage " + F_ + " was not valid JSON", i), {};
      throw i;
    }
    return LA(s) ? s : (console.log("Local storage " + F_ + " was not valid format", s), {});
  }, Fx = (o) => {
    const s = g4();
    return cn(s, o).getOr([]);
  }, YB = (o, s) => {
    if (!p4(o))
      return;
    const i = g4(), l = cn(i, s).getOr([]), f = Pn(l, (m) => m !== o);
    i[s] = [o].concat(f).slice(0, 5), ((m) => {
      if (!LA(m))
        throw new Error(`Bad format for history:
` + JSON.stringify(m));
      ry.setItem(F_, JSON.stringify(m));
    })(i);
  }, PA = (o) => !!o, IA = (o) => ho(jg.makeMap(o, /[, ]/), PA), $_ = (o) => M.from(nS(o)), h4 = (o) => M.from(o).filter(ce).getOrUndefined(), XB = (o) => ({ getHistory: Fx, addToHistory: YB, getLinkInformation: () => ((s) => sS(s) ? M.some({ targets: KB(s.getBody()), anchorTop: h4(GT(s)), anchorBottom: h4(aS(s)) }) : M.none())(o), getValidationHandler: () => ((s) => M.from(oS(s)))(o), getUrlPicker: (s) => ((i, l) => ((f, m) => {
    const b = ((x) => {
      const w = M.from(qT(x)).filter(PA).map(IA);
      return $_(x).fold(Xe, (E) => w.fold(un, (O) => po(O).length > 0 && O));
    })(f);
    return Ye(b) ? b ? $_(f) : M.none() : b[m] ? $_(f) : M.none();
  })(i, l).map((f) => (m) => sy((b) => {
    const x = { filetype: l, fieldname: m.fieldname, ...M.from(m.meta).getOr({}) };
    f.call(i, (w, E) => {
      if (!ce(w))
        throw new Error("Expected value to be string");
      if (E !== void 0 && !he(E))
        throw new Error("Expected meta to be a object");
      b({ value: w, meta: E });
    }, m.value, x);
  })))(o, s) }), Il = Mg, Wg = Do, JB = Ee([He("shell", !1), st("makeItem"), He("setupItem", gt), $i("listBehaviours", [Jn])]), QB = rn({ name: "items", overrides: () => ({ behaviours: $t([Jn.config({})]) }) }), e6 = Ee([QB]), b4 = hc({ name: Ee("CustomList")(), configFields: JB(), partFields: e6(), factory: (o, s, i, l) => {
    const f = o.shell ? { behaviours: [Jn.config({})], components: [] } : { behaviours: [], components: s };
    return { uid: o.uid, dom: o.dom, components: f.components, behaviours: Fi(o.listBehaviours, f.behaviours), apis: { setItems: (m, b) => {
      var x;
      (x = m, o.shell ? M.some(x) : Dn(x, o, "items")).fold(() => {
        throw console.error("Custom List was defined to not be a shell, but no item container was specified in components"), new Error("Custom List was defined to not be a shell, but no item container was specified in components");
      }, (w) => {
        const E = Jn.contents(w), O = b.length, A = O - E.length, B = A > 0 ? Tt(A, () => o.makeItem()) : [], $ = E.slice(O);
        tn($, (oe) => Jn.remove(w, oe)), tn(B, (oe) => Jn.append(w, oe));
        const Z = Jn.contents(w);
        tn(Z, (oe, re) => {
          o.setupItem(m, oe, b[re], re);
        });
      });
    } } };
  }, apis: { setItems: (o, s, i) => {
    o.setItems(s, i);
  } } }), Zu = Ee([st("dom"), He("shell", !0), pa("toolbarBehaviours", [Jn])]), t6 = Ee([rn({ name: "groups", overrides: () => ({ behaviours: $t([Jn.config({})]) }) })]), Nm = hc({ name: "Toolbar", configFields: Zu(), partFields: t6(), factory: (o, s, i, l) => {
    const f = o.shell ? { behaviours: [Jn.config({})], components: [] } : { behaviours: [], components: s };
    return { uid: o.uid, dom: o.dom, components: f.components, behaviours: Fi(o.toolbarBehaviours, f.behaviours), apis: { setGroups: (m, b) => {
      var x;
      (x = m, o.shell ? M.some(x) : Dn(x, o, "groups")).fold(() => {
        throw console.error("Toolbar was defined to not be a shell, but no groups container was specified in components"), new Error("Toolbar was defined to not be a shell, but no groups container was specified in components");
      }, (w) => {
        Jn.set(w, b);
      });
    }, refresh: gt }, domModification: { attributes: { role: "group" } } };
  }, apis: { setGroups: (o, s, i) => {
    o.setGroups(s, i);
  } } }), FA = gt, $A = Xe, HA = Ee([]);
  var y4, VA = Object.freeze({ __proto__: null, setup: FA, isDocked: $A, getBehaviours: HA });
  const H_ = (o) => (Si(Xs(o, "position"), "fixed") ? M.none() : nm(o)).orThunk(() => {
    const s = Cl("span");
    return cl(o).bind((i) => {
      Zs(i, s);
      const l = nm(s);
      return ya(s), l;
    });
  }), UA = (o) => H_(o).map($n).getOrThunk(() => so(0, 0)), n6 = (o, s) => {
    const i = o.element;
    vr(i, s.transitionClass), $s(i, s.fadeOutClass), vr(i, s.fadeInClass), s.onShow(o);
  }, o6 = (o, s) => {
    const i = o.element;
    vr(i, s.transitionClass), $s(i, s.fadeInClass), vr(i, s.fadeOutClass), s.onHide(o);
  }, jA = (o, s) => o.y >= s.y, ZA = (o, s) => o.bottom <= s.bottom, V_ = (o, s, i) => ({ location: "top", leftX: s, topY: i.bounds.y - o.y }), U_ = (o, s, i) => ({ location: "bottom", leftX: s, bottomY: o.bottom - i.bounds.bottom }), j_ = (o) => o.box.x - o.win.x, v4 = (o, s, i) => i.getInitialPos().map((l) => {
    const f = ((m, b) => {
      const x = b.optScrollEnv.fold(Ee(m.bounds.y), (w) => w.scrollElmTop + (m.bounds.y - w.currentScrollTop));
      return so(m.bounds.x, x);
    })(l, s);
    return { box: Ws(f.left, f.top, Wr(o), Qe(o)), location: l.location };
  }), WA = (o, s, i, l, f) => {
    const m = ((x, w) => {
      const E = w.optScrollEnv.fold(Ee(x.y), (O) => x.y + O.currentScrollTop - O.scrollElmTop);
      return so(x.x, E);
    })(s, i), b = Ws(m.left, m.top, s.width, s.height);
    l.setInitialPos({ style: hu(o), position: Ts(o, "position") || "static", bounds: b, location: f.location });
  }, qA = (o, s, i) => i.getInitialPos().bind((l) => {
    var f;
    switch (i.clearInitialPos(), l.position) {
      case "static":
        return M.some({ morph: "static" });
      case "absolute":
        const m = H_(o).getOr(Wa()), b = va(m), x = (f = m.dom.scrollTop) !== null && f !== void 0 ? f : 0;
        return M.some({ morph: "absolute", positionCss: Wl("absolute", cn(l.style, "left").map((w) => s.x - b.x), cn(l.style, "top").map((w) => s.y - b.y + x), cn(l.style, "right").map((w) => b.right - s.right), cn(l.style, "bottom").map((w) => b.bottom - s.bottom)) });
      default:
        return M.none();
    }
  }), yy = (o) => {
    switch (o.location) {
      case "top":
        return M.some({ morph: "fixed", positionCss: Wl("fixed", M.some(o.leftX), M.some(o.topY), M.none(), M.none()) });
      case "bottom":
        return M.some({ morph: "fixed", positionCss: Wl("fixed", M.some(o.leftX), M.none(), M.none(), M.some(o.bottomY)) });
      default:
        return M.none();
    }
  }, r6 = (o, s, i) => {
    const l = o.element;
    return Si(Xs(l, "position"), "fixed") ? ((f, m, b) => ((x, w, E) => v4(x, w, E).filter(({ box: O }) => ((A, B, $) => nc(A, (Z) => {
      switch (Z) {
        case "bottom":
          return ZA(B, $.bounds);
        case "top":
          return jA(B, $.bounds);
      }
    }))(E.getModes(), O, w)).bind(({ box: O }) => qA(x, O, E)))(f, m, b).orThunk(() => m.optScrollEnv.bind((x) => v4(f, m, b)).bind(({ box: x, location: w }) => {
      const E = os(), O = j_({ win: E, box: x }), A = w === "top" ? V_(E, O, m) : U_(E, O, m);
      return yy(A);
    })))(l, s, i) : ((f, m, b) => {
      const x = va(f), w = os(), E = ((O, A, B) => {
        const $ = A.win, Z = A.box, oe = j_(A);
        return Ko(O, (re) => {
          switch (re) {
            case "bottom":
              return ZA(Z, B.bounds) ? M.none() : M.some(U_($, oe, B));
            case "top":
              return jA(Z, B.bounds) ? M.none() : M.some(V_($, oe, B));
            default:
              return M.none();
          }
        }).getOr({ location: "no-dock" });
      })(b.getModes(), { win: w, box: x }, m);
      return E.location === "top" || E.location === "bottom" ? (WA(f, x, m, b, E), yy(E)) : M.none();
    })(l, s, i);
  }, x4 = (o, s, i) => {
    i.setDocked(!1), tn(["left", "right", "top", "bottom", "position"], (l) => ar(o.element, l)), s.onUndocked(o);
  }, Z_ = (o, s, i, l) => {
    const f = l.position === "fixed";
    i.setDocked(f), db(o.element, l), (f ? s.onDocked : s.onUndocked)(o);
  }, w4 = (o, s, i, l, f = !1) => {
    s.contextual.each((m) => {
      m.lazyContext(o).each((b) => {
        const x = ((w, E) => w.y < E.bottom && w.bottom > E.y)(b, l.bounds);
        x !== i.isVisible() && (i.setVisible(x), f && !x ? (nl(o.element, [m.fadeOutClass]), m.onHide(o)) : (x ? n6 : o6)(o, m));
      });
    });
  }, W_ = (o, s, i, l, f) => {
    w4(o, s, i, l, !0), Z_(o, s, i, f.positionCss);
  }, ev = (o, s, i) => {
    o.getSystem().isConnected() && ((l, f, m) => {
      const b = f.lazyViewport(l);
      w4(l, f, m, b), r6(l, b, m).each((x) => {
        ((w, E, O, A, B) => {
          switch (B.morph) {
            case "static":
              return x4(w, E, O);
            case "absolute":
              return Z_(w, E, O, B.positionCss);
            case "fixed":
              W_(w, E, O, A, B);
          }
        })(l, f, m, b, x);
      });
    })(o, s, i);
  }, q_ = (o, s, i) => {
    i.isDocked() && ((l, f, m) => {
      const b = l.element;
      m.setDocked(!1);
      const x = f.lazyViewport(l);
      ((w, E, O) => {
        const A = w.element;
        return v4(A, E, O).bind(({ box: B }) => qA(A, B, O));
      })(l, x, m).each((w) => {
        switch (w.morph) {
          case "static":
            x4(l, f, m);
            break;
          case "absolute":
            Z_(l, f, m, w.positionCss);
        }
      }), m.setVisible(!0), f.contextual.each((w) => {
        jc(b, [w.fadeInClass, w.fadeOutClass, w.transitionClass]), w.onShow(l);
      }), ev(l, f, m);
    })(o, s, i);
  }, k4 = (o) => (s, i, l) => {
    const f = i.lazyViewport(s);
    ((m, b, x, w) => {
      const E = va(m), O = os(), A = w(O, j_({ win: O, box: E }), b);
      return A.location === "bottom" || A.location === "top" ? (((B, $, Z, oe, re) => {
        oe.getInitialPos().fold(() => WA(B, $, Z, oe, re), () => gt);
      })(m, E, b, x, A), yy(A)) : M.none();
    })(s.element, f, l, o).each((m) => {
      W_(s, i, l, f, m);
    });
  }, s6 = k4(V_), GA = k4(U_);
  var a6 = Object.freeze({ __proto__: null, refresh: ev, reset: q_, isDocked: (o, s, i) => i.isDocked(), getModes: (o, s, i) => i.getModes(), setModes: (o, s, i, l) => i.setModes(l), forceDockToTop: s6, forceDockToBottom: GA }), i6 = Object.freeze({ __proto__: null, events: (o, s) => Bo([Xd(Ri(), (i, l) => {
    o.contextual.each((f) => {
      _s(i.element, f.transitionClass) && (jc(i.element, [f.transitionClass, f.fadeInClass]), (s.isVisible() ? f.onShown : f.onHidden)(i)), l.stop();
    });
  }), ft(Wd(), (i, l) => {
    ev(i, o, s);
  }), ft(cs(), (i, l) => {
    ev(i, o, s);
  }), ft(Uc(), (i, l) => {
    q_(i, o, s);
  })]) }), l6 = [Ol("contextual", [Is("fadeInClass"), Is("fadeOutClass"), Is("transitionClass"), Ia("lazyContext"), Vo("onShow"), Vo("onShown"), Vo("onHide"), Vo("onHidden")]), fs("lazyViewport", () => ({ bounds: os(), optScrollEnv: M.none() })), Ir("modes", ["top", "bottom"], xa), Vo("onDocked"), Vo("onUndocked")];
  const ei = _i({ fields: l6, name: "docking", active: i6, apis: a6, state: Object.freeze({ __proto__: null, init: (o) => {
    const s = Ln(!1), i = Ln(!0), l = As(), f = Ln(o.modes);
    return as({ isDocked: s.get, setDocked: s.set, getInitialPos: l.get, setInitialPos: l.set, clearInitialPos: l.clear, isVisible: i.get, setVisible: i.set, getModes: f.get, setModes: f.set, readState: () => `docked:  ${s.get()}, visible: ${i.get()}, modes: ${f.get().join(",")}` });
  } }) }), G_ = Ee(hn("toolbar-height-change")), Gp = { fadeInClass: "tox-editor-dock-fadein", fadeOutClass: "tox-editor-dock-fadeout", transitionClass: "tox-editor-dock-transition" }, KA = "tox-tinymce--toolbar-sticky-on", YA = "tox-tinymce--toolbar-sticky-off", K_ = (o, s) => Bn(ei.getModes(o), s), _4 = (o) => {
    const s = o.element;
    sa(s).each((i) => {
      const l = "padding-" + ei.getModes(o)[0];
      if (ei.isDocked(o)) {
        const f = Wr(i);
        qn(s, "width", f + "px"), qn(i, l, ((m) => Ft(m) + (parseInt(Ts(m, "margin-top"), 10) || 0) + (parseInt(Ts(m, "margin-bottom"), 10) || 0))(s) + "px");
      } else
        ar(s, "width"), ar(i, l);
    });
  }, XA = (o, s) => {
    s ? ($s(o, Gp.fadeOutClass), nl(o, [Gp.transitionClass, Gp.fadeInClass])) : ($s(o, Gp.fadeInClass), nl(o, [Gp.fadeOutClass, Gp.transitionClass]));
  }, JA = (o, s) => {
    const i = Xt(o.getContainer());
    s ? (vr(i, KA), $s(i, YA)) : (vr(i, YA), $s(i, KA));
  }, QA = (o, s) => {
    const i = As(), l = s.getSink, f = (x) => {
      l().each((w) => x(w.element));
    }, m = (x) => {
      o.inline || _4(x), JA(o, ei.isDocked(x)), x.getSystem().broadcastOn([Og()], {}), l().each((w) => w.getSystem().broadcastOn([Og()], {}));
    }, b = o.inline ? [] : [pc.config({ channels: { [G_()]: { onReceive: _4 } } })];
    return [io.config({}), ei.config({ contextual: { lazyContext: (x) => {
      const w = Ft(x.element), E = o.inline ? o.getContentAreaContainer() : o.getContainer();
      return M.from(E).map((O) => {
        const A = va(Xt(O));
        return k1(o, x.element).fold(() => {
          const B = A.height - w, $ = A.y + (K_(x, "top") ? 0 : w);
          return Ws(A.x, $, A.width, B);
        }, (B) => {
          const $ = od(A, H0(B)), Z = K_(x, "top") ? $.y : $.y + w;
          return Ws($.x, Z, $.width, $.height - w);
        });
      });
    }, onShow: () => {
      f((x) => XA(x, !0));
    }, onShown: (x) => {
      f((w) => jc(w, [Gp.transitionClass, Gp.fadeInClass])), i.get().each((w) => {
        ((E, O) => {
          const A = ni(O);
          Zc(A).filter((B) => !tr(O, B)).filter((B) => tr(B, Xt(A.dom.body)) || Ms(E, B)).each(() => gc(O));
        })(x.element, w), i.clear();
      });
    }, onHide: (x) => {
      ((w, E) => iu(w).orThunk(() => E().toOptional().bind((O) => iu(O.element))))(x.element, l).fold(i.clear, i.set), f((w) => XA(w, !1));
    }, onHidden: () => {
      f((x) => jc(x, [Gp.transitionClass]));
    }, ...Gp }, lazyViewport: (x) => k1(o, x.element).fold(() => {
      const w = os(), E = ZT(o), O = w.y + (K_(x, "top") ? E : 0), A = w.height - (K_(x, "bottom") ? E : 0);
      return { bounds: Ws(w.x, O, w.width, A), optScrollEnv: M.none() };
    }, (w) => ({ bounds: H0(w), optScrollEnv: M.some({ currentScrollTop: w.element.dom.scrollTop, scrollElmTop: $n(w.element).top }) })), modes: [s.header.getDockingMode()], onDocked: m, onUndocked: m }), ...b];
  };
  var c6 = Object.freeze({ __proto__: null, setup: (o, s, i) => {
    o.inline || (s.header.isPositionedAtTop() || o.on("ResizeEditor", () => {
      i().each(ei.reset);
    }), o.on("ResizeWindow ResizeEditor", () => {
      i().each(_4);
    }), o.on("SkinLoaded", () => {
      i().each((l) => {
        ei.isDocked(l) ? ei.reset(l) : ei.refresh(l);
      });
    }), o.on("FullscreenStateChanged", () => {
      i().each(ei.reset);
    })), o.on("AfterScrollIntoView", (l) => {
      i().each((f) => {
        ei.refresh(f);
        const m = f.element;
        l1(m) && ((b, x) => {
          const w = ni(x), E = Bd(x).dom.innerHeight, O = Ls(w), A = Xt(b.elm), B = la(A), $ = Qe(A), Z = B.y, oe = Z + $, re = $n(x), fe = Qe(x), ee = re.top, J = ee + fe, le = Math.abs(ee - O.top) < 2, me = Math.abs(J - (O.top + E)) < 2;
          if (le && Z < J)
            Vr(O.left, Z - fe, w);
          else if (me && oe > ee) {
            const ke = Z - E + $ + fe;
            Vr(O.left, ke, w);
          }
        })(l, m);
      });
    }), o.on("PostRender", () => {
      JA(o, !1);
    });
  }, isDocked: (o) => o().map(ei.isDocked).getOr(!1), getBehaviours: QA });
  const u6 = Nn([ci, zl("items", Di([Ec([Rk, Ka("items", xa)]), xa]))].concat(D0)), d6 = [Nr("text"), Nr("tooltip"), Nr("icon"), za("search", !1, Di([$c, Nn([Nr("placeholder")])], (o) => Ye(o) ? o ? M.some({ placeholder: M.none() }) : M.none() : M.some(o))), Ia("fetch"), fs("onSetup", () => gt)], eD = Nn([ci, ...d6]), C4 = (o) => Gr("menubutton", eD, o), f6 = Nn([ci, Kv, Wf, ey, gM, wS, Qb, Fs("presets", "normal", ["normal", "color", "listpreview"]), hz(1), z0, mM]);
  var S4 = Bu({ factory: (o, s) => {
    const i = { focus: Jt.focusIn, setMenus: (l, f) => {
      const m = Ct(f, (b) => {
        const x = { type: "menubutton", text: b.text, fetch: (E) => {
          E(b.getItems());
        } }, w = C4(x).mapError((E) => nu(E)).getOrDie();
        return zx(w, "tox-mbtn", s.backstage, M.some("menuitem"));
      });
      Jn.set(l, m);
    } };
    return { uid: o.uid, dom: o.dom, components: [], behaviours: $t([Jn.config({}), wo("menubar-events", [ss((l) => {
      o.onSetup(l);
    }), ft(_e(), (l, f) => {
      fa(l.element, ".tox-mbtn--active").each((m) => {
        Ou(f.event.target, ".tox-mbtn").each((b) => {
          tr(m, b) || l.getSystem().getByDom(m).each((x) => {
            l.getSystem().getByDom(b).each((w) => {
              qf.expand(w), qf.close(x), io.focus(w);
            });
          });
        });
      });
    }), ft(Dl(), (l, f) => {
      f.event.prevFocus.bind((m) => l.getSystem().getByDom(m).toOptional()).each((m) => {
        f.event.newFocus.bind((b) => l.getSystem().getByDom(b).toOptional()).each((b) => {
          qf.isOpen(m) && (qf.expand(b), qf.close(m));
        });
      });
    })]), Jt.config({ mode: "flow", selector: ".tox-mbtn", onEscape: (l) => (o.onEscape(l), M.some(!0)) }), Aa.config({})]), apis: i, domModification: { attributes: { role: "menubar" } } };
  }, name: "silver.Menubar", configFields: [st("dom"), st("uid"), st("onEscape"), st("backstage"), He("onSetup", gt)], apis: { focus: (o, s) => {
    o.focus(s);
  }, setMenus: (o, s, i) => {
    o.setMenus(s, i);
  } } });
  const tD = "container", m6 = [pa("slotBehaviours", [])], nD = (o) => "<alloy.field." + o + ">", Y_ = (o, s) => {
    const i = (O) => Ah(o), l = (O, A) => (B, $) => Dn(B, o, $).map((Z) => O(Z, $)).getOr(A), f = (O, A) => js(O.element, "aria-hidden") !== "true", m = l(f, !1), b = l((O, A) => {
      if (f(O)) {
        const B = O.element;
        qn(B, "display", "none"), eo(B, "aria-hidden", "true"), pn(O, lm(), { name: A, visible: !1 });
      }
    }), x = ((O) => (A, B) => {
      tn(B, ($) => O(A, $));
    })(b), w = l((O, A) => {
      if (!f(O)) {
        const B = O.element;
        ar(B, "display"), ts(B, "aria-hidden"), pn(O, lm(), { name: A, visible: !0 });
      }
    }), E = { getSlotNames: i, getSlot: (O, A) => Dn(O, o, A), isShowing: m, hideSlot: b, hideAllSlots: (O) => x(O, i()), showSlot: w };
    return { uid: o.uid, dom: o.dom, components: s, behaviours: ir(o.slotBehaviours), apis: E };
  }, oD = ho({ getSlotNames: (o, s) => o.getSlotNames(s), getSlot: (o, s, i) => o.getSlot(s, i), isShowing: (o, s, i) => o.isShowing(s, i), hideSlot: (o, s, i) => o.hideSlot(s, i), hideAllSlots: (o, s) => o.hideAllSlots(s), showSlot: (o, s, i) => o.showSlot(s, i) }, (o) => _o(o)), Gc = { ...oD, sketch: (o) => {
    const s = (() => {
      const m = [];
      return { slot: (b, x) => (m.push(b), zr(tD, nD(b), x)), record: Ee(m) };
    })(), i = o(s), l = s.record(), f = Ct(l, (m) => Lt({ name: m, pname: nD(m) }));
    return Sv(tD, m6, f, Y_, i);
  } }, p6 = Nn([Wf, Kv, fs("onShow", gt), fs("onHide", gt), Qb]), g6 = (o) => ({ element: () => o.element.dom }), h6 = (o, s) => {
    const i = Ct(po(s), (l) => {
      const f = s[l], m = ic(((b) => Gr("sidebar", p6, b))(f));
      return { name: l, getApi: g6, onSetup: m.onSetup, onShow: m.onShow, onHide: m.onHide };
    });
    return Ct(i, (l) => {
      const f = Ln(gt);
      return o.slot(l.name, { dom: { tag: "div", classes: ["tox-sidebar__pane"] }, behaviours: v1([Ih(l, f), Fh(l, f), ft(lm(), (m, b) => {
        const x = b.event;
        Go(i, (E) => E.name === x.name).each((E) => {
          (x.visible ? E.onShow : E.onHide)(E.getApi(m));
        });
      })]) });
    });
  }, b6 = (o) => Gc.sketch((s) => ({ dom: { tag: "div", classes: ["tox-sidebar__pane-container"] }, components: h6(s, o), slotBehaviours: v1([ss((i) => Gc.hideAllSlots(i))]) })), X_ = (o, s) => {
    eo(o, "role", s);
  }, E4 = (o) => rr.getCurrent(o).bind((s) => Cd.isGrowing(s) || Cd.hasGrown(s) ? rr.getCurrent(s).bind((i) => Go(Gc.getSlotNames(i), (l) => Gc.isShowing(i, l))) : M.none()), J_ = hn("FixSizeEvent"), Q_ = hn("AutoSizeEvent");
  var y6 = Object.freeze({ __proto__: null, block: (o, s, i, l) => {
    eo(o.element, "aria-busy", !0);
    const f = s.getRoot(o).getOr(o), m = $t([Jt.config({ mode: "special", onTab: () => M.some(!0), onShiftTab: () => M.some(!0) }), io.config({})]), b = l(f, m), x = f.getSystem().build(b);
    Jn.append(f, Yr(x)), x.hasConfigured(Jt) && s.focus && Jt.focusIn(x), i.isBlocked() || s.onBlock(o), i.blockWith(() => Jn.remove(f, x));
  }, unblock: (o, s, i) => {
    ts(o.element, "aria-busy"), i.isBlocked() && s.onUnblock(o), i.clear();
  }, isBlocked: (o, s, i) => i.isBlocked() }), T4 = [fs("getRoot", M.none), rs("focus", !0), Vo("onBlock"), Vo("onUnblock")];
  const Kp = _i({ fields: T4, name: "blocking", apis: y6, state: Object.freeze({ __proto__: null, init: () => {
    const o = Ym((s) => s.destroy());
    return as({ readState: o.isSet, blockWith: (s) => {
      o.set({ destroy: s });
    }, clear: o.clear, isBlocked: o.isSet });
  } }) }), rD = (o) => rr.getCurrent(o).each((s) => gc(s.element, !0)), v6 = (o, s, i) => {
    const l = Ln(!1), f = As(), m = (x) => {
      var w;
      l.get() && (!((E) => E.type === "focusin")(w = x) || !(w.composed ? ct(w.composedPath()) : M.from(w.target)).map(Xt).filter(ra).exists((E) => _s(E, "mce-pastebin"))) && (x.preventDefault(), rD(s()), o.editorManager.setActive(o));
    };
    o.inline || o.on("PreInit", () => {
      o.dom.bind(o.getWin(), "focusin", m), o.on("BeforeExecCommand", (x) => {
        x.command.toLowerCase() === "mcefocus" && x.value !== !0 && m(x);
      });
    });
    const b = (x) => {
      x !== l.get() && (l.set(x), ((w, E, O, A) => {
        const B = E.element;
        if ((($, Z) => {
          const oe = "tabindex", re = `data-mce-${oe}`;
          M.from($.iframeElement).map(Xt).each((fe) => {
            Z ? (Sa(fe, oe).each((ee) => eo(fe, re, ee)), eo(fe, oe, -1)) : (ts(fe, oe), Sa(fe, re).each((ee) => {
              eo(fe, oe, ee), ts(fe, re);
            }));
          });
        })(w, O), O)
          Kp.block(E, (($) => (Z, oe) => ({ dom: { tag: "div", attributes: { "aria-label": $.translate("Loading..."), tabindex: "0" }, classes: ["tox-throbber__busy-spinner"] }, components: [{ dom: Bh('<div class="tox-spinner"><div></div><div></div><div></div></div>') }] }))(A)), ar(B, "display"), ts(B, "aria-hidden"), w.hasFocus() && rD(E);
        else {
          const $ = rr.getCurrent(E).exists((Z) => mm(Z.element));
          Kp.unblock(E), qn(B, "display", "none"), eo(B, "aria-hidden", "true"), $ && w.focus();
        }
      })(o, s(), x, i.providers), ((w, E) => {
        w.dispatch("AfterProgressState", { state: E });
      })(o, x));
    };
    o.on("ProgressState", (x) => {
      if (f.on(clearTimeout), en(x.time)) {
        const w = ck.setEditorTimeout(o, () => b(x.state), x.time);
        f.set(w);
      } else
        b(x.state), f.clear();
    });
  }, z4 = (o, s, i) => ({ within: o, extra: s, withinWidth: i }), sD = (o, s, i) => {
    const l = K(o, (b, x) => ((w, E) => {
      const O = i(w);
      return M.some({ element: w, start: E, finish: E + O, width: O });
    })(x, b.len).fold(Ee(b), (w) => ({ len: w.finish, list: b.list.concat([w]) })), { len: 0, list: [] }).list, f = Pn(l, (b) => b.finish <= s), m = Mo(f, (b, x) => b + x.width, 0);
    return { within: f, extra: l.slice(f.length), withinWidth: m };
  }, e2 = (o) => Ct(o, (s) => s.element), aD = (o, s) => {
    const i = Ct(s, (l) => Yr(l));
    Nm.setGroups(o, i);
  }, iD = (o, s, i) => {
    const l = s.builtGroups.get();
    if (l.length === 0)
      return;
    const f = ii(o, s, "primary"), m = Qa.getCoupled(o, "overflowGroup");
    qn(f.element, "visibility", "hidden");
    const b = l.concat([m]), x = Ko(b, (E) => iu(E.element).bind((O) => E.getSystem().getByDom(O).toOptional()));
    i([]), aD(f, b);
    const w = ((E, O, A, B) => {
      const $ = ((fe, ee, J) => {
        const le = sD(ee, fe, J);
        return le.extra.length === 0 ? M.some(le) : M.none();
      })(E, O, A).getOrThunk(() => sD(O, E - A(B), A)), Z = $.within, oe = $.extra, re = $.withinWidth;
      return oe.length === 1 && oe[0].width <= A(B) ? ((fe, ee, J) => {
        const le = e2(fe.concat(ee));
        return z4(le, [], J);
      })(Z, oe, re) : oe.length >= 1 ? ((fe, ee, J, le) => {
        const me = e2(fe).concat([J]);
        return z4(me, e2(ee), le);
      })(Z, oe, B, re) : ((fe, ee, J) => z4(e2(fe), [], J))(Z, 0, re);
    })(Wr(f.element), s.builtGroups.get(), (E) => Wr(E.element), m);
    w.extra.length === 0 ? (Jn.remove(f, m), i([])) : (aD(f, w.within), i(w.extra)), ar(f.element, "visibility"), te(f.element), x.each(io.focus);
  }, lD = Ee([pa("splitToolbarBehaviours", [Qa]), ua("builtGroups", () => Ln([]))]), x6 = Ee([Au(["overflowToggledClass"]), Vl("getOverflowBounds"), st("lazySink"), ua("overflowGroups", () => Ln([])), Vo("onOpened"), Vo("onClosed")].concat(lD())), t2 = Ee([Lt({ factory: Nm, schema: Zu(), name: "primary" }), Vt({ schema: Zu(), name: "overflow" }), Vt({ name: "overflow-button" }), Vt({ name: "overflow-group" })]), $x = Ee((o, s) => {
    ((i, l) => {
      const f = Cr.max(i, l, ["margin-left", "border-left-width", "padding-left", "padding-right", "border-right-width", "margin-right"]);
      qn(i, "max-width", f + "px");
    })(o, Math.floor(s));
  }), O4 = Ee([Au(["toggledClass"]), st("lazySink"), Ia("fetch"), Vl("getBounds"), Ol("fireDismissalEventInstead", [He("event", qd())]), ym(), Vo("onToggled")]), cD = Ee([Vt({ name: "button", overrides: (o) => ({ dom: { attributes: { "aria-haspopup": "true" } }, buttonBehaviours: $t([Lo.config({ toggleClass: o.markers.toggledClass, aria: { mode: "expanded" }, toggleOnExecute: !1, onToggled: o.onToggled })]) }) }), Vt({ factory: Nm, schema: Zu(), name: "toolbar", overrides: (o) => ({ toolbarBehaviours: $t([Jt.config({ mode: "cyclic", onEscape: (s) => (Dn(s, o, "button").each(io.focus), M.none()) })]) }) })]), n2 = As(), A4 = (o, s) => {
    const i = Qa.getCoupled(o, "toolbarSandbox");
    zo.isOpen(i) ? zo.close(i) : zo.open(i, s.toolbar());
  }, Hx = (o, s, i, l) => {
    const f = i.getBounds.map((b) => b()), m = i.lazySink(o).getOrDie();
    Ll.positionWithinBounds(m, s, { anchor: { type: "hotspot", hotspot: o, layouts: l, overrides: { maxWidthFunction: $x() } } }, f);
  }, o2 = (o, s, i, l, f) => {
    Nm.setGroups(s, f), Hx(o, s, i, l), Lo.on(o);
  }, Yp = hc({ name: "FloatingToolbarButton", factory: (o, s, i, l) => ({ ...bc.sketch({ ...l.button(), action: (f) => {
    A4(f, l);
  }, buttonBehaviours: Ua({ dump: l.button().buttonBehaviours }, [Qa.config({ others: { toolbarSandbox: (f) => ((m, b, x) => {
    const w = Qd();
    return { dom: { tag: "div", attributes: { id: w.id } }, behaviours: $t([Jt.config({ mode: "special", onEscape: (E) => (zo.close(E), M.some(!0)) }), zo.config({ onOpen: (E, O) => {
      const A = n2.get().getOr(!1);
      x.fetch().get((B) => {
        o2(m, O, x, b.layouts, B), w.link(m.element), A || Jt.focusIn(O);
      });
    }, onClose: () => {
      Lo.off(m), n2.get().getOr(!1) || io.focus(m), w.unlink(m.element);
    }, isPartOf: (E, O, A) => wi(O, A) || wi(m, A), getAttachPoint: () => x.lazySink(m).getOrDie() }), pc.config({ channels: { ...Rb({ isExtraPart: Xe, ...x.fireDismissalEventInstead.map((E) => ({ fireEventInstead: { event: E.event } })).getOr({}) }), ...Dg({ doReposition: () => {
      zo.getState(Qa.getCoupled(m, "toolbarSandbox")).each((E) => {
        Hx(m, E, x, b.layouts);
      });
    } }) } })]) };
  })(f, i, o) } })]) }), apis: { setGroups: (f, m) => {
    zo.getState(Qa.getCoupled(f, "toolbarSandbox")).each((b) => {
      o2(f, b, o, i.layouts, m);
    });
  }, reposition: (f) => {
    zo.getState(Qa.getCoupled(f, "toolbarSandbox")).each((m) => {
      Hx(f, m, o, i.layouts);
    });
  }, toggle: (f) => {
    A4(f, l);
  }, toggleWithoutFocusing: (f) => {
    ((m, b) => {
      n2.set(!0), A4(m, b), n2.clear();
    })(f, l);
  }, getToolbar: (f) => zo.getState(Qa.getCoupled(f, "toolbarSandbox")), isOpen: (f) => zo.isOpen(Qa.getCoupled(f, "toolbarSandbox")) } }), configFields: O4(), partFields: cD(), apis: { setGroups: (o, s, i) => {
    o.setGroups(s, i);
  }, reposition: (o, s) => {
    o.reposition(s);
  }, toggle: (o, s) => {
    o.toggle(s);
  }, toggleWithoutFocusing: (o, s) => {
    o.toggleWithoutFocusing(s);
  }, getToolbar: (o, s) => o.getToolbar(s), isOpen: (o, s) => o.isOpen(s) } }), uD = Ee([st("items"), Au(["itemSelector"]), pa("tgroupBehaviours", [Jt])]), w6 = Ee([Vn({ name: "items", unit: "item" })]), r2 = hc({ name: "ToolbarGroup", configFields: uD(), partFields: w6(), factory: (o, s, i, l) => ({ uid: o.uid, dom: o.dom, components: s, behaviours: Fi(o.tgroupBehaviours, [Jt.config({ mode: "flow", selector: o.markers.itemSelector })]), domModification: { attributes: { role: "toolbar" } } }) }), dD = (o) => Ct(o, (s) => Yr(s)), fD = (o, s, i) => {
    iD(o, i, (l) => {
      i.overflowGroups.set(l), s.getOpt(o).each((f) => {
        Yp.setGroups(f, dD(l));
      });
    });
  }, mD = hc({ name: "SplitFloatingToolbar", configFields: x6(), partFields: t2(), factory: (o, s, i, l) => {
    const f = Ur(Yp.sketch({ fetch: () => sy((m) => {
      m(dD(o.overflowGroups.get()));
    }), layouts: { onLtr: () => [Tr, Bi], onRtl: () => [Bi, Tr], onBottomLtr: () => [ps, rl], onBottomRtl: () => [rl, ps] }, getBounds: i.getOverflowBounds, lazySink: o.lazySink, fireDismissalEventInstead: {}, markers: { toggledClass: o.markers.overflowToggledClass }, parts: { button: l["overflow-button"](), toolbar: l.overflow() }, onToggled: (m, b) => o[b ? "onOpened" : "onClosed"](m) }));
    return { uid: o.uid, dom: o.dom, components: s, behaviours: Fi(o.splitToolbarBehaviours, [Qa.config({ others: { overflowGroup: () => r2.sketch({ ...l["overflow-group"](), items: [f.asSpec()] }) } })]), apis: { setGroups: (m, b) => {
      o.builtGroups.set(Ct(b, m.getSystem().build)), fD(m, f, o);
    }, refresh: (m) => fD(m, f, o), toggle: (m) => {
      f.getOpt(m).each((b) => {
        Yp.toggle(b);
      });
    }, toggleWithoutFocusing: (m) => {
      f.getOpt(m).each(Yp.toggleWithoutFocusing);
    }, isOpen: (m) => f.getOpt(m).map(Yp.isOpen).getOr(!1), reposition: (m) => {
      f.getOpt(m).each((b) => {
        Yp.reposition(b);
      });
    }, getOverflow: (m) => f.getOpt(m).bind(Yp.getToolbar) }, domModification: { attributes: { role: "group" } } };
  }, apis: { setGroups: (o, s, i) => {
    o.setGroups(s, i);
  }, refresh: (o, s) => {
    o.refresh(s);
  }, reposition: (o, s) => {
    o.reposition(s);
  }, toggle: (o, s) => {
    o.toggle(s);
  }, toggleWithoutFocusing: (o, s) => {
    o.toggle(s);
  }, isOpen: (o, s) => o.isOpen(s), getOverflow: (o, s) => o.getOverflow(s) } }), k6 = Ee([Au(["closedClass", "openClass", "shrinkingClass", "growingClass", "overflowToggledClass"]), Vo("onOpened"), Vo("onClosed")].concat(lD())), _6 = Ee([Lt({ factory: Nm, schema: Zu(), name: "primary" }), Lt({ factory: Nm, schema: Zu(), name: "overflow", overrides: (o) => ({ toolbarBehaviours: $t([Cd.config({ dimension: { property: "height" }, closedClass: o.markers.closedClass, openClass: o.markers.openClass, shrinkingClass: o.markers.shrinkingClass, growingClass: o.markers.growingClass, onShrunk: (s) => {
    Dn(s, o, "overflow-button").each((i) => {
      Lo.off(i), io.focus(i);
    }), o.onClosed(s);
  }, onGrown: (s) => {
    Jt.focusIn(s), o.onOpened(s);
  }, onStartGrow: (s) => {
    Dn(s, o, "overflow-button").each(Lo.on);
  } }), Jt.config({ mode: "acyclic", onEscape: (s) => (Dn(s, o, "overflow-button").each(io.focus), M.some(!0)) })]) }) }), Vt({ name: "overflow-button", overrides: (o) => ({ buttonBehaviours: $t([Lo.config({ toggleClass: o.markers.overflowToggledClass, aria: { mode: "pressed" }, toggleOnExecute: !1 })]) }) }), Vt({ name: "overflow-group" })]), pD = (o, s) => {
    Dn(o, s, "overflow-button").bind(() => Dn(o, s, "overflow")).each((i) => {
      D4(o, s), Cd.toggleGrow(i);
    });
  }, D4 = (o, s) => {
    Dn(o, s, "overflow").each((i) => {
      iD(o, s, (l) => {
        const f = Ct(l, (m) => Yr(m));
        Nm.setGroups(i, f);
      }), Dn(o, s, "overflow-button").each((l) => {
        Cd.hasGrown(i) && Lo.on(l);
      }), Cd.refresh(i);
    });
  }, R4 = hc({ name: "SplitSlidingToolbar", configFields: k6(), partFields: _6(), factory: (o, s, i, l) => {
    const f = "alloy.toolbar.toggle";
    return { uid: o.uid, dom: o.dom, components: s, behaviours: Fi(o.splitToolbarBehaviours, [Qa.config({ others: { overflowGroup: (m) => r2.sketch({ ...l["overflow-group"](), items: [bc.sketch({ ...l["overflow-button"](), action: (b) => {
      Io(m, f);
    } })] }) } }), wo("toolbar-toggle-events", [ft(f, (m) => {
      pD(m, o);
    })])]), apis: { setGroups: (m, b) => {
      ((x, w) => {
        const E = Ct(w, x.getSystem().build);
        o.builtGroups.set(E);
      })(m, b), D4(m, o);
    }, refresh: (m) => D4(m, o), toggle: (m) => pD(m, o), isOpen: (m) => ((b, x) => Dn(b, x, "overflow").map(Cd.hasGrown).getOr(!1))(m, o) }, domModification: { attributes: { role: "group" } } };
  }, apis: { setGroups: (o, s, i) => {
    o.setGroups(s, i);
  }, refresh: (o, s) => {
    o.refresh(s);
  }, toggle: (o, s) => {
    o.toggle(s);
  }, isOpen: (o, s) => o.isOpen(s) } }), gD = (o) => {
    const s = o.title.fold(() => ({}), (i) => ({ attributes: { title: i } }));
    return { dom: { tag: "div", classes: ["tox-toolbar__group"], ...s }, components: [r2.parts.items({})], items: o.items, markers: { itemSelector: "*:not(.tox-split-button) > .tox-tbtn:not([disabled]), .tox-split-button:not([disabled]), .tox-toolbar-nav-js:not([disabled]), .tox-number-input:not([disabled])" }, tgroupBehaviours: $t([Aa.config({}), io.config({})]) };
  }, s2 = (o) => r2.sketch(gD(o)), hD = (o, s) => {
    const i = ss((l) => {
      const f = Ct(o.initGroups, s2);
      Nm.setGroups(l, f);
    });
    return $t([MS(o.providers.isDisabled), il(), Jt.config({ mode: s, onEscape: o.onEscape, selector: ".tox-toolbar__group" }), wo("toolbar-events", [i])]);
  }, N4 = (o) => {
    const s = o.cyclicKeying ? "cyclic" : "acyclic";
    return { uid: o.uid, dom: { tag: "div", classes: ["tox-toolbar-overlord"] }, parts: { "overflow-group": gD({ title: M.none(), items: [] }), "overflow-button": LB({ name: "more", icon: M.some("more-drawer"), enabled: !0, tooltip: M.some("Reveal or hide additional toolbar items"), primary: !1, buttonType: M.none(), borderless: !1 }, M.none(), o.providers) }, splitToolbarBehaviours: hD(o, s) };
  }, C6 = (o) => {
    const s = N4(o), i = mD.parts.primary({ dom: { tag: "div", classes: ["tox-toolbar__primary"] } });
    return mD.sketch({ ...s, lazySink: o.getSink, getOverflowBounds: () => {
      const l = o.moreDrawerData.lazyHeader().element, f = la(l), m = Md(l), b = la(m), x = Math.max(m.dom.scrollHeight, b.height);
      return Ws(f.x + 4, b.y, f.width - 8, x);
    }, parts: { ...s.parts, overflow: { dom: { tag: "div", classes: ["tox-toolbar__overflow"], attributes: o.attributes } } }, components: [i], markers: { overflowToggledClass: "tox-tbtn--enabled" }, onOpened: (l) => o.onToggled(l, !0), onClosed: (l) => o.onToggled(l, !1) });
  }, S6 = (o) => {
    const s = R4.parts.primary({ dom: { tag: "div", classes: ["tox-toolbar__primary"] } }), i = R4.parts.overflow({ dom: { tag: "div", classes: ["tox-toolbar__overflow"] } }), l = N4(o);
    return R4.sketch({ ...l, components: [s, i], markers: { openClass: "tox-toolbar__overflow--open", closedClass: "tox-toolbar__overflow--closed", growingClass: "tox-toolbar__overflow--growing", shrinkingClass: "tox-toolbar__overflow--shrinking", overflowToggledClass: "tox-tbtn--enabled" }, onOpened: (f) => {
      f.getSystem().broadcastOn([G_()], { type: "opened" }), o.onToggled(f, !0);
    }, onClosed: (f) => {
      f.getSystem().broadcastOn([G_()], { type: "closed" }), o.onToggled(f, !1);
    } });
  }, yp = (o) => {
    const s = o.cyclicKeying ? "cyclic" : "acyclic";
    return Nm.sketch({ uid: o.uid, dom: { tag: "div", classes: ["tox-toolbar"].concat(o.type === Zf.scrolling ? ["tox-toolbar--scrolling"] : []) }, components: [Nm.parts.groups({})], toolbarBehaviours: hD(o, s) });
  }, bD = [ey, Wf, Nr("tooltip"), Fs("buttonType", "secondary", ["primary", "secondary"]), rs("borderless", !1), Ia("onAction")], yD = { button: [...bD, Jb, Pa("type", ["button"])], togglebutton: [...bD, rs("active", !1), Pa("type", ["togglebutton"])] }, M4 = [Pa("type", ["group"]), Ir("buttons", [], bi("type", yD))], ll = bi("type", { ...yD, group: M4 }), E6 = Nn([Ir("buttons", [], ll), Ia("onShow"), Ia("onHide")]), vD = (o, s) => ((i, l) => {
    var f, m;
    const b = i.type === "togglebutton", x = i.icon.map((ee) => bp(ee, l.icons)).map(Ur), w = { ...i, name: b ? i.text.getOr(i.icon.getOr("")) : (f = i.text) !== null && f !== void 0 ? f : i.icon.getOr(""), primary: i.buttonType === "primary", buttonType: M.from(i.buttonType), tooltip: i.tooltip, icon: i.icon, enabled: !0, borderless: i.borderless }, E = JE((m = i.buttonType) !== null && m !== void 0 ? m : "secondary"), O = b ? i.text.map(l.translate) : M.some(l.translate(i.text)), A = O.map(Os), B = w.tooltip.or(O).map((ee) => ({ "aria-label": l.translate(ee), title: l.translate(ee) })).getOr({}), $ = x.map((ee) => ee.asSpec()), Z = B0([$, A]), oe = i.icon.isSome() && A.isSome(), re = { tag: "button", classes: E.concat(...i.icon.isSome() && !oe ? ["tox-button--icon"] : []).concat(...oe ? ["tox-button--icon-and-text"] : []).concat(...i.borderless ? ["tox-button--naked"] : []).concat(...i.type === "togglebutton" && i.active ? ["tox-button--enabled"] : []), attributes: B }, fe = O_(w, M.some((ee) => {
      const J = (le) => {
        x.map((me) => me.getOpt(ee).each((ke) => {
          Jn.set(ke, [bp(le, l.icons)]);
        }));
      };
      return b ? i.onAction({ setIcon: J, setActive: (le) => {
        const me = ee.element;
        le ? (vr(me, "tox-button--enabled"), eo(me, "aria-pressed", !0)) : ($s(me, "tox-button--enabled"), ts(me, "aria-pressed"));
      }, isActive: () => _s(ee.element, "tox-button--enabled") }) : i.type === "button" ? i.onAction({ setIcon: J }) : void 0;
    }), [], re, Z, l);
    return bc.sketch(fe);
  })(o, s), xD = Ic().deviceType, T6 = xD.isPhone(), z6 = xD.isTablet();
  var tv = hc({ name: "silver.View", configFields: [st("viewConfig")], partFields: [rn({ factory: { sketch: (o) => {
    let s = !1;
    const i = Ct(o.buttons, (l) => l.type === "group" ? (s = !0, ((f, m) => ({ dom: { tag: "div", classes: ["tox-view__toolbar__group"] }, components: Ct(f.buttons, (b) => vD(b, m)) }))(l, o.providers)) : vD(l, o.providers));
    return { uid: o.uid, dom: { tag: "div", classes: [s ? "tox-view__toolbar" : "tox-view__header", ...T6 || z6 ? ["tox-view--mobile", "tox-view--scrolling"] : []] }, behaviours: $t([io.config({}), Jt.config({ mode: "flow", selector: "button, .tox-button", focusInside: $b.OnEnterOrSpaceMode })]), components: s ? i : [Uu.sketch({ dom: { tag: "div", classes: ["tox-view__header-start"] }, components: [] }), Uu.sketch({ dom: { tag: "div", classes: ["tox-view__header-end"] }, components: i })] };
  } }, schema: [st("buttons"), st("providers")], name: "header" }), rn({ factory: { sketch: (o) => ({ uid: o.uid, dom: { tag: "div", classes: ["tox-view__pane"] } }) }, schema: [], name: "pane" })], factory: (o, s, i, l) => {
    const f = { getPane: (m) => Il.getPart(m, o, "pane"), getOnShow: (m) => o.viewConfig.onShow, getOnHide: (m) => o.viewConfig.onHide };
    return { uid: o.uid, dom: o.dom, components: s, apis: f };
  }, apis: { getPane: (o, s) => o.getPane(s), getOnShow: (o, s) => o.getOnShow(s), getOnHide: (o, s) => o.getOnHide(s) } });
  const O6 = (o, s, i) => Po(s, (l, f) => {
    const m = ic(Gr("view", E6, l));
    return o.slot(f, tv.sketch({ dom: { tag: "div", classes: ["tox-view"] }, viewConfig: m, components: [...m.buttons.length > 0 ? [tv.parts.header({ buttons: m.buttons, providers: i })] : [], tv.parts.pane({})] }));
  }), A6 = (o, s) => Gc.sketch((i) => ({ dom: { tag: "div", classes: ["tox-view-wrap__slot-container"] }, components: O6(i, o, s), slotBehaviours: v1([ss((l) => Gc.hideAllSlots(l))]) })), wD = (o) => Go(Gc.getSlotNames(o), (s) => Gc.isShowing(o, s)), kD = (o, s, i) => {
    Gc.getSlot(o, s).each((l) => {
      tv.getPane(l).each((f) => {
        var m;
        i(l)((m = f.element.dom, { getContainer: Ee(m) }));
      });
    });
  };
  var a2 = Bu({ factory: (o, s) => {
    const i = { setViews: (l, f) => {
      Jn.set(l, [A6(f, s.backstage.shared.providers)]);
    }, whichView: (l) => rr.getCurrent(l).bind(wD), toggleView: (l, f, m, b) => rr.getCurrent(l).exists((x) => {
      const w = wD(x), E = w.exists((A) => b === A), O = Gc.getSlot(x, b).isSome();
      return O && (Gc.hideAllSlots(x), E ? (((A) => {
        const B = A.element;
        qn(B, "display", "none"), eo(B, "aria-hidden", "true");
      })(l), f()) : (m(), ((A) => {
        const B = A.element;
        ar(B, "display"), ts(B, "aria-hidden");
      })(l), Gc.showSlot(x, b), ((A, B) => {
        kD(A, B, tv.getOnShow);
      })(x, b)), w.each((A) => ((B, $) => kD(B, $, tv.getOnHide))(x, A))), O;
    }) };
    return { uid: o.uid, dom: { tag: "div", classes: ["tox-view-wrap"], attributes: { "aria-hidden": "true" }, styles: { display: "none" } }, components: [], behaviours: $t([Jn.config({}), rr.config({ find: (l) => {
      const f = Jn.contents(l);
      return ct(f);
    } })]), apis: i };
  }, name: "silver.ViewWrapper", configFields: [st("backstage")], apis: { setViews: (o, s, i) => o.setViews(s, i), toggleView: (o, s, i, l, f) => o.toggleView(s, i, l, f), whichView: (o, s) => o.whichView(s) } });
  const D6 = Wg.optional({ factory: S4, name: "menubar", schema: [st("backstage")] }), R6 = Wg.optional({ factory: { sketch: (o) => b4.sketch({ uid: o.uid, dom: o.dom, listBehaviours: $t([Jt.config({ mode: "acyclic", selector: ".tox-toolbar" })]), makeItem: () => yp({ type: o.type, uid: hn("multiple-toolbar-item"), cyclicKeying: !1, initGroups: [], providers: o.providers, onEscape: () => (o.onEscape(), M.some(!0)) }), setupItem: (s, i, l, f) => {
    Nm.setGroups(i, l);
  }, shell: !0 }) }, name: "multiple-toolbar", schema: [st("dom"), st("onEscape")] }), N6 = Wg.optional({ factory: { sketch: (o) => ((i) => i.type === Zf.sliding ? S6 : i.type === Zf.floating ? C6 : yp)(o)({ type: o.type, uid: o.uid, onEscape: () => (o.onEscape(), M.some(!0)), onToggled: (i, l) => o.onToolbarToggled(l), cyclicKeying: !1, initGroups: [], getSink: o.getSink, providers: o.providers, moreDrawerData: { lazyToolbar: o.lazyToolbar, lazyMoreButton: o.lazyMoreButton, lazyHeader: o.lazyHeader }, attributes: o.attributes }) }, name: "toolbar", schema: [st("dom"), st("onEscape"), st("getSink")] }), M6 = Wg.optional({ factory: { sketch: (o) => {
    const s = o.editor, i = o.sticky ? QA : HA;
    return { uid: o.uid, dom: o.dom, components: o.components, behaviours: $t(i(s, o.sharedBackstage)) };
  } }, name: "header", schema: [st("dom")] }), B6 = Wg.optional({ factory: { sketch: (o) => ({ uid: o.uid, dom: o.dom, components: [{ dom: { tag: "a", attributes: { href: "https://www.tiny.cloud/tinymce-self-hosted-premium-features/?utm_campaign=self_hosted_upgrade_promo&utm_source=tiny&utm_medium=referral", rel: "noopener", target: "_blank", "aria-hidden": "true" }, classes: ["tox-promotion-link"], innerHtml: "⚡️Upgrade" } }] }) }, name: "promotion", schema: [st("dom")] }), L6 = Wg.optional({ name: "socket", schema: [st("dom")] }), P6 = Wg.optional({ factory: { sketch: (o) => ({ uid: o.uid, dom: { tag: "div", classes: ["tox-sidebar"], attributes: { role: "presentation" } }, components: [{ dom: { tag: "div", classes: ["tox-sidebar__slider"] }, components: [], behaviours: $t([Aa.config({}), io.config({}), Cd.config({ dimension: { property: "width" }, closedClass: "tox-sidebar--sliding-closed", openClass: "tox-sidebar--sliding-open", shrinkingClass: "tox-sidebar--sliding-shrinking", growingClass: "tox-sidebar--sliding-growing", onShrunk: (s) => {
    rr.getCurrent(s).each(Gc.hideAllSlots), Io(s, Q_);
  }, onGrown: (s) => {
    Io(s, Q_);
  }, onStartGrow: (s) => {
    pn(s, J_, { width: Xs(s.element, "width").getOr("") });
  }, onStartShrink: (s) => {
    pn(s, J_, { width: Wr(s.element) + "px" });
  } }), Jn.config({}), rr.config({ find: (s) => {
    const i = Jn.contents(s);
    return ct(i);
  } })]) }], behaviours: $t([kx(0), wo("sidebar-sliding-events", [ft(J_, (s, i) => {
    qn(s.element, "width", i.event.width);
  }), ft(Q_, (s, i) => {
    ar(s.element, "width");
  })])]) }) }, name: "sidebar", schema: [st("dom")] }), I6 = Wg.optional({ factory: { sketch: (o) => ({ uid: o.uid, dom: { tag: "div", attributes: { "aria-hidden": "true" }, classes: ["tox-throbber"], styles: { display: "none" } }, behaviours: $t([Jn.config({}), Kp.config({ focus: !1 }), rr.config({ find: (s) => ct(s.components()) })]), components: [] }) }, name: "throbber", schema: [st("dom")] }), F6 = Wg.optional({ factory: a2, name: "viewWrapper", schema: [st("backstage")] }), $6 = Wg.optional({ factory: { sketch: (o) => ({ uid: o.uid, dom: { tag: "div", classes: ["tox-editor-container"] }, components: o.components }) }, name: "editorContainer", schema: [] });
  var Rs = hc({ name: "OuterContainer", factory: (o, s, i) => {
    let l = !1;
    const f = { getSocket: (m) => Il.getPart(m, o, "socket"), setSidebar: (m, b, x) => {
      Il.getPart(m, o, "sidebar").each((w) => ((E, O, A) => {
        rr.getCurrent(E).each((B) => {
          Jn.set(B, [b6(O)]);
          const $ = A == null ? void 0 : A.toLowerCase();
          ce($) && _n(O, $) && rr.getCurrent(B).each((Z) => {
            Gc.showSlot(Z, $), Cd.immediateGrow(B), ar(B.element, "width"), X_(E.element, "region");
          });
        });
      })(w, b, x));
    }, toggleSidebar: (m, b) => {
      Il.getPart(m, o, "sidebar").each((x) => ((w, E) => {
        rr.getCurrent(w).each((O) => {
          rr.getCurrent(O).each((A) => {
            Cd.hasGrown(O) ? Gc.isShowing(A, E) ? (Cd.shrink(O), X_(w.element, "presentation")) : (Gc.hideAllSlots(A), Gc.showSlot(A, E), X_(w.element, "region")) : (Gc.hideAllSlots(A), Gc.showSlot(A, E), Cd.grow(O), X_(w.element, "region"));
          });
        });
      })(x, b));
    }, whichSidebar: (m) => Il.getPart(m, o, "sidebar").bind(E4).getOrNull(), getHeader: (m) => Il.getPart(m, o, "header"), getToolbar: (m) => Il.getPart(m, o, "toolbar"), setToolbar: (m, b) => {
      Il.getPart(m, o, "toolbar").each((x) => {
        const w = Ct(b, s2);
        x.getApis().setGroups(x, w);
      });
    }, setToolbars: (m, b) => {
      Il.getPart(m, o, "multiple-toolbar").each((x) => {
        const w = Ct(b, (E) => Ct(E, s2));
        b4.setItems(x, w);
      });
    }, refreshToolbar: (m) => {
      Il.getPart(m, o, "toolbar").each((b) => b.getApis().refresh(b));
    }, toggleToolbarDrawer: (m) => {
      Il.getPart(m, o, "toolbar").each((b) => {
        Zo(b.getApis().toggle, (x) => x(b));
      });
    }, toggleToolbarDrawerWithoutFocusing: (m) => {
      Il.getPart(m, o, "toolbar").each((b) => {
        Zo(b.getApis().toggleWithoutFocusing, (x) => x(b));
      });
    }, isToolbarDrawerToggled: (m) => Il.getPart(m, o, "toolbar").bind((b) => M.from(b.getApis().isOpen).map((x) => x(b))).getOr(!1), getThrobber: (m) => Il.getPart(m, o, "throbber"), focusToolbar: (m) => {
      Il.getPart(m, o, "toolbar").orThunk(() => Il.getPart(m, o, "multiple-toolbar")).each((b) => {
        Jt.focusIn(b);
      });
    }, setMenubar: (m, b) => {
      Il.getPart(m, o, "menubar").each((x) => {
        S4.setMenus(x, b);
      });
    }, focusMenubar: (m) => {
      Il.getPart(m, o, "menubar").each((b) => {
        S4.focus(b);
      });
    }, setViews: (m, b) => {
      Il.getPart(m, o, "viewWrapper").each((x) => {
        a2.setViews(x, b);
      });
    }, toggleView: (m, b) => Il.getPart(m, o, "viewWrapper").exists((x) => a2.toggleView(x, () => f.showMainView(m), () => f.hideMainView(m), b)), whichView: (m) => Il.getPart(m, o, "viewWrapper").bind(a2.whichView).getOrNull(), hideMainView: (m) => {
      l = f.isToolbarDrawerToggled(m), l && f.toggleToolbarDrawer(m), Il.getPart(m, o, "editorContainer").each((b) => {
        const x = b.element;
        qn(x, "display", "none"), eo(x, "aria-hidden", "true");
      });
    }, showMainView: (m) => {
      l && f.toggleToolbarDrawer(m), Il.getPart(m, o, "editorContainer").each((b) => {
        const x = b.element;
        ar(x, "display"), ts(x, "aria-hidden");
      });
    } };
    return { uid: o.uid, dom: o.dom, components: s, apis: f, behaviours: o.behaviours };
  }, configFields: [st("dom"), st("behaviours")], partFields: [M6, D6, N6, R6, L6, P6, B6, I6, F6, $6], apis: { getSocket: (o, s) => o.getSocket(s), setSidebar: (o, s, i, l) => {
    o.setSidebar(s, i, l);
  }, toggleSidebar: (o, s, i) => {
    o.toggleSidebar(s, i);
  }, whichSidebar: (o, s) => o.whichSidebar(s), getHeader: (o, s) => o.getHeader(s), getToolbar: (o, s) => o.getToolbar(s), setToolbar: (o, s, i) => {
    o.setToolbar(s, i);
  }, setToolbars: (o, s, i) => {
    o.setToolbars(s, i);
  }, refreshToolbar: (o, s) => o.refreshToolbar(s), toggleToolbarDrawer: (o, s) => {
    o.toggleToolbarDrawer(s);
  }, toggleToolbarDrawerWithoutFocusing: (o, s) => {
    o.toggleToolbarDrawerWithoutFocusing(s);
  }, isToolbarDrawerToggled: (o, s) => o.isToolbarDrawerToggled(s), getThrobber: (o, s) => o.getThrobber(s), setMenubar: (o, s, i) => {
    o.setMenubar(s, i);
  }, focusMenubar: (o, s) => {
    o.focusMenubar(s);
  }, focusToolbar: (o, s) => {
    o.focusToolbar(s);
  }, setViews: (o, s, i) => {
    o.setViews(s, i);
  }, toggleView: (o, s, i) => o.toggleView(s, i), whichView: (o, s) => o.whichView(s) } });
  const _D = { file: { title: "File", items: "newdocument restoredraft | preview | export print | deleteallconversations" }, edit: { title: "Edit", items: "undo redo | cut copy paste pastetext | selectall | searchreplace" }, view: { title: "View", items: "code | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments" }, insert: { title: "Insert", items: "image link media addcomment pageembed template inserttemplate codesample inserttable accordion | charmap emoticons hr | pagebreak nonbreaking anchor tableofcontents footnotes | mergetags | insertdatetime" }, format: { title: "Format", items: "bold italic underline strikethrough superscript subscript codeformat | styles blocks fontfamily fontsize align lineheight | forecolor backcolor | language | removeformat" }, tools: { title: "Tools", items: "aidialog aishortcuts | spellchecker spellcheckerlanguage | autocorrect capitalization | a11ycheck code typography wordcount addtemplate" }, table: { title: "Table", items: "inserttable | cell row column | advtablesort | tableprops deletetable" }, help: { title: "Help", items: "help" } }, B4 = (o) => o.split(" "), CD = (o, s) => {
    const i = { ..._D, ...s.menus }, l = po(s.menus).length > 0, f = s.menubar === void 0 || s.menubar === !0 ? B4("file edit view insert format tools table help") : B4(s.menubar === !1 ? "" : s.menubar), m = Pn(f, (x) => {
      const w = _n(_D, x);
      return l ? w || cn(s.menus, x).exists((E) => _n(E, "items")) : w;
    }), b = Ct(m, (x) => {
      const w = i[x];
      return ((E, O, A) => {
        const B = VT(A).split(/[ ,]/);
        return { text: E.title, getItems: () => Qr(E.items, ($) => {
          const Z = $.toLowerCase();
          return Z.trim().length === 0 || jr(B, (oe) => oe === Z) ? [] : Z === "separator" || Z === "|" ? [{ type: "separator" }] : O.menuItems[Z] ? [O.menuItems[Z]] : [];
        }) };
      })({ title: w.title, items: B4(w.items) }, s, o);
    });
    return Pn(b, (x) => x.getItems().length > 0 && jr(x.getItems(), (w) => ce(w) || w.type !== "separator"));
  }, L4 = (o, s, i) => (o.on("remove", () => i.unload(s)), i.load(s)), P4 = (o, s, i, l) => (o.on("remove", () => l.unloadRawCss(s)), l.loadRawCss(s, i)), H6 = async (o, s) => {
    const i = "ui/" + kk(o).getOr("default") + "/skin.css", l = tinymce.Resource.get(i);
    return ce(l) ? Promise.resolve(P4(o, i, l, o.ui.styleSheetLoader)) : L4(o, s + "/skin.min.css", o.ui.styleSheetLoader);
  }, V6 = async (o, s) => {
    var i;
    if (i = Xt(o.getElement()), Us(i).isSome()) {
      const l = "ui/" + kk(o).getOr("default") + "/skin.shadowdom.css", f = tinymce.Resource.get(l);
      return ce(f) ? (P4(o, l, f, Ph.DOM.styleSheetLoader), Promise.resolve()) : L4(o, s + "/skin.shadowdom.min.css", Ph.DOM.styleSheetLoader);
    }
  }, I4 = (o, s) => (async (i, l) => {
    kk(l).fold(() => {
      const m = _0(l);
      m && l.contentCSS.push(m + (i ? "/content.inline" : "/content") + ".min.css");
    }, (m) => {
      const b = "ui/" + m + (i ? "/content.inline" : "/content") + ".css", x = tinymce.Resource.get(b);
      if (ce(x))
        P4(l, b, x, l.ui.styleSheetLoader);
      else {
        const w = _0(l);
        w && l.contentCSS.push(w + (i ? "/content.inline" : "/content") + ".min.css");
      }
    });
    const f = _0(l);
    if (!wk(l) && ce(f))
      return Promise.all([H6(l, f), V6(l, f)]).then();
  })(o, s).then(((i) => {
    const l = () => {
      i._skinLoaded = !0, ((f) => {
        f.dispatch("SkinLoaded");
      })(i);
    };
    return () => {
      i.initialized ? l() : i.on("init", l);
    };
  })(s), ((i, l) => () => ((f, m) => {
    f.dispatch("SkinLoadError", m);
  })(i, { message: "Skin could not be loaded" }))(s)), U6 = We(I4, !1), j6 = We(I4, !0), nv = (o, s, i) => o.translate([s, o.translate(i)]), SD = (o, s) => {
    const i = (m, b, x, w) => {
      const E = o.shared.providers.translate(m.title);
      if (m.type === "separator")
        return M.some({ type: "separator", text: E });
      if (m.type === "submenu") {
        const O = Qr(m.getStyleItems(), (A) => l(A, b, w));
        return b === 0 && O.length <= 0 ? M.none() : M.some({ type: "nestedmenuitem", text: E, enabled: O.length > 0, getSubmenuItems: () => Qr(m.getStyleItems(), (A) => l(A, b, w)) });
      }
      return M.some({ type: "togglemenuitem", text: E, icon: m.icon, active: m.isSelected(w), enabled: !x, onAction: s.onAction(m), ...m.getStylePreview().fold(() => ({}), (O) => ({ meta: { style: O } })) });
    }, l = (m, b, x) => {
      const w = m.type === "formatter" && s.isInvalid(m);
      return b === 0 ? w ? [] : i(m, b, !1, x).toArray() : i(m, b, w, x).toArray();
    }, f = (m) => {
      const b = s.getCurrentValue(), x = s.shouldHide ? 0 : 1;
      return Qr(m, (w) => l(w, x, b));
    };
    return { validateItems: f, getFetch: (m, b) => (x, w) => {
      const E = b(), O = f(E);
      w(R1(O, Tm.CLOSE_ON_EXECUTE, m, { isHorizontalMenu: !1, search: M.none() }));
    } };
  }, ov = (o, s, i) => {
    const l = i.dataset, f = l.type === "basic" ? () => Ct(l.data, (m) => L_(m, i.isSelectedFor, i.getPreviewFor)) : l.getData;
    return { items: SD(s, i), getStyleItems: f };
  }, Vx = (o, s, i, l, f) => {
    const { items: m, getStyleItems: b } = ov(0, s, i);
    return w_({ text: i.icon.isSome() ? M.none() : i.text, icon: i.icon, tooltip: M.from(i.tooltip), role: M.none(), fetch: m.getFetch(s, b), onSetup: (x) => {
      const w = (E) => x.setTooltip(nv(o, l, E.value));
      return o.on(f, w), Fk(oy(o, "NodeChange", (E) => {
        const O = E.getComponent();
        i.updateText(O), Xn.set(E.getComponent(), !o.selection.isEditable());
      })(x), () => o.off(f, w));
    }, getApi: (x) => ({ getComponent: Ee(x), setTooltip: (w) => {
      const E = s.shared.providers.translate(w);
      gi(x.element, { "aria-label": E, title: E });
    } }), columns: 1, presets: "normal", classes: i.icon.isSome() ? [] : ["bespoke"], dropdownBehaviours: [] }, "tox-tbtn", s.shared);
  };
  var rv;
  (function(o) {
    o[o.SemiColon = 0] = "SemiColon", o[o.Space = 1] = "Space";
  })(rv || (rv = {}));
  const F4 = (o, s, i) => {
    const l = (f = ((m, b) => b === rv.SemiColon ? m.replace(/;$/, "").split(";") : m.split(" "))(o.options.get(s), i), Ct(f, (m) => {
      let b = m, x = m;
      const w = m.split("=");
      return w.length > 1 && (b = w[0], x = w[1]), { title: b, format: x };
    }));
    var f;
    return { type: "basic", data: l };
  }, $4 = "Alignment {0}", ED = "left", i2 = [{ title: "Left", icon: "align-left", format: "alignleft", command: "JustifyLeft" }, { title: "Center", icon: "align-center", format: "aligncenter", command: "JustifyCenter" }, { title: "Right", icon: "align-right", format: "alignright", command: "JustifyRight" }, { title: "Justify", icon: "align-justify", format: "alignjustify", command: "JustifyFull" }], TD = (o) => {
    const s = { type: "basic", data: i2 };
    return { tooltip: nv(o, $4, ED), text: M.none(), icon: M.some("align-left"), isSelectedFor: (i) => () => o.formatter.match(i), getCurrentValue: M.none, getPreviewFor: (i) => M.none, onAction: (i) => () => Go(i2, (l) => l.format === i.format).each((l) => o.execCommand(l.command)), updateText: (i) => {
      const l = Go(i2, (f) => o.formatter.match(f.format)).fold(Ee(ED), (f) => f.title.toLowerCase());
      pn(i, D1, { icon: `align-${l}` }), ((f, m) => {
        f.dispatch("AlignTextUpdate", m);
      })(o, { value: l });
    }, dataset: s, shouldHide: !1, isInvalid: (i) => !o.formatter.canApply(i.format) };
  }, H4 = (o, s) => {
    const i = s(), l = Ct(i, (f) => f.format);
    return M.from(o.formatter.closest(l)).bind((f) => Go(i, (m) => m.format === f)).orThunk(() => mi(o.formatter.match("p"), { title: "Paragraph", format: "p" }));
  }, zD = "Block {0}", V4 = "Paragraph", OD = (o) => {
    const s = F4(o, "block_formats", rv.SemiColon);
    return { tooltip: nv(o, zD, V4), text: M.some(V4), icon: M.none(), isSelectedFor: (i) => () => o.formatter.match(i), getCurrentValue: M.none, getPreviewFor: (i) => () => {
      const l = o.formatter.get(i);
      return l ? M.some({ tag: l.length > 0 && (l[0].inline || l[0].block) || "div", styles: o.dom.parseStyle(o.formatter.getCssText(i)) }) : M.none();
    }, onAction: WS(o), updateText: (i) => {
      const l = H4(o, () => s.data).fold(Ee(V4), (f) => f.title);
      pn(i, Am, { text: l }), ((f, m) => {
        f.dispatch("BlocksTextUpdate", m);
      })(o, { value: l });
    }, dataset: s, shouldHide: !1, isInvalid: (i) => !o.formatter.canApply(i.format) };
  }, AD = "Font {0}", U4 = "System Font", Z6 = ["-apple-system", "Segoe UI", "Roboto", "Helvetica Neue", "sans-serif"], DD = (o) => {
    const s = o.split(/\s*,\s*/);
    return Ct(s, (i) => i.replace(/^['"]+|['"]+$/g, ""));
  }, RD = (o, s) => s.length > 0 && nc(s, (i) => o.indexOf(i.toLowerCase()) > -1), ND = (o) => {
    const s = () => {
      const l = (E) => E ? DD(E)[0] : "", f = o.queryCommandValue("FontName"), m = i.data, b = f ? f.toLowerCase() : "", x = ez(o);
      return { matchOpt: Go(m, (E) => {
        const O = E.format;
        return O.toLowerCase() === b || l(O).toLowerCase() === l(b).toLowerCase();
      }).orThunk(() => mi(((E, O) => {
        if (E.indexOf("-apple-system") === 0 || O.length > 0) {
          const A = DD(E.toLowerCase());
          return RD(A, Z6) || RD(A, O);
        }
        return !1;
      })(b, x), { title: U4, format: b })), font: f };
    }, i = F4(o, "font_family_formats", rv.SemiColon);
    return { tooltip: nv(o, AD, U4), text: M.some(U4), icon: M.none(), isSelectedFor: (l) => (f) => f.exists((m) => m.format === l), getCurrentValue: () => {
      const { matchOpt: l } = s();
      return l;
    }, getPreviewFor: (l) => () => M.some({ tag: "div", styles: l.indexOf("dings") === -1 ? { "font-family": l } : {} }), onAction: (l) => () => {
      o.undoManager.transact(() => {
        o.focus(), o.execCommand("FontName", !1, l.format);
      });
    }, updateText: (l) => {
      const { matchOpt: f, font: m } = s(), b = f.fold(Ee(m), (x) => x.title);
      pn(l, Am, { text: b }), ((x, w) => {
        x.dispatch("FontFamilyTextUpdate", w);
      })(o, { value: b });
    }, dataset: i, shouldHide: !1, isInvalid: Xe };
  }, W6 = { unsupportedLength: ["em", "ex", "cap", "ch", "ic", "rem", "lh", "rlh", "vw", "vh", "vi", "vb", "vmin", "vmax", "cm", "mm", "Q", "in", "pc", "pt", "px"], fixed: ["px", "pt"], relative: ["%"], empty: [""] }, q6 = (() => {
    const o = "[0-9]+", s = "[eE][+-]?" + o, i = (f) => `(?:${f})?`, l = ["Infinity", o + "\\." + i(o) + i(s), "\\." + o + i(s), o + i(s)].join("|");
    return new RegExp(`^([+-]?(?:${l}))(.*)$`);
  })(), l2 = (o, s) => M.from(q6.exec(o)).bind((i) => {
    const l = Number(i[1]), f = i[2];
    return ((m, b) => jr(b, (x) => jr(W6[x], (w) => m === w)))(f, s) ? M.some({ value: l, unit: f }) : M.none();
  }), j4 = { tab: Ee(9), escape: Ee(27), enter: Ee(13), backspace: Ee(8), delete: Ee(46), left: Ee(37), up: Ee(38), right: Ee(39), down: Ee(40), space: Ee(32), home: Ee(36), end: Ee(35), pageUp: Ee(33), pageDown: Ee(34) }, MD = "Font size {0}", BD = "12pt", G6 = { "8pt": "1", "10pt": "2", "12pt": "3", "14pt": "4", "18pt": "5", "24pt": "6", "36pt": "7" }, K6 = { "xx-small": "7pt", "x-small": "8pt", small: "10pt", medium: "12pt", large: "14pt", "x-large": "18pt", "xx-large": "24pt" }, Y6 = (o, s) => /[0-9.]+px$/.test(o) ? ((i, l) => {
    const f = Math.pow(10, l);
    return Math.round(i * f) / f;
  })(72 * parseInt(o, 10) / 96, s || 0) + "pt" : cn(K6, o).getOr(o), Z4 = (o) => cn(G6, o).getOr(""), LD = (o) => {
    const s = () => {
      let f = M.none();
      const m = l.data, b = o.queryCommandValue("FontSize");
      if (b)
        for (let x = 3; f.isNone() && x >= 0; x--) {
          const w = Y6(b, x), E = Z4(w);
          f = Go(m, (O) => O.format === b || O.format === w || O.format === E);
        }
      return { matchOpt: f, size: b };
    }, i = Ee(M.none), l = F4(o, "font_size_formats", rv.Space);
    return { tooltip: nv(o, MD, BD), text: M.some(BD), icon: M.none(), isSelectedFor: (f) => (m) => m.exists((b) => b.format === f), getPreviewFor: i, getCurrentValue: () => {
      const { matchOpt: f } = s();
      return f;
    }, onAction: (f) => () => {
      o.undoManager.transact(() => {
        o.focus(), o.execCommand("FontSize", !1, f.format);
      });
    }, updateText: (f) => {
      const { matchOpt: m, size: b } = s(), x = m.fold(Ee(b), (w) => w.title);
      pn(f, Am, { text: x }), ((w, E) => {
        w.dispatch("FontSizeTextUpdate", E);
      })(o, { value: x });
    }, dataset: l, shouldHide: !1, isInvalid: Xe };
  }, PD = "Format {0}", ID = (o, s) => {
    const i = "Paragraph";
    return { tooltip: nv(o, PD, i), text: M.some(i), icon: M.none(), isSelectedFor: (l) => () => o.formatter.match(l), getCurrentValue: M.none, getPreviewFor: (l) => () => {
      const f = o.formatter.get(l);
      return f !== void 0 ? M.some({ tag: f.length > 0 && (f[0].inline || f[0].block) || "div", styles: o.dom.parseStyle(o.formatter.getCssText(l)) }) : M.none();
    }, onAction: WS(o), updateText: (l) => {
      const f = (x) => zA(x) ? Qr(x.items, f) : by(x) ? [{ title: x.title, format: x.format }] : [], m = Qr(B_(o), f), b = H4(o, Ee(m)).fold(Ee(i), (x) => x.title);
      pn(l, Am, { text: b }), ((x, w) => {
        x.dispatch("StylesTextUpdate", w);
      })(o, { value: b });
    }, shouldHide: eS(o), isInvalid: (l) => !o.formatter.canApply(l.format), dataset: s };
  }, FD = Ee([st("toggleClass"), st("fetch"), bd("onExecute"), He("getHotspot", M.some), He("getAnchorOverrides", Ee({})), ym(), bd("onItemExecute"), pr("lazySink"), st("dom"), Vo("onOpen"), pa("splitDropdownBehaviours", [Qa, Jt, io]), He("matchWidth", !1), He("useMinWidth", !1), He("eventOrder", {}), pr("role")].concat(aE())), $D = Lt({ factory: bc, schema: [st("dom")], name: "arrow", defaults: () => ({ buttonBehaviours: $t([io.revoke()]) }), overrides: (o) => ({ dom: { tag: "span", attributes: { role: "presentation" } }, action: (s) => {
    s.getSystem().getByUid(o.uid).each(Kd);
  }, buttonBehaviours: $t([Lo.config({ toggleOnExecute: !1, toggleClass: o.toggleClass })]) }) }), X6 = Lt({ factory: bc, schema: [st("dom")], name: "button", defaults: () => ({ buttonBehaviours: $t([io.revoke()]) }), overrides: (o) => ({ dom: { tag: "span", attributes: { role: "presentation" } }, action: (s) => {
    s.getSystem().getByUid(o.uid).each((i) => {
      o.onExecute(i, s);
    });
  } }) }), J6 = Ee([$D, X6, rn({ factory: { sketch: (o) => ({ uid: o.uid, dom: { tag: "span", styles: { display: "none" }, attributes: { "aria-hidden": "true" }, innerHtml: o.text } }) }, schema: [st("text")], name: "aria-descriptor" }), Vt({ schema: [hg()], name: "menu", defaults: (o) => ({ onExecute: (s, i) => {
    s.getSystem().getByUid(o.uid).each((l) => {
      o.onItemExecute(l, s, i);
    });
  } }) }), nO()]), Ux = hc({ name: "SplitDropdown", configFields: FD(), partFields: J6(), factory: (o, s, i, l) => {
    const f = (E) => {
      rr.getCurrent(E).each((O) => {
        mr.highlightFirst(O), Jt.focusIn(O);
      });
    }, m = (E) => {
      x1(o, wt, E, l, f, cu.HighlightMenuAndItem).get(gt);
    }, b = (E) => {
      const O = ii(E, o, "button");
      return Kd(O), M.some(!0);
    }, x = { ...Bo([ss((E, O) => {
      Dn(E, o, "aria-descriptor").each((A) => {
        const B = hn("aria");
        eo(A.element, "id", B), eo(E.element, "aria-describedby", B);
      });
    })]), ...Pv(M.some(m)) }, w = { repositionMenus: (E) => {
      Lo.isOn(E) && oO(E);
    } };
    return { uid: o.uid, dom: o.dom, components: s, apis: w, eventOrder: { ...o.eventOrder, [gl()]: ["disabling", "toggling", "alloy.base.behaviour"] }, events: x, behaviours: Fi(o.splitDropdownBehaviours, [Qa.config({ others: { sandbox: (E) => {
      const O = ii(E, o, "arrow");
      return Kk(o, E, { onOpen: () => {
        Lo.on(O), Lo.on(E);
      }, onClose: () => {
        Lo.off(O), Lo.off(E);
      } });
    } } }), Jt.config({ mode: "special", onSpace: b, onEnter: b, onDown: (E) => (m(E), M.some(!0)) }), io.config({}), Lo.config({ toggleOnExecute: !1, aria: { mode: "expanded" } })]), domModification: { attributes: { role: o.role.getOr("button"), "aria-haspopup": !0 } } };
  }, apis: { repositionMenus: (o, s) => o.repositionMenus(s) } }), HD = (o) => ({ isEnabled: () => !Xn.isDisabled(o), setEnabled: (s) => Xn.set(o, !s), setText: (s) => pn(o, Am, { text: s }), setIcon: (s) => pn(o, D1, { icon: s }) }), Q6 = (o) => ({ setActive: (s) => {
    Lo.set(o, s);
  }, isActive: () => Lo.isOn(o), isEnabled: () => !Xn.isDisabled(o), setEnabled: (s) => Xn.set(o, !s), setText: (s) => pn(o, Am, { text: s }), setIcon: (s) => pn(o, D1, { icon: s }) }), VD = (o, s) => o.map((i) => ({ "aria-label": s.translate(i), title: s.translate(i) })).getOr({}), UD = hn("focus-button"), W4 = (o, s, i, l, f) => {
    const m = s.map((x) => Ur(FE(x, "tox-tbtn", f))), b = o.map((x) => Ur(bp(x, f.icons)));
    return { dom: { tag: "button", classes: ["tox-tbtn"].concat(s.isSome() ? ["tox-tbtn--select"] : []), attributes: VD(i, f) }, components: B0([b.map((x) => x.asSpec()), m.map((x) => x.asSpec())]), eventOrder: { [da()]: ["focusing", "alloy.base.behaviour", A1], [At()]: [A1, "toolbar-group-button-events"] }, buttonBehaviours: $t([MS(f.isDisabled), il(), wo(A1, [ss((x, w) => v_(x)), ft(Am, (x, w) => {
      m.bind((E) => E.getOpt(x)).each((E) => {
        Jn.set(E, [Os(f.translate(w.event.text))]);
      });
    }), ft(D1, (x, w) => {
      b.bind((E) => E.getOpt(x)).each((E) => {
        Jn.set(E, [bp(w.event.icon, f.icons)]);
      });
    }), ft(da(), (x, w) => {
      w.event.prevent(), Io(x, UD);
    })])].concat(l.getOr([]))) };
  }, jD = (o, s, i) => {
    var l;
    const f = Ln(gt), m = W4(o.icon, o.text, o.tooltip, M.none(), i);
    return bc.sketch({ dom: m.dom, components: m.components, eventOrder: IE, buttonBehaviours: { ...$t([wo("toolbar-button-events", [(b = { onAction: o.onAction, getApi: s.getApi }, hl((x, w) => {
      Qv(b, x)((E) => {
        pn(x, KO, { buttonApi: E }), b.onAction(E);
      });
    })), Ih(s, f), Fh(s, f)]), MS(() => !o.enabled || i.isDisabled()), il()].concat(s.toolbarButtonBehaviours)), [A1]: (l = m.buttonBehaviours) === null || l === void 0 ? void 0 : l[A1] } });
    var b;
  }, jx = (o, s, i) => jD(o, { toolbarButtonBehaviours: i.length > 0 ? [wo("toolbarButtonWith", i)] : [], getApi: HD, onSetup: o.onSetup }, s), ZD = (o, s, i) => jD(o, { toolbarButtonBehaviours: [Jn.config({}), Lo.config({ toggleClass: "tox-tbtn--enabled", aria: { mode: "pressed" }, toggleOnExecute: !1 })].concat(i.length > 0 ? [wo("toolbarToggleButtonWith", i)] : []), getApi: Q6, onSetup: o.onSetup }, s), c2 = (o, s, i) => (l) => sy((f) => s.fetch(f)).map((f) => M.from(cE(be(Wk(hn("menu-value"), f, (m) => {
    s.onItemAction(o(l), m);
  }, s.columns, s.presets, Tm.CLOSE_ON_EXECUTE, s.select.getOr(Xe), i), { movement: qk(s.columns, s.presets), menuBehaviours: v1(s.columns !== "auto" ? [] : [ss((m, b) => {
    N0(m, 4, lz(s.presets)).each(({ numRows: x, numColumns: w }) => {
      Jt.setGridSize(m, x, w);
    });
  })]) })))), eL = [{ name: "history", items: ["undo", "redo"] }, { name: "ai", items: ["aidialog", "aishortcuts"] }, { name: "styles", items: ["styles"] }, { name: "formatting", items: ["bold", "italic"] }, { name: "alignment", items: ["alignleft", "aligncenter", "alignright", "alignjustify"] }, { name: "indentation", items: ["outdent", "indent"] }, { name: "permanent pen", items: ["permanentpen"] }, { name: "comments", items: ["addcomment"] }], Zx = (o, s) => (i, l, f) => {
    const m = o(i).mapError((b) => nu(b)).getOrDie();
    return s(m, l, f);
  }, tL = { button: Zx(yz, (o, s) => {
    return i = o, l = s.shared.providers, jx(i, l, []);
    var i, l;
  }), togglebutton: Zx(TS, (o, s) => {
    return i = o, l = s.shared.providers, ZD(i, l, []);
    var i, l;
  }), menubutton: Zx(C4, (o, s) => zx(o, "tox-tbtn", s, M.none(), !1)), splitbutton: Zx((o) => Gr("SplitButton", f6, o), (o, s) => ((i, l) => {
    const f = (x) => ({ isEnabled: () => !Xn.isDisabled(x), setEnabled: (w) => Xn.set(x, !w), setIconFill: (w, E) => {
      fa(x.element, `svg path[class="${w}"], rect[class="${w}"]`).each((O) => {
        eo(O, "fill", E);
      });
    }, setActive: (w) => {
      eo(x.element, "aria-pressed", w), fa(x.element, "span").each((E) => {
        x.getSystem().getByDom(E).each((O) => Lo.set(O, w));
      });
    }, isActive: () => fa(x.element, "span").exists((w) => x.getSystem().getByDom(w).exists(Lo.isOn)), setText: (w) => fa(x.element, "span").each((E) => x.getSystem().getByDom(E).each((O) => pn(O, Am, { text: w }))), setIcon: (w) => fa(x.element, "span").each((E) => x.getSystem().getByDom(E).each((O) => pn(O, D1, { icon: w }))), setTooltip: (w) => {
      const E = l.providers.translate(w);
      gi(x.element, { "aria-label": E, title: E });
    } }), m = Ln(gt), b = { getApi: f, onSetup: i.onSetup };
    return Ux.sketch({ dom: { tag: "div", classes: ["tox-split-button"], attributes: { "aria-pressed": !1, ...VD(i.tooltip, l.providers) } }, onExecute: (x) => {
      const w = f(x);
      w.isEnabled() && i.onAction(w);
    }, onItemExecute: (x, w, E) => {
    }, splitDropdownBehaviours: $t([Bk(l.providers.isDisabled), il(), wo("split-dropdown-events", [ss((x, w) => v_(x)), ft(UD, io.focus), Ih(b, m), Fh(b, m)]), px.config({})]), eventOrder: { [At()]: ["alloy.base.behaviour", "split-dropdown-events"] }, toggleClass: "tox-tbtn--enabled", lazySink: l.getSink, fetch: c2(f, i, l.providers), parts: { menu: Zv(0, i.columns, i.presets) }, components: [Ux.parts.button(W4(i.icon, i.text, M.none(), M.some([Lo.config({ toggleClass: "tox-tbtn--enabled", toggleOnExecute: !1 })]), l.providers)), Ux.parts.arrow({ dom: { tag: "button", classes: ["tox-tbtn", "tox-split-button__chevron"], innerHtml: KC("chevron-down", l.providers.icons) }, buttonBehaviours: $t([Bk(l.providers.isDisabled), il(), gk()]) }), Ux.parts["aria-descriptor"]({ text: l.providers.translate("To open the popup, press Shift+Enter") })] });
  })(o, s.shared)), grouptoolbarbutton: Zx((o) => Gr("GroupToolbarButton", u6, o), (o, s, i) => {
    const l = i.ui.registry.getAll().buttons, f = { [Ja]: s.shared.header.isPositionedAtTop() ? Gl.TopToBottom : Gl.BottomToTop };
    if (k0(i) === Zf.floating)
      return ((m, b, x, w) => {
        const E = b.shared, O = Ln(gt), A = { toolbarButtonBehaviours: [], getApi: HD, onSetup: m.onSetup }, B = [wo("toolbar-group-button-events", [Ih(A, O), Fh(A, O)])];
        return Yp.sketch({ lazySink: E.getSink, fetch: () => sy(($) => {
          $(Ct(x(m.items), s2));
        }), markers: { toggledClass: "tox-tbtn--enabled" }, parts: { button: W4(m.icon, m.text, m.tooltip, M.some(B), E.providers), toolbar: { dom: { tag: "div", classes: ["tox-toolbar__overflow"], attributes: w } } } });
      })(o, s, (m) => q4(i, { buttons: l, toolbar: m, allowToolbarGroups: !1 }, s, M.none()), f);
    throw new Error("Toolbar groups are only supported when using floating toolbar mode");
  }) }, WD = { styles: (o, s) => {
    const i = { type: "advanced", ...s.styles };
    return Vx(o, s, ID(o, i), PD, "StylesTextUpdate");
  }, fontsize: (o, s) => Vx(o, s, LD(o), MD, "FontSizeTextUpdate"), fontsizeinput: (o, s) => ((i, l, f) => {
    let m = M.none();
    const b = oy(i, "NodeChange SwitchMode", (J) => {
      const le = J.getComponent();
      m = M.some(le), f.updateInputValue(le), Xn.set(le, !i.selection.isEditable());
    }), x = (J) => ({ getComponent: Ee(J) }), w = Ln(gt), E = hn("custom-number-input-events"), O = (J, le, me) => {
      const ke = m.map((St) => ln.getValue(St)).getOr(""), Re = f.getNewValue(ke, J), qe = ke.length - `${Re}`.length, mt = m.map((St) => St.element.dom.selectionStart - qe), bt = m.map((St) => St.element.dom.selectionEnd - qe);
      f.onAction(Re, me), m.each((St) => {
        ln.setValue(St, Re), le && (mt.each((Qt) => St.element.dom.selectionStart = Qt), bt.each((Qt) => St.element.dom.selectionEnd = Qt));
      });
    }, A = (J, le) => O((me, ke) => me - ke, J, le), B = (J, le) => O((me, ke) => me + ke, J, le), $ = (J) => sa(J.element).fold(M.none, (le) => (gc(le), M.some(!0))), Z = (J) => mm(J.element) ? (El(J.element).each((le) => gc(le)), M.some(!0)) : M.none(), oe = (J, le, me, ke) => {
      const Re = Ln(gt), qe = l.shared.providers.translate(me), mt = hn("altExecuting"), bt = oy(i, "NodeChange SwitchMode", (Qt) => {
        Xn.set(Qt.getComponent(), !i.selection.isEditable());
      }), St = (Qt) => {
        Xn.isDisabled(Qt) || J(!0);
      };
      return bc.sketch({ dom: { tag: "button", attributes: { title: qe, "aria-label": qe }, classes: ke.concat(le) }, components: [x_(le, l.shared.providers.icons)], buttonBehaviours: $t([Xn.config({}), wo(mt, [Ih({ onSetup: bt, getApi: x }, Re), Fh({ getApi: x }, Re), ft(bn(), (Qt, vn) => {
        vn.event.raw.keyCode !== j4.space() && vn.event.raw.keyCode !== j4.enter() || Xn.isDisabled(Qt) || J(!1);
      }), ft(yr(), St), ft(Ac(), St)])]), eventOrder: { [bn()]: [mt, "keying"], [yr()]: [mt, "alloy.base.behaviour"], [Ac()]: [mt, "alloy.base.behaviour"] } });
    }, re = Ur(oe((J) => A(!1, J), "minus", "Decrease font size", [])), fe = Ur(oe((J) => B(!1, J), "plus", "Increase font size", [])), ee = Ur({ dom: { tag: "div", classes: ["tox-input-wrapper"] }, components: [Yb.sketch({ inputBehaviours: $t([Xn.config({}), wo(E, [Ih({ onSetup: b, getApi: x }, w), Fh({ getApi: x }, w)]), wo("input-update-display-text", [ft(Am, (J, le) => {
      ln.setValue(J, le.event.text);
    }), ft(zt(), (J) => {
      f.onAction(ln.getValue(J));
    }), ft(En(), (J) => {
      f.onAction(ln.getValue(J));
    })]), Jt.config({ mode: "special", onEnter: (J) => (O(wt, !0, !0), M.some(!0)), onEscape: $, onUp: (J) => (B(!0, !1), M.some(!0)), onDown: (J) => (A(!0, !1), M.some(!0)), onLeft: (J, le) => (le.cut(), M.none()), onRight: (J, le) => (le.cut(), M.none()) })]) })], behaviours: $t([io.config({}), Jt.config({ mode: "special", onEnter: Z, onSpace: Z, onEscape: $ }), wo("input-wrapper-events", [ft(_e(), (J) => {
      tn([re, fe], (le) => {
        const me = Xt(le.get(J).element.dom);
        mm(me) && ub(me);
      });
    })])]) });
    return { dom: { tag: "div", classes: ["tox-number-input"] }, components: [re.asSpec(), ee.asSpec(), fe.asSpec()], behaviours: $t([io.config({}), Jt.config({ mode: "flow", focusInside: $b.OnEnterOrSpaceMode, cycles: !1, selector: "button, .tox-input-wrapper", onEscape: (J) => mm(J.element) ? M.none() : (gc(J.element), M.some(!0)) })]) };
  })(o, s, ((i) => {
    const l = () => i.queryCommandValue("FontSize");
    return { updateInputValue: (f) => pn(f, Am, { text: l() }), onAction: (f, m) => i.execCommand("FontSize", !1, f, { skip_focus: !m }), getNewValue: (f, m) => {
      l2(f, ["unsupportedLength", "empty"]);
      const b = l(), x = l2(f, ["unsupportedLength", "empty"]).or(l2(b, ["unsupportedLength", "empty"])), w = x.map(($) => $.value).getOr(16), E = rS(i), O = x.map(($) => $.unit).filter(($) => $ !== "").getOr(E), A = m(w, (($) => {
        var Z;
        return (Z = { em: { step: 0.1 }, cm: { step: 0.1 }, in: { step: 0.1 }, pc: { step: 0.1 }, ch: { step: 0.1 }, rem: { step: 0.1 } }[$]) !== null && Z !== void 0 ? Z : { step: 1 };
      })(O).step), B = `${(($) => $ >= 0)(A) ? A : w}${O}`;
      return B !== b && (($, Z) => {
        $.dispatch("FontSizeInputTextUpdate", Z);
      })(i, { value: B }), B;
    } };
  })(o)), fontfamily: (o, s) => Vx(o, s, ND(o), AD, "FontFamilyTextUpdate"), blocks: (o, s) => Vx(o, s, OD(o), zD, "BlocksTextUpdate"), align: (o, s) => Vx(o, s, TD(o), $4, "AlignTextUpdate") }, q4 = (o, s, i, l) => {
    const f = ((b) => {
      const x = b.toolbar, w = b.buttons;
      return x === !1 ? [] : x === void 0 || x === !0 ? ((E) => {
        const O = Ct(eL, (A) => {
          const B = Pn(A.items, ($) => _n(E, $) || _n(WD, $));
          return { name: A.name, items: B };
        });
        return Pn(O, (A) => A.items.length > 0);
      })(w) : ce(x) ? ((E) => {
        const O = E.split("|");
        return Ct(O, (A) => ({ items: A.trim().split(" ") }));
      })(x) : ((E) => Gt(E, (O) => _n(O, "name") && _n(O, "items")))(x) ? x : (console.error("Toolbar type should be string, string[], boolean or ToolbarGroup[]"), []);
    })(s), m = Ct(f, (b) => {
      const x = Qr(b.items, (w) => w.trim().length === 0 ? [] : ((E, O, A, B, $, Z) => cn(O, A.toLowerCase()).orThunk(() => Z.bind((oe) => Ko(oe, (re) => cn(O, re + A.toLowerCase())))).fold(() => cn(WD, A.toLowerCase()).map((oe) => oe(E, $)), (oe) => oe.type !== "grouptoolbarbutton" || B ? ((re, fe, ee) => cn(tL, re.type).fold(() => (console.error("skipping button defined by", re), M.none()), (J) => M.some(J(re, fe, ee))))(oe, $, E) : (console.warn(`Ignoring the '${A}' toolbar button. Group toolbar buttons are only supported when using floating toolbar mode and cannot be nested.`), M.none())))(o, s.buttons, w, s.allowToolbarGroups, i, l).toArray());
      return { title: M.from(o.translate(b.name)), items: x };
    });
    return Pn(m, (b) => b.items.length > 0);
  }, Wx = (o, s, i, l) => {
    const f = s.mainUi.outerContainer, m = i.toolbar, b = i.buttons;
    if (Gt(m, ce)) {
      const x = m.map((w) => {
        const E = { toolbar: w, buttons: b, allowToolbarGroups: i.allowToolbarGroups };
        return q4(o, E, l, M.none());
      });
      Rs.setToolbars(f, x);
    } else
      Rs.setToolbar(f, q4(o, i, l, M.none()));
  }, N1 = Ic(), qD = N1.os.isiOS() && N1.os.version.major <= 12;
  var GD = Object.freeze({ __proto__: null, render: (o, s, i, l, f) => {
    const { mainUi: m, uiMotherships: b } = s, x = Ln(0), w = m.outerContainer;
    U6(o);
    const E = Xt(f.targetNode), O = Ma(us(E));
    ip(E, m.mothership), ((Z, oe, re) => {
      b1(Z) && ip(re.mainUi.mothership.element, re.popupUi.mothership), Eh(oe, re.dialogUi.mothership);
    })(o, O, s), o.on("SkinLoaded", () => {
      Rs.setSidebar(w, i.sidebar, QT(o)), Wx(o, s, i, l), x.set(o.getWin().innerWidth), Rs.setMenubar(w, CD(o, i)), Rs.setViews(w, i.views), ((Z, oe) => {
        const { uiMotherships: re } = oe, fe = Z.dom;
        let ee = Z.getWin();
        const J = Z.getDoc().documentElement, le = Ln(so(ee.innerWidth, ee.innerHeight)), me = Ln(so(J.offsetWidth, J.offsetHeight)), ke = () => {
          const bt = le.get();
          bt.left === ee.innerWidth && bt.top === ee.innerHeight || (le.set(so(ee.innerWidth, ee.innerHeight)), Ik(Z));
        }, Re = () => {
          const bt = Z.getDoc().documentElement, St = me.get();
          St.left === bt.offsetWidth && St.top === bt.offsetHeight || (me.set(so(bt.offsetWidth, bt.offsetHeight)), Ik(Z));
        }, qe = (bt) => {
          ((St, Qt) => {
            St.dispatch("ScrollContent", Qt);
          })(Z, bt);
        };
        fe.bind(ee, "resize", ke), fe.bind(ee, "scroll", qe);
        const mt = kg(Xt(Z.getBody()), "load", Re);
        Z.on("hide", () => {
          tn(re, (bt) => {
            qn(bt.element, "display", "none");
          });
        }), Z.on("show", () => {
          tn(re, (bt) => {
            ar(bt.element, "display");
          });
        }), Z.on("NodeChange", Re), Z.on("remove", () => {
          mt.unbind(), fe.unbind(ee, "resize", ke), fe.unbind(ee, "scroll", qe), ee = null;
        });
      })(o, s);
    });
    const A = Rs.getSocket(w).getOrDie("Could not find expected socket element");
    if (qD) {
      ac(A.element, { overflow: "scroll", "-webkit-overflow-scrolling": "touch" });
      const Z = ((re, fe) => {
        let ee = null;
        return { cancel: () => {
          Ze(ee) || (clearTimeout(ee), ee = null);
        }, throttle: (...J) => {
          Ze(ee) && (ee = setTimeout(() => {
            ee = null, re.apply(null, J);
          }, 20));
        } };
      })(() => {
        o.dispatch("ScrollContent");
      }), oe = sl(A.element, "scroll", Z.throttle);
      o.on("remove", oe.unbind);
    }
    ty(o, s), o.addCommand("ToggleSidebar", (Z, oe) => {
      Rs.toggleSidebar(w, oe), o.dispatch("ToggleSidebar");
    }), o.addQueryValueHandler("ToggleSidebar", () => {
      var Z;
      return (Z = Rs.whichSidebar(w)) !== null && Z !== void 0 ? Z : "";
    }), o.addCommand("ToggleView", (Z, oe) => {
      if (Rs.toggleView(w, oe)) {
        const re = w.element;
        m.mothership.broadcastOn([Pl()], { target: re }), tn(b, (fe) => {
          fe.broadcastOn([Pl()], { target: re });
        }), Ze(Rs.whichView(w)) && (o.focus(), o.nodeChanged(), Rs.refreshToolbar(w));
      }
    }), o.addQueryValueHandler("ToggleView", () => {
      var Z;
      return (Z = Rs.whichView(w)) !== null && Z !== void 0 ? Z : "";
    });
    const B = k0(o);
    B !== Zf.sliding && B !== Zf.floating || o.on("ResizeWindow ResizeEditor ResizeContent", () => {
      const Z = o.getWin().innerWidth;
      Z !== x.get() && (Rs.refreshToolbar(s.mainUi.outerContainer), x.set(Z));
    });
    const $ = { setEnabled: (Z) => {
      Mk(s, !Z);
    }, isEnabled: () => !Xn.isDisabled(w) };
    return { iframeContainer: A.element.dom, editorContainer: w.element.dom, api: $ };
  } });
  const G4 = (o) => /^[0-9\.]+(|px)$/i.test("" + o) ? M.some(parseInt("" + o, 10)) : M.none(), K4 = (o) => en(o) ? o + "px" : o, u2 = (o, s, i) => {
    const l = s.filter((m) => o < m), f = i.filter((m) => o > m);
    return l.or(f).getOr(o);
  }, KD = (o) => {
    const s = bk(o), i = XC(o), l = vk(o);
    return G4(s).map((f) => u2(f, i, l));
  }, { ToolbarLocation: Y4, ToolbarMode: YD } = rM, nL = (o, s, i, l, f) => {
    const { mainUi: m, uiMotherships: b } = i, x = Ph.DOM, w = h1(o), E = Uv(o), O = vk(o).or(KD(o)), A = l.shared.header, B = A.isPositionedAtTop, $ = k0(o), Z = $ === YD.sliding || $ === YD.floating, oe = Ln(!1), re = () => oe.get() && !o.removed, fe = (me) => Z ? me.fold(Ee(0), (ke) => ke.components().length > 1 ? Qe(ke.components()[1].element) : 0) : 0, ee = () => {
      tn(b, (me) => {
        me.broadcastOn([Og()], {});
      });
    }, J = (me) => {
      if (!re())
        return;
      w || f.on((Re) => {
        const qe = O.getOrThunk(() => {
          const mt = G4(Ts(Wa(), "margin-left")).getOr(0);
          return Wr(Wa()) - $n(s).left + mt;
        });
        qn(Re.element, "max-width", qe + "px");
      });
      const ke = w ? M.none() : (() => {
        if (w)
          return M.none();
        if ($n(m.outerContainer.element).left + Ba(m.outerContainer.element) >= window.innerWidth - 40 || Xs(m.outerContainer.element, "width").isSome()) {
          qn(m.outerContainer.element, "position", "absolute"), qn(m.outerContainer.element, "left", "0px"), ar(m.outerContainer.element, "width");
          const Re = Ba(m.outerContainer.element);
          return M.some(Re);
        }
        return M.none();
      })();
      Z && Rs.refreshToolbar(m.outerContainer), w || ((Re) => {
        f.on((qe) => {
          const mt = Rs.getToolbar(m.outerContainer), bt = fe(mt), St = va(s), { top: Qt, left: vn } = ((fo, $o) => b1(fo) ? H_($o) : M.none())(o, m.outerContainer.element).fold(() => ({ top: B() ? Math.max(St.y - Qe(qe.element) + bt, 0) : St.bottom, left: St.x }), (fo) => {
            var $o;
            const Hs = va(fo), ga = ($o = fo.dom.scrollTop) !== null && $o !== void 0 ? $o : 0, Xo = tr(fo, Wa()), Fl = Xo ? Math.max(St.y - Qe(qe.element) + bt, 0) : St.y - Hs.y + ga - Qe(qe.element) + bt;
            return { top: B() ? Fl : St.bottom, left: Xo ? St.x : St.x - Hs.x };
          }), Mn = { position: "absolute", left: Math.round(vn) + "px", top: Math.round(Qt) + "px" }, Qn = Re.map((fo) => {
            const $o = Ls(), Hs = window.innerWidth - (vn - $o.left);
            return { width: Math.max(Math.min(fo, Hs), 150) + "px" };
          }).getOr({});
          ac(m.outerContainer.element, { ...Mn, ...Qn });
        });
      })(ke), E && f.on(me), ee();
    }, le = () => !(w || !E || !re()) && f.get().exists((me) => {
      const ke = A.getDockingMode(), Re = ((mt) => {
        switch (tS(o)) {
          case Y4.auto:
            const bt = Rs.getToolbar(m.outerContainer), St = fe(bt), Qt = Qe(mt.element) - St, vn = va(s);
            if (vn.y > Qt)
              return "top";
            {
              const Mn = Md(s), Qn = Math.max(Mn.dom.scrollHeight, Qe(Mn));
              return vn.bottom < Qn - Qt || os().bottom < vn.bottom - Qt ? "bottom" : "top";
            }
          case Y4.bottom:
            return "bottom";
          case Y4.top:
          default:
            return "top";
        }
      })(me);
      return Re !== ke && (qe = Re, f.on((mt) => {
        ei.setModes(mt, [qe]), A.setDockingMode(qe);
        const bt = B() ? Gl.TopToBottom : Gl.BottomToTop;
        eo(mt.element, Ja, bt);
      }), !0);
      var qe;
    });
    return { isVisible: re, isPositionedAtTop: B, show: () => {
      oe.set(!0), qn(m.outerContainer.element, "display", "flex"), x.addClass(o.getBody(), "mce-edit-focus"), tn(b, (me) => {
        ar(me.element, "display");
      }), le(), b1(o) ? J((me) => ei.isDocked(me) ? ei.reset(me) : ei.refresh(me)) : J(ei.refresh);
    }, hide: () => {
      oe.set(!1), qn(m.outerContainer.element, "display", "none"), x.removeClass(o.getBody(), "mce-edit-focus"), tn(b, (me) => {
        qn(me.element, "display", "none");
      });
    }, update: J, updateMode: () => {
      le() && J(ei.reset);
    }, repositionPopups: ee };
  }, XD = (o, s) => {
    const i = va(o);
    return { pos: s ? i.y : i.bottom, bounds: i };
  };
  var oL = Object.freeze({ __proto__: null, render: (o, s, i, l, f) => {
    const { mainUi: m } = s, b = As(), x = Xt(f.targetNode), w = nL(o, x, s, l, b), E = jT(o);
    j6(o);
    const O = () => {
      if (b.isSet())
        return void w.show();
      b.set(Rs.getHeader(m.outerContainer).getOrDie());
      const B = dS(o);
      b1(o) ? (ip(x, m.mothership), ip(x, s.popupUi.mothership)) : Eh(B, m.mothership), Eh(B, s.dialogUi.mothership), Wx(o, s, i, l), Rs.setMenubar(m.outerContainer, CD(o, i)), w.show(), (($, Z, oe, re) => {
        const fe = Ln(XD(Z, oe.isPositionedAtTop())), ee = (ke) => {
          const { pos: Re, bounds: qe } = XD(Z, oe.isPositionedAtTop()), { pos: mt, bounds: bt } = fe.get(), St = qe.height !== bt.height || qe.width !== bt.width;
          fe.set({ pos: Re, bounds: qe }), St && Ik($, ke), oe.isVisible() && (mt !== Re ? oe.update(ei.reset) : St && (oe.updateMode(), oe.repositionPopups()));
        };
        re || ($.on("activate", oe.show), $.on("deactivate", oe.hide)), $.on("SkinLoaded ResizeWindow", () => oe.update(ei.reset)), $.on("NodeChange keydown", (ke) => {
          requestAnimationFrame(() => ee(ke));
        });
        let J = 0;
        const le = _x(() => oe.update(ei.refresh), 33);
        $.on("ScrollWindow", () => {
          const ke = Ls().left;
          ke !== J && (J = ke, le.throttle()), oe.updateMode();
        }), b1($) && $.on("ElementScroll", (ke) => {
          oe.update(ei.refresh);
        });
        const me = Lf();
        me.set(kg(Xt($.getBody()), "load", (ke) => ee(ke.raw))), $.on("remove", () => {
          me.clear();
        });
      })(o, x, w, E), o.nodeChanged();
    };
    o.on("show", O), o.on("hide", w.hide), E || (o.on("focus", O), o.on("blur", w.hide)), o.on("init", () => {
      (o.hasFocus() || E) && O();
    }), ty(o, s);
    const A = { show: O, hide: w.hide, setEnabled: (B) => {
      Mk(s, !B);
    }, isEnabled: () => !Xn.isDisabled(m.outerContainer) };
    return { editorContainer: m.outerContainer.element.dom, api: A };
  } });
  const JD = "contexttoolbar-hide", QD = (o, s) => ft(KO, (i, l) => {
    const f = ((m) => ({ hide: () => Io(m, Tp()), getValue: () => ln.getValue(m) }))(o.get(i));
    s.onAction(f, l.event.buttonApi);
  }), eR = (o, s) => {
    const i = o.label.fold(() => ({}), (m) => ({ "aria-label": m })), l = Ur(Yb.sketch({ inputClasses: ["tox-toolbar-textfield", "tox-toolbar-nav-js"], data: o.initValue(), inputAttributes: i, selectOnFocus: !0, inputBehaviours: $t([Jt.config({ mode: "special", onEnter: (m) => f.findPrimary(m).map((b) => (Kd(b), !0)), onLeft: (m, b) => (b.cut(), M.none()), onRight: (m, b) => (b.cut(), M.none()) })]) })), f = ((m, b, x) => {
      const w = Ct(b, (E) => Ur(((O, A, B) => (($) => $.type === "contextformtogglebutton")(A) ? (($, Z, oe) => {
        const { primary: re, ...fe } = Z.original, ee = ic(TS({ ...fe, type: "togglebutton", onAction: gt }));
        return ZD(ee, oe, [QD($, Z)]);
      })(O, A, B) : (($, Z, oe) => {
        const { primary: re, ...fe } = Z.original, ee = ic(yz({ ...fe, type: "button", onAction: gt }));
        return jx(ee, oe, [QD($, Z)]);
      })(O, A, B))(m, E, x)));
      return { asSpecs: () => Ct(w, (E) => E.asSpec()), findPrimary: (E) => Ko(b, (O, A) => O.primary ? M.from(w[A]).bind((B) => B.getOpt(E)).filter(Cn(Xn.isDisabled)) : M.none()) };
    })(l, o.commands, s);
    return [{ title: M.none(), items: [l.asSpec()] }, { title: M.none(), items: f.asSpecs() }];
  }, M1 = (o, s, i) => s.bottom - o.y >= i && o.bottom - s.y >= i, jh = (o) => {
    const s = ((i) => {
      const l = i.getBoundingClientRect();
      if (l.height <= 0 && l.width <= 0) {
        const f = Lc(Xt(i.startContainer), i.startOffset).element;
        return (Gi(f) ? cl(f) : M.some(f)).filter(ra).map((m) => m.dom.getBoundingClientRect()).getOr(l);
      }
      return l;
    })(o.selection.getRng());
    if (o.inline) {
      const i = Ls();
      return Ws(i.left + s.left, i.top + s.top, s.width, s.height);
    }
    {
      const i = la(Xt(o.getBody()));
      return Ws(i.x + s.left, i.y + s.top, s.width, s.height);
    }
  }, tR = (o, s, i, l = 0) => {
    const f = Qi(window), m = va(Xt(o.getContentAreaContainer())), b = g1(o) || _k(o) || C0(o), { x, width: w } = ((E, O, A) => {
      const B = Math.max(E.x + A, O.x);
      return { x: B, width: Math.min(E.right - A, O.right) - B };
    })(m, f, l);
    if (o.inline && !b)
      return Ws(x, f.y, w, f.height);
    {
      const E = s.header.isPositionedAtTop(), { y: O, bottom: A } = ((B, $, Z, oe, re, fe) => {
        const ee = Xt(B.getContainer()), J = fa(ee, ".tox-editor-header").getOr(ee), le = va(J), me = le.y >= $.bottom, ke = oe && !me;
        if (B.inline && ke)
          return { y: Math.max(le.bottom + fe, Z.y), bottom: Z.bottom };
        if (B.inline && !ke)
          return { y: Z.y, bottom: Math.min(le.y - fe, Z.bottom) };
        const Re = re === "line" ? va(ee) : $;
        return ke ? { y: Math.max(le.bottom + fe, Z.y), bottom: Math.min(Re.bottom - fe, Z.bottom) } : { y: Math.max(Re.y + fe, Z.y), bottom: Math.min(le.y - fe, Z.bottom) };
      })(o, m, f, E, i, l);
      return Ws(x, O, w, A - O);
    }
  }, X4 = { valignCentre: [], alignCentre: [], alignLeft: ["tox-pop--align-left"], alignRight: ["tox-pop--align-right"], right: ["tox-pop--right"], left: ["tox-pop--left"], bottom: ["tox-pop--bottom"], top: ["tox-pop--top"], inset: ["tox-pop--inset"] }, J4 = { maxHeightFunction: Lp(), maxWidthFunction: $x() }, qx = (o) => o === "node", rL = (o, s, i, l, f) => {
    const m = jh(o), b = l.lastElement().exists((x) => tr(i, x));
    return ((x, w) => {
      const E = x.selection.getRng(), O = Lc(Xt(E.startContainer), E.startOffset);
      return E.startContainer === E.endContainer && E.startOffset === E.endOffset - 1 && tr(O.element, w);
    })(o, i) ? b ? Bx : Vi : b ? ((x, w, E) => {
      const O = Xs(x, "position");
      qn(x, "position", w);
      const A = M1(m, va(s), -20) && !l.isReposition() ? Lx : Bx;
      return O.each((B) => qn(x, "position", B)), A;
    })(s, l.getMode()) : (l.getMode() === "fixed" ? f.y + Ls().top : f.y) + (Qe(s) + 12) <= m.y ? Vi : Sd;
  }, Gx = (o, s, i, l) => {
    const f = (b) => (x, w, E, O, A) => ({ ...rL(o, O, b, i, A)({ ...x, y: A.y, height: A.height }, w, E, O, A), alwaysFit: !0 }), m = (b) => qx(l) ? [f(b)] : [];
    return s ? { onLtr: (b) => [ma, Bi, Tr, rl, ps, Zl].concat(m(b)), onRtl: (b) => [ma, Tr, Bi, ps, rl, Zl].concat(m(b)) } : { onLtr: (b) => [Zl, ma, rl, Bi, ps, Tr].concat(m(b)), onRtl: (b) => [Zl, ma, ps, Tr, rl, Bi].concat(m(b)) };
  }, B1 = (o, s) => {
    const i = Pn(s, (m) => m.predicate(o.dom)), { pass: l, fail: f } = oa(i, (m) => m.type === "contexttoolbar");
    return { contextToolbars: l, contextForms: f };
  }, sL = (o, s) => {
    const i = {}, l = [], f = [], m = {}, b = {}, x = po(o);
    return tn(x, (w) => {
      const E = o[w];
      E.type === "contextform" ? ((O, A) => {
        const B = ic(Gr("ContextForm", kM, A));
        i[O] = B, B.launch.map(($) => {
          m["form:" + O] = { ...A.launch, type: $.type === "contextformtogglebutton" ? "togglebutton" : "button", onAction: () => {
            s(B);
          } };
        }), B.scope === "editor" ? f.push(B) : l.push(B), b[O] = B;
      })(w, E) : E.type === "contexttoolbar" && ((O, A) => {
        var B;
        (B = A, Gr("ContextToolbar", OS, B)).each(($) => {
          A.scope === "editor" ? f.push($) : l.push($), b[O] = $;
        });
      })(w, E);
    }), { forms: i, inNodeScope: l, inEditorScope: f, lookupTable: b, formNavigators: m };
  }, nR = hn("forward-slide"), oR = hn("backward-slide"), Q4 = hn("change-slide-event"), e3 = "tox-pop--resizing", t3 = "tox-pop--transition", d2 = (o, s, i, l) => {
    const f = l.backstage, m = f.shared, b = Ic().deviceType.isTouch, x = As(), w = As(), E = As(), O = Nl(((ke) => {
      const Re = Ln([]);
      return Oa.sketch({ dom: { tag: "div", classes: ["tox-pop"] }, fireDismissalEventInstead: { event: "doNotDismissYet" }, onShow: (qe) => {
        Re.set([]), Oa.getContent(qe).each((mt) => {
          ar(mt.element, "visibility");
        }), $s(qe.element, e3), ar(qe.element, "width");
      }, inlineBehaviours: $t([wo("context-toolbar-events", [Xd(Ri(), (qe, mt) => {
        mt.event.raw.propertyName === "width" && ($s(qe.element, e3), ar(qe.element, "width"));
      }), ft(Q4, (qe, mt) => {
        const bt = qe.element;
        ar(bt, "width");
        const St = Wr(bt);
        Oa.setContent(qe, mt.event.contents), vr(bt, e3);
        const Qt = Wr(bt);
        qn(bt, "width", St + "px"), Oa.getContent(qe).each((vn) => {
          mt.event.focus.bind((Mn) => (gc(Mn), iu(bt))).orThunk(() => (Jt.focusIn(vn), Zc(us(bt))));
        }), setTimeout(() => {
          qn(qe.element, "width", Qt + "px");
        }, 0);
      }), ft(nR, (qe, mt) => {
        Oa.getContent(qe).each((bt) => {
          Re.set(Re.get().concat([{ bar: bt, focus: Zc(us(qe.element)) }]));
        }), pn(qe, Q4, { contents: mt.event.forwardContents, focus: M.none() });
      }), ft(oR, (qe, mt) => {
        xn(Re.get()).each((bt) => {
          Re.set(Re.get().slice(0, Re.get().length - 1)), pn(qe, Q4, { contents: Yr(bt.bar), focus: bt.focus });
        });
      })]), Jt.config({ mode: "special", onEscape: (qe) => xn(Re.get()).fold(() => ke.onEscape(), (mt) => (Io(qe, oR), M.some(!0))) })]), lazySink: () => To.value(ke.sink) });
    })({ sink: i, onEscape: () => (o.focus(), M.some(!0)) })), A = () => {
      const ke = E.get().getOr("node"), Re = qx(ke) ? 1 : 0;
      return tR(o, m, ke, Re);
    }, B = () => !(o.removed || b() && f.isContextMenuOpen()), $ = () => {
      if (B()) {
        const ke = A(), Re = Si(E.get(), "node") ? ((qe, mt) => mt.filter((bt) => Rr(bt) && pi(bt)).map(la).getOrThunk(() => jh(qe)))(o, x.get()) : jh(o);
        return ke.height <= 0 || !M1(Re, ke, 0.01);
      }
      return !0;
    }, Z = () => {
      x.clear(), w.clear(), E.clear(), Oa.hide(O);
    }, oe = () => {
      if (Oa.isOpen(O)) {
        const ke = O.element;
        ar(ke, "display"), $() ? qn(ke, "display", "none") : (w.set(0), Oa.reposition(O));
      }
    }, re = (ke) => ({ dom: { tag: "div", classes: ["tox-pop__dialog"] }, components: [ke], behaviours: $t([Jt.config({ mode: "acyclic" }), wo("pop-dialog-wrap-events", [ss((Re) => {
      o.shortcuts.add("ctrl+F9", "focus statusbar", () => Jt.focusIn(Re));
    }), ud((Re) => {
      o.shortcuts.remove("ctrl+F9");
    })])]) }), fe = ml(() => sL(s, (ke) => {
      const Re = ee([ke]);
      pn(O, nR, { forwardContents: re(Re) });
    })), ee = (ke) => {
      const { buttons: Re } = o.ui.registry.getAll(), qe = { ...Re, ...fe().formNavigators }, mt = k0(o) === Zf.scrolling ? Zf.scrolling : Zf.default, bt = er(Ct(ke, (St) => St.type === "contexttoolbar" ? ((Qt, vn) => q4(o, { buttons: Qt, toolbar: vn.items, allowToolbarGroups: !1 }, l.backstage, M.some(["form:"])))(qe, St) : ((Qt, vn) => eR(Qt, vn))(St, m.providers)));
      return yp({ type: mt, uid: hn("context-toolbar"), initGroups: bt, onEscape: M.none, cyclicKeying: !0, providers: m.providers });
    }, J = (ke, Re) => {
      if (me.cancel(), !B())
        return;
      const qe = ee(ke), mt = ke[0].position, bt = ((Qt, vn) => {
        const Mn = Qt === "node" ? m.anchors.node(vn) : m.anchors.cursor(), Qn = ((fo, $o, Hs, ga) => $o === "line" ? { bubble: Ii(12, 0, X4), layouts: { onLtr: () => [Li], onRtl: () => [ph] }, overrides: J4 } : { bubble: Ii(0, 12, X4, 1 / 12), layouts: Gx(fo, Hs, ga, $o), overrides: J4 })(o, Qt, b(), { lastElement: x.get, isReposition: () => Si(w.get(), 0), getMode: () => Ll.getMode(i) });
        return be(Mn, Qn);
      })(mt, Re);
      E.set(mt), w.set(1);
      const St = O.element;
      ar(St, "display"), ((Qt) => Si(fi(Qt, x.get(), tr), !0))(Re) || ($s(St, t3), Ll.reset(i, O)), Oa.showWithinBounds(O, re(qe), { anchor: bt, transition: { classes: [t3], mode: "placement" } }, () => M.some(A())), Re.fold(x.clear, x.set), $() && qn(St, "display", "none");
    };
    let le = !1;
    const me = _x(() => {
      !o.hasFocus() || o.removed || le || (_s(O.element, t3) ? me.throttle() : ((ke, Re) => {
        const qe = Xt(Re.getBody()), mt = (St) => tr(St, qe), bt = Xt(Re.selection.getNode());
        return ((St) => !mt(St) && !Ms(qe, St))(bt) ? M.none() : ((St, Qt, vn) => {
          const Mn = B1(St, Qt);
          if (Mn.contextForms.length > 0)
            return M.some({ elem: St, toolbars: [Mn.contextForms[0]] });
          {
            const Qn = B1(St, vn);
            if (Qn.contextForms.length > 0)
              return M.some({ elem: St, toolbars: [Qn.contextForms[0]] });
            if (Mn.contextToolbars.length > 0 || Qn.contextToolbars.length > 0) {
              const fo = (($o) => {
                if ($o.length <= 1)
                  return $o;
                {
                  const Hs = (go) => jr($o, (ui) => ui.position === go), ga = (go) => Pn($o, (ui) => ui.position === go), Xo = Hs("selection"), Fl = Hs("node");
                  if (Xo || Fl) {
                    if (Fl && Xo) {
                      const go = ga("node"), ui = Ct(ga("selection"), (qs) => ({ ...qs, position: "node" }));
                      return go.concat(ui);
                    }
                    return ga(Xo ? "selection" : "node");
                  }
                  return ga("line");
                }
              })(Mn.contextToolbars.concat(Qn.contextToolbars));
              return M.some({ elem: St, toolbars: fo });
            }
            return M.none();
          }
        })(bt, ke.inNodeScope, ke.inEditorScope).orThunk(() => ((St, Qt, vn) => St(Qt) ? M.none() : zc(Qt, (Mn) => {
          if (ra(Mn)) {
            const { contextToolbars: Qn, contextForms: fo } = B1(Mn, vn.inNodeScope), $o = fo.length > 0 ? fo : ((Hs) => {
              if (Hs.length <= 1)
                return Hs;
              {
                const ga = (Xo) => Go(Hs, (Fl) => Fl.position === Xo);
                return ga("selection").orThunk(() => ga("node")).orThunk(() => ga("line")).map((Xo) => Xo.position).fold(() => [], (Xo) => Pn(Hs, (Fl) => Fl.position === Xo));
              }
            })(Qn);
            return $o.length > 0 ? M.some({ elem: Mn, toolbars: $o }) : M.none();
          }
          return M.none();
        }, St))(mt, bt, ke));
      })(fe(), o).fold(Z, (ke) => {
        J(ke.toolbars, M.some(ke.elem));
      }));
    }, 17);
    o.on("init", () => {
      o.on("remove", Z), o.on("ScrollContent ScrollWindow ObjectResized ResizeEditor longpress", oe), o.on("click keyup focus SetContent", me.throttle), o.on(JD, Z), o.on("contexttoolbar-show", (ke) => {
        const Re = fe();
        cn(Re.lookupTable, ke.toolbarKey).each((qe) => {
          J([qe], mi(ke.target !== o, ke.target)), Oa.getContent(O).each(Jt.focusIn);
        });
      }), o.on("focusout", (ke) => {
        ck.setEditorTimeout(o, () => {
          iu(i.element).isNone() && iu(O.element).isNone() && Z();
        }, 0);
      }), o.on("SwitchMode", () => {
        o.mode.isReadOnly() && Z();
      }), o.on("AfterProgressState", (ke) => {
        ke.state ? Z() : o.hasFocus() && me.throttle();
      }), o.on("dragstart", () => {
        le = !0;
      }), o.on("dragend drop", () => {
        le = !1;
      }), o.on("NodeChange", (ke) => {
        iu(O.element).fold(me.throttle, gt);
      });
    });
  }, rR = (o, s) => {
    const i = () => {
      const l = s.getOptions(o), f = s.getCurrent(o).map(s.hash), m = As();
      return Ct(l, (b) => ({ type: "togglemenuitem", text: s.display(b), onSetup: (x) => {
        const w = (O) => {
          O && (m.on((A) => A.setActive(!1)), m.set(x)), x.setActive(O);
        };
        w(Si(f, s.hash(b)));
        const E = s.watcher(o, b, w);
        return () => {
          m.clear(), E();
        };
      }, onAction: () => s.setCurrent(o, b) }));
    };
    o.ui.registry.addMenuButton(s.name, { tooltip: s.text, icon: s.icon, fetch: (l) => l(i()), onSetup: s.onToolbarSetup }), o.ui.registry.addNestedMenuItem(s.name, { type: "nestedmenuitem", text: s.text, getSubmenuItems: i, onSetup: s.onMenuSetup });
  }, n3 = (o) => {
    rR(o, ((s) => ({ name: "lineheight", text: "Line height", icon: "line-height", getOptions: cS, hash: (i) => ((l, f) => l2(l, ["fixed", "relative", "empty"]).map(({ value: m, unit: b }) => m + b))(i).getOr(i), display: wt, watcher: (i, l, f) => i.formatter.formatChanged("lineheight", f, !1, { value: l }).unbind, getCurrent: (i) => M.from(i.queryCommandValue("LineHeight")), setCurrent: (i, l) => i.execCommand("LineHeight", !1, l), onToolbarSetup: fu(s), onMenuSetup: fu(s) }))(o)), ((s) => M.from(HT(s)).map((i) => ({ name: "language", text: "Language", icon: "language", getOptions: Ee(i), hash: (l) => yt(l.customCode) ? l.code : `${l.code}/${l.customCode}`, display: (l) => l.title, watcher: (l, f, m) => {
      var b;
      return l.formatter.formatChanged("lang", m, !1, { value: f.code, customValue: (b = f.customCode) !== null && b !== void 0 ? b : null }).unbind;
    }, getCurrent: (l) => {
      const f = Xt(l.selection.getNode());
      return lc(f, (m) => M.some(m).filter(ra).bind((b) => Sa(b, "lang").map((x) => ({ code: x, customCode: Sa(b, "data-mce-lang").getOrUndefined(), title: "" }))));
    }, setCurrent: (l, f) => l.execCommand("Lang", !1, f), onToolbarSetup: (l) => {
      const f = Lf();
      return l.setActive(s.formatter.match("lang", {}, void 0, !0)), f.set(s.formatter.formatChanged("lang", l.setActive, !0)), Fk(f.clear, fu(s)(l));
    }, onMenuSetup: fu(s) })))(o).each((s) => rR(o, s));
  }, aL = (o) => oy(o, "NodeChange", (s) => {
    s.setEnabled(o.queryCommandState("outdent") && o.selection.isEditable());
  }), sR = (o, s) => (i) => {
    i.setActive(s.get());
    const l = (f) => {
      s.set(f.state), i.setActive(f.state);
    };
    return o.on("PastePlainTextToggle", l), Fk(() => o.off("PastePlainTextToggle", l), fu(o)(i));
  }, o3 = (o, s) => () => {
    o.execCommand("mceToggleFormat", !1, s);
  }, aR = (o) => {
    ((s) => {
      ((i) => {
        jg.each([{ name: "bold", text: "Bold", icon: "bold" }, { name: "italic", text: "Italic", icon: "italic" }, { name: "underline", text: "Underline", icon: "underline" }, { name: "strikethrough", text: "Strikethrough", icon: "strike-through" }, { name: "subscript", text: "Subscript", icon: "subscript" }, { name: "superscript", text: "Superscript", icon: "superscript" }], (l, f) => {
          i.ui.registry.addToggleButton(l.name, { tooltip: l.text, icon: l.icon, onSetup: $k(i, l.name), onAction: o3(i, l.name) });
        });
        for (let l = 1; l <= 6; l++) {
          const f = "h" + l;
          i.ui.registry.addToggleButton(f, { text: f.toUpperCase(), tooltip: "Heading " + l, onSetup: $k(i, f), onAction: o3(i, f) });
        }
      })(s), ((i) => {
        jg.each([{ name: "copy", text: "Copy", action: "Copy", icon: "copy" }, { name: "help", text: "Help", action: "mceHelp", icon: "help" }, { name: "selectall", text: "Select all", action: "SelectAll", icon: "select-all" }, { name: "newdocument", text: "New document", action: "mceNewDocument", icon: "new-document" }, { name: "print", text: "Print", action: "mcePrint", icon: "print" }], (l) => {
          i.ui.registry.addButton(l.name, { tooltip: l.text, icon: l.icon, onAction: Jl(i, l.action) });
        }), jg.each([{ name: "cut", text: "Cut", action: "Cut", icon: "cut" }, { name: "paste", text: "Paste", action: "Paste", icon: "paste" }, { name: "removeformat", text: "Clear formatting", action: "RemoveFormat", icon: "remove-formatting" }, { name: "remove", text: "Remove", action: "Delete", icon: "remove" }, { name: "hr", text: "Horizontal line", action: "InsertHorizontalRule", icon: "horizontal-rule" }], (l) => {
          i.ui.registry.addButton(l.name, { tooltip: l.text, icon: l.icon, onSetup: fu(i), onAction: Jl(i, l.action) });
        });
      })(s), ((i) => {
        jg.each([{ name: "blockquote", text: "Blockquote", action: "mceBlockQuote", icon: "quote" }], (l) => {
          i.ui.registry.addToggleButton(l.name, { tooltip: l.text, icon: l.icon, onAction: Jl(i, l.action), onSetup: $k(i, l.name) });
        });
      })(s);
    })(o), ((s) => {
      jg.each([{ name: "newdocument", text: "New document", action: "mceNewDocument", icon: "new-document" }, { name: "copy", text: "Copy", action: "Copy", icon: "copy", shortcut: "Meta+C" }, { name: "selectall", text: "Select all", action: "SelectAll", icon: "select-all", shortcut: "Meta+A" }, { name: "print", text: "Print...", action: "mcePrint", icon: "print", shortcut: "Meta+P" }], (i) => {
        s.ui.registry.addMenuItem(i.name, { text: i.text, icon: i.icon, shortcut: i.shortcut, onAction: Jl(s, i.action) });
      }), jg.each([{ name: "bold", text: "Bold", action: "Bold", icon: "bold", shortcut: "Meta+B" }, { name: "italic", text: "Italic", action: "Italic", icon: "italic", shortcut: "Meta+I" }, { name: "underline", text: "Underline", action: "Underline", icon: "underline", shortcut: "Meta+U" }, { name: "strikethrough", text: "Strikethrough", action: "Strikethrough", icon: "strike-through" }, { name: "subscript", text: "Subscript", action: "Subscript", icon: "subscript" }, { name: "superscript", text: "Superscript", action: "Superscript", icon: "superscript" }, { name: "removeformat", text: "Clear formatting", action: "RemoveFormat", icon: "remove-formatting" }, { name: "cut", text: "Cut", action: "Cut", icon: "cut", shortcut: "Meta+X" }, { name: "paste", text: "Paste", action: "Paste", icon: "paste", shortcut: "Meta+V" }, { name: "hr", text: "Horizontal line", action: "InsertHorizontalRule", icon: "horizontal-rule" }], (i) => {
        s.ui.registry.addMenuItem(i.name, { text: i.text, icon: i.icon, shortcut: i.shortcut, onSetup: fu(s), onAction: Jl(s, i.action) });
      }), s.ui.registry.addMenuItem("codeformat", { text: "Code", icon: "sourcecode", onSetup: fu(s), onAction: o3(s, "code") });
    })(o);
  }, f2 = (o, s) => oy(o, "Undo Redo AddUndo TypingUndo ClearUndos SwitchMode", (i) => {
    i.setEnabled(!o.mode.isReadOnly() && o.undoManager[s]());
  }), iL = (o) => oy(o, "VisualAid", (s) => {
    s.setActive(o.hasVisual);
  }), lL = (o, s) => {
    ((i) => {
      tn([{ name: "alignleft", text: "Align left", cmd: "JustifyLeft", icon: "align-left" }, { name: "aligncenter", text: "Align center", cmd: "JustifyCenter", icon: "align-center" }, { name: "alignright", text: "Align right", cmd: "JustifyRight", icon: "align-right" }, { name: "alignjustify", text: "Justify", cmd: "JustifyFull", icon: "align-justify" }], (l) => {
        i.ui.registry.addToggleButton(l.name, { tooltip: l.text, icon: l.icon, onAction: Jl(i, l.cmd), onSetup: $k(i, l.name) });
      }), i.ui.registry.addButton("alignnone", { tooltip: "No alignment", icon: "align-none", onSetup: fu(i), onAction: Jl(i, "JustifyNone") });
    })(o), aR(o), ((i, l) => {
      ((f, m) => {
        const b = ov(0, m, TD(f));
        f.ui.registry.addNestedMenuItem("align", { text: m.shared.providers.translate("Align"), onSetup: fu(f), getSubmenuItems: () => b.items.validateItems(b.getStyleItems()) });
      })(i, l), ((f, m) => {
        const b = ov(0, m, ND(f));
        f.ui.registry.addNestedMenuItem("fontfamily", { text: m.shared.providers.translate("Fonts"), onSetup: fu(f), getSubmenuItems: () => b.items.validateItems(b.getStyleItems()) });
      })(i, l), ((f, m) => {
        const b = { type: "advanced", ...m.styles }, x = ov(0, m, ID(f, b));
        f.ui.registry.addNestedMenuItem("styles", { text: "Formats", onSetup: fu(f), getSubmenuItems: () => x.items.validateItems(x.getStyleItems()) });
      })(i, l), ((f, m) => {
        const b = ov(0, m, OD(f));
        f.ui.registry.addNestedMenuItem("blocks", { text: "Blocks", onSetup: fu(f), getSubmenuItems: () => b.items.validateItems(b.getStyleItems()) });
      })(i, l), ((f, m) => {
        const b = ov(0, m, LD(f));
        f.ui.registry.addNestedMenuItem("fontsize", { text: "Font sizes", onSetup: fu(f), getSubmenuItems: () => b.items.validateItems(b.getStyleItems()) });
      })(i, l);
    })(o, s), ((i) => {
      ((l) => {
        l.ui.registry.addMenuItem("undo", { text: "Undo", icon: "undo", shortcut: "Meta+Z", onSetup: f2(l, "hasUndo"), onAction: Jl(l, "undo") }), l.ui.registry.addMenuItem("redo", { text: "Redo", icon: "redo", shortcut: "Meta+Y", onSetup: f2(l, "hasRedo"), onAction: Jl(l, "redo") });
      })(i), ((l) => {
        l.ui.registry.addButton("undo", { tooltip: "Undo", icon: "undo", enabled: !1, onSetup: f2(l, "hasUndo"), onAction: Jl(l, "undo") }), l.ui.registry.addButton("redo", { tooltip: "Redo", icon: "redo", enabled: !1, onSetup: f2(l, "hasRedo"), onAction: Jl(l, "redo") });
      })(i);
    })(o), ((i) => {
      ((x) => {
        x.addCommand("mceApplyTextcolor", (w, E) => {
          ((O, A, B) => {
            O.undoManager.transact(() => {
              O.focus(), O.formatter.apply(A, { value: B }), O.nodeChanged();
            });
          })(x, w, E);
        }), x.addCommand("mceRemoveTextcolor", (w) => {
          ((E, O) => {
            E.undoManager.transact(() => {
              E.focus(), E.formatter.remove(O, { value: null }, void 0, !0), E.nodeChanged();
            });
          })(x, w);
        });
      })(i);
      const l = qz(i), f = Gz(i), m = Ln(l), b = Ln(f);
      QS(i, "forecolor", "forecolor", m), QS(i, "backcolor", "hilitecolor", b), eE(i, "forecolor", "forecolor", "Text color", m), eE(i, "backcolor", "hilitecolor", "Background color", b);
    })(o), ((i) => {
      ((l) => {
        l.ui.registry.addButton("visualaid", { tooltip: "Visual aids", text: "Visual aids", onAction: Jl(l, "mceToggleVisualAid") });
      })(i), ((l) => {
        l.ui.registry.addToggleMenuItem("visualaid", { text: "Visual aids", onSetup: iL(l), onAction: Jl(l, "mceToggleVisualAid") });
      })(i);
    })(o), ((i) => {
      ((l) => {
        l.ui.registry.addButton("outdent", { tooltip: "Decrease indent", icon: "outdent", onSetup: aL(l), onAction: Jl(l, "outdent") }), l.ui.registry.addButton("indent", { tooltip: "Increase indent", icon: "indent", onSetup: fu(l), onAction: Jl(l, "indent") });
      })(i);
    })(o), n3(o), ((i) => {
      const l = Ln(lS(i)), f = () => i.execCommand("mceTogglePlainTextPaste");
      i.ui.registry.addToggleButton("pastetext", { active: !1, icon: "paste-text", tooltip: "Paste as text", onAction: f, onSetup: sR(i, l) }), i.ui.registry.addToggleMenuItem("pastetext", { text: "Paste as text", icon: "paste-text", onAction: f, onSetup: sR(i, l) });
    })(o);
  }, iR = (o) => ce(o) ? o.split(/[ ,]/) : o, lR = (o) => (s) => s.options.get(o), cR = lR("contextmenu_never_use_native"), cL = lR("contextmenu_avoid_overlap"), uR = (o) => {
    const s = o.ui.registry.getAll().contextMenus, i = o.options.get("contextmenu");
    return o.options.isSet("contextmenu") ? i : Pn(i, (l) => _n(s, l));
  }, Kx = (o, s) => ({ type: "makeshift", x: o, y: s }), r3 = (o) => o.type === "longpress" || o.type.indexOf("touch") === 0, dR = (o, s) => s.type === "contextmenu" || s.type === "longpress" ? o.inline ? ((i) => {
    if (r3(i)) {
      const l = i.touches[0];
      return Kx(l.pageX, l.pageY);
    }
    return Kx(i.pageX, i.pageY);
  })(s) : ((i, l) => {
    const f = Ph.DOM.getPos(i);
    return ((m, b, x) => Kx(m.x + b, m.y + x))(l, f.x, f.y);
  })(o.getContentAreaContainer(), ((i) => {
    if (r3(i)) {
      const l = i.touches[0];
      return Kx(l.clientX, l.clientY);
    }
    return Kx(i.clientX, i.clientY);
  })(s)) : fR(o), fR = (o) => ({ type: "selection", root: Xt(o.selection.getNode()) }), mR = (o, s, i) => {
    switch (i) {
      case "node":
        return ((l) => ({ type: "node", node: M.some(Xt(l.selection.getNode())), root: Xt(l.getBody()) }))(o);
      case "point":
        return dR(o, s);
      case "selection":
        return fR(o);
    }
  }, uL = (o, s, i, l, f, m) => {
    const b = i(), x = mR(o, s, m);
    R1(b, Tm.CLOSE_ON_EXECUTE, l, { isHorizontalMenu: !1, search: M.none() }).map((w) => {
      s.preventDefault(), Oa.showMenuAt(f, { anchor: x }, { menu: { markers: pp("normal") }, data: w });
    });
  }, dL = { onLtr: () => [ma, Bi, Tr, rl, ps, Zl, Vi, Sd, Mx, N_, Nx, Rx], onRtl: () => [ma, Tr, Bi, ps, rl, Zl, Vi, Sd, Nx, Rx, Mx, N_] }, fL = { valignCentre: [], alignCentre: [], alignLeft: ["tox-pop--align-left"], alignRight: ["tox-pop--align-right"], right: ["tox-pop--right"], left: ["tox-pop--left"], bottom: ["tox-pop--bottom"], top: ["tox-pop--top"] }, pR = (o, s, i, l, f, m) => {
    const b = Ic(), x = b.os.isiOS(), w = b.os.isMacOS(), E = b.os.isAndroid(), O = b.deviceType.isTouch(), A = () => {
      const B = i();
      (($, Z, oe, re, fe, ee, J) => {
        const le = ((me, ke, Re) => {
          const qe = mR(me, ke, Re);
          return { bubble: Ii(0, Re === "point" ? 12 : 0, fL), layouts: dL, overrides: { maxWidthFunction: $x(), maxHeightFunction: Lp() }, ...qe };
        })($, Z, ee);
        R1(oe, Tm.CLOSE_ON_EXECUTE, re, { isHorizontalMenu: !0, search: M.none() }).map((me) => {
          Z.preventDefault();
          const ke = J ? cu.HighlightMenuAndItem : cu.HighlightNone;
          Oa.showMenuWithinBounds(fe, { anchor: le }, { menu: { markers: pp("normal"), highlightOnOpen: ke }, data: me, type: "horizontal" }, () => M.some(tR($, re.shared, ee === "node" ? "node" : "selection"))), $.dispatch(JD);
        });
      })(o, s, B, l, f, m, !(E || x || w && O));
    };
    if ((w || x) && m !== "node") {
      const B = () => {
        (($) => {
          const Z = $.selection.getRng(), oe = () => {
            ck.setEditorTimeout($, () => {
              $.selection.setRng(Z);
            }, 10), ee();
          };
          $.once("touchend", oe);
          const re = (J) => {
            J.preventDefault(), J.stopImmediatePropagation();
          };
          $.on("mousedown", re, !0);
          const fe = () => ee();
          $.once("longpresscancel", fe);
          const ee = () => {
            $.off("touchend", oe), $.off("longpresscancel", fe), $.off("mousedown", re);
          };
        })(o), A();
      };
      (($, Z) => {
        const oe = $.selection;
        if (oe.isCollapsed() || Z.touches.length < 1)
          return !1;
        {
          const re = Z.touches[0], fe = oe.getRng();
          return kb($.getWin(), If.domRange(fe)).exists((ee) => ee.left <= re.clientX && ee.right >= re.clientX && ee.top <= re.clientY && ee.bottom >= re.clientY);
        }
      })(o, s) ? B() : (o.once("selectionchange", B), o.once("touchend", () => o.off("selectionchange", B)));
    } else
      A();
  }, L1 = (o) => ce(o) ? o === "|" : o.type === "separator", s3 = { type: "separator" }, gR = (o) => {
    const s = (i) => ({ text: i.text, icon: i.icon, enabled: i.enabled, shortcut: i.shortcut });
    if (ce(o))
      return o;
    switch (o.type) {
      case "separator":
        return s3;
      case "submenu":
        return { type: "nestedmenuitem", ...s(o), getSubmenuItems: () => {
          const l = o.getSubmenuItems();
          return ce(l) ? l : Ct(l, gR);
        } };
      default:
        const i = o;
        return { type: "menuitem", ...s(i), onAction: an(i.onAction) };
    }
  }, hR = (o, s) => {
    if (s.length === 0)
      return o;
    const i = xn(o).filter((l) => !L1(l)).fold(() => [], (l) => [s3]);
    return o.concat(i).concat(s).concat([s3]);
  }, Yx = (o, s) => !((i) => i.type === "longpress" || _n(i, "touches"))(s) && (s.button !== 2 || s.target === o.getBody() && s.pointerType === ""), Kf = (o, s) => Yx(o, s) ? o.selection.getStart(!0) : s.target, a3 = (o, s, i) => {
    const l = Ic().deviceType.isTouch, f = Nl(Oa.sketch({ dom: { tag: "div" }, lazySink: s, onEscape: () => o.focus(), onShow: () => i.setContextMenuState(!0), onHide: () => i.setContextMenuState(!1), fireDismissalEventInstead: {}, inlineBehaviours: $t([wo("dismissContextMenu", [ft(qd(), (x, w) => {
      zo.close(x), o.focus();
    })])]) })), m = () => Oa.hide(f), b = (x) => {
      if (cR(o) && x.preventDefault(), ((E, O) => O.ctrlKey && !cR(E))(o, x) || ((E) => uR(E).length === 0)(o))
        return;
      const w = ((E, O) => {
        const A = cL(E), B = Yx(E, O) ? "selection" : "point";
        if (oc(A)) {
          const $ = Kf(E, O);
          return ux(Xt($), A) ? "node" : B;
        }
        return B;
      })(o, x);
      (l() ? pR : uL)(o, x, () => {
        const E = Kf(o, x), O = o.ui.registry.getAll(), A = uR(o);
        return ((B, $, Z) => {
          const oe = K($, (re, fe) => cn(B, fe.toLowerCase()).map((ee) => {
            const J = ee.update(Z);
            if (ce(J) && oc(Wi(J)))
              return hR(re, J.split(" "));
            if (Me(J) && J.length > 0) {
              const le = Ct(J, gR);
              return hR(re, le);
            }
            return re;
          }).getOrThunk(() => re.concat([fe])), []);
          return oe.length > 0 && L1(oe[oe.length - 1]) && oe.pop(), oe;
        })(O.contextMenus, A, E);
      }, i, f, w);
    };
    o.on("init", () => {
      const x = "ResizeEditor ScrollContent ScrollWindow longpresscancel" + (l() ? "" : " ResizeWindow");
      o.on(x, m), o.on("longpress contextmenu", b);
    });
  }, m2 = Fa([{ offset: ["x", "y"] }, { absolute: ["x", "y"] }, { fixed: ["x", "y"] }]), p2 = (o) => (s) => s.translate(-o.left, -o.top), g2 = (o) => (s) => s.translate(o.left, o.top), Zh = (o) => (s, i) => K(o, (l, f) => f(l), so(s, i)), h2 = (o, s, i) => o.fold(Zh([g2(i), p2(s)]), Zh([p2(s)]), Zh([])), P1 = (o, s, i) => o.fold(Zh([g2(i)]), Zh([]), Zh([g2(s)])), i3 = (o, s, i) => o.fold(Zh([]), Zh([p2(i)]), Zh([g2(s), p2(i)])), bR = (o, s, i) => {
    const l = o.fold((f, m) => ({ position: M.some("absolute"), left: M.some(f + "px"), top: M.some(m + "px") }), (f, m) => ({ position: M.some("absolute"), left: M.some(f - i.left + "px"), top: M.some(m - i.top + "px") }), (f, m) => ({ position: M.some("fixed"), left: M.some(f + "px"), top: M.some(m + "px") }));
    return { right: M.none(), bottom: M.none(), ...l };
  }, l3 = (o, s, i, l) => {
    const f = (m, b) => (x, w) => {
      const E = m(s, i, l);
      return b(x.getOr(E.left), w.getOr(E.top));
    };
    return o.fold(f(i3, Xx), f(P1, vy), f(h2, xy));
  }, Xx = m2.offset, vy = m2.absolute, xy = m2.fixed, c3 = (o, s) => {
    const i = js(o, s);
    return yt(i) ? NaN : parseInt(i, 10);
  }, yR = (o, s, i, l, f, m) => {
    const b = ((E, O, A, B) => (($, Z) => {
      const oe = $.element, re = c3(oe, Z.leftAttr), fe = c3(oe, Z.topAttr);
      return isNaN(re) || isNaN(fe) ? M.none() : M.some(so(re, fe));
    })(E, O).fold(() => A, ($) => xy($.left + B.left, $.top + B.top)))(o, s, i, l), x = s.mustSnap ? mL(o, s, b, f, m) : pL(o, s, b, f, m), w = h2(b, f, m);
    return ((E, O, A) => {
      const B = E.element;
      eo(B, O.leftAttr, A.left + "px"), eo(B, O.topAttr, A.top + "px");
    })(o, s, w), x.fold(() => ({ coord: xy(w.left, w.top), extra: M.none() }), (E) => ({ coord: E.output, extra: E.extra }));
  }, vR = (o, s, i, l) => Ko(o, (f) => {
    const m = f.sensor;
    return ((x, w, E, O, A, B) => {
      const $ = P1(x, A, B), Z = P1(w, A, B);
      return Math.abs($.left - Z.left) <= E && Math.abs($.top - Z.top) <= O;
    })(s, m, f.range.left, f.range.top, i, l) ? M.some({ output: l3(f.output, s, i, l), extra: f.extra }) : M.none();
  }), mL = (o, s, i, l, f) => {
    const m = s.getSnapPoints(o);
    return vR(m, i, l, f).orThunk(() => K(m, (x, w) => {
      const E = w.sensor, O = ((A, B, $, Z, oe, re) => {
        const fe = P1(A, oe, re), ee = P1(B, oe, re), J = Math.abs(fe.left - ee.left), le = Math.abs(fe.top - ee.top);
        return so(J, le);
      })(i, E, w.range.left, w.range.top, l, f);
      return x.deltas.fold(() => ({ deltas: M.some(O), snap: M.some(w) }), (A) => (O.left + O.top) / 2 <= (A.left + A.top) / 2 ? { deltas: M.some(O), snap: M.some(w) } : x);
    }, { deltas: M.none(), snap: M.none() }).snap.map((x) => ({ output: l3(x.output, i, l, f), extra: x.extra })));
  }, pL = (o, s, i, l, f) => {
    const m = s.getSnapPoints(o);
    return vR(m, i, l, f);
  };
  var gL = Object.freeze({ __proto__: null, snapTo: (o, s, i, l) => {
    const f = s.getTarget(o.element);
    if (s.repositionTarget) {
      const m = ni(o.element), b = Ls(m), x = UA(f), w = ((O, A, B) => ({ coord: l3(O.output, O.output, A, B), extra: O.extra }))(l, b, x), E = bR(w.coord, 0, x);
      Yi(f, E);
    }
  } });
  const u3 = "data-initial-z-index", xR = (o, s) => {
    o.getSystem().addToGui(s), ((i) => {
      cl(i.element).filter(ra).each((l) => {
        Xs(l, "z-index").each((f) => {
          eo(l, u3, f);
        }), qn(l, "z-index", Ts(i.element, "z-index"));
      });
    })(s);
  }, d3 = (o) => {
    ((s) => {
      cl(s.element).filter(ra).each((i) => {
        Sa(i, u3).fold(() => ar(i, "z-index"), (l) => qn(i, "z-index", l)), ts(i, u3);
      });
    })(o), o.getSystem().removeFromGui(o);
  }, wR = (o, s, i) => o.getSystem().build(Uu.sketch({ dom: { styles: { left: "0px", top: "0px", width: "100%", height: "100%", position: "fixed", "z-index": "1000000000000000" }, classes: [s] }, events: i }));
  var kR = Ol("snaps", [st("getSnapPoints"), Vo("onSensor"), st("leftAttr"), st("topAttr"), He("lazyViewport", os), He("mustSnap", !1)]);
  const f3 = [He("useFixed", Xe), st("blockerClass"), He("getTarget", wt), He("onDrag", gt), He("repositionTarget", !0), He("onDrop", gt), fs("getBounds", os), kR], hL = (o) => {
    return (s = Xs(o, "left"), i = Xs(o, "top"), l = Xs(o, "position"), s.isSome() && i.isSome() && l.isSome() ? M.some(((f, m, b) => (b === "fixed" ? xy : Xx)(parseInt(f, 10), parseInt(m, 10)))(s.getOrDie(), i.getOrDie(), l.getOrDie())) : M.none()).getOrThunk(() => {
      const f = $n(o);
      return vy(f.left, f.top);
    });
    var s, i, l;
  }, _R = (o, s) => ({ bounds: o.getBounds(), height: Ft(s.element), width: Ba(s.element) }), m3 = (o, s, i, l, f) => {
    const m = i.update(l, f), b = i.getStartData().getOrThunk(() => _R(s, o));
    m.each((x) => {
      ((w, E, O, A) => {
        const B = E.getTarget(w.element);
        if (E.repositionTarget) {
          const $ = ni(w.element), Z = Ls($), oe = UA(B), re = hL(B), fe = ((J, le, me, ke, Re, qe, mt) => ((bt, St, Qt, vn, Mn) => {
            const Qn = Mn.bounds, fo = P1(St, Qt, vn), $o = Dc(fo.left, Qn.x, Qn.x + Qn.width - Mn.width), Hs = Dc(fo.top, Qn.y, Qn.y + Qn.height - Mn.height), ga = vy($o, Hs);
            return St.fold(() => {
              const Xo = i3(ga, Qt, vn);
              return Xx(Xo.left, Xo.top);
            }, Ee(ga), () => {
              const Xo = h2(ga, Qt, vn);
              return xy(Xo.left, Xo.top);
            });
          })(0, le.fold(() => {
            const bt = (St = me, Qt = qe.left, vn = qe.top, St.fold((Qn, fo) => Xx(Qn + Qt, fo + vn), (Qn, fo) => vy(Qn + Qt, fo + vn), (Qn, fo) => xy(Qn + Qt, fo + vn)));
            var St, Qt, vn;
            const Mn = h2(bt, ke, Re);
            return xy(Mn.left, Mn.top);
          }, (bt) => {
            const St = yR(J, bt, me, qe, ke, Re);
            return St.extra.each((Qt) => {
              bt.onSensor(J, Qt);
            }), St.coord;
          }), ke, Re, mt))(w, E.snaps, re, Z, oe, A, O), ee = bR(fe, 0, oe);
          Yi(B, ee);
        }
        E.onDrag(w, B, A);
      })(o, s, b, x);
    });
  }, CR = (o, s, i, l) => {
    s.each(d3), i.snaps.each((m) => {
      ((b, x) => {
        ((w, E) => {
          const O = w.element;
          ts(O, E.leftAttr), ts(O, E.topAttr);
        })(b, x);
      })(o, m);
    });
    const f = i.getTarget(o.element);
    l.reset(), i.onDrop(o, f);
  }, p3 = (o) => (s, i) => {
    const l = (f) => {
      i.setStartData(_R(s, f));
    };
    return Bo([ft(Wd(), (f) => {
      i.getStartData().each(() => l(f));
    }), ...o(s, i, l)]);
  };
  var bL = Object.freeze({ __proto__: null, getData: (o) => M.from(so(o.x, o.y)), getDelta: (o, s) => so(s.left - o.left, s.top - o.top) });
  const g3 = (o, s, i) => [ft(da(), (l, f) => {
    if (f.event.raw.button !== 0)
      return;
    f.stop();
    const m = () => CR(l, M.some(w), o, s), b = lO(m, 200), x = { drop: m, delayDrop: b.schedule, forceDrop: m, move: (E) => {
      b.cancel(), m3(l, o, s, bL, E);
    } }, w = wR(l, o.blockerClass, ((E) => Bo([ft(da(), E.forceDrop), ft(X(), E.drop), ft(z(), (O, A) => {
      E.move(A.event);
    }), ft(F(), E.delayDrop)]))(x));
    i(l), xR(l, w);
  })], SR = [...f3, ms("dragger", { handlers: p3(g3) })];
  var ER = Object.freeze({ __proto__: null, getData: (o) => {
    const s = o.raw.touches;
    return s.length === 1 ? ((i) => {
      const l = i[0];
      return M.some(so(l.clientX, l.clientY));
    })(s) : M.none();
  }, getDelta: (o, s) => so(s.left - o.left, s.top - o.top) });
  const TR = (o, s, i) => {
    const l = As(), f = (m) => {
      CR(m, l.get(), o, s), l.clear();
    };
    return [ft(Yo(), (m, b) => {
      b.stop();
      const x = () => f(m), w = { drop: x, delayDrop: gt, forceDrop: x, move: (O) => {
        m3(m, o, s, ER, O);
      } }, E = wR(m, o.blockerClass, ((O) => Bo([ft(Yo(), O.forceDrop), ft(Ac(), O.drop), ft(Cf(), O.drop), ft(id(), (A, B) => {
        O.move(B.event);
      })]))(w));
      l.set(E), i(m), xR(m, E);
    }), ft(id(), (m, b) => {
      b.stop(), m3(m, o, s, ER, b.event);
    }), ft(Ac(), (m, b) => {
      b.stop(), f(m);
    }), ft(Cf(), f)];
  }, yL = SR, vL = [...f3, ms("dragger", { handlers: p3(TR) })], xL = [...f3, ms("dragger", { handlers: p3((o, s, i) => [...g3(o, s, i), ...TR(o, s, i)]) })];
  var wL = Object.freeze({ __proto__: null, mouse: yL, touch: vL, mouseOrTouch: xL }), zR = Object.freeze({ __proto__: null, init: () => {
    let o = M.none(), s = M.none();
    const i = Ee({});
    return as({ readState: i, reset: () => {
      o = M.none(), s = M.none();
    }, update: (l, f) => l.getData(f).bind((m) => ((b, x) => {
      const w = o.map((E) => b.getDelta(E, x));
      return o = M.some(x), w;
    })(l, m)), getStartData: () => s, setStartData: (l) => {
      s = M.some(l);
    } });
  } });
  const wy = Gm({ branchKey: "mode", branches: wL, name: "dragging", active: { events: (o, s) => o.dragger.handlers(o, s) }, extra: { snap: (o) => ({ sensor: o.sensor, range: o.range, output: o.output, extra: M.from(o.extra) }) }, state: zR, apis: gL }), h3 = (o, s, i, l, f, m) => o.fold(() => wy.snap({ sensor: vy(i - 20, l - 20), range: so(f, m), output: vy(M.some(i), M.some(l)), extra: { td: s } }), (b) => {
    const x = i - 20, w = l - 20, E = b.element.dom.getBoundingClientRect();
    return wy.snap({ sensor: vy(x, w), range: so(40, 40), output: vy(M.some(i - E.width / 2), M.some(l - E.height / 2)), extra: { td: s } });
  }), b2 = (o, s, i) => ({ getSnapPoints: o, leftAttr: "data-drag-left", topAttr: "data-drag-top", onSensor: (l, f) => {
    const m = f.td;
    ((b, x) => b.exists((w) => tr(w, x)))(s.get(), m) || (s.set(m), i(m));
  }, mustSnap: !0 }), OR = (o) => Ur(bc.sketch({ dom: { tag: "div", classes: ["tox-selector"] }, buttonBehaviours: $t([wy.config({ mode: "mouseOrTouch", blockerClass: "blocker", snaps: o }), px.config({})]), eventOrder: { mousedown: ["dragging", "alloy.base.behaviour"], touchstart: ["dragging", "alloy.base.behaviour"] } })), AR = (o, s) => {
    const i = Ln([]), l = Ln([]), f = Ln(!1), m = As(), b = As(), x = (ee) => {
      const J = la(ee);
      return h3(A.getOpt(s), ee, J.x, J.y, J.width, J.height);
    }, w = (ee) => {
      const J = la(ee);
      return h3(B.getOpt(s), ee, J.right, J.bottom, J.width, J.height);
    }, E = b2(() => Ct(i.get(), (ee) => x(ee)), m, (ee) => {
      b.get().each((J) => {
        o.dispatch("TableSelectorChange", { start: ee, finish: J });
      });
    }), O = b2(() => Ct(l.get(), (ee) => w(ee)), b, (ee) => {
      m.get().each((J) => {
        o.dispatch("TableSelectorChange", { start: J, finish: ee });
      });
    }), A = OR(E), B = OR(O), $ = Nl(A.asSpec()), Z = Nl(B.asSpec()), oe = (ee, J, le, me) => {
      const ke = le(J);
      wy.snapTo(ee, ke), ((Re, qe, mt, bt) => {
        const St = qe.dom.getBoundingClientRect();
        ar(Re.element, "display");
        const Qt = Bd(Xt(o.getBody())).dom.innerHeight, vn = St[me] < 0, Mn = ((Qn, fo) => Qn[me] > fo)(St, Qt);
        (vn || Mn) && qn(Re.element, "display", "none");
      })(ee, J);
    }, re = (ee) => oe($, ee, x, "top"), fe = (ee) => oe(Z, ee, w, "bottom");
    Ic().deviceType.isTouch() && (o.on("TableSelectionChange", (ee) => {
      f.get() || (sp(s, $), sp(s, Z), f.set(!0)), m.set(ee.start), b.set(ee.finish), ee.otherCells.each((J) => {
        i.set(J.upOrLeftCells), l.set(J.downOrRightCells), re(ee.start), fe(ee.finish);
      });
    }), o.on("ResizeEditor ResizeWindow ScrollContent", () => {
      m.get().each(re), b.get().each(fe);
    }), o.on("TableSelectionClear", () => {
      f.get() && (Cm($), Cm(Z), f.set(!1)), m.clear(), b.clear();
    }));
  }, kL = (o, s, i) => {
    var l;
    const f = (l = s.delimiter) !== null && l !== void 0 ? l : "›";
    return { dom: { tag: "div", classes: ["tox-statusbar__path"], attributes: { role: "navigation" } }, behaviours: $t([Jt.config({ mode: "flow", selector: "div[role=button]" }), Xn.config({ disabled: i.isDisabled }), il(), Aa.config({}), Jn.config({}), wo("elementPathEvents", [ss((m, b) => {
      o.shortcuts.add("alt+F11", "focus statusbar elementpath", () => Jt.focusIn(m)), o.on("NodeChange", (x) => {
        const w = ((O) => {
          const A = [];
          let B = O.length;
          for (; B-- > 0; ) {
            const Z = O[B];
            if (Z.nodeType === 1 && ($ = Z).nodeName !== "BR" && !$.getAttribute("data-mce-bogus") && $.getAttribute("data-mce-type") !== "bookmark") {
              const oe = MM(o, Z);
              if (oe.isDefaultPrevented() || A.push({ name: oe.name, element: Z }), oe.isPropagationStopped())
                break;
            }
          }
          var $;
          return A;
        })(x.parents), E = w.length > 0 ? K(w, (O, A, B) => {
          const $ = ((Z, oe, re) => bc.sketch({ dom: { tag: "div", classes: ["tox-statusbar__path-item"], attributes: { "data-index": re, "aria-level": re + 1 } }, components: [Os(Z)], action: (fe) => {
            o.focus(), o.selection.select(oe), o.nodeChanged();
          }, buttonBehaviours: $t([M0(i.isDisabled), il()]) }))(A.name, A.element, B);
          return B === 0 ? O.concat([$]) : O.concat([{ dom: { tag: "div", classes: ["tox-statusbar__path-divider"], attributes: { "aria-hidden": !0 } }, components: [Os(` ${f} `)] }, $]);
        }, []) : [];
        Jn.set(m, E);
      });
    })])]), components: [] };
  };
  var ky;
  (function(o) {
    o[o.None = 0] = "None", o[o.Both = 1] = "Both", o[o.Vertical = 2] = "Vertical";
  })(ky || (ky = {}));
  const DR = (o, s, i) => {
    const l = Xt(o.getContainer()), f = ((m, b, x, w, E) => {
      const O = { height: u2(w + b.top, yk(m), JC(m)) };
      return x === ky.Both && (O.width = u2(E + b.left, XC(m), vk(m))), O;
    })(o, s, i, Qe(l), Wr(l));
    Mr(f, (m, b) => {
      en(m) && qn(l, b, K4(m));
    }), ((m) => {
      m.dispatch("ResizeEditor");
    })(o);
  }, y2 = (o, s, i, l) => {
    const f = so(20 * i, 20 * l);
    return DR(o, f, s), M.some(!0);
  }, b3 = (o, s) => {
    const i = () => {
      const l = [], f = Kb(o), m = XT(o), b = iS(o) || o.hasPlugin("wordcount");
      return m && l.push(kL(o, {}, s)), f && l.push((() => {
        const x = Lk("Alt+0");
        return { dom: { tag: "div", classes: ["tox-statusbar__help-text"] }, components: [Os(_d.translate(["Press {0} for help", x]))] };
      })()), b && l.push((() => {
        const x = [];
        return o.hasPlugin("wordcount") && x.push(((w, E) => {
          const O = (A, B, $) => Jn.set(A, [Os(E.translate(["{0} " + $, B[$]]))]);
          return bc.sketch({ dom: { tag: "button", classes: ["tox-statusbar__wordcount"] }, components: [], buttonBehaviours: $t([M0(E.isDisabled), il(), Aa.config({}), Jn.config({}), ln.config({ store: { mode: "memory", initialValue: { mode: "words", count: { words: 0, characters: 0 } } } }), wo("wordcount-events", [hl((A) => {
            const B = ln.getValue(A), $ = B.mode === "words" ? "characters" : "words";
            ln.setValue(A, { mode: $, count: B.count }), O(A, B.count, $);
          }), ss((A) => {
            w.on("wordCountUpdate", (B) => {
              const { mode: $ } = ln.getValue(A);
              ln.setValue(A, { mode: $, count: B.wordCount }), O(A, B.wordCount, $);
            });
          })])]), eventOrder: { [gl()]: ["disabling", "alloy.base.behaviour", "wordcount-events"] } });
        })(o, s)), iS(o) && x.push({ dom: { tag: "span", classes: ["tox-statusbar__branding"] }, components: [{ dom: { tag: "a", attributes: { href: "https://www.tiny.cloud/powered-by-tiny?utm_campaign=poweredby&utm_source=tiny&utm_medium=referral&utm_content=v6", rel: "noopener", target: "_blank", "aria-label": _d.translate(["Powered by {0}", "Tiny"]) }, innerHtml: `<svg width="50px" height="16px" viewBox="0 0 50 16" xmlns="http://www.w3.org/2000/svg">
  <path fill-rule="evenodd" clip-rule="evenodd" d="M10.143 0c2.608.015 5.186 2.178 5.186 5.331 0 0 .077 3.812-.084 4.87-.361 2.41-2.164 4.074-4.65 4.496-1.453.284-2.523.49-3.212.623-.373.071-.634.122-.785.152-.184.038-.997.145-1.35.145-2.732 0-5.21-2.04-5.248-5.33 0 0 0-3.514.03-4.442.093-2.4 1.758-4.342 4.926-4.963 0 0 3.875-.752 4.036-.782.368-.07.775-.1 1.15-.1Zm1.826 2.8L5.83 3.989v2.393l-2.455.475v5.968l6.137-1.189V9.243l2.456-.476V2.8ZM5.83 6.382l3.682-.713v3.574l-3.682.713V6.382Zm27.173-1.64-.084-1.066h-2.226v9.132h2.456V7.743c-.008-1.151.998-2.064 2.149-2.072 1.15-.008 1.987.92 1.995 2.072v5.065h2.455V7.359c-.015-2.18-1.657-3.929-3.837-3.913a3.993 3.993 0 0 0-2.908 1.296Zm-6.3-4.266L29.16 0v2.387l-2.456.475V.476Zm0 3.2v9.132h2.456V3.676h-2.456Zm18.179 11.787L49.11 3.676H46.58l-1.612 4.527-.46 1.382-.384-1.382-1.611-4.527H39.98l3.3 9.132L42.15 16l2.732-.537ZM22.867 9.738c0 .752.568 1.075.921 1.075.353 0 .668-.047.998-.154l.537 1.765c-.23.154-.92.537-2.225.537-1.305 0-2.655-.997-2.686-2.686a136.877 136.877 0 0 1 0-4.374H18.8V3.676h1.612v-1.98l2.455-.476v2.456h2.302V5.9h-2.302v3.837Z"/>
</svg>
`.trim() }, behaviours: $t([io.config({})]) }] }), { dom: { tag: "div", classes: ["tox-statusbar__right-container"] }, components: x };
      })()), l.length > 0 ? [{ dom: { tag: "div", classes: ["tox-statusbar__text-container", ...(() => {
        const x = "tox-statusbar__text-container--flex-start", w = "tox-statusbar__text-container--flex-end";
        if (f) {
          const E = "tox-statusbar__text-container-3-cols";
          return b || m ? b && !m ? [E, w] : [E, x] : [E, "tox-statusbar__text-container--space-around"];
        }
        return [b && !m ? w : x];
      })()] }, components: l }] : [];
    };
    return { dom: { tag: "div", classes: ["tox-statusbar"] }, components: (() => {
      const l = i(), f = ((m, b) => {
        const x = ((E) => {
          const O = JT(E);
          return O === !1 ? ky.None : O === "both" ? ky.Both : ky.Vertical;
        })(m);
        if (x === ky.None)
          return M.none();
        const w = x === ky.Both ? "Press the arrow keys to resize the editor." : "Press the Up and Down arrow keys to resize the editor.";
        return M.some(fp("resize-handle", { tag: "div", classes: ["tox-statusbar__resize-handle"], attributes: { title: b.translate("Resize"), "aria-label": b.translate(w) }, behaviours: [wy.config({ mode: "mouse", repositionTarget: !1, onDrag: (E, O, A) => DR(m, A, x), blockerClass: "tox-blocker" }), Jt.config({ mode: "special", onLeft: () => y2(m, x, -1, 0), onRight: () => y2(m, x, 1, 0), onUp: () => y2(m, x, 0, -1), onDown: () => y2(m, x, 0, 1) }), Aa.config({}), io.config({})] }, b.icons));
      })(o, s);
      return l.concat(f.toArray());
    })() };
  }, qg = (o, s) => s.get().getOrDie(`UI for ${o} has not been rendered`), _L = (o, s) => {
    const i = o.inline, l = i ? oL : GD, f = Uv(o) ? c6 : VA, m = (() => {
      const ke = As(), Re = As(), qe = As();
      return { dialogUi: ke, popupUi: Re, mainUi: qe, getUiMotherships: () => {
        const mt = ke.get().map((St) => St.mothership), bt = Re.get().map((St) => St.mothership);
        return mt.fold(() => bt.toArray(), (St) => bt.fold(() => [St], (Qt) => tr(St.element, Qt.element) ? [St] : [St, Qt]));
      }, lazyGetInOuterOrDie: (mt, bt) => () => qe.get().bind((St) => bt(St.outerContainer)).getOrDie(`Could not find ${mt} element in OuterContainer`) };
    })(), b = As(), x = As(), w = As(), E = Ic().deviceType.isTouch() ? ["tox-platform-touch"] : [], O = Vv(o), A = k0(o), B = Ur({ dom: { tag: "div", classes: ["tox-anchorbar"] } }), $ = Ur({ dom: { tag: "div", classes: ["tox-bottom-anchorbar"] } }), Z = () => m.mainUi.get().map((ke) => ke.outerContainer).bind(Rs.getHeader), oe = m.lazyGetInOuterOrDie("anchor bar", B.getOpt), re = m.lazyGetInOuterOrDie("bottom anchor bar", $.getOpt), fe = m.lazyGetInOuterOrDie("toolbar", Rs.getToolbar), ee = m.lazyGetInOuterOrDie("throbber", Rs.getThrobber), J = ((ke, Re, qe, mt) => {
      const bt = Ln(!1), St = ((Xo) => {
        const Fl = Ln(Vv(Xo) ? "bottom" : "top");
        return { isPositionedAtTop: () => Fl.get() === "top", getDockingMode: Fl.get, setDockingMode: Fl.set };
      })(Re), Qt = { icons: () => Re.ui.registry.getAll().icons, menuItems: () => Re.ui.registry.getAll().menuItems, translate: _d.translate, isDisabled: () => Re.mode.isReadOnly() || !Re.ui.isEnabled(), getOption: Re.options.get }, vn = XB(Re), Mn = ((Xo) => {
        const Fl = (Er) => () => Xo.formatter.match(Er), go = (Er) => () => {
          const Ui = Xo.formatter.get(Er);
          return Ui !== void 0 ? M.some({ tag: Ui.length > 0 && (Ui[0].inline || Ui[0].block) || "div", styles: Xo.dom.parseStyle(Xo.formatter.getCssText(Er)) }) : M.none();
        }, ui = Ln([]), qs = Ln([]), qu = Ln(!1);
        return Xo.on("PreInit", (Er) => {
          const Ui = B_(Xo), Gu = OA(Xo, Ui, Fl, go);
          ui.set(Gu);
        }), Xo.on("addStyleModifications", (Er) => {
          const Ui = OA(Xo, Er.items, Fl, go);
          qs.set(Ui), qu.set(Er.replace);
        }), { getData: () => {
          const Er = qu.get() ? [] : ui.get(), Ui = qs.get();
          return Er.concat(Ui);
        } };
      })(Re), Qn = ((Xo) => ({ colorPicker: mf(Xo), hasCustomColors: Ix(Xo), getColors: Rm(Xo), getColorCols: ZB(Xo) }))(Re), fo = ((Xo) => ({ isDraggableModal: Ds(Xo) }))(Re), $o = { shared: { providers: Qt, anchors: qp(Re, qe, mt, St.isPositionedAtTop), header: St }, urlinput: vn, styles: Mn, colorinput: Qn, dialog: fo, isContextMenuOpen: () => bt.get(), setContextMenuState: (Xo) => bt.set(Xo) }, Hs = { ...$o, shared: { ...$o.shared, interpreter: (Xo) => CA(Xo, {}, Hs), getSink: ke.popup } }, ga = { ...$o, shared: { ...$o.shared, interpreter: (Xo) => CA(Xo, {}, ga), getSink: ke.dialog } };
      return { popup: Hs, dialog: ga };
    })({ popup: () => To.fromOption(m.popupUi.get().map((ke) => ke.sink), "(popup) UI has not been rendered"), dialog: () => To.fromOption(m.dialogUi.get().map((ke) => ke.sink), "UI has not been rendered") }, o, oe, re), le = () => {
      const ke = (() => {
        const $o = { attributes: { [Ja]: O ? Gl.BottomToTop : Gl.TopToBottom } }, Hs = Rs.parts.menubar({ dom: { tag: "div", classes: ["tox-menubar"] }, backstage: J.popup, onEscape: () => {
          o.focus();
        } }), ga = Rs.parts.toolbar({ dom: { tag: "div", classes: ["tox-toolbar"] }, getSink: J.popup.shared.getSink, providers: J.popup.shared.providers, onEscape: () => {
          o.focus();
        }, onToolbarToggled: (Gu) => {
          ((iv, V1) => {
            iv.dispatch("ToggleToolbarDrawer", { state: V1 });
          })(o, Gu);
        }, type: A, lazyToolbar: fe, lazyHeader: () => Z().getOrDie("Could not find header element"), ...$o }), Xo = Rs.parts["multiple-toolbar"]({ dom: { tag: "div", classes: ["tox-toolbar-overlord"] }, providers: J.popup.shared.providers, onEscape: () => {
          o.focus();
        }, type: A }), Fl = C0(o), go = _k(o), ui = g1(o), qs = yn(o), qu = Rs.parts.promotion({ dom: { tag: "div", classes: ["tox-promotion"] } }), Er = Fl || go || ui, Ui = qs ? [qu, Hs] : [Hs];
        return Rs.parts.header({ dom: { tag: "div", classes: ["tox-editor-header"].concat(Er ? [] : ["tox-editor-header--empty"]), ...$o }, components: er([ui ? Ui : [], Fl ? [Xo] : go ? [ga] : [], h1(o) ? [] : [B.asSpec()]]), sticky: Uv(o), editor: o, sharedBackstage: J.popup.shared });
      })(), Re = { dom: { tag: "div", classes: ["tox-sidebar-wrap"] }, components: [Rs.parts.socket({ dom: { tag: "div", classes: ["tox-edit-area"] } }), Rs.parts.sidebar({ dom: { tag: "div", classes: ["tox-sidebar"] } })] }, qe = Rs.parts.throbber({ dom: { tag: "div", classes: ["tox-throbber"] }, backstage: J.popup }), mt = Rs.parts.viewWrapper({ backstage: J.popup }), bt = YT(o) && !i ? M.some(b3(o, J.popup.shared.providers)) : M.none(), St = er([O ? [] : [ke], i ? [] : [Re], O ? [ke] : []]), Qt = Rs.parts.editorContainer({ components: er([St, i ? [] : [$.asSpec(), ...bt.toArray()]]) }), vn = fS(o), Mn = { role: "application", ..._d.isRtl() ? { dir: "rtl" } : {}, ...vn ? { "aria-hidden": "true" } : {} }, Qn = Nl(Rs.sketch({ dom: { tag: "div", classes: ["tox", "tox-tinymce"].concat(i ? ["tox-tinymce-inline"] : []).concat(O ? ["tox-tinymce--toolbar-bottom"] : []).concat(E), styles: { visibility: "hidden", ...vn ? { opacity: "0", border: "0" } : {} }, attributes: Mn }, components: [Qt, ...i ? [] : [mt], qe], behaviours: $t([il(), Xn.config({ disableClass: "tox-tinymce--disabled" }), Jt.config({ mode: "cyclic", selector: ".tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a, .tox-statusbar__resize-handle" })]) })), fo = mE(Qn);
      return b.set(fo), { mothership: fo, outerContainer: Qn };
    }, me = (ke) => {
      const Re = K4(((mt) => ((St) => {
        const Qt = YC(St), vn = yk(St), Mn = JC(St);
        return G4(Qt).map((Qn) => u2(Qn, vn, Mn));
      })(mt).getOr(YC(mt)))(o)), qe = K4(((mt) => KD(mt).getOr(bk(mt)))(o));
      return o.inline || (xf("div", "width", qe) && qn(ke.element, "width", qe), xf("div", "height", Re) ? qn(ke.element, "height", Re) : qn(ke.element, "height", "400px")), Re;
    };
    return { popups: { backstage: J.popup, getMothership: () => qg("popups", w) }, dialogs: { backstage: J.dialog, getMothership: () => qg("dialogs", x) }, renderUI: () => {
      const ke = le(), Re = (() => {
        const mt = dS(o), bt = tr(Wa(), mt) && Ts(mt, "display") === "grid", St = { dom: { tag: "div", classes: ["tox", "tox-silver-sink", "tox-tinymce-aux"].concat(E), attributes: { ..._d.isRtl() ? { dir: "rtl" } : {} } }, behaviours: $t([Ll.config({ useFixed: () => f.isDocked(Z) })]) }, Qt = { dom: { styles: { width: document.body.clientWidth + "px" } }, events: Bo([ft(Uc(), (Qn) => {
          qn(Qn.element, "width", document.body.clientWidth + "px");
        })]) }, vn = Nl(be(St, bt ? Qt : {})), Mn = mE(vn);
        return x.set(Mn), { sink: vn, mothership: Mn };
      })(), qe = b1(o) ? (() => {
        const mt = { dom: { tag: "div", classes: ["tox", "tox-silver-sink", "tox-silver-popup-sink", "tox-tinymce-aux"].concat(E), attributes: { ..._d.isRtl() ? { dir: "rtl" } : {} } }, behaviours: $t([Ll.config({ useFixed: () => f.isDocked(Z), getBounds: () => s.getPopupSinkBounds() })]) }, bt = Nl(mt), St = mE(bt);
        return w.set(St), { sink: bt, mothership: St };
      })() : ((mt) => (w.set(mt.mothership), mt))(Re);
      return m.dialogUi.set(Re), m.popupUi.set(qe), m.mainUi.set(ke), ((mt) => {
        const { mainUi: bt, popupUi: St, uiMotherships: Qt } = mt;
        ho(UT(o), (go, ui) => {
          o.ui.registry.addGroupToolbarButton(ui, go);
        });
        const { buttons: vn, menuItems: Mn, contextToolbars: Qn, sidebars: fo, views: $o } = o.ui.registry.getAll(), Hs = uS(o), ga = { menuItems: Mn, menus: mS(o), menubar: WT(o), toolbar: Hs.getOrThunk(() => xk(o)), allowToolbarGroups: A === Zf.floating, buttons: vn, sidebar: fo, views: $o };
        var Xo;
        Xo = bt.outerContainer, o.addShortcut("alt+F9", "focus menubar", () => {
          Rs.focusMenubar(Xo);
        }), o.addShortcut("alt+F10", "focus toolbar", () => {
          Rs.focusToolbar(Xo);
        }), o.addCommand("ToggleToolbarDrawer", (go, ui) => {
          ui != null && ui.skipFocus ? Rs.toggleToolbarDrawerWithoutFocusing(Xo) : Rs.toggleToolbarDrawer(Xo);
        }), o.addQueryStateHandler("ToggleToolbarDrawer", () => Rs.isToolbarDrawerToggled(Xo)), ((go, ui, qs) => {
          const qu = (is, vp) => {
            tn([ui, ...qs], (gf) => {
              gf.broadcastEvent(is, vp);
            });
          }, Er = (is, vp) => {
            tn([ui, ...qs], (gf) => {
              gf.broadcastOn([is], vp);
            });
          }, Ui = (is) => Er(Pl(), { target: is.target }), Gu = Js(), iv = sl(Gu, "touchstart", Ui), V1 = sl(Gu, "touchmove", (is) => qu(sh(), is)), R2 = sl(Gu, "touchend", (is) => qu(Cu(), is)), ow = sl(Gu, "mousedown", Ui), _y = sl(Gu, "mouseup", (is) => {
            is.raw.button === 0 && Er(nt(), { target: is.target });
          }), Cy = (is) => Er(Pl(), { target: Xt(is.target) }), Kg = (is) => {
            is.button === 0 && Er(nt(), { target: Xt(is.target) });
          }, U1 = () => {
            tn(go.editorManager.get(), (is) => {
              go !== is && is.dispatch("DismissPopups", { relatedTarget: go });
            });
          }, j1 = (is) => qu(Wd(), fb(is)), Yg = (is) => {
            Er(Og(), {}), qu(Uc(), fb(is));
          }, qh = us(Xt(go.getElement())), lv = kg(qh, "scroll", (is) => {
            requestAnimationFrame(() => {
              if (go.getContainer() != null) {
                const vp = k1(go, ui.element).map((gf) => [gf.element, ...gf.others]).getOr([]);
                jr(vp, (gf) => tr(gf, is.target)) && (go.dispatch("ElementScroll", { target: is.target.dom }), qu(cs(), is));
              }
            });
          }), rw = () => Er(Og(), {}), sw = (is) => {
            is.state && Er(Pl(), { target: Xt(go.getContainer()) });
          }, cv = (is) => {
            Er(Pl(), { target: Xt(is.relatedTarget.getContainer()) });
          };
          go.on("PostRender", () => {
            go.on("click", Cy), go.on("tap", Cy), go.on("mouseup", Kg), go.on("mousedown", U1), go.on("ScrollWindow", j1), go.on("ResizeWindow", Yg), go.on("ResizeEditor", rw), go.on("AfterProgressState", sw), go.on("DismissPopups", cv);
          }), go.on("remove", () => {
            go.off("click", Cy), go.off("tap", Cy), go.off("mouseup", Kg), go.off("mousedown", U1), go.off("ScrollWindow", j1), go.off("ResizeWindow", Yg), go.off("ResizeEditor", rw), go.off("AfterProgressState", sw), go.off("DismissPopups", cv), ow.unbind(), iv.unbind(), V1.unbind(), R2.unbind(), _y.unbind(), lv.unbind();
          }), go.on("detach", () => {
            tn([ui, ...qs], zh), tn([ui, ...qs], (is) => is.destroy());
          });
        })(o, bt.mothership, Qt), f.setup(o, J.popup.shared, Z), lL(o, J.popup), a3(o, J.popup.shared.getSink, J.popup), ((go) => {
          const { sidebars: ui } = go.ui.registry.getAll();
          tn(po(ui), (qs) => {
            const qu = ui[qs], Er = () => Si(M.from(go.queryCommandValue("ToggleSidebar")), qs);
            go.ui.registry.addToggleButton(qs, { icon: qu.icon, tooltip: qu.tooltip, onAction: (Ui) => {
              go.execCommand("ToggleSidebar", !1, qs), Ui.setActive(Er());
            }, onSetup: (Ui) => {
              Ui.setActive(Er());
              const Gu = () => Ui.setActive(Er());
              return go.on("ToggleSidebar", Gu), () => {
                go.off("ToggleSidebar", Gu);
              };
            } });
          });
        })(o), v6(o, ee, J.popup.shared), d2(o, Qn, St.sink, { backstage: J.popup }), AR(o, St.sink);
        const Fl = { targetNode: o.getElement(), height: me(bt.outerContainer) };
        return l.render(o, mt, ga, J.popup, Fl);
      })({ popupUi: qe, dialogUi: Re, mainUi: ke, uiMotherships: m.getUiMotherships() });
    } };
  }, Jx = Ee([st("lazySink"), pr("dragBlockClass"), fs("getBounds", os), He("useTabstopAt", un), He("firstTabstop", 0), He("eventOrder", {}), pa("modalBehaviours", [Jt]), fc("onExecute"), bg("onEscape")]), y3 = { sketch: wt }, v3 = Ee([rn({ name: "draghandle", overrides: (o, s) => ({ behaviours: $t([wy.config({ mode: "mouse", getTarget: (i) => Va(i, '[role="dialog"]').getOr(i), blockerClass: o.dragBlockClass.getOrDie(new Error(`The drag blocker class was not specified for a dialog with a drag handle: 
` + JSON.stringify(s, null, 2)).message), getBounds: o.getDragBounds })]) }) }), Lt({ schema: [st("dom")], name: "title" }), Lt({ factory: y3, schema: [st("dom")], name: "close" }), Lt({ factory: y3, schema: [st("dom")], name: "body" }), rn({ factory: y3, schema: [st("dom")], name: "footer" }), Vt({ factory: { sketch: (o, s) => ({ ...o, dom: s.dom, components: s.components }) }, schema: [He("dom", { tag: "div", styles: { position: "fixed", left: "0px", top: "0px", right: "0px", bottom: "0px" } }), He("components", [])], name: "blocker" })]), xl = hc({ name: "ModalDialog", configFields: Jx(), partFields: v3(), factory: (o, s, i, l) => {
    const f = As(), m = hn("modal-events"), b = { ...o.eventOrder, [At()]: [m].concat(o.eventOrder["alloy.system.attached"] || []) };
    return { uid: o.uid, dom: o.dom, components: s, apis: { show: (x) => {
      f.set(x);
      const w = o.lazySink(x).getOrDie(), E = l.blocker(), O = w.getSystem().build({ ...E, components: E.components.concat([Yr(x)]), behaviours: $t([io.config({}), wo("dialog-blocker-events", [Xd(Oe(), () => {
        Kp.isBlocked(x) || Jt.focusIn(x);
      })])]) });
      sp(w, O), Jt.focusIn(x);
    }, hide: (x) => {
      f.clear(), cl(x.element).each((w) => {
        x.getSystem().getByDom(w).each((E) => {
          Cm(E);
        });
      });
    }, getBody: (x) => ii(x, o, "body"), getFooter: (x) => Dn(x, o, "footer"), setIdle: (x) => {
      Kp.unblock(x);
    }, setBusy: (x, w) => {
      Kp.block(x, w);
    } }, eventOrder: b, domModification: { attributes: { role: "dialog", "aria-modal": "true" } }, behaviours: Fi(o.modalBehaviours, [Jn.config({}), Jt.config({ mode: "cyclic", onEnter: o.onExecute, onEscape: o.onEscape, useTabstopAt: o.useTabstopAt, firstTabstop: o.firstTabstop }), Kp.config({ getRoot: f.get }), wo(m, [ss((x) => {
      ((w, E) => {
        const O = Sa(w, "id").fold(() => {
          const A = hn("dialog-label");
          return eo(E, "id", A), A;
        }, wt);
        eo(w, "aria-labelledby", O);
      })(x.element, ii(x, o, "title").element);
    })])]) };
  }, apis: { show: (o, s) => {
    o.show(s);
  }, hide: (o, s) => {
    o.hide(s);
  }, getBody: (o, s) => o.getBody(s), getFooter: (o, s) => o.getFooter(s), setBusy: (o, s, i) => {
    o.setBusy(s, i);
  }, setIdle: (o, s) => {
    o.setIdle(s);
  } } }), CL = Nn([ci, Rk].concat(du)), SL = $c, v2 = [SS("button"), Wf, Fs("align", "end", ["start", "end"]), Yv, zm, Pm("buttonType", ["primary", "secondary"])], RR = [...v2, Jb], Qx = [Pa("type", ["submit", "cancel", "custom"]), ...RR], x3 = [Pa("type", ["menu"]), ey, Kv, Wf, Ka("items", CL), ...v2], w3 = [...v2, Pa("type", ["togglebutton"]), Is("tooltip"), Wf, ey, rs("active", !1)], EL = bi("type", { submit: Qx, cancel: Qx, custom: Qx, menu: x3, togglebutton: w3 }), Yf = [ci, Jb, Pa("level", ["info", "warn", "error", "success"]), mz, He("url", "")], TL = Nn(Yf), zL = [ci, Jb, zm, SS("button"), Wf, gz, Pm("buttonType", ["primary", "secondary", "toolbar"]), Yv], NR = Nn(zL), I1 = [ci, Rk], Xp = I1.concat([kS]), OL = I1.concat([xS, zm]), AL = Nn(OL), DL = $c, RL = Xp.concat([hz("auto")]), NL = Nn(RL), ML = Ec([Gv, Jb, mz]), MR = Xp.concat([Al("storageKey", "default")]), BL = Nn(MR), LL = xa, PL = Nn(Xp), BR = xa, k3 = I1.concat([Al("tag", "textarea"), Is("scriptId"), Is("scriptUrl"), za("settings", void 0, Ep)]), IL = I1.concat([Al("tag", "textarea"), Ia("init")]), _3 = Tl((o) => Gr("customeditor.old", hi(IL), o).orThunk(() => Gr("customeditor.new", hi(k3), o))), sv = xa, LR = Nn(Xp), PR = Ps(Sn), IR = (o) => [ci, Lm("columns"), o], FL = [ci, Is("html"), Fs("presets", "presentation", ["presentation", "document"])], $L = Nn(FL), x2 = Xp.concat([rs("border", !1), rs("sandboxed", !0), rs("streamContent", !1), rs("transparent", !0)]), HL = Nn(x2), VL = xa, FR = Nn(I1.concat([Nr("height")])), $R = Nn([Is("url"), ea("zoom"), ea("cachedWidth"), ea("cachedHeight")]), C3 = Xp.concat([Nr("inputMode"), Nr("placeholder"), rs("maximized", !1), zm]), HR = Nn(C3), Wu = xa, VR = (o) => [ci, xS, o, Fs("align", "start", ["start", "center", "end"])], UL = [Jb, Gv], jL = [Jb, Ka("items", ad(0, () => S3))], S3 = Di([Nn(UL), Nn(jL)]), ZL = Xp.concat([Ka("items", S3), zm]), WL = Nn(ZL), qL = xa, UR = Xp.concat([jd("items", [Jb, Gv]), ou("size", 1), zm]), Gg = Nn(UR), E3 = xa, jR = Xp.concat([rs("constrain", !0), zm]), w2 = Nn(jR), k2 = Nn([Is("width"), Is("height")]), GL = I1.concat([xS, ou("min", 0), ou("max", 0)]), KL = Nn(GL), YL = qr, XL = [ci, Ka("header", xa), Ka("cells", Ps(xa))], JL = Nn(XL), QL = Xp.concat([Nr("placeholder"), rs("maximized", !1), zm]), eP = Nn(QL), ZR = xa, WR = [Pa("type", ["directory", "leaf"]), dM, Is("id"), Hl("menu", eD)], Jp = Nn(WR), _2 = WR.concat([Ka("children", ad(0, () => ku("type", { directory: qR, leaf: Jp })))]), qR = Nn(_2), tP = ku("type", { directory: qR, leaf: Jp }), GR = [ci, Ka("items", tP), Vl("onLeafAction"), Vl("onToggleExpand"), Ir("defaultExpandedIds", [], xa), Nr("defaultSelectedId")], KR = Nn(GR), T3 = Xp.concat([Fs("filetype", "file", ["image", "media", "file"]), zm, Nr("picker_text")]), C2 = Nn(T3), ew = Nn([Gv, _S]), F1 = (o) => Qs("items", "items", { tag: "required", process: {} }, Ps(Tl((s) => Gr(`Checking item of ${o}`, S2, s).fold((i) => To.error(nu(i)), (i) => To.value(i))))), S2 = Br(() => {
    return ku("type", { alertbanner: TL, bar: Nn((o = F1("bar"), [ci, o])), button: NR, checkbox: AL, colorinput: BL, colorpicker: PL, dropzone: LR, grid: Nn(IR(F1("grid"))), iframe: HL, input: HR, listbox: WL, selectbox: Gg, sizeinput: w2, slider: KL, textarea: eP, urlinput: C2, customeditor: _3, htmlpanel: $L, imagepreview: FR, collection: NL, label: Nn(VR(F1("label"))), table: JL, tree: KR, panel: z3 });
    var o;
  }), YR = [ci, He("classes", []), Ka("items", S2)], z3 = Nn(YR), XR = [SS("tab"), dM, Ka("items", S2)], nP = [ci, jd("tabs", XR)], oP = Nn(nP), rP = RR, sP = EL, aP = Nn([Is("title"), zl("body", ku("type", { panel: z3, tabpanel: oP })), Al("size", "normal"), Ir("buttons", [], sP), He("initialData", {}), fs("onAction", gt), fs("onChange", gt), fs("onSubmit", gt), fs("onClose", gt), fs("onCancel", gt), fs("onTabChange", gt)]), JR = Nn([Pa("type", ["cancel", "custom"]), ...rP]), QR = Nn([Is("title"), Is("url"), ea("height"), ea("width"), Ya("buttons", JR), fs("onAction", gt), fs("onCancel", gt), fs("onClose", gt), fs("onMessage", gt)]), O3 = (o) => he(o) ? [o].concat(Qr(ro(o), O3)) : Me(o) ? Qr(o, O3) : [], eN = (o) => ce(o.type) && ce(o.name), iP = { checkbox: DL, colorinput: LL, colorpicker: BR, dropzone: PR, input: Wu, iframe: VL, imagepreview: $R, selectbox: E3, sizeinput: k2, slider: YL, listbox: qL, size: k2, textarea: ZR, urlinput: ew, customeditor: sv, collection: ML, togglemenuitem: SL }, tN = (o) => {
    const s = ((l) => Pn(O3(l), eN))(o), i = Qr(s, (l) => ((f) => M.from(iP[f.type]))(l).fold(() => [], (f) => [zl(l.name, f)]));
    return Nn(i);
  }, av = (o) => {
    var s;
    return { internalDialog: ic(Gr("dialog", aP, o)), dataValidator: tN(o), initialData: (s = o.initialData) !== null && s !== void 0 ? s : {} };
  }, $1 = { open: (o, s) => {
    const i = av(s);
    return o(i.internalDialog, i.initialData, i.dataValidator);
  }, openUrl: (o, s) => o(ic(Gr("dialog", QR, s))), redial: (o) => av(o) };
  var nN = Object.freeze({ __proto__: null, events: (o, s) => {
    const i = (l, f) => {
      o.updateState.each((m) => {
        const b = m(l, f);
        s.set(b);
      }), o.renderComponents.each((m) => {
        const b = m(f, s.get());
        (o.reuseDom ? Nc : bs)(l, b);
      });
    };
    return Bo([ft(ta(), (l, f) => {
      const m = f;
      if (!m.universal) {
        const b = o.channel;
        Bn(m.channels, b) && i(l, m.data);
      }
    }), ss((l, f) => {
      o.initialData.each((m) => {
        i(l, m);
      });
    })]);
  } }), lP = Object.freeze({ __proto__: null, getState: (o, s, i) => i }), cP = [st("channel"), pr("renderComponents"), pr("updateState"), pr("initialData"), rs("reuseDom", !0)];
  const pf = _i({ fields: cP, name: "reflecting", active: nN, apis: lP, state: Object.freeze({ __proto__: null, init: () => {
    const o = Ln(M.none());
    return { readState: () => o.get().getOr("none"), get: o.get, set: o.set, clear: () => o.set(M.none()) };
  } }) }), oN = (o) => {
    const s = [], i = {};
    return Mr(o, (l, f) => {
      l.fold(() => {
        s.push(f);
      }, (m) => {
        i[f] = m;
      });
    }), s.length > 0 ? To.error(s) : To.value(i);
  }, rN = (o, s, i) => {
    const l = Ur(G0.sketch((m) => ({ dom: { tag: "div", classes: ["tox-form"].concat(o.classes) }, components: Ct(o.items, (b) => o4(m, b, s, i)) })));
    return { dom: { tag: "div", classes: ["tox-dialog__body"] }, components: [{ dom: { tag: "div", classes: ["tox-dialog__body-content"] }, components: [l.asSpec()] }], behaviours: $t([Jt.config({ mode: "acyclic", useTabstopAt: Cn(Cx) }), (f = l, rr.config({ find: f.getOpt })), SB(l, { postprocess: (m) => oN(m).fold((b) => (console.error(b), {}), wt) }), wo("dialog-body-panel", [ft(Oe(), (m, b) => {
      m.getSystem().broadcastOn([y_], { newFocus: M.some(b.event.target) });
    })])]) };
    var f;
  }, uP = Bu({ name: "TabButton", configFields: [He("uid", void 0), st("value"), Qs("dom", "dom", _f(() => ({ attributes: { role: "tab", id: hn("aria"), "aria-selected": "false" } })), Pr()), pr("action"), He("domModification", {}), pa("tabButtonBehaviours", [io, Jt, ln]), st("view")], factory: (o, s) => ({ uid: o.uid, dom: o.dom, components: o.components, events: Pv(o.action), behaviours: Fi(o.tabButtonBehaviours, [io.config({}), Jt.config({ mode: "execution", useSpace: !0, useEnter: !0 }), ln.config({ store: { mode: "memory", initialValue: o.value } })]), domModification: o.domModification }) }), sN = Ee([st("tabs"), st("dom"), He("clickToDismiss", !1), pa("tabbarBehaviours", [mr, Jt]), Au(["tabClass", "selectedClass"])]), A3 = Vn({ factory: uP, name: "tabs", unit: "tab", overrides: (o) => {
    const s = (l, f) => {
      mr.dehighlight(l, f), pn(l, cc(), { tabbar: l, button: f });
    }, i = (l, f) => {
      mr.highlight(l, f), pn(l, Rl(), { tabbar: l, button: f });
    };
    return { action: (l) => {
      const f = l.getSystem().getByUid(o.uid).getOrDie(), m = mr.isHighlighted(f, l);
      (m && o.clickToDismiss ? s : m ? gt : i)(f, l);
    }, domModification: { classes: [o.markers.tabClass] } };
  } }), Wh = Ee([A3]), E2 = hc({ name: "Tabbar", configFields: sN(), partFields: Wh(), factory: (o, s, i, l) => ({ uid: o.uid, dom: o.dom, components: s, "debug.sketcher": "Tabbar", domModification: { attributes: { role: "tablist" } }, behaviours: Fi(o.tabbarBehaviours, [mr.config({ highlightClass: o.markers.selectedClass, itemClass: o.markers.tabClass, onHighlight: (f, m) => {
    eo(m.element, "aria-selected", "true");
  }, onDehighlight: (f, m) => {
    eo(m.element, "aria-selected", "false");
  } }), Jt.config({ mode: "flow", getInitial: (f) => mr.getHighlighted(f).map((m) => m.element), selector: "." + o.markers.tabClass, executeOnMove: !0 })]) }) }), aN = Bu({ name: "Tabview", configFields: [pa("tabviewBehaviours", [Jn])], factory: (o, s) => ({ uid: o.uid, dom: o.dom, behaviours: Fi(o.tabviewBehaviours, [Jn.config({})]), domModification: { attributes: { role: "tabpanel" } } }) }), iN = Ee([He("selectFirst", !0), Vo("onChangeTab"), Vo("onDismissTab"), He("tabs", []), pa("tabSectionBehaviours", [])]), D3 = Lt({ factory: E2, schema: [st("dom"), el("markers", [st("tabClass"), st("selectedClass")])], name: "tabbar", defaults: (o) => ({ tabs: o.tabs }) }), lN = Lt({ factory: aN, name: "tabview" }), T2 = Ee([D3, lN]), H1 = hc({ name: "TabSection", configFields: iN(), partFields: T2(), factory: (o, s, i, l) => {
    const f = (m, b) => {
      Dn(m, o, "tabbar").each((x) => {
        b(x).each(Kd);
      });
    };
    return { uid: o.uid, dom: o.dom, components: s, behaviours: ir(o.tabSectionBehaviours), events: Bo(er([o.selectFirst ? [ss((m, b) => {
      f(m, mr.getFirst);
    })] : [], [ft(Rl(), (m, b) => {
      ((x) => {
        const w = ln.getValue(x);
        Dn(x, o, "tabview").each((E) => {
          Go(o.tabs, (O) => O.value === w).each((O) => {
            const A = O.view();
            Sa(x.element, "id").each((B) => {
              eo(E.element, "aria-labelledby", B);
            }), Jn.set(E, A), o.onChangeTab(E, x, A);
          });
        });
      })(b.event.button);
    }), ft(cc(), (m, b) => {
      const x = b.event.button;
      o.onDismissTab(m, x);
    })]])), apis: { getViewItems: (m) => Dn(m, o, "tabview").map((b) => Jn.contents(b)).getOr([]), showTab: (m, b) => {
      f(m, (x) => {
        const w = mr.getCandidates(x);
        return Go(w, (E) => ln.getValue(E) === b).filter((E) => !mr.isHighlighted(x, E));
      });
    } } };
  }, apis: { getViewItems: (o, s) => o.getViewItems(s), showTab: (o, s, i) => {
    o.showTab(s, i);
  } } }), R3 = (o, s) => {
    qn(o, "height", s + "px"), qn(o, "flex-basis", s + "px");
  }, z2 = (o, s, i) => {
    Va(o, '[role="dialog"]').each((l) => {
      fa(l, '[role="tablist"]').each((f) => {
        i.get().map((m) => (qn(s, "height", "0"), qn(s, "flex-basis", "0"), Math.min(m, ((b, x, w) => {
          const E = Md(b).dom, O = Va(b, ".tox-dialog-wrap").getOr(b);
          let A;
          A = Ts(O, "position") === "fixed" ? Math.max(E.clientHeight, window.innerHeight) : Math.max(E.offsetHeight, E.scrollHeight);
          const B = Qe(x), $ = x.dom.offsetLeft >= w.dom.offsetLeft + Wr(w) ? Math.max(Qe(w), B) : B, Z = parseInt(Ts(b, "margin-top"), 10) || 0, oe = parseInt(Ts(b, "margin-bottom"), 10) || 0;
          return A - (Qe(b) + Z + oe - $);
        })(l, s, f)))).each((m) => {
          R3(s, m);
        });
      });
    });
  }, N3 = (o) => fa(o, '[role="tabpanel"]'), cN = "send-data-to-section", uN = "send-data-to-view", dP = (o, s, i) => {
    const l = Ln({}), f = (E) => {
      const O = ln.getValue(E), A = oN(O).getOr({}), B = l.get(), $ = be(B, A);
      l.set($);
    }, m = (E) => {
      const O = l.get();
      ln.setValue(E, O);
    }, b = Ln(null), x = Ct(o.tabs, (E) => ({ value: E.name, dom: { tag: "div", classes: ["tox-dialog__body-nav-item"] }, components: [Os(i.shared.providers.translate(E.title))], view: () => [G0.sketch((O) => ({ dom: { tag: "div", classes: ["tox-form"] }, components: Ct(E.items, (A) => o4(O, A, s, i)), formBehaviours: $t([Jt.config({ mode: "acyclic", useTabstopAt: Cn(Cx) }), wo("TabView.form.events", [ss(m), ud(f)]), pc.config({ channels: dr([{ key: cN, value: { onReceive: f } }, { key: uN, value: { onReceive: m } }]) })]) }))] })), w = ((E) => {
      const O = As();
      return { extraEvents: [ss((B) => {
        const $ = B.element;
        N3($).each((Z) => {
          qn(Z, "visibility", "hidden"), B.getSystem().getByDom(Z).toOptional().each((oe) => {
            const re = ((ee, J, le) => Ct(ee, (me, ke) => {
              Jn.set(le, ee[ke].view());
              const Re = J.dom.getBoundingClientRect();
              return Jn.set(le, []), Re.height;
            }))(E, Z, oe);
            ((ee) => ct(kt(ee, (J, le) => J > le ? -1 : J < le ? 1 : 0)))(re).fold(O.clear, O.set);
          }), z2($, Z, O), ar(Z, "visibility"), ((oe, re) => {
            ct(oe).each((fe) => H1.showTab(re, fe.value));
          })(E, B), requestAnimationFrame(() => {
            z2($, Z, O);
          });
        });
      }), ft(Uc(), (B) => {
        const $ = B.element;
        N3($).each((Z) => {
          z2($, Z, O);
        });
      }), ft(hE, (B, $) => {
        const Z = B.element;
        N3(Z).each((oe) => {
          const re = Zc(us(oe));
          qn(oe, "visibility", "hidden");
          const fe = Xs(oe, "height").map((J) => parseInt(J, 10));
          ar(oe, "height"), ar(oe, "flex-basis");
          const ee = oe.dom.getBoundingClientRect().height;
          fe.forall((J) => ee > J) ? (O.set(ee), z2(Z, oe, O)) : fe.each((J) => {
            R3(oe, J);
          }), ar(oe, "visibility"), re.each(gc);
        });
      })], selectFirst: !1 };
    })(x);
    return H1.sketch({ dom: { tag: "div", classes: ["tox-dialog__body"] }, onChangeTab: (E, O, A) => {
      const B = ln.getValue(O);
      pn(E, gE, { name: B, oldName: b.get() }), b.set(B);
    }, tabs: x, components: [H1.parts.tabbar({ dom: { tag: "div", classes: ["tox-dialog__body-nav"] }, components: [E2.parts.tabs({})], markers: { tabClass: "tox-tab", selectedClass: "tox-dialog__body-nav-item--active" }, tabbarBehaviours: $t([Aa.config({})]) }), H1.parts.tabview({ dom: { tag: "div", classes: ["tox-dialog__body-content"] } })], selectFirst: w.selectFirst, tabSectionBehaviours: $t([wo("tabpanel", w.extraEvents), Jt.config({ mode: "acyclic" }), rr.config({ find: (E) => ct(H1.getViewItems(E)) }), z1(M.none(), (E) => (E.getSystem().broadcastOn([cN], {}), l.get()), (E, O) => {
      l.set(O), E.getSystem().broadcastOn([uN], {});
    })]) });
  }, M3 = (o, s, i, l, f) => ({ dom: { tag: "div", classes: ["tox-dialog__content-js"], attributes: { ...i.map((m) => ({ id: m })).getOr({}), ...f ? { "aria-live": "polite" } : {} } }, components: [], behaviours: $t([kx(0), pf.config({ channel: `${ZO}-${s}`, updateState: (m, b) => M.some({ isTabPanel: () => b.body.type === "tabpanel" }), renderComponents: (m) => {
    const b = m.body;
    return b.type === "tabpanel" ? [dP(b, m.initialData, l)] : [rN(b, m.initialData, l)];
  }, initialData: o })]) }), dN = mp.deviceType.isTouch(), fN = (o, s) => ({ dom: { tag: "div", styles: { display: "none" }, classes: ["tox-dialog__header"] }, components: [o, s] }), mN = (o, s) => xl.parts.close(bc.sketch({ dom: { tag: "button", classes: ["tox-button", "tox-button--icon", "tox-button--naked"], attributes: { type: "button", "aria-label": s.translate("Close") } }, action: o, buttonBehaviours: $t([Aa.config({})]) })), pN = () => xl.parts.title({ dom: { tag: "div", classes: ["tox-dialog__title"], innerHtml: "", styles: { display: "none" } } }), tw = (o, s) => xl.parts.body({ dom: { tag: "div", classes: ["tox-dialog__body"] }, components: [{ dom: { tag: "div", classes: ["tox-dialog__body-content"] }, components: [{ dom: Bh(`<p>${WC(s.translate(o))}</p>`) }] }] }), gN = (o) => xl.parts.footer({ dom: { tag: "div", classes: ["tox-dialog__footer"] }, components: o }), hN = (o, s) => [Uu.sketch({ dom: { tag: "div", classes: ["tox-dialog__footer-start"] }, components: o }), Uu.sketch({ dom: { tag: "div", classes: ["tox-dialog__footer-end"] }, components: s })], O2 = (o) => {
    const s = "tox-dialog", i = s + "-wrap", l = i + "__backdrop", f = s + "__disable-scroll";
    return xl.sketch({ lazySink: o.lazySink, onEscape: (m) => (o.onEscape(m), M.some(!0)), useTabstopAt: (m) => !Cx(m), firstTabstop: o.firstTabstop, dom: { tag: "div", classes: [s].concat(o.extraClasses), styles: { position: "relative", ...o.extraStyles } }, components: [o.header, o.body, ...o.footer.toArray()], parts: { blocker: { dom: Bh(`<div class="${i}"></div>`), components: [{ dom: { tag: "div", classes: dN ? [l, l + "--opaque"] : [l] } }] } }, dragBlockClass: i, modalBehaviours: $t([io.config({}), wo("dialog-events", o.dialogEvents.concat([Xd(Oe(), (m, b) => {
      Kp.isBlocked(m) || Jt.focusIn(m);
    }), ft(Dl(), (m, b) => {
      m.getSystem().broadcastOn([y_], { newFocus: b.event.newFocus });
    })])), wo("scroll-lock", [ss(() => {
      vr(Wa(), f);
    }), ud(() => {
      $s(Wa(), f);
    })]), ...o.extraBehaviours]), eventOrder: { [gl()]: ["dialog-events"], [At()]: ["scroll-lock", "dialog-events", "alloy.base.behaviour"], [Fm()]: ["alloy.base.behaviour", "dialog-events", "scroll-lock"], ...o.eventOrder } });
  }, B3 = (o) => bc.sketch({ dom: { tag: "button", classes: ["tox-button", "tox-button--icon", "tox-button--naked"], attributes: { type: "button", "aria-label": o.translate("Close"), title: o.translate("Close") } }, buttonBehaviours: $t([Aa.config({})]), components: [fp("close", { tag: "span", classes: ["tox-icon"] }, o.icons)], action: (s) => {
    Io(s, ly);
  } }), bN = (o, s, i, l) => ({ dom: { tag: "div", classes: ["tox-dialog__title"], attributes: { ...i.map((f) => ({ id: f })).getOr({}) } }, components: [], behaviours: $t([pf.config({ channel: `${Y0}-${s}`, initialData: o, renderComponents: (f) => [Os(l.translate(f.title))] })]) }), yN = () => ({ dom: Bh('<div class="tox-dialog__draghandle"></div>') }), A2 = (o, s, i) => ((l, f, m) => {
    const b = xl.parts.title(bN(l, f, M.none(), m)), x = xl.parts.draghandle(yN()), w = xl.parts.close(B3(m)), E = [b].concat(l.draggable ? [x] : []).concat([w]);
    return Uu.sketch({ dom: Bh('<div class="tox-dialog__header"></div>'), components: E });
  })({ title: i.shared.providers.translate(o), draggable: i.dialog.isDraggableModal() }, s, i.shared.providers), vN = (o, s, i, l) => ({ dom: { tag: "div", classes: ["tox-dialog__busy-spinner"], attributes: { "aria-label": i.translate(o) }, styles: { left: "0px", right: "0px", bottom: "0px", top: `${l.getOr(0)}px`, position: "absolute" } }, behaviours: s, components: [{ dom: Bh('<div class="tox-spinner"><div></div><div></div><div></div></div>') }] }), L3 = (o, s, i) => ({ onClose: () => i.closeWindow(), onBlock: (l) => {
    const f = fa(o().element, ".tox-dialog__header").map((m) => Qe(m));
    xl.setBusy(o(), (m, b) => vN(l.message, b, s, f));
  }, onUnblock: () => {
    xl.setIdle(o());
  } }), xN = "tox-dialog--fullscreen", P3 = "tox-dialog--width-lg", I3 = "tox-dialog--width-md", nw = (o) => {
    switch (o) {
      case "large":
        return M.some(P3);
      case "medium":
        return M.some(I3);
      default:
        return M.none();
    }
  }, F3 = (o, s) => {
    const i = Xt(s.element.dom);
    _s(i, xN) || (jc(i, [P3, I3]), nw(o).each((l) => vr(i, l)));
  }, wN = (o, s) => {
    const i = Xt(o.element.dom), l = pd(i), f = Go(l, (m) => m === P3 || m === I3).or(nw(s));
    ((m, b) => {
      tn(b, (x) => {
        ((w, E) => {
          md(w) ? w.dom.classList.toggle(E) : ((O, A) => Bn(Oo(O), A) ? xi(O, A) : Sr(O, A))(w, E), fg(w);
        })(m, x);
      });
    })(i, [xN, ...f.toArray()]);
  }, kN = (o, s, i) => Nl(O2({ ...o, firstTabstop: 1, lazySink: i.shared.getSink, extraBehaviours: [m_({}), ...o.extraBehaviours], onEscape: (l) => {
    Io(l, ly);
  }, dialogEvents: s, eventOrder: { [ta()]: [pf.name(), pc.name()], [At()]: ["scroll-lock", pf.name(), "messages", "dialog-events", "alloy.base.behaviour"], [Fm()]: ["alloy.base.behaviour", "dialog-events", "messages", pf.name(), "scroll-lock"] } })), $3 = (o, s = {}) => Ct(o, (i) => i.type === "menu" ? ((l) => {
    const f = Ct(l.items, (m) => {
      const b = cn(s, m.name).getOr(Ln(!1));
      return { ...m, storage: b };
    });
    return { ...l, items: f };
  })(i) : i), _N = (o) => K(o, (s, i) => i.type === "menu" ? K(i.items, (l, f) => (l[f.name] = f.storage, l), s) : s, {}), H3 = (o, s) => [Yd(Oe(), EB), o(C1, (i, l, f, m) => {
    Zc(us(m.element)).fold(gt, ub), s.onClose(), l.onClose();
  }), o(ly, (i, l, f, m) => {
    l.onCancel(i), Io(m, C1);
  }), ft(mx, (i, l) => s.onUnblock()), ft(V0, (i, l) => s.onBlock(l.event))], CN = (o, s, i) => {
    const l = (m, b) => ft(m, (x, w) => {
      f(x, (E, O) => {
        b(o(), E, w.event, x);
      });
    }), f = (m, b) => {
      pf.getState(m).get().each((x) => {
        b(x.internalDialog, m);
      });
    };
    return [...H3(l, s), l(fx, (m, b) => b.onSubmit(m)), l(df, (m, b, x) => {
      b.onChange(m, { name: x.name });
    }), l(Hg, (m, b, x, w) => {
      const E = () => w.getSystem().isConnected() ? Jt.focusIn(w) : void 0, O = ($) => Ki($, "disabled") || Sa($, "aria-disabled").exists((Z) => Z === "true"), A = us(w.element), B = Zc(A);
      b.onAction(m, { name: x.name, value: x.value }), Zc(A).fold(E, ($) => {
        O($) || B.exists((Z) => Ms($, Z) && O(Z)) ? E() : i().toOptional().filter((Z) => !Ms(Z.element, $)).each(E);
      });
    }), l(gE, (m, b, x) => {
      b.onTabChange(m, { newTabName: x.name, oldTabName: x.oldName });
    }), ud((m) => {
      const b = o();
      ln.setValue(m, b.getData());
    })];
  }, SN = (o, s) => {
    const i = s.map((m) => m.footerButtons).getOr([]), l = oa(i, (m) => m.align === "start"), f = (m, b) => Uu.sketch({ dom: { tag: "div", classes: [`tox-dialog__footer-${m}`] }, components: Ct(b, (x) => x.memento.asSpec()) });
    return [f("start", l.pass), f("end", l.fail)];
  }, EN = (o, s, i) => ({ dom: Bh('<div class="tox-dialog__footer"></div>'), components: [], behaviours: $t([pf.config({ channel: `${LE}-${s}`, initialData: o, updateState: (l, f) => {
    const m = Ct(f.buttons, (b) => {
      const x = Ur(((w, E) => A_(w, w.type, E))(b, i));
      return { name: b.name, align: b.align, memento: x };
    });
    return M.some({ lookupByName: (b) => ((x, w, E) => Go(w, (O) => O.name === E).bind((O) => O.memento.getOpt(x)))(l, m, b), footerButtons: m });
  }, renderComponents: SN })]) }), TN = (o, s, i) => xl.parts.footer(EN(o, s, i)), zN = (o, s) => {
    if (o.getRoot().getSystem().isConnected()) {
      const i = rr.getCurrent(o.getFormWrapper()).getOr(o.getFormWrapper());
      return G0.getField(i, s).orThunk(() => o.getFooter().bind((f) => pf.getState(f).get()).bind((f) => f.lookupByName(s)));
    }
    return M.none();
  }, ON = (o, s, i) => {
    const l = (m) => {
      const b = o.getRoot();
      b.getSystem().isConnected() && m(b);
    }, f = { getData: () => {
      const m = o.getRoot(), b = m.getSystem().isConnected() ? o.getFormWrapper() : m;
      return { ...ln.getValue(b), ...ho(i, (x) => x.get()) };
    }, setData: (m) => {
      l((b) => {
        const x = f.getData(), w = be(x, m), E = ((A, B) => {
          const $ = A.getRoot();
          return pf.getState($).get().map((Z) => ic(Gr("data", Z.dataValidator, B))).getOr(B);
        })(o, w), O = o.getFormWrapper();
        ln.setValue(O, E), Mr(i, (A, B) => {
          _n(w, B) && A.set(w[B]);
        });
      });
    }, setEnabled: (m, b) => {
      zN(o, m).each(b ? Xn.enable : Xn.disable);
    }, focus: (m) => {
      zN(o, m).each(io.focus);
    }, block: (m) => {
      if (!ce(m))
        throw new Error("The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
      l((b) => {
        pn(b, V0, { message: m });
      });
    }, unblock: () => {
      l((m) => {
        Io(m, mx);
      });
    }, showTab: (m) => {
      l((b) => {
        const x = o.getBody();
        pf.getState(x).get().exists((w) => w.isTabPanel()) && rr.getCurrent(x).each((w) => {
          H1.showTab(w, m);
        });
      });
    }, redial: (m) => {
      l((b) => {
        const x = o.getId(), w = s(m), E = $3(w.internalDialog.buttons, i);
        b.getSystem().broadcastOn([`${h_}-${x}`], w), b.getSystem().broadcastOn([`${Y0}-${x}`], w.internalDialog), b.getSystem().broadcastOn([`${ZO}-${x}`], w.internalDialog), b.getSystem().broadcastOn([`${LE}-${x}`], { ...w.internalDialog, buttons: E }), f.setData(w.initialData);
      });
    }, close: () => {
      l((m) => {
        Io(m, C1);
      });
    }, toggleFullscreen: o.toggleFullscreen };
    return f;
  }, AN = (o, s, i, l = !1, f) => {
    const m = hn("dialog"), b = hn("dialog-label"), x = hn("dialog-content"), w = o.internalDialog, E = Ln(w.size), O = nw(E.get()).toArray(), A = Ur(((J, le, me, ke) => Uu.sketch({ dom: Bh('<div class="tox-dialog__header"></div>'), components: [bN(J, le, M.some(me), ke), yN(), B3(ke)], containerBehaviours: $t([wy.config({ mode: "mouse", blockerClass: "blocker", getTarget: (Re) => Ou(Re, '[role="dialog"]').getOrDie(), snaps: { getSnapPoints: () => [], leftAttr: "data-drag-left", topAttr: "data-drag-top" } })]) }))({ title: w.title, draggable: !0 }, m, b, i.shared.providers)), B = Ur(((J, le, me, ke, Re) => M3(J, le, M.some(me), ke, Re))({ body: w.body, initialData: w.initialData }, m, x, i, l)), $ = $3(w.buttons), Z = _N($), oe = mi($.length !== 0, Ur(((J, le, me) => EN(J, le, me))({ buttons: $ }, m, i))), re = CN(() => ee, { onBlock: (J) => {
      Kp.block(fe, (le, me) => {
        const ke = A.getOpt(fe).map((Re) => Qe(Re.element));
        return vN(J.message, me, i.shared.providers, ke);
      });
    }, onUnblock: () => {
      Kp.unblock(fe);
    }, onClose: () => s.closeWindow() }, i.shared.getSink), fe = Nl({ dom: { tag: "div", classes: ["tox-dialog", "tox-dialog-inline", ...O], attributes: { role: "dialog", "aria-labelledby": b } }, eventOrder: { [ta()]: [pf.name(), pc.name()], [gl()]: ["execute-on-form"], [At()]: ["reflecting", "execute-on-form"] }, behaviours: $t([Jt.config({ mode: "cyclic", onEscape: (J) => (Io(J, C1), M.some(!0)), useTabstopAt: (J) => !Cx(J) && (Ti(J) !== "button" || js(J, "disabled") !== "disabled"), firstTabstop: 1 }), pf.config({ channel: `${h_}-${m}`, updateState: (J, le) => (E.set(le.internalDialog.size), F3(le.internalDialog.size, J), f(), M.some(le)), initialData: o }), io.config({}), wo("execute-on-form", re.concat([Xd(Oe(), (J, le) => {
      Jt.focusIn(J);
    }), ft(Dl(), (J, le) => {
      J.getSystem().broadcastOn([y_], { newFocus: le.event.newFocus });
    })])), Kp.config({ getRoot: () => M.some(fe) }), Jn.config({}), m_({})]), components: [A.asSpec(), B.asSpec(), ...oe.map((J) => J.asSpec()).toArray()] }), ee = ON({ getId: Ee(m), getRoot: Ee(fe), getFooter: () => oe.map((J) => J.get(fe)), getBody: () => B.get(fe), getFormWrapper: () => {
      const J = B.get(fe);
      return rr.getCurrent(J).getOr(J);
    }, toggleFullscreen: () => {
      wN(fe, E.get());
    } }, s.redial, Z);
    return { dialog: fe, instanceApi: ee };
  };
  var V3 = tinymce.util.Tools.resolve("tinymce.util.URI");
  const fP = ["insertContent", "setContent", "execCommand", "close", "block", "unblock"], DN = (o) => he(o) && fP.indexOf(o.mceAction) !== -1, mP = (o, s, i, l) => {
    const f = hn("dialog"), m = A2(o.title, f, l), b = ((fe) => {
      const ee = { dom: { tag: "div", classes: ["tox-dialog__content-js"] }, components: [{ dom: { tag: "div", classes: ["tox-dialog__body-iframe"] }, components: [g_(M.none(), { dom: { tag: "iframe", attributes: { src: fe.url } }, behaviours: $t([Aa.config({}), io.config({})]) })] }], behaviours: $t([Jt.config({ mode: "acyclic", useTabstopAt: Cn(Cx) })]) };
      return xl.parts.body(ee);
    })(o), x = o.buttons.bind((fe) => fe.length === 0 ? M.none() : M.some(TN({ buttons: fe }, f, l))), w = ((fe, ee) => {
      const J = (me, ke) => ft(me, (Re, qe) => {
        le(Re, (mt, bt) => {
          ke(re, mt, qe.event, Re);
        });
      }), le = (me, ke) => {
        pf.getState(me).get().each((Re) => {
          ke(Re, me);
        });
      };
      return [...H3(J, ee), J(Hg, (me, ke, Re) => {
        ke.onAction(me, { name: Re.name });
      })];
    })(0, L3(() => oe, l.shared.providers, s)), E = { ...o.height.fold(() => ({}), (fe) => ({ height: fe + "px", "max-height": fe + "px" })), ...o.width.fold(() => ({}), (fe) => ({ width: fe + "px", "max-width": fe + "px" })) }, O = o.width.isNone() && o.height.isNone() ? ["tox-dialog--width-lg"] : [], A = new V3(o.url, { base_uri: new V3(window.location.href) }), B = `${A.protocol}://${A.host}${A.port ? ":" + A.port : ""}`, $ = Lf(), Z = [pf.config({ channel: `${h_}-${f}`, updateState: (fe, ee) => M.some(ee), initialData: o }), wo("messages", [ss(() => {
      const fe = sl(Xt(window), "message", (ee) => {
        if (A.isSameOrigin(new V3(ee.raw.origin))) {
          const J = ee.raw.data;
          DN(J) ? ((le, me, ke) => {
            switch (ke.mceAction) {
              case "insertContent":
                le.insertContent(ke.content);
                break;
              case "setContent":
                le.setContent(ke.content);
                break;
              case "execCommand":
                const Re = !!Ye(ke.ui) && ke.ui;
                le.execCommand(ke.cmd, Re, ke.value);
                break;
              case "close":
                me.close();
                break;
              case "block":
                me.block(ke.message);
                break;
              case "unblock":
                me.unblock();
            }
          })(i, re, J) : ((le) => !DN(le) && he(le) && _n(le, "mceAction"))(J) && o.onMessage(re, J);
        }
      });
      $.set(fe);
    }), ud($.clear)]), pc.config({ channels: { [b_]: { onReceive: (fe, ee) => {
      fa(fe.element, "iframe").each((J) => {
        const le = J.dom.contentWindow;
        it(le) && le.postMessage(ee, B);
      });
    } } } })], oe = kN({ id: f, header: m, body: b, footer: x, extraClasses: O, extraBehaviours: Z, extraStyles: E }, w, l), re = ((fe) => {
      const ee = (J) => {
        fe.getSystem().isConnected() && J(fe);
      };
      return { block: (J) => {
        if (!ce(J))
          throw new Error("The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
        ee((le) => {
          pn(le, V0, { message: J });
        });
      }, unblock: () => {
        ee((J) => {
          Io(J, mx);
        });
      }, close: () => {
        ee((J) => {
          Io(J, C1);
        });
      }, sendMessage: (J) => {
        ee((le) => {
          le.getSystem().broadcastOn([b_], J);
        });
      } };
    })(oe);
    return { dialog: oe, instanceApi: re };
  }, D2 = (o, s) => ic(Gr("data", s, o)), RN = (o) => ux(o, ".tox-alert-dialog") || ux(o, ".tox-confirm-dialog"), pP = (o, s, i) => s && i ? [] : [ei.config({ contextual: { lazyContext: () => M.some(va(Xt(o.getContentAreaContainer()))), fadeInClass: "tox-dialog-dock-fadein", fadeOutClass: "tox-dialog-dock-fadeout", transitionClass: "tox-dialog-dock-transition" }, modes: ["top"], lazyViewport: (l) => k1(o, l.element).map((f) => ({ bounds: H0(f), optScrollEnv: M.some({ currentScrollTop: f.element.dom.scrollTop, scrollElmTop: $n(f.element).top }) })).getOrThunk(() => ({ bounds: os(), optScrollEnv: M.none() })) })], gP = (o) => {
    const s = o.editor, i = Uv(s), l = ((w) => {
      const E = w.shared;
      return { open: (O, A) => {
        const B = () => {
          xl.hide(re), A();
        }, $ = Ur(A_({ name: "close-alert", text: "OK", primary: !0, buttonType: M.some("primary"), align: "end", enabled: !0, icon: M.none() }, "cancel", w)), Z = pN(), oe = mN(B, E.providers), re = Nl(O2({ lazySink: () => E.getSink(), header: fN(Z, oe), body: tw(O, E.providers), footer: M.some(gN(hN([], [$.asSpec()]))), onEscape: B, extraClasses: ["tox-alert-dialog"], extraBehaviours: [], extraStyles: {}, dialogEvents: [ft(ly, B)], eventOrder: {} }));
        xl.show(re);
        const fe = $.get(re);
        io.focus(fe);
      } };
    })(o.backstages.dialog), f = ((w) => {
      const E = w.shared;
      return { open: (O, A) => {
        const B = (J) => {
          xl.hide(fe), A(J);
        }, $ = Ur(A_({ name: "yes", text: "Yes", primary: !0, buttonType: M.some("primary"), align: "end", enabled: !0, icon: M.none() }, "submit", w)), Z = A_({ name: "no", text: "No", primary: !1, buttonType: M.some("secondary"), align: "end", enabled: !0, icon: M.none() }, "cancel", w), oe = pN(), re = mN(() => B(!1), E.providers), fe = Nl(O2({ lazySink: () => E.getSink(), header: fN(oe, re), body: tw(O, E.providers), footer: M.some(gN(hN([], [Z, $.asSpec()]))), onEscape: () => B(!1), extraClasses: ["tox-confirm-dialog"], extraBehaviours: [], extraStyles: {}, dialogEvents: [ft(ly, () => B(!1)), ft(fx, () => B(!0))], eventOrder: {} }));
        xl.show(fe);
        const ee = $.get(fe);
        io.focus(ee);
      } };
    })(o.backstages.dialog), m = (w, E) => $1.open((O, A, B) => {
      const $ = A, Z = ((oe, re, fe) => {
        const ee = hn("dialog"), J = oe.internalDialog, le = A2(J.title, ee, fe), me = Ln(J.size), ke = nw(me.get()).toArray(), Re = ((fo, $o, Hs) => {
          const ga = M3(fo, $o, M.none(), Hs, !1);
          return xl.parts.body(ga);
        })({ body: J.body, initialData: J.initialData }, ee, fe), qe = $3(J.buttons), mt = _N(qe), bt = mi(qe.length !== 0, TN({ buttons: qe }, ee, fe)), St = CN(() => Qn, L3(() => vn, fe.shared.providers, re), fe.shared.getSink), Qt = { id: ee, header: le, body: Re, footer: bt, extraClasses: ke, extraBehaviours: [pf.config({ channel: `${h_}-${ee}`, updateState: (fo, $o) => (me.set($o.internalDialog.size), F3($o.internalDialog.size, fo), M.some($o)), initialData: oe })], extraStyles: {} }, vn = kN(Qt, St, fe), Mn = { getId: Ee(ee), getRoot: Ee(vn), getBody: () => xl.getBody(vn), getFooter: () => xl.getFooter(vn), getFormWrapper: () => {
          const fo = xl.getBody(vn);
          return rr.getCurrent(fo).getOr(fo);
        }, toggleFullscreen: () => {
          wN(vn, me.get());
        } }, Qn = ON(Mn, re.redial, mt);
        return { dialog: vn, instanceApi: Qn };
      })({ dataValidator: B, initialData: $, internalDialog: O }, { redial: $1.redial, closeWindow: () => {
        xl.hide(Z.dialog), E(Z.instanceApi);
      } }, o.backstages.dialog);
      return xl.show(Z.dialog), Z.instanceApi.setData($), Z.instanceApi;
    }, w), b = (w, E, O, A) => $1.open((B, $, Z) => {
      const oe = D2($, Z), re = As(), fe = o.backstages.popup.shared.header.isPositionedAtTop(), ee = () => re.on((me) => {
        Oa.reposition(me), i && fe || ei.refresh(me);
      }), J = AN({ dataValidator: Z, initialData: oe, internalDialog: B }, { redial: $1.redial, closeWindow: () => {
        re.on(Oa.hide), s.off("ResizeEditor", ee), re.clear(), O(J.instanceApi);
      } }, o.backstages.popup, A.ariaAttrs, ee), le = Nl(Oa.sketch({ lazySink: o.backstages.popup.shared.getSink, dom: { tag: "div", classes: [] }, fireDismissalEventInstead: A.persistent ? { event: "doNotDismissYet" } : {}, ...fe ? {} : { fireRepositionEventInstead: {} }, inlineBehaviours: $t([wo("window-manager-inline-events", [ft(qd(), (me, ke) => {
        Io(J.dialog, ly);
      })]), ...pP(s, i, fe)]), isExtraPart: (me, ke) => RN(ke) }));
      return re.set(le), Oa.showWithinBounds(le, Yr(J.dialog), { anchor: E }, () => {
        const me = s.inline ? Wa() : Xt(s.getContainer()), ke = va(me);
        return M.some(ke);
      }), i && fe || (ei.refresh(le), s.on("ResizeEditor", ee)), J.instanceApi.setData(oe), Jt.focusIn(J.dialog), J.instanceApi;
    }, w), x = (w, E, O, A) => $1.open((B, $, Z) => {
      const oe = D2($, Z), re = As(), fe = o.backstages.popup.shared.header.isPositionedAtTop(), ee = () => re.on((me) => {
        Oa.reposition(me), ei.refresh(me);
      }), J = AN({ dataValidator: Z, initialData: oe, internalDialog: B }, { redial: $1.redial, closeWindow: () => {
        re.on(Oa.hide), s.off("ResizeEditor ScrollWindow ElementScroll", ee), re.clear(), O(J.instanceApi);
      } }, o.backstages.popup, A.ariaAttrs, ee), le = Nl(Oa.sketch({ lazySink: o.backstages.popup.shared.getSink, dom: { tag: "div", classes: [] }, fireDismissalEventInstead: A.persistent ? { event: "doNotDismissYet" } : {}, ...fe ? {} : { fireRepositionEventInstead: {} }, inlineBehaviours: $t([wo("window-manager-inline-events", [ft(qd(), (me, ke) => {
        Io(J.dialog, ly);
      })]), ei.config({ contextual: { lazyContext: () => M.some(va(Xt(s.getContentAreaContainer()))), fadeInClass: "tox-dialog-dock-fadein", fadeOutClass: "tox-dialog-dock-fadeout", transitionClass: "tox-dialog-dock-transition" }, modes: ["top", "bottom"], lazyViewport: (me) => k1(s, me.element).map((ke) => ({ bounds: H0(ke), optScrollEnv: M.some({ currentScrollTop: ke.element.dom.scrollTop, scrollElmTop: $n(ke.element).top }) })).getOrThunk(() => ({ bounds: os(), optScrollEnv: M.none() })) })]), isExtraPart: (me, ke) => RN(ke) }));
      return re.set(le), Oa.showWithinBounds(le, Yr(J.dialog), { anchor: E }, () => o.backstages.popup.shared.getSink().toOptional().bind((me) => {
        const ke = k1(s, me.element).map((mt) => H0(mt)).getOr(os()), Re = va(Xt(s.getContentAreaContainer())), qe = od(Re, ke);
        return M.some(Ws(qe.x, qe.y, qe.width, qe.height - 15));
      })), ei.refresh(le), s.on("ResizeEditor ScrollWindow ElementScroll ResizeWindow", ee), J.instanceApi.setData(oe), Jt.focusIn(J.dialog), J.instanceApi;
    }, w);
    return { open: (w, E, O) => {
      if (!yt(E)) {
        if (E.inline === "toolbar")
          return b(w, o.backstages.popup.shared.anchors.inlineDialog(), O, E);
        if (E.inline === "bottom")
          return x(w, o.backstages.popup.shared.anchors.inlineBottomDialog(), O, E);
        if (E.inline === "cursor")
          return b(w, o.backstages.popup.shared.anchors.cursor(), O, E);
      }
      return m(w, O);
    }, openUrl: (w, E) => ((O, A) => $1.openUrl((B) => {
      const $ = mP(B, { closeWindow: () => {
        xl.hide($.dialog), A($.instanceApi);
      } }, s, o.backstages.dialog);
      return xl.show($.dialog), $.instanceApi;
    }, O))(w, E), alert: (w, E) => {
      l.open(w, E);
    }, close: (w) => {
      w.close();
    }, confirm: (w, E) => {
      f.open(w, E);
    } };
  };
  sm.add("silver", (o) => {
    ((b) => {
      FT(b), ((x) => {
        const w = x.options.register, E = (A) => Gt(A, ce) ? { value: BM(A), valid: !0 } : { valid: !1, message: "Must be an array of strings." }, O = (A) => en(A) && A > 0 ? { value: A, valid: !0 } : { valid: !1, message: "Must be a positive number." };
        w("color_map", { processor: E, default: ["#BFEDD2", "Light Green", "#FBEEB8", "Light Yellow", "#F8CAC6", "Light Red", "#ECCAFA", "Light Purple", "#C2E0F4", "Light Blue", "#2DC26B", "Green", "#F1C40F", "Yellow", "#E03E2D", "Red", "#B96AD9", "Purple", "#3598DB", "Blue", "#169179", "Dark Turquoise", "#E67E23", "Orange", "#BA372A", "Dark Red", "#843FA1", "Dark Purple", "#236FA1", "Dark Blue", "#ECF0F1", "Light Gray", "#CED4D9", "Medium Gray", "#95A5A6", "Gray", "#7E8C8D", "Dark Gray", "#34495E", "Navy Blue", "#000000", "Black", "#ffffff", "White"] }), w("color_map_background", { processor: E }), w("color_map_foreground", { processor: E }), w("color_cols", { processor: O, default: KS(x) }), w("color_cols_foreground", { processor: O, default: Wz(x, sx) }), w("color_cols_background", { processor: O, default: Wz(x, ax) }), w("custom_colors", { processor: "boolean", default: !0 }), w("color_default_foreground", { processor: "string", default: Vk }), w("color_default_background", { processor: "string", default: Vk });
      })(b), ((x) => {
        const w = x.options.register;
        w("contextmenu_avoid_overlap", { processor: "string", default: "" }), w("contextmenu_never_use_native", { processor: "boolean", default: !1 }), w("contextmenu", { processor: (E) => E === !1 ? { value: [], valid: !0 } : ce(E) || Gt(E, ce) ? { value: iR(E), valid: !0 } : { valid: !1, message: "Must be false or a string." }, default: "link linkchecker image editimage table spellchecker configurepermanentpen" });
      })(b);
    })(o);
    let s = () => os();
    const { dialogs: i, popups: l, renderUI: f } = _L(o, { getPopupSinkBounds: () => s() });
    UM(o, l.backstage.shared);
    const m = gP({ editor: o, backstages: { popup: l.backstage, dialog: i.backstage } });
    return { renderUI: () => {
      const b = f();
      return k1(o, l.getMothership().element).each((x) => {
        s = () => H0(x);
      }), b;
    }, getWindowManagerImpl: Ee(m), getNotificationManagerImpl: () => ((b, x, w) => {
      const E = x.backstage.shared, O = () => {
        const A = va(Xt(b.getContentAreaContainer())), B = os(), $ = Dc(B.x, A.x, A.right), Z = Dc(B.y, A.y, A.bottom), oe = Math.max(A.right, B.right), re = Math.max(A.bottom, B.bottom);
        return M.some(Ws($, Z, oe - $, re - Z));
      };
      return { open: (A, B) => {
        const $ = () => {
          B(), Oa.hide(oe);
        }, Z = Nl(hk.sketch({ text: A.text, level: Bn(["success", "error", "warning", "warn", "info"], A.type) ? A.type : void 0, progress: A.progressBar === !0, icon: A.icon, closeButton: A.closeButton, onAction: $, iconProvider: E.providers.icons, translationProvider: E.providers.translate })), oe = Nl(Oa.sketch({ dom: { tag: "div", classes: ["tox-notifications-container"] }, lazySink: E.getSink, fireDismissalEventInstead: {}, ...E.header.isPositionedAtTop() ? {} : { fireRepositionEventInstead: {} } }));
        w.add(oe), en(A.timeout) && A.timeout > 0 && ck.setEditorTimeout(b, () => {
          $();
        }, A.timeout);
        const re = { close: $, reposition: () => {
          const fe = Yr(Z), ee = { maxHeightFunction: Lp() }, J = b.notificationManager.getNotifications();
          if (J[0] === re) {
            const le = { ...E.anchors.banner(), overrides: ee };
            Oa.showWithinBounds(oe, fe, { anchor: le }, O);
          } else
            dt(J, re).each((le) => {
              const me = J[le - 1].getEl(), ke = { type: "node", root: Wa(), node: M.some(Xt(me)), overrides: ee, layouts: { onRtl: () => [ma], onLtr: () => [ma] } };
              Oa.showWithinBounds(oe, fe, { anchor: ke }, O);
            });
        }, text: (fe) => {
          hk.updateText(Z, fe);
        }, settings: A, getEl: () => Z.element.dom, progressBar: { value: (fe) => {
          hk.updateProgress(Z, fe);
        } } };
        return re;
      }, close: (A) => {
        A.close();
      }, getArgs: (A) => A.settings };
    })(o, { backstage: l.backstage }, l.getMothership()) };
  });
})();
(function() {
  var v = tinymce.util.Tools.resolve("tinymce.ModelManager");
  const L = (p) => (y) => ((_) => {
    const T = typeof _;
    return _ === null ? "null" : T === "object" && Array.isArray(_) ? "array" : T === "object" && (P = I = _, (j = String).prototype.isPrototypeOf(P) || ((Y = I.constructor) === null || Y === void 0 ? void 0 : Y.name) === j.name) ? "string" : T;
    var P, I, j, Y;
  })(y) === p, N = (p) => (y) => typeof y === p, W = (p) => (y) => p === y, ue = L("string"), ce = L("object"), he = L("array"), pe = W(null), Me = N("boolean"), Ze = W(void 0), Ye = (p) => !((y) => y == null)(p), yt = N("function"), jt = N("number"), it = () => {
  }, Rt = (p) => () => p, en = (p) => p, Gt = (p, y) => p === y;
  function gt(p, ...y) {
    return (..._) => {
      const T = y.concat(_);
      return p.apply(null, T);
    };
  }
  const an = (p) => (y) => !p(y), Ot = (p) => p(), Ee = Rt(!1), wt = Rt(!0);
  class Se {
    constructor(y, _) {
      this.tag = y, this.value = _;
    }
    static some(y) {
      return new Se(!0, y);
    }
    static none() {
      return Se.singletonNone;
    }
    fold(y, _) {
      return this.tag ? _(this.value) : y();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(y) {
      return this.tag ? Se.some(y(this.value)) : Se.none();
    }
    bind(y) {
      return this.tag ? y(this.value) : Se.none();
    }
    exists(y) {
      return this.tag && y(this.value);
    }
    forall(y) {
      return !this.tag || y(this.value);
    }
    filter(y) {
      return !this.tag || y(this.value) ? this : Se.none();
    }
    getOr(y) {
      return this.tag ? this.value : y;
    }
    or(y) {
      return this.tag ? this : y;
    }
    getOrThunk(y) {
      return this.tag ? this.value : y();
    }
    orThunk(y) {
      return this.tag ? this : y();
    }
    getOrDie(y) {
      if (this.tag)
        return this.value;
      throw new Error(y ?? "Called getOrDie on None");
    }
    static from(y) {
      return Ye(y) ? Se.some(y) : Se.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(y) {
      this.tag && y(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Se.singletonNone = new Se(!1);
  const We = Array.prototype.slice, Cn = Array.prototype.indexOf, ko = Array.prototype.push, jn = (p, y) => {
    return _ = p, T = y, Cn.call(_, T) > -1;
    var _, T;
  }, Xe = (p, y) => {
    for (let _ = 0, T = p.length; _ < T; _++)
      if (y(p[_], _))
        return !0;
    return !1;
  }, un = (p, y) => {
    const _ = [];
    for (let T = 0; T < p; T++)
      _.push(y(T));
    return _;
  }, M = (p, y) => {
    const _ = p.length, T = new Array(_);
    for (let P = 0; P < _; P++) {
      const I = p[P];
      T[P] = y(I, P);
    }
    return T;
  }, Et = (p, y) => {
    for (let _ = 0, T = p.length; _ < T; _++)
      y(p[_], _);
  }, ht = (p, y) => {
    const _ = [], T = [];
    for (let P = 0, I = p.length; P < I; P++) {
      const j = p[P];
      (y(j, P) ? _ : T).push(j);
    }
    return { pass: _, fail: T };
  }, mn = (p, y) => {
    const _ = [];
    for (let T = 0, P = p.length; T < P; T++) {
      const I = p[T];
      y(I, T) && _.push(I);
    }
    return _;
  }, lo = (p, y, _) => (((T, P) => {
    for (let I = T.length - 1; I >= 0; I--)
      P(T[I], I);
  })(p, (T, P) => {
    _ = y(_, T, P);
  }), _), dt = (p, y, _) => (Et(p, (T, P) => {
    _ = y(_, T, P);
  }), _), Bn = (p, y) => ((_, T, P) => {
    for (let I = 0, j = _.length; I < j; I++) {
      const Y = _[I];
      if (T(Y, I))
        return Se.some(Y);
      if (P(Y, I))
        break;
    }
    return Se.none();
  })(p, y, Ee), jr = (p, y) => {
    for (let _ = 0, T = p.length; _ < T; _++)
      if (y(p[_], _))
        return Se.some(_);
    return Se.none();
  }, Tt = (p) => {
    const y = [];
    for (let _ = 0, T = p.length; _ < T; ++_) {
      if (!he(p[_]))
        throw new Error("Arr.flatten item " + _ + " was not an array, input: " + p);
      ko.apply(y, p[_]);
    }
    return y;
  }, yo = (p, y) => Tt(M(p, y)), Ct = (p, y) => {
    for (let _ = 0, T = p.length; _ < T; ++_)
      if (y(p[_], _) !== !0)
        return !1;
    return !0;
  }, tn = (p, y) => {
    const _ = {};
    for (let T = 0, P = p.length; T < P; T++) {
      const I = p[T];
      _[String(I)] = y(I, T);
    }
    return _;
  }, oa = (p, y) => y >= 0 && y < p.length ? Se.some(p[y]) : Se.none(), Pn = (p) => oa(p, 0), Mo = (p) => oa(p, p.length - 1), K = (p, y) => {
    for (let _ = 0; _ < p.length; _++) {
      const T = y(p[_], _);
      if (T.isSome())
        return T;
    }
    return Se.none();
  }, Go = Object.keys, Zi = Object.hasOwnProperty, er = (p, y) => {
    const _ = Go(p);
    for (let T = 0, P = _.length; T < P; T++) {
      const I = _[T];
      y(p[I], I);
    }
  }, Qr = (p, y) => nc(p, (_, T) => ({ k: T, v: y(_, T) })), nc = (p, y) => {
    const _ = {};
    return er(p, (T, P) => {
      const I = y(T, P);
      _[I.k] = I.v;
    }), _;
  }, So = (p, y) => {
    const _ = [];
    return er(p, (T, P) => {
      _.push(y(T, P));
    }), _;
  }, cr = (p) => So(p, en), oo = (p, y) => Zi.call(p, y), ut = typeof window < "u" ? window : Function("return this;")(), kt = (p, y) => ((_, T) => {
    let P = T ?? ut;
    for (let I = 0; I < _.length && P != null; ++I)
      P = P[_[I]];
    return P;
  })(p.split("."), y), It = Object.getPrototypeOf, ct = (p) => {
    const y = kt("ownerDocument.defaultView", p);
    return ce(p) && (((_) => ((T, P) => {
      const I = ((j, Y) => kt(j, Y))(T, P);
      if (I == null)
        throw new Error(T + " not available on this browser");
      return I;
    })("HTMLElement", _))(y).prototype.isPrototypeOf(p) || /^HTML\w*Element$/.test(It(p).constructor.name));
  }, xn = (p) => p.dom.nodeName.toLowerCase(), co = (p) => p.dom.nodeType, Ko = (p) => (y) => co(y) === p, po = (p) => co(p) === 8 || xn(p) === "#comment", Ra = (p) => Mr(p) && ct(p.dom), Mr = Ko(1), ho = Ko(3), Ns = Ko(9), Ca = Ko(11), Zr = (p) => (y) => Mr(y) && xn(y) === p, $r = (p, y, _) => {
    if (!(ue(_) || Me(_) || jt(_)))
      throw console.error("Invalid call to Attribute.set. Key ", y, ":: Value ", _, ":: Element ", p), new Error("Attribute value was not simple");
    p.setAttribute(y, _ + "");
  }, Po = (p, y, _) => {
    $r(p.dom, y, _);
  }, ha = (p, y) => {
    const _ = p.dom;
    er(y, (T, P) => {
      $r(_, P, T);
    });
  }, ro = (p, y) => {
    const _ = p.dom.getAttribute(y);
    return _ === null ? void 0 : _;
  }, cn = (p, y) => Se.from(ro(p, y)), _n = (p, y) => {
    p.dom.removeAttribute(y);
  }, Ys = (p) => dt(p.dom.attributes, (y, _) => (y[_.name] = _.value, y), {}), Si = (p) => {
    if (p == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: p };
  }, Nt = { fromHtml: (p, y) => {
    const _ = (y || document).createElement("div");
    if (_.innerHTML = p, !_.hasChildNodes() || _.childNodes.length > 1) {
      const T = "HTML does not have a single root node";
      throw console.error(T, p), new Error(T);
    }
    return Si(_.childNodes[0]);
  }, fromTag: (p, y) => {
    const _ = (y || document).createElement(p);
    return Si(_);
  }, fromText: (p, y) => {
    const _ = (y || document).createTextNode(p);
    return Si(_);
  }, fromDom: Si, fromPoint: (p, y, _) => Se.from(p.dom.elementFromPoint(y, _)).map(Si) }, fi = (p, y) => {
    const _ = p.dom;
    if (_.nodeType !== 1)
      return !1;
    {
      const T = _;
      if (T.matches !== void 0)
        return T.matches(y);
      if (T.msMatchesSelector !== void 0)
        return T.msMatchesSelector(y);
      if (T.webkitMatchesSelector !== void 0)
        return T.webkitMatchesSelector(y);
      if (T.mozMatchesSelector !== void 0)
        return T.mozMatchesSelector(y);
      throw new Error("Browser lacks native selectors");
    }
  }, Zo = (p) => p.nodeType !== 1 && p.nodeType !== 9 && p.nodeType !== 11 || p.childElementCount === 0, mi = (p, y) => {
    const _ = y === void 0 ? document : y.dom;
    return Zo(_) ? Se.none() : Se.from(_.querySelector(p)).map(Nt.fromDom);
  }, kr = (p, y) => p.dom === y.dom, Qu = (p, y) => {
    const _ = p.dom, T = y.dom;
    return _ !== T && _.contains(T);
  }, ba = fi, xc = (p) => Nt.fromDom(p.dom.ownerDocument), _l = (p) => Ns(p) ? p : xc(p), Wi = (p) => Se.from(p.dom.parentNode).map(Nt.fromDom), oc = (p) => Se.from(p.dom.parentElement).map(Nt.fromDom), Hr = (p, y) => {
    const _ = yt(y) ? y : Ee;
    let T = p.dom;
    const P = [];
    for (; T.parentNode !== null && T.parentNode !== void 0; ) {
      const I = T.parentNode, j = Nt.fromDom(I);
      if (P.push(j), _(j) === !0)
        break;
      T = I;
    }
    return P;
  }, Yn = (p) => Se.from(p.dom.previousSibling).map(Nt.fromDom), qi = (p) => Se.from(p.dom.nextSibling).map(Nt.fromDom), Ei = (p) => M(p.dom.childNodes, Nt.fromDom), Cl = (p, y) => {
    const _ = p.dom.childNodes;
    return Se.from(_[y]).map(Nt.fromDom);
  }, Xc = (p, y) => {
    Wi(p).each((_) => {
      _.dom.insertBefore(y.dom, p.dom);
    });
  }, Xt = (p, y) => {
    qi(p).fold(() => {
      Wi(p).each((_) => {
        es(_, y);
      });
    }, (_) => {
      Xc(_, y);
    });
  }, Dd = (p, y) => {
    ((T) => Cl(T, 0))(p).fold(() => {
      es(p, y);
    }, (T) => {
      p.dom.insertBefore(y.dom, T.dom);
    });
  }, es = (p, y) => {
    p.dom.appendChild(y.dom);
  }, yf = (p, y) => {
    Xc(p, y), es(y, p);
  }, Rd = (p, y) => {
    Et(y, (_, T) => {
      const P = T === 0 ? p : y[T - 1];
      Xt(P, _);
    });
  }, Ti = (p, y) => {
    Et(y, (_) => {
      es(p, _);
    });
  }, wc = (p) => {
    p.dom.textContent = "", Et(Ei(p), (y) => {
      pi(y);
    });
  }, pi = (p) => {
    const y = p.dom;
    y.parentNode !== null && y.parentNode.removeChild(y);
  }, ra = (p) => {
    const y = Ei(p);
    y.length > 0 && Rd(p, y), pi(p);
  }, Gi = (p, y) => Nt.fromDom(p.dom.cloneNode(y)), vf = (p) => Gi(p, !1), rc = (p) => Gi(p, !0), tm = (p, y) => {
    const _ = Nt.fromTag(y), T = Ys(p);
    return ha(_, T), _;
  }, Sl = ["tfoot", "thead", "tbody", "colgroup"], Nd = (p, y, _) => ({ element: p, rowspan: y, colspan: _ }), tr = (p, y, _) => ({ element: p, cells: y, section: _ }), Ms = (p, y, _) => ({ element: p, isNew: y, isLocked: _ }), ni = (p, y, _, T) => ({ element: p, cells: y, section: _, isNew: T }), Jc = yt(Element.prototype.attachShadow) && yt(Node.prototype.getRootNode), Md = Rt(Jc), Bd = Jc ? (p) => Nt.fromDom(p.dom.getRootNode()) : _l, cl = (p) => Nt.fromDom(p.dom.host), sa = (p) => {
    const y = ho(p) ? p.dom.parentNode : p.dom;
    if (y == null || y.ownerDocument === null)
      return !1;
    const _ = y.ownerDocument;
    return ((I) => {
      const j = Bd(I);
      return Ca(Y = j) && Ye(Y.dom.host) ? Se.some(j) : Se.none();
      var Y;
    })(Nt.fromDom(y)).fold(() => _.body.contains(y), (T = sa, P = cl, (I) => T(P(I))));
    var T, P;
  }, nm = (p) => {
    const y = p.dom.body;
    if (y == null)
      throw new Error("Body is not available yet");
    return Nt.fromDom(y);
  }, _r = (p, y) => {
    let _ = [];
    return Et(Ei(p), (T) => {
      y(T) && (_ = _.concat([T])), _ = _.concat(_r(T, y));
    }), _;
  }, Dr = (p, y, _) => ((T, P, I) => mn(Hr(T, I), (j) => fi(j, y)))(p, 0, _), El = (p, y) => ((_, T) => mn(Ei(_), (P) => fi(P, y)))(p), ul = (p, y) => ((_, T) => {
    const P = T === void 0 ? document : T.dom;
    return Zo(P) ? [] : M(P.querySelectorAll(_), Nt.fromDom);
  })(y, p);
  var Lc = (p, y, _, T, P) => p(_, T) ? Se.some(_) : yt(P) && P(_) ? Se.none() : y(_, T, P);
  const kc = (p, y, _) => {
    let T = p.dom;
    const P = yt(_) ? _ : Ee;
    for (; T.parentNode; ) {
      T = T.parentNode;
      const I = Nt.fromDom(T);
      if (y(I))
        return Se.some(I);
      if (P(I))
        break;
    }
    return Se.none();
  }, gu = (p, y, _) => Lc((T, P) => P(T), kc, p, y, _), Na = (p, y, _) => kc(p, (T) => fi(T, y), _), us = (p, y) => ((_, T) => Bn(_.dom.childNodes, (P) => {
    return I = Nt.fromDom(P), fi(I, y);
    var I;
  }).map(Nt.fromDom))(p), Ma = (p, y) => mi(y, p), Us = (p, y, _) => Lc((T, P) => fi(T, P), Na, p, y, _), dl = (p, y, _ = Gt) => p.exists((T) => _(T, y)), Rr = (p) => {
    const y = [], _ = (T) => {
      y.push(T);
    };
    for (let T = 0; T < p.length; T++)
      p[T].each(_);
    return y;
  }, Wa = (p, y) => p ? Se.some(y) : Se.none(), zi = (p, y, _) => y === "" || p.length >= y.length && p.substr(_, _ + y.length) === y, qa = (p, y, _ = 0, T) => {
    const P = p.indexOf(y, _);
    return P !== -1 && (!!Ze(T) || P + y.length <= T);
  }, eo = (p, y) => zi(p, y, 0), gi = (p, y) => zi(p, y, p.length - y.length), js = ((p) => (y) => y.replace(p, ""))(/^\s+|\s+$/g), Sa = (p) => p.length > 0, Ki = (p) => p.style !== void 0 && yt(p.style.getPropertyValue), ts = (p, y, _) => {
    if (!ue(_))
      throw console.error("Invalid call to CSS.set. Property ", y, ":: Value ", _, ":: Element ", p), new Error("CSS value must be a string: " + _);
    Ki(p) && p.style.setProperty(y, _);
  }, Bs = (p, y, _) => {
    const T = p.dom;
    ts(T, y, _);
  }, sc = (p, y) => {
    const _ = p.dom;
    er(y, (T, P) => {
      ts(_, P, T);
    });
  }, qn = (p, y) => {
    const _ = p.dom, T = window.getComputedStyle(_).getPropertyValue(y);
    return T !== "" || sa(p) ? T : ac(_, y);
  }, ac = (p, y) => Ki(p) ? p.style.getPropertyValue(y) : "", Yi = (p, y) => {
    const _ = p.dom, T = ac(_, y);
    return Se.from(T).filter((P) => P.length > 0);
  }, Ts = (p, y) => {
    ((_, T) => {
      Ki(_) && _.style.removeProperty(T);
    })(p.dom, y), dl(cn(p, "style").map(js), "") && _n(p, "style");
  }, fl = (p, y, _ = 0) => cn(p, y).map((T) => parseInt(T, 10)).getOr(_), Xs = (p, y) => fl(p, y, 1), hu = (p) => Zr("col")(p) ? fl(p, "span", 1) > 1 : Xs(p, "colspan") > 1, xf = (p) => Xs(p, "rowspan") > 1, ar = (p, y) => parseInt(qn(p, y), 10), te = Rt(10), ze = Rt(10), Pe = (p, y) => Qe(p, y, wt), Qe = (p, y, _) => yo(Ei(p), (T) => fi(T, y) ? _(T) ? [T] : [] : Qe(T, y, _)), Ft = (p, y) => ((_, T, P = Ee) => P(T) ? Se.none() : jn(_, xn(T)) ? Se.some(T) : Na(T, _.join(","), (I) => fi(I, "table") || P(I)))(["td", "th"], p, y), An = (p) => Pe(p, "th,td"), so = (p) => fi(p, "colgroup") ? El(p, "col") : yo(ds(p), (y) => El(y, "col")), Zn = (p, y) => Us(p, "table", y), $n = (p) => Pe(p, "tr"), ds = (p) => Zn(p).fold(Rt([]), (y) => El(y, "colgroup")), Cr = (p, y) => M(p, (_) => {
    if (xn(_) === "colgroup") {
      const T = M(so(_), (P) => {
        const I = fl(P, "span", 1);
        return Nd(P, 1, I);
      });
      return tr(_, T, "colgroup");
    }
    {
      const T = M(An(_), (P) => {
        const I = fl(P, "rowspan", 1), j = fl(P, "colspan", 1);
        return Nd(P, I, j);
      });
      return tr(_, T, y(_));
    }
  }), Wr = (p) => Wi(p).map((y) => {
    const _ = xn(y);
    return ((T) => jn(Sl, T))(_) ? _ : "tbody";
  }).getOr("tbody"), Ba = (p) => {
    const y = $n(p), _ = [...ds(p), ...y];
    return Cr(_, Wr);
  }, ml = (p) => {
    let y, _ = !1;
    return (...T) => (_ || (_ = !0, y = p.apply(null, T)), y);
  }, nr = () => wf(0, 0), wf = (p, y) => ({ major: p, minor: y }), Qc = { nu: wf, detect: (p, y) => {
    const _ = String(y).toLowerCase();
    return p.length === 0 ? nr() : ((T, P) => {
      const I = ((Y, ne) => {
        for (let ve = 0; ve < Y.length; ve++) {
          const Ce = Y[ve];
          if (Ce.test(ne))
            return Ce;
        }
      })(T, P);
      if (!I)
        return { major: 0, minor: 0 };
      const j = (Y) => Number(P.replace(I, "$" + Y));
      return wf(j(1), j(2));
    })(p, _);
  }, unknown: nr }, Ga = (p, y) => {
    const _ = String(y).toLowerCase();
    return Bn(p, (T) => T.search(_));
  }, Ld = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, aa = (p) => (y) => qa(y, p), sg = [{ name: "Edge", versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/], search: (p) => qa(p, "edge/") && qa(p, "chrome") && qa(p, "safari") && qa(p, "applewebkit") }, { name: "Chromium", brand: "Chromium", versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, Ld], search: (p) => qa(p, "chrome") && !qa(p, "chromeframe") }, { name: "IE", versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/], search: (p) => qa(p, "msie") || qa(p, "trident") }, { name: "Opera", versionRegexes: [Ld, /.*?opera\/([0-9]+)\.([0-9]+).*/], search: aa("opera") }, { name: "Firefox", versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/], search: aa("firefox") }, { name: "Safari", versionRegexes: [Ld, /.*?cpu os ([0-9]+)_([0-9]+).*/], search: (p) => (qa(p, "safari") || qa(p, "mobile/")) && qa(p, "applewebkit") }], oi = [{ name: "Windows", search: aa("win"), versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/] }, { name: "iOS", search: (p) => qa(p, "iphone") || qa(p, "ipad"), versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/] }, { name: "Android", search: aa("android"), versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/] }, { name: "macOS", search: aa("mac os x"), versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/] }, { name: "Linux", search: aa("linux"), versionRegexes: [] }, { name: "Solaris", search: aa("sunos"), versionRegexes: [] }, { name: "FreeBSD", search: aa("freebsd"), versionRegexes: [] }, { name: "ChromeOS", search: aa("cros"), versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/] }], $l = { browsers: Rt(sg), oses: Rt(oi) }, kp = "Edge", oh = "Chromium", Ht = "Opera", Pd = "Firefox", _p = "Safari", ed = (p) => {
    const y = p.current, _ = p.version, T = (P) => () => y === P;
    return { current: y, version: _, isEdge: T(kp), isChromium: T(oh), isIE: T("IE"), isOpera: T(Ht), isFirefox: T(Pd), isSafari: T(_p) };
  }, ns = () => ed({ current: void 0, version: Qc.unknown() }), ag = ed, Xi = "Windows", Id = "Android", Cp = "Linux", Pc = "macOS", bu = "Solaris", rh = "FreeBSD", Ea = "ChromeOS", yu = (p) => {
    const y = p.current, _ = p.version, T = (P) => () => y === P;
    return { current: y, version: _, isWindows: T(Xi), isiOS: T("iOS"), isAndroid: T(Id), isMacOS: T(Pc), isLinux: T(Cp), isSolaris: T(bu), isFreeBSD: T(rh), isChromeOS: T(Ea) };
  }, ig = () => yu({ current: void 0, version: Qc.unknown() }), eu = yu, om = (p) => window.matchMedia(p).matches;
  let kf = ml(() => ((p, y, _) => {
    const T = $l.browsers(), P = $l.oses(), I = y.bind((ne) => ((ve, Ce) => K(Ce.brands, (ge) => {
      const Te = ge.brand.toLowerCase();
      return Bn(ve, (Ae) => {
        var Ge;
        return Te === ((Ge = Ae.brand) === null || Ge === void 0 ? void 0 : Ge.toLowerCase());
      }).map((Ae) => ({ current: Ae.name, version: Qc.nu(parseInt(ge.version, 10), 0) }));
    }))(T, ne)).orThunk(() => ((ne, ve) => Ga(ne, ve).map((Ce) => {
      const ge = Qc.detect(Ce.versionRegexes, ve);
      return { current: Ce.name, version: ge };
    }))(T, p)).fold(ns, ag), j = ((ne, ve) => Ga(ne, ve).map((Ce) => {
      const ge = Qc.detect(Ce.versionRegexes, ve);
      return { current: Ce.name, version: ge };
    }))(P, p).fold(ig, eu), Y = ((ne, ve, Ce, ge) => {
      const Te = ne.isiOS() && /ipad/i.test(Ce) === !0, Ae = ne.isiOS() && !Te, Ge = ne.isiOS() || ne.isAndroid(), $e = Ge || ge("(pointer:coarse)"), lt = Te || !Ae && Ge && ge("(min-device-width:768px)"), pt = Ae || Ge && !lt, Bt = ve.isSafari() && ne.isiOS() && /safari/i.test(Ce) === !1, xt = !pt && !lt && !Bt;
      return { isiPad: Rt(Te), isiPhone: Rt(Ae), isTablet: Rt(lt), isPhone: Rt(pt), isTouch: Rt($e), isAndroid: ne.isAndroid, isiOS: ne.isiOS, isWebView: Rt(Bt), isDesktop: Rt(xt) };
    })(j, I, p, _);
    return { browser: I, os: j, deviceType: Y };
  })(navigator.userAgent, Se.from(navigator.userAgentData), om));
  const _c = () => kf(), Ic = (p, y) => {
    const _ = (P) => {
      const I = y(P);
      if (I <= 0 || I === null) {
        const j = qn(P, p);
        return parseFloat(j) || 0;
      }
      return I;
    }, T = (P, I) => dt(I, (j, Y) => {
      const ne = qn(P, Y), ve = ne === void 0 ? 0 : parseInt(ne, 10);
      return isNaN(ve) ? j : j + ve;
    }, 0);
    return { set: (P, I) => {
      if (!jt(I) && !I.match(/^[0-9]+$/))
        throw new Error(p + ".set accepts only positive integer values. Value was " + I);
      const j = P.dom;
      Ki(j) && (j.style[p] = I + "px");
    }, get: _, getOuter: _, aggregate: T, max: (P, I, j) => {
      const Y = T(P, j);
      return I > Y ? I - Y : 0;
    } };
  }, Eo = (p, y, _) => ((T, P) => ((I) => {
    const j = parseFloat(I);
    return isNaN(j) ? Se.none() : Se.some(j);
  })(T).getOr(P))(qn(p, y), _), Fd = Ic("width", (p) => p.dom.offsetWidth), ia = (p) => Fd.get(p), td = (p) => Fd.getOuter(p), $d = (p) => ((y, _) => {
    const T = y.dom, P = T.getBoundingClientRect().width || T.offsetWidth;
    return _ === "border-box" ? P : ((I, j, Y, ne) => j - Eo(I, `padding-${Y}`, 0) - Eo(I, `padding-${ne}`, 0) - Eo(I, `border-${Y}-width`, 0) - Eo(I, `border-${ne}-width`, 0))(y, P, "left", "right");
  })(p, "content-box"), Ji = (p, y, _) => {
    const T = p.cells, P = T.slice(0, y), I = T.slice(y), j = P.concat(_).concat(I);
    return rm(p, j);
  }, Zs = (p, y, _) => Ji(p, y, [_]), nd = (p, y, _) => {
    p.cells[y] = _;
  }, rm = (p, y) => ni(p.element, y, p.section, p.isNew), ya = (p, y) => p.cells[y], Ls = (p, y) => ya(p, y).element, Vr = (p) => p.cells.length, zs = (p) => {
    const y = ht(p, (_) => _.section === "colgroup");
    return { rows: y.fail, cols: y.pass };
  }, Qi = (p, y, _) => {
    const T = M(p.cells, _);
    return ni(y(p.element), T, p.section, !0);
  }, Js = "data-snooker-locked-cols", La = (p) => cn(p, Js).bind((y) => Se.from(y.match(/\d+/g))).map((y) => tn(y, wt)), xs = (p) => {
    const y = dt(zs(p).rows, (T, P) => (Et(P.cells, (I, j) => {
      I.isLocked && (T[j] = !0);
    }), T), {}), _ = So(y, (T, P) => parseInt(P, 10));
    return ((T, P) => {
      const I = We.call(T, 0);
      return I.sort(void 0), I;
    })(_);
  }, Hd = (p, y) => p + "," + y, Ws = (p, y) => {
    const _ = yo(p.all, (T) => T.cells);
    return mn(_, y);
  }, va = (p) => {
    const y = {}, _ = [], T = Pn(p).map((Te) => Te.element).bind(Zn).bind(La).getOr({});
    let P = 0, I = 0, j = 0;
    const { pass: Y, fail: ne } = ht(p, (Te) => Te.section === "colgroup");
    Et(ne, (Te) => {
      const Ae = [];
      Et(Te.cells, (Ge) => {
        let $e = 0;
        for (; y[Hd(j, $e)] !== void 0; )
          $e++;
        const lt = ((Bt, xt) => oo(Bt, xt) && Bt[xt] !== void 0 && Bt[xt] !== null)(T, $e.toString()), pt = ((Bt, xt, Lt, Vt, rn, Vn) => ({ element: Bt, rowspan: xt, colspan: Lt, row: Vt, column: rn, isLocked: Vn }))(Ge.element, Ge.rowspan, Ge.colspan, j, $e, lt);
        for (let Bt = 0; Bt < Ge.colspan; Bt++)
          for (let xt = 0; xt < Ge.rowspan; xt++) {
            const Lt = $e + Bt, Vt = Hd(j + xt, Lt);
            y[Vt] = pt, I = Math.max(I, Lt + 1);
          }
        Ae.push(pt);
      }), P++, _.push(tr(Te.element, Ae, Te.section)), j++;
    });
    const { columns: ve, colgroups: Ce } = Mo(Y).map((Te) => {
      const Ae = (($e) => {
        const lt = {};
        let pt = 0;
        return Et($e.cells, (Bt) => {
          const xt = Bt.colspan;
          un(xt, (Lt) => {
            const Vt = pt + Lt;
            lt[Vt] = ((rn, Vn, Un) => ({ element: rn, colspan: Vn, column: Un }))(Bt.element, xt, Vt);
          }), pt += xt;
        }), lt;
      })(Te);
      return { colgroups: [(($e, lt) => ({ element: $e, columns: lt }))(Te.element, cr(Ae))], columns: Ae };
    }).getOrThunk(() => ({ colgroups: [], columns: {} }));
    return { grid: ((Te, Ae) => ({ rows: Te, columns: Ae }))(P, I), access: y, all: _, columns: ve, colgroups: Ce };
  }, la = (p) => {
    const y = Ba(p);
    return va(y);
  }, od = va, os = (p, y, _) => Se.from(p.access[Hd(y, _)]), sm = (p, y, _) => {
    const T = Ws(p, (P) => _(y, P.element));
    return T.length > 0 ? Se.some(T[0]) : Se.none();
  }, vu = Ws, Cc = (p) => yo(p.all, (y) => y.cells), To = (p) => cr(p.columns), ca = (p) => Go(p.columns).length > 0, rd = (p, y) => Se.from(p.columns[y]), Oi = (p, y = wt) => {
    const _ = p.grid, T = un(_.columns, en), P = un(_.rows, en);
    return M(T, (I) => Vd(() => yo(P, (j) => os(p, j, I).filter((Y) => Y.column === I).toArray()), (j) => j.colspan === 1 && y(j.element), () => os(p, 0, I)));
  }, Vd = (p, y, _) => {
    const T = p();
    return Bn(T, y).orThunk(() => Se.from(T[0]).orThunk(_)).map((P) => P.element);
  }, Fc = (p) => {
    const y = p.grid, _ = un(y.rows, en), T = un(y.columns, en);
    return M(_, (P) => Vd(() => yo(T, (I) => os(p, P, I).filter((j) => j.row === P).fold(Rt([]), (j) => [j])), (I) => I.rowspan === 1, () => os(p, P, 0)));
  }, xu = (p, y) => (_) => lg(_) === "rtl" ? y : p, lg = (p) => qn(p, "direction") === "rtl" ? "rtl" : "ltr", wu = Ic("height", (p) => {
    const y = p.dom;
    return sa(p) ? y.getBoundingClientRect().height : y.offsetHeight;
  }), ri = (p) => wu.get(p), Sp = (p) => wu.getOuter(p), be = (p, y) => ({ left: p, top: y, translate: (_, T) => be(p + _, y + T) }), Sc = be, Ai = (p, y) => p !== void 0 ? p : y !== void 0 ? y : 0, tu = (p) => {
    const y = p.dom.ownerDocument, _ = y.body, T = y.defaultView, P = y.documentElement;
    if (_ === p.dom)
      return Sc(_.offsetLeft, _.offsetTop);
    const I = Ai(T == null ? void 0 : T.pageYOffset, P.scrollTop), j = Ai(T == null ? void 0 : T.pageXOffset, P.scrollLeft), Y = Ai(P.clientTop, _.clientTop), ne = Ai(P.clientLeft, _.clientLeft);
    return _f(p).translate(j - ne, I - Y);
  }, _f = (p) => {
    const y = p.dom, _ = y.ownerDocument.body;
    return _ === y ? Sc(_.offsetLeft, _.offsetTop) : sa(p) ? ((T) => {
      const P = T.getBoundingClientRect();
      return Sc(P.left, P.top);
    })(y) : Sc(0, 0);
  }, sd = (p, y) => ({ row: p, y }), Le = (p, y) => ({ col: p, x: y }), Dt = (p) => tu(p).left + td(p), vt = (p) => tu(p).left, Sn = (p, y) => Le(p, vt(y)), Fo = (p, y) => Le(p, Dt(y)), ur = (p) => tu(p).top, Br = (p, y) => sd(p, ur(y)), Lr = (p, y) => sd(p, ur(y) + Sp(y)), hi = (p, y, _) => {
    if (_.length === 0)
      return [];
    const T = M(_.slice(1), (I, j) => I.map((Y) => p(j, Y))), P = _[_.length - 1].map((I) => y(_.length - 1, I));
    return T.concat([P]);
  }, Nn = { delta: en, positions: (p) => hi(Br, Lr, p), edge: ur }, Ps = xu({ delta: en, edge: vt, positions: (p) => hi(Sn, Fo, p) }, { delta: (p) => -p, edge: Dt, positions: (p) => hi(Fo, Sn, p) }), Di = { delta: (p, y) => Ps(y).delta(p, y), positions: (p, y) => Ps(y).positions(p, y), edge: (p) => Ps(p).edge(p) }, cg = { unsupportedLength: ["em", "ex", "cap", "ch", "ic", "rem", "lh", "rlh", "vw", "vh", "vi", "vb", "vmin", "vmax", "cm", "mm", "Q", "in", "pc", "pt", "px"], fixed: ["px", "pt"], relative: ["%"], empty: [""] }, Ec = (() => {
    const p = "[0-9]+", y = "[eE][+-]?" + p, _ = (P) => `(?:${P})?`, T = ["Infinity", p + "\\." + _(p) + _(y), "\\." + p + _(y), p + _(y)].join("|");
    return new RegExp(`^([+-]?(?:${T}))(.*)$`);
  })(), Pr = /(\d+(\.\d+)?)%/, Tc = /(\d+(\.\d+)?)px|em/, qr = Zr("col"), xa = (p, y, _) => {
    const T = oc(p).getOrThunk(() => nm(xc(p)));
    return y(p) / _(T) * 100;
  }, $c = (p, y) => {
    Bs(p, "width", y + "px");
  }, Ud = (p, y) => {
    Bs(p, "width", y + "%");
  }, am = (p, y) => {
    Bs(p, "height", y + "px");
  }, Ep = (p) => {
    const y = ((_) => {
      return Eo(T = _, "height", T.dom.offsetHeight) + "px";
      var T;
    })(p);
    return y ? ((_, T, P, I) => {
      const j = parseFloat(_);
      return gi(_, "%") && xn(T) !== "table" ? ((Y, ne, ve, Ce) => {
        const ge = Zn(Y).map((Te) => {
          const Ae = ve(Te);
          return Math.floor(ne / 100 * Ae);
        }).getOr(ne);
        return Ce(Y, ge), ge;
      })(T, j, P, I) : j;
    })(y, p, ri, am) : ri(p);
  }, ku = (p, y) => Yi(p, y).orThunk(() => cn(p, y).map((_) => _ + "px")), Tl = (p) => ku(p, "width"), pl = (p) => xa(p, ia, $d), Gr = (p) => {
    return qr(p) ? ia(p) : Eo(y = p, "width", y.dom.offsetWidth);
    var y;
  }, ic = (p) => ((y, _, T) => T(y) / Xs(y, "rowspan"))(p, 0, Ep), Ta = (p, y, _) => {
    Bs(p, "width", y + _);
  }, nu = (p) => xa(p, ia, $d) + "%", bi = Rt(Pr), ad = Zr("col"), Qs = (p) => Tl(p).getOrThunk(() => Gr(p) + "px"), ua = (p) => {
    return (y = p, ku(y, "height")).getOrThunk(() => ic(p) + "px");
    var y;
  }, si = (p, y, _, T, P, I) => p.filter(T).fold(() => I(((j, Y) => {
    if (Y < 0 || Y >= j.length - 1)
      return Se.none();
    const ne = j[Y].fold(() => {
      const Ce = ((ge) => {
        const Te = We.call(ge, 0);
        return Te.reverse(), Te;
      })(j.slice(0, Y));
      return K(Ce, (ge, Te) => ge.map((Ae) => ({ value: Ae, delta: Te + 1 })));
    }, (Ce) => Se.some({ value: Ce, delta: 0 })), ve = j[Y + 1].fold(() => {
      const Ce = j.slice(Y + 1);
      return K(Ce, (ge, Te) => ge.map((Ae) => ({ value: Ae, delta: Te + 1 })));
    }, (Ce) => Se.some({ value: Ce, delta: 1 }));
    return ne.bind((Ce) => ve.map((ge) => {
      const Te = ge.delta + Ce.delta;
      return Math.abs(ge.value - Ce.value) / Te;
    }));
  })(_, y)), (j) => P(j)), st = (p, y, _, T) => {
    const P = Oi(p), I = ca(p) ? ((ne) => M(To(ne), (ve) => Se.from(ve.element)))(p) : P, j = [Se.some(Di.edge(y))].concat(M(Di.positions(P, y), (ne) => ne.map((ve) => ve.x))), Y = an(hu);
    return M(I, (ne, ve) => si(ne, ve, j, Y, (Ce) => {
      if (((Te) => {
        const Ae = _c().browser, Ge = Ae.isChromium() || Ae.isFirefox();
        return !ad(Te) || Ge;
      })(Ce))
        return _(Ce);
      {
        const Te = (ge = P[ve]) != null ? en(ge) : Se.none();
        return si(Te, ve, j, Y, (Ae) => T(Se.some(ia(Ae))), T);
      }
      var ge;
    }, T));
  }, zl = (p) => p.map((y) => y + "px").getOr(""), Lm = (p, y, _) => st(p, y, Gr, (T) => T.getOrThunk(_.minCellWidth)), Is = (p, y, _, T, P) => {
    const I = Fc(p), j = [Se.some(_.edge(y))].concat(M(_.positions(I, y), (Y) => Y.map((ne) => ne.y)));
    return M(I, (Y, ne) => si(Y, ne, j, an(xf), T, P));
  }, Pa = (p, y) => () => sa(p) ? y(p) : parseFloat(Yi(p, "width").getOr("0")), Ia = (p) => {
    const y = Pa(p, (T) => parseFloat(nu(T))), _ = Pa(p, ia);
    return { width: y, pixelWidth: _, getWidths: (T, P) => ((I, j, Y) => st(I, j, pl, (ne) => ne.fold(() => Y.minCellWidth(), (ve) => ve / Y.pixelWidth() * 100)))(T, p, P), getCellDelta: (T) => T / _() * 100, singleColumnWidth: (T, P) => [100 - T], minCellWidth: () => te() / _() * 100, setElementWidth: Ud, adjustTableWidth: (T) => {
      const P = y();
      Ud(p, P + T / 100 * P);
    }, isRelative: !0, label: "percent" };
  }, el = (p) => {
    const y = Pa(p, ia);
    return { width: y, pixelWidth: y, getWidths: (_, T) => Lm(_, p, T), getCellDelta: en, singleColumnWidth: (_, T) => [Math.max(te(), _ + T) - _], minCellWidth: te, setElementWidth: $c, adjustTableWidth: (_) => {
      const T = y() + _;
      $c(p, T);
    }, isRelative: !1, label: "pixel" };
  }, jd = (p) => Tl(p).fold(() => ((y) => {
    const _ = Pa(y, ia), T = Rt(0);
    return { width: _, pixelWidth: _, getWidths: (P, I) => Lm(P, y, I), getCellDelta: T, singleColumnWidth: Rt([0]), minCellWidth: T, setElementWidth: it, adjustTableWidth: it, isRelative: !0, label: "none" };
  })(p), (y) => ((_, T) => bi().exec(T) !== null ? Ia(_) : el(_))(p, y)), Ka = el, pr = Ia, Hl = (p, y, _) => {
    const T = p[_].element, P = Nt.fromTag("td");
    es(P, Nt.fromTag("br")), (y ? es : Dd)(T, P);
  }, ea = ((p, y) => {
    const _ = (T) => p(T) ? Se.from(T.dom.nodeValue) : Se.none();
    return { get: (T) => {
      if (!p(T))
        throw new Error("Can only get text value of a text node");
      return _(T).getOr("");
    }, getOption: _, set: (T, P) => {
      if (!p(T))
        throw new Error("Can only set raw text value of a text node");
      T.dom.nodeValue = P;
    } };
  })(ho), Nr = (p) => ea.get(p), Pm = (p) => ea.getOption(p), Vl = (p, y) => ea.set(p, y), Ya = (p) => xn(p) === "img" ? 1 : Pm(p).fold(() => Ei(p).length, (y) => y.length), Ol = ["img", "br"], He = (p) => Pm(p).filter((y) => y.trim().length !== 0 || y.indexOf(" ") > -1).isSome() || jn(Ol, xn(p)) || ((y) => Ra(y) && ro(y, "contenteditable") === "false")(p), za = (p) => ((y, _) => {
    const T = (P) => {
      for (let I = 0; I < P.childNodes.length; I++) {
        const j = Nt.fromDom(P.childNodes[I]);
        if (_(j))
          return Se.some(j);
        const Y = T(P.childNodes[I]);
        if (Y.isSome())
          return Y;
      }
      return Se.none();
    };
    return T(y.dom);
  })(p, He), ou = (p) => Al(p, He), Al = (p, y) => {
    const _ = (T) => {
      const P = Ei(T);
      for (let I = P.length - 1; I >= 0; I--) {
        const j = P[I];
        if (y(j))
          return Se.some(j);
        const Y = _(j);
        if (Y.isSome())
          return Y;
      }
      return Se.none();
    };
    return _(p);
  }, Fs = { scope: ["row", "col"] }, rs = (p) => () => {
    const y = Nt.fromTag("td", p.dom);
    return es(y, Nt.fromTag("br", p.dom)), y;
  }, fs = (p) => () => Nt.fromTag("col", p.dom), Ir = (p) => () => Nt.fromTag("colgroup", p.dom), im = (p) => () => Nt.fromTag("tr", p.dom), Ln = (p, y, _) => {
    const T = ((P, I) => {
      const j = tm(P, I), Y = Ei(rc(P));
      return Ti(j, Y), j;
    })(p, y);
    return er(_, (P, I) => {
      P === null ? _n(T, I) : Po(T, I, P);
    }), T;
  }, Fa = (p) => p, yi = (p, y, _) => {
    const T = (P, I) => {
      ((j, Y) => {
        const ne = j.dom, ve = Y.dom;
        Ki(ne) && Ki(ve) && (ve.style.cssText = ne.style.cssText);
      })(P.element, I), Ts(I, "height"), P.colspan !== 1 && Ts(I, "width");
    };
    return { col: (P) => {
      const I = Nt.fromTag(xn(P.element), y.dom);
      return T(P, I), p(P.element, I), I;
    }, colgroup: Ir(y), row: im(y), cell: (P) => {
      const I = Nt.fromTag(xn(P.element), y.dom), j = _.getOr(["strong", "em", "b", "i", "span", "font", "h1", "h2", "h3", "h4", "h5", "h6", "p", "div"]), Y = j.length > 0 ? ((ne, ve, Ce) => za(ne).map((ge) => {
        const Te = Ce.join(","), Ae = Dr(ge, Te, (Ge) => kr(Ge, ne));
        return lo(Ae, (Ge, $e) => {
          const lt = vf($e);
          return es(Ge, lt), lt;
        }, ve);
      }).getOr(ve))(P.element, I, j) : I;
      return es(Y, Nt.fromTag("br")), T(P, I), ((ne, ve) => {
        er(Fs, (Ce, ge) => cn(ne, ge).filter((Te) => jn(Ce, Te)).each((Te) => Po(ve, ge, Te)));
      })(P.element, I), p(P.element, I), I;
    }, replace: Ln, colGap: fs(y), gap: rs(y) };
  }, dr = (p) => ({ col: fs(p), colgroup: Ir(p), row: im(p), cell: rs(p), replace: Fa, colGap: fs(p), gap: rs(p) }), wa = (p) => (y) => y.options.get(p), zc = "100%", lc = (p) => {
    var y;
    const _ = p.dom, T = (y = _.getParent(p.selection.getStart(), _.isBlock)) !== null && y !== void 0 ? y : p.getBody();
    return $d(Nt.fromDom(T)) + "px";
  }, de = (p) => Se.from(p.options.get("table_clone_elements")), Hc = wa("table_header_type"), Oc = wa("table_column_resizing"), ls = (p) => Oc(p) === "preservetable", Yo = (p) => Oc(p) === "resizetable", id = wa("table_sizing_mode"), Ac = (p) => id(p) === "relative", Cf = (p) => id(p) === "fixed", da = (p) => id(p) === "responsive", z = wa("table_resize_bars"), F = wa("table_style_by_css"), X = wa("table_merge_content_on_paste"), _e = (p) => {
    const y = p.options, _ = y.get("table_default_attributes");
    return y.isSet("table_default_attributes") ? _ : ((T, P) => da(T) || F(T) ? P : Cf(T) ? { ...P, width: lc(T) } : { ...P, width: zc })(p, _);
  }, Oe = wa("table_use_colgroups"), zt = (p) => Us(p, "[contenteditable]"), bn = (p, y = !1) => sa(p) ? p.dom.isContentEditable : zt(p).fold(Rt(y), (_) => ao(_) === "true"), ao = (p) => p.dom.contentEditable, Hn = (p) => Nt.fromDom(p.getBody()), En = (p) => (y) => kr(y, Hn(p)), yr = (p) => {
    _n(p, "data-mce-style");
    const y = (_) => _n(_, "data-mce-style");
    Et(An(p), y), Et(so(p), y), Et($n(p), y);
  }, ws = (p) => Nt.fromDom(p.selection.getStart()), Ri = (p) => p.getBoundingClientRect().width, _u = (p) => p.getBoundingClientRect().height, Ni = (p) => gu(p, Zr("table")).exists(bn), ka = (p, y) => {
    const _ = y.column, T = y.column + y.colspan - 1, P = y.row, I = y.row + y.rowspan - 1;
    return _ <= p.finishCol && T >= p.startCol && P <= p.finishRow && I >= p.startRow;
  }, vi = (p, y) => y.column >= p.startCol && y.column + y.colspan - 1 <= p.finishCol && y.row >= p.startRow && y.row + y.rowspan - 1 <= p.finishRow, Mi = (p, y, _) => {
    const T = sm(p, y, kr), P = sm(p, _, kr);
    return T.bind((I) => P.map((j) => {
      return Y = I, ne = j, { startRow: Math.min(Y.row, ne.row), startCol: Math.min(Y.column, ne.column), finishRow: Math.max(Y.row + Y.rowspan - 1, ne.row + ne.rowspan - 1), finishCol: Math.max(Y.column + Y.colspan - 1, ne.column + ne.colspan - 1) };
      var Y, ne;
    }));
  }, Im = (p, y, _) => Mi(p, y, _).map((T) => {
    const P = vu(p, gt(ka, T));
    return M(P, (I) => I.element);
  }), wn = (p, y) => sm(p, y, (_, T) => Qu(T, _)).map((_) => _.element), ta = (p, y, _) => {
    const T = Vc(p);
    return Im(T, y, _);
  }, gl = (p, y, _, T, P) => {
    const I = Vc(p), j = kr(p, _) ? Se.some(y) : wn(I, y), Y = kr(p, P) ? Se.some(T) : wn(I, T);
    return j.bind((ne) => Y.bind((ve) => Im(I, ne, ve)));
  }, Vc = la;
  var Ul = ["body", "p", "div", "article", "aside", "figcaption", "figure", "footer", "header", "nav", "section", "ol", "ul", "li", "table", "thead", "tbody", "tfoot", "caption", "tr", "td", "th", "h1", "h2", "h3", "h4", "h5", "h6", "blockquote", "pre", "address"], Zd = () => ({ up: Rt({ selector: Na, closest: Us, predicate: kc, all: Hr }), down: Rt({ selector: ul, predicate: _r }), styles: Rt({ get: qn, getRaw: Yi, set: Bs, remove: Ts }), attrs: Rt({ get: ro, set: Po, remove: _n, copyTo: (p, y) => {
    const _ = Ys(p);
    ha(y, _);
  } }), insert: Rt({ before: Xc, after: Xt, afterAll: Rd, append: es, appendAll: Ti, prepend: Dd, wrap: yf }), remove: Rt({ unwrap: ra, remove: pi }), create: Rt({ nu: Nt.fromTag, clone: (p) => Nt.fromDom(p.dom.cloneNode(!1)), text: Nt.fromText }), query: Rt({ comparePosition: (p, y) => p.dom.compareDocumentPosition(y.dom), prevSibling: Yn, nextSibling: qi }), property: Rt({ children: Ei, name: xn, parent: Wi, document: (p) => _l(p).dom, isText: ho, isComment: po, isElement: Mr, isSpecial: (p) => {
    const y = xn(p);
    return jn(["script", "noscript", "iframe", "noframes", "noembed", "title", "style", "textarea", "xmp"], y);
  }, getLanguage: (p) => Mr(p) ? cn(p, "lang") : Se.none(), getText: Nr, setText: Vl, isBoundary: (p) => !!Mr(p) && (xn(p) === "body" || jn(Ul, xn(p))), isEmptyTag: (p) => !!Mr(p) && jn(["br", "img", "hr", "input"], xn(p)), isNonEditable: (p) => Mr(p) && ro(p, "contenteditable") === "false" }), eq: kr, is: ba });
  const Tp = (p, y, _, T) => {
    const P = y(p, _);
    return lo(T, (I, j) => {
      const Y = y(p, j);
      return ug(p, I, Y);
    }, P);
  }, ug = (p, y, _) => y.bind((T) => _.filter(gt(p.eq, T))), ru = Zd(), sh = (p, y) => ((_, T, P) => P.length > 0 ? ((I, j, Y, ne) => ne(I, j, Y[0], Y.slice(1)))(_, T, P, Tp) : Se.none())(ru, (_, T) => p(T), y), Cu = (p) => Na(p, "table"), Wd = (p, y, _) => {
    const T = (P) => (I) => _ !== void 0 && _(I) || kr(I, P);
    return kr(p, y) ? Se.some({ boxes: Se.some([p]), start: p, finish: y }) : Cu(p).bind((P) => Cu(y).bind((I) => {
      if (kr(P, I))
        return Se.some({ boxes: ta(P, p, y), start: p, finish: y });
      if (Qu(P, I)) {
        const j = Dr(y, "td,th", T(P)), Y = j.length > 0 ? j[j.length - 1] : y;
        return Se.some({ boxes: gl(P, p, P, y, I), start: p, finish: Y });
      }
      if (Qu(I, P)) {
        const j = Dr(p, "td,th", T(I)), Y = j.length > 0 ? j[j.length - 1] : p;
        return Se.some({ boxes: gl(I, p, P, y, I), start: p, finish: Y });
      }
      return ((j, Y, ne) => ((ve, Ce, ge, Te = Ee) => {
        const Ae = [Ce].concat(ve.up().all(Ce)), Ge = [ge].concat(ve.up().all(ge)), $e = (xt) => jr(xt, Te).fold(() => xt, (Lt) => xt.slice(0, Lt + 1)), lt = $e(Ae), pt = $e(Ge), Bt = Bn(lt, (xt) => Xe(pt, ((Lt, Vt) => gt(Lt.eq, Vt))(ve, xt)));
        return { firstpath: lt, secondpath: pt, shared: Bt };
      })(ru, j, Y, void 0))(p, y).shared.bind((j) => Us(j, "table", _).bind((Y) => {
        const ne = Dr(y, "td,th", T(Y)), ve = ne.length > 0 ? ne[ne.length - 1] : y, Ce = Dr(p, "td,th", T(Y)), ge = Ce.length > 0 ? Ce[Ce.length - 1] : p;
        return Se.some({ boxes: gl(Y, p, P, y, I), start: ge, finish: ve });
      }));
    }));
  }, Uc = (p, y) => {
    const _ = ul(p, y);
    return _.length > 0 ? Se.some(_) : Se.none();
  }, At = (p, y, _) => Ma(p, y).bind((T) => Ma(p, _).bind((P) => sh(Cu, [T, P]).map((I) => ({ first: T, last: P, table: I })))), Fm = (p, y, _, T, P) => ((I, j) => Bn(I, (Y) => fi(Y, j)))(p, P).bind((I) => ((j, Y, ne) => Zn(j).bind((ve) => ((Ce, ge, Te, Ae) => sm(Ce, ge, kr).bind((Ge) => {
    const $e = Te > 0 ? Ge.row + Ge.rowspan - 1 : Ge.row, lt = Ae > 0 ? Ge.column + Ge.colspan - 1 : Ge.column;
    return os(Ce, $e + Te, lt + Ae).map((pt) => pt.element);
  }))(Vc(ve), j, Y, ne)))(I, y, _).bind((j) => ((Y, ne) => Na(Y, "table").bind((ve) => Ma(ve, ne).bind((Ce) => Wd(Ce, Y).bind((ge) => ge.boxes.map((Te) => ({ boxes: Te, start: ge.start, finish: ge.finish }))))))(j, T))), qd = (p, y) => Uc(p, y), Gd = (p, y, _) => At(p, y, _).bind((T) => {
    const P = (ne) => kr(p, ne), I = "thead,tfoot,tbody,table", j = Na(T.first, I, P), Y = Na(T.last, I, P);
    return j.bind((ne) => Y.bind((ve) => kr(ne, ve) ? ((Ce, ge, Te) => ((Ae, Ge, $e) => Mi(Ae, Ge, $e).bind((lt) => ((pt, Bt) => {
      let xt = !0;
      const Lt = gt(vi, Bt);
      for (let Vt = Bt.startRow; Vt <= Bt.finishRow; Vt++)
        for (let rn = Bt.startCol; rn <= Bt.finishCol; rn++)
          xt = xt && os(pt, Vt, rn).exists(Lt);
      return xt ? Se.some(Bt) : Se.none();
    })(Ae, lt)))(Vc(Ce), ge, Te))(T.table, T.first, T.last) : Se.none()));
  }), Dl = en, lm = (p) => {
    const y = (_, T) => cn(_, T).exists((P) => parseInt(P, 10) > 1);
    return p.length > 0 && Ct(p, (_) => y(_, "rowspan") || y(_, "colspan")) ? Se.some(p) : Se.none();
  }, cs = (p, y, _) => y.length <= 1 ? Se.none() : Gd(p, _.firstSelectedSelector, _.lastSelectedSelector).map((T) => ({ bounds: T, cells: y })), Rl = "data-mce-selected", cc = "data-mce-first-selected", Kr = "data-mce-last-selected", Sf = "[" + Rl + "]", Io = { selected: Rl, selectedSelector: "td[" + Rl + "],th[" + Rl + "]", firstSelected: cc, firstSelectedSelector: "td[" + cc + "],th[" + cc + "]", lastSelected: Kr, lastSelectedSelector: "td[" + Kr + "],th[" + Kr + "]" }, pn = (p, y, _) => ({ element: _, mergable: cs(y, p, Io), unmergable: lm(p), selection: Dl(p) }), Kd = (p) => (y, _) => {
    const T = xn(y), P = T === "col" || T === "colgroup" ? Zn(I = y).bind((j) => qd(j, Io.firstSelectedSelector)).fold(Rt(I), (j) => j[0]) : y;
    var I;
    return Us(P, p, _);
  }, zp = Kd("th,td,caption"), Ef = Kd("th,td"), uc = (p) => {
    return y = p.model.table.getSelectedCells(), M(y, Nt.fromDom);
    var y;
  }, Bo = (p, y) => {
    p.on("BeforeGetContent", (_) => {
      const T = (P) => {
        _.preventDefault(), ((I) => Zn(I[0]).map((j) => {
          const Y = ((ne, ve) => {
            const Ce = (xt) => fi(xt.element, ve), ge = rc(ne), Te = Ba(ge), Ae = jd(ne), Ge = od(Te), $e = ((xt, Lt) => {
              const Vt = xt.grid.columns;
              let rn = xt.grid.rows, Vn = Vt, Un = 0, Do = 0;
              const Gn = [], Ro = [];
              return er(xt.access, (xo) => {
                if (Gn.push(xo), Lt(xo)) {
                  Ro.push(xo);
                  const zr = xo.row, Wt = zr + xo.rowspan - 1, Hi = xo.column, ja = Hi + xo.colspan - 1;
                  zr < rn ? rn = zr : Wt > Un && (Un = Wt), Hi < Vn ? Vn = Hi : ja > Do && (Do = ja);
                }
              }), ((xo, zr, Wt, Hi, ja, ai) => ({ minRow: xo, minCol: zr, maxRow: Wt, maxCol: Hi, allCells: ja, selectedCells: ai }))(rn, Vn, Un, Do, Gn, Ro);
            })(Ge, Ce), lt = "th:not(" + ve + "),td:not(" + ve + ")", pt = Qe(ge, "th,td", (xt) => fi(xt, lt));
            Et(pt, pi), ((xt, Lt, Vt, rn) => {
              const Vn = mn(xt, (Gn) => Gn.section !== "colgroup"), Un = Lt.grid.columns, Do = Lt.grid.rows;
              for (let Gn = 0; Gn < Do; Gn++) {
                let Ro = !1;
                for (let xo = 0; xo < Un; xo++)
                  Gn < Vt.minRow || Gn > Vt.maxRow || xo < Vt.minCol || xo > Vt.maxCol || (os(Lt, Gn, xo).filter(rn).isNone() ? Hl(Vn, Ro, Gn) : Ro = !0);
              }
            })(Te, Ge, $e, Ce);
            const Bt = ((xt, Lt, Vt, rn) => {
              if (rn.minCol === 0 && Lt.grid.columns === rn.maxCol + 1)
                return 0;
              const Vn = Lm(Lt, xt, Vt), Un = dt(Vn, (Ro, xo) => Ro + xo, 0), Do = dt(Vn.slice(rn.minCol, rn.maxCol + 1), (Ro, xo) => Ro + xo, 0), Gn = Do / Un * Vt.pixelWidth() - Vt.pixelWidth();
              return Vt.getCellDelta(Gn);
            })(ne, la(ne), Ae, $e);
            return ((xt, Lt, Vt, rn) => {
              er(Vt.columns, (Un) => {
                (Un.column < Lt.minCol || Un.column > Lt.maxCol) && pi(Un.element);
              });
              const Vn = mn(Pe(xt, "tr"), (Un) => Un.dom.childElementCount === 0);
              Et(Vn, pi), Lt.minCol !== Lt.maxCol && Lt.minRow !== Lt.maxRow || Et(Pe(xt, "th,td"), (Un) => {
                _n(Un, "rowspan"), _n(Un, "colspan");
              }), _n(xt, Js), _n(xt, "data-snooker-col-series"), jd(xt).adjustTableWidth(rn);
            })(ge, $e, Ge, Bt), ge;
          })(j, Sf);
          return yr(Y), [Y];
        }))(P).each((I) => {
          _.content = _.format === "text" ? ((j) => M(j, (Y) => Y.dom.innerText).join(""))(I) : ((j, Y) => M(Y, (ne) => j.selection.serializer.serialize(ne.dom, {})).join(""))(p, I);
        });
      };
      if (_.selection === !0) {
        const P = ((I) => mn(uc(I), (j) => fi(j, Io.selectedSelector)))(p);
        P.length >= 1 && T(P);
      }
    }), p.on("BeforeSetContent", (_) => {
      if (_.selection === !0 && _.paste === !0) {
        const T = uc(p);
        Pn(T).each((P) => {
          Zn(P).each((I) => {
            const j = mn(((ne, ve) => {
              const Ce = document.createElement("div");
              return Ce.innerHTML = ne, Ei(Nt.fromDom(Ce));
            })(_.content), (ne) => xn(ne) !== "meta"), Y = Zr("table");
            if (X(p) && j.length === 1 && Y(j[0])) {
              _.preventDefault();
              const ne = Nt.fromDom(p.getDoc()), ve = dr(ne), Ce = ((ge, Te, Ae) => ({ element: ge, clipboard: Te, generators: Ae }))(P, j[0], ve);
              y.pasteCells(I, Ce).each(() => {
                p.focus();
              });
            }
          });
        });
      }
    });
  }, $a = (p, y) => ({ element: p, offset: y }), $m = (p, y, _) => p.property().isText(y) && p.property().getText(y).trim().length === 0 || p.property().isComment(y) ? _(y).bind((T) => $m(p, T, _).orThunk(() => Se.some(T))) : Se.none(), ft = (p, y) => p.property().isText(y) ? p.property().getText(y).length : p.property().children(y).length, dc = (p, y) => {
    const _ = $m(p, y, p.query().prevSibling).getOr(y);
    if (p.property().isText(_))
      return $a(_, ft(p, _));
    const T = p.property().children(_);
    return T.length > 0 ? dc(p, T[T.length - 1]) : $a(_, ft(p, _));
  }, ld = dc, cd = Zd(), Yd = (p, y) => {
    hu(p) || ((T) => Tl(T).bind((P) => {
      return I = P, j = ["fixed", "relative", "empty"], Se.from(Ec.exec(I)).bind((Y) => {
        const ne = Number(Y[1]), ve = Y[2];
        return ((Ce, ge) => Xe(ge, (Te) => Xe(cg[Te], (Ae) => Ce === Ae)))(ve, j) ? Se.some({ value: ne, unit: ve }) : Se.none();
      });
      var I, j;
    }))(p).each((T) => {
      const P = T.value / 2;
      Ta(p, P, T.unit), Ta(y, P, T.unit);
    });
  }, Su = (p) => M(p, Rt(0)), jl = (p, y, _, T, P) => P(p.slice(0, y)).concat(T).concat(P(p.slice(_))), Xd = (p) => (y, _, T, P) => {
    if (p(T)) {
      const I = Math.max(P, y[_] - Math.abs(T)), j = Math.abs(I - y[_]);
      return T >= 0 ? j : -j;
    }
    return T;
  }, ss = Xd((p) => p < 0), ud = Xd(wt), eb = () => {
    const p = (_, T, P, I) => {
      const j = (100 + P) / 100, Y = Math.max(I, (_[T] + P) / j);
      return M(_, (ne, ve) => (ve === T ? Y : ne / j) - ne);
    }, y = (_, T, P, I, j, Y) => Y ? p(_, T, I, j) : ((ne, ve, Ce, ge, Te) => {
      const Ae = ss(ne, ve, ge, Te);
      return jl(ne, ve, Ce + 1, [Ae, 0], Su);
    })(_, T, P, I, j);
    return { resizeTable: (_, T) => _(T), clampTableDelta: ss, calcLeftEdgeDeltas: y, calcMiddleDeltas: (_, T, P, I, j, Y, ne) => y(_, P, I, j, Y, ne), calcRightEdgeDeltas: (_, T, P, I, j, Y) => {
      if (Y)
        return p(_, P, I, j);
      {
        const ne = ss(_, P, I, j);
        return Su(_.slice(0, P)).concat([ne]);
      }
    }, calcRedestributedWidths: (_, T, P, I) => {
      if (I) {
        const j = (T + P) / T, Y = M(_, (ne) => ne / j);
        return { delta: 100 * j - 100, newSizes: Y };
      }
      return { delta: P, newSizes: _ };
    } };
  }, hl = () => {
    const p = (y, _, T, P, I) => {
      const j = ud(y, P >= 0 ? T : _, P, I);
      return jl(y, _, T + 1, [j, -j], Su);
    };
    return { resizeTable: (y, _, T) => {
      T && y(_);
    }, clampTableDelta: (y, _, T, P, I) => {
      if (I) {
        if (T >= 0)
          return T;
        {
          const j = dt(y, (Y, ne) => Y + ne - P, 0);
          return Math.max(-j, T);
        }
      }
      return ss(y, _, T, P);
    }, calcLeftEdgeDeltas: p, calcMiddleDeltas: (y, _, T, P, I, j) => p(y, T, P, I, j), calcRightEdgeDeltas: (y, _, T, P, I, j) => {
      if (j)
        return Su(y);
      {
        const Y = P / y.length;
        return M(y, Rt(Y));
      }
    }, calcRedestributedWidths: (y, _, T, P) => ({ delta: 0, newSizes: y }) };
  }, Hm = (p) => la(p).grid, tl = Zr("th"), cm = (p) => Ct(p, (y) => tl(y.element)), Eu = (p, y) => p && y ? "sectionCells" : p ? "section" : "cells", Jd = (p) => {
    const y = p.section === "thead", _ = dl(Tu(p.cells), "th");
    return p.section === "tfoot" ? { type: "footer" } : y || _ ? { type: "header", subType: Eu(y, _) } : { type: "body" };
  }, Tu = (p) => {
    const y = mn(p, (_) => tl(_.element));
    return y.length === 0 ? Se.some("td") : y.length === p.length ? Se.some("th") : Se.none();
  }, Tf = (p, y, _) => Ms(_(p.element, y), !0, p.isLocked), um = (p, y) => p.section !== y ? ni(p.element, p.cells, y, p.isNew) : p, hn = () => ({ transformRow: um, transformCell: (p, y, _) => {
    const T = _(p.element, y), P = xn(T) !== "td" ? ((I, j) => {
      const Y = tm(I, "td");
      Xt(I, Y);
      const ne = Ei(I);
      return Ti(Y, ne), pi(I), Y;
    })(T) : T;
    return Ms(P, p.isNew, p.isLocked);
  } }), Op = () => ({ transformRow: um, transformCell: Tf }), Vm = () => ({ transformRow: (p, y) => um(p, y === "thead" ? "tbody" : y), transformCell: Tf }), zf = hn, tb = Op, C = Vm, R = () => ({ transformRow: en, transformCell: Tf }), q = (p, y, _, T) => {
    _ === T ? _n(p, y) : Po(p, y, _);
  }, se = (p, y, _) => {
    Mo(El(p, y)).fold(() => Dd(p, _), (T) => Xt(T, _));
  }, De = (p, y) => {
    const _ = [], T = [], P = (Te) => M(Te, (Ae) => {
      Ae.isNew && _.push(Ae.element);
      const Ge = Ae.element;
      return wc(Ge), Et(Ae.cells, ($e) => {
        $e.isNew && T.push($e.element), q($e.element, "colspan", $e.colspan, 1), q($e.element, "rowspan", $e.rowspan, 1), es(Ge, $e.element);
      }), Ge;
    }), I = (Te) => yo(Te, (Ae) => M(Ae.cells, (Ge) => (q(Ge.element, "span", Ge.colspan, 1), Ge.element))), j = (Te, Ae) => {
      const Ge = ((lt, pt) => {
        const Bt = us(lt, pt).getOrThunk(() => {
          const xt = Nt.fromTag(pt, xc(lt).dom);
          return pt === "thead" ? se(lt, "caption,colgroup", xt) : pt === "colgroup" ? se(lt, "caption", xt) : es(lt, xt), xt;
        });
        return wc(Bt), Bt;
      })(p, Ae), $e = (Ae === "colgroup" ? I : P)(Te);
      Ti(Ge, $e);
    }, Y = (Te, Ae) => {
      Te.length > 0 ? j(Te, Ae) : ((Ge) => {
        us(p, Ge).each(pi);
      })(Ae);
    }, ne = [], ve = [], Ce = [], ge = [];
    return Et(y, (Te) => {
      switch (Te.section) {
        case "thead":
          ne.push(Te);
          break;
        case "tbody":
          ve.push(Te);
          break;
        case "tfoot":
          Ce.push(Te);
          break;
        case "colgroup":
          ge.push(Te);
      }
    }), Y(ge, "colgroup"), Y(ne, "thead"), Y(ve, "tbody"), Y(Ce, "tfoot"), { newRows: _, newCells: T };
  }, rt = (p, y) => {
    if (p.length === 0)
      return 0;
    const _ = p[0];
    return jr(p, (T) => !y(_.element, T.element)).getOr(p.length);
  }, Pt = (p, y) => {
    const _ = M(p, (T) => M(T.cells, Ee));
    return M(p, (T, P) => {
      const I = yo(T.cells, (j, Y) => {
        if (_[P][Y] === !1) {
          const Te = ((Ae, Ge, $e, lt) => {
            const pt = ((Vt, rn) => Vt[rn])(Ae, Ge), Bt = pt.section === "colgroup", xt = rt(pt.cells.slice($e), lt), Lt = Bt ? 1 : rt(((Vt, rn) => M(Vt, (Vn) => ya(Vn, rn)))(Ae.slice(Ge), $e), lt);
            return { colspan: xt, rowspan: Lt };
          })(p, P, Y, y);
          return ((Ae, Ge, $e, lt) => {
            for (let pt = Ae; pt < Ae + $e; pt++)
              for (let Bt = Ge; Bt < Ge + lt; Bt++)
                _[pt][Bt] = !0;
          })(P, Y, Te.rowspan, Te.colspan), [(ne = j.element, ve = Te.rowspan, Ce = Te.colspan, ge = j.isNew, { element: ne, rowspan: ve, colspan: Ce, isNew: ge })];
        }
        return [];
        var ne, ve, Ce, ge;
      });
      return ((j, Y, ne, ve) => ({ element: j, cells: Y, section: ne, isNew: ve }))(T.element, I, T.section, T.isNew);
    });
  }, on = (p, y, _) => {
    const T = [];
    Et(p.colgroups, (P) => {
      const I = [];
      for (let j = 0; j < p.grid.columns; j++) {
        const Y = rd(p, j).map((ne) => Ms(ne.element, _, !1)).getOrThunk(() => Ms(y.colGap(), !0, !1));
        I.push(Y);
      }
      T.push(ni(P.element, I, "colgroup", _));
    });
    for (let P = 0; P < p.grid.rows; P++) {
      const I = [];
      for (let ne = 0; ne < p.grid.columns; ne++) {
        const ve = os(p, P, ne).map((Ce) => Ms(Ce.element, _, Ce.isLocked)).getOrThunk(() => Ms(y.gap(), !0, !1));
        I.push(ve);
      }
      const j = p.all[P], Y = ni(j.element, I, j.section, _);
      T.push(Y);
    }
    return T;
  }, Tn = (p) => Pt(p, kr), uo = (p, y) => K(p.all, (_) => Bn(_.cells, (T) => kr(y, T.element))), ks = (p, y, _) => {
    const T = M(y.selection, (I) => Ft(I).bind((j) => uo(p, j)).filter(_)), P = Rr(T);
    return Wa(P.length > 0, P);
  }, _o = (p, y, _, T, P) => (I, j, Y, ne) => {
    const ve = la(I), Ce = Se.from(ne == null ? void 0 : ne.section).getOrThunk(R);
    return y(ve, j).map((ge) => {
      const Te = (($e, lt) => on($e, lt, !1))(ve, Y), Ae = p(Te, ge, kr, P(Y), Ce), Ge = xs(Ae.grid);
      return { info: ge, grid: Tn(Ae.grid), cursor: Ae.cursor, lockedColumns: Ge };
    }).bind((ge) => {
      const Te = De(I, ge.grid), Ae = Se.from(ne == null ? void 0 : ne.sizing).getOrThunk(() => jd(I)), Ge = Se.from(ne == null ? void 0 : ne.resize).getOrThunk(hl);
      return _(I, ge.grid, ge.info, { sizing: Ae, resize: Ge, section: Ce }), T(I), _n(I, Js), ge.lockedColumns.length > 0 && Po(I, Js, ge.lockedColumns.join(",")), Se.some({ cursor: ge.cursor, newRows: Te.newRows, newCells: Te.newCells });
    });
  }, fr = (p, y) => ks(p, y, wt).map((_) => ({ cells: _, generators: y.generators, clipboard: y.clipboard })), as = (p, y) => ks(p, y, wt), Ha = (p, y) => ks(p, y, (_) => !_.isLocked), Xa = (p, y) => Ct(y, (_) => ((T, P) => uo(T, P).exists((I) => !I.isLocked))(p, _)), su = (p, y, _, T) => {
    const P = zs(p).rows;
    let I = !0;
    for (let j = 0; j < P.length; j++)
      for (let Y = 0; Y < Vr(P[0]); Y++) {
        const ne = P[j], ve = ya(ne, Y), Ce = _(ve.element, y);
        Ce && !I ? nd(ne, Y, Ms(T(), !0, ve.isLocked)) : Ce && (I = !1);
      }
    return p;
  }, Um = (p) => {
    const y = (I) => I(p), _ = Rt(p), T = () => P, P = { tag: !0, inner: p, fold: (I, j) => j(p), isValue: wt, isError: Ee, map: (I) => or.value(I(p)), mapError: T, bind: y, exists: y, forall: y, getOr: _, or: T, getOrThunk: _, orThunk: T, getOrDie: _, each: (I) => {
      I(p);
    }, toOptional: () => Se.some(p) };
    return P;
  }, Of = (p) => {
    const y = () => _, _ = { tag: !1, inner: p, fold: (P, I) => P(p), isValue: Ee, isError: wt, map: y, mapError: (P) => or.error(P(p)), bind: y, exists: Ee, forall: wt, getOr: en, or: en, getOrThunk: Ot, orThunk: Ot, getOrDie: (T = String(p), () => {
      throw new Error(T);
    }), each: it, toOptional: Se.none };
    var T;
    return _;
  }, or = { value: Um, error: Of, fromOption: (p, y) => p.fold(() => Of(y), Um) }, jm = (p, y) => ({ rowDelta: 0, colDelta: Vr(p[0]) - Vr(y[0]) }), dd = (p, y) => ({ rowDelta: p.length - y.length, colDelta: 0 }), fd = (p, y, _, T) => {
    const P = y.section === "colgroup" ? _.col : _.cell;
    return un(p, (I) => Ms(P(), !0, T(I)));
  }, Ap = (p, y, _, T) => {
    const P = p[p.length - 1];
    return p.concat(un(y, () => {
      const I = P.section === "colgroup" ? _.colgroup : _.row, j = Qi(P, I, en), Y = fd(j.cells.length, j, _, (ne) => oo(T, ne.toString()));
      return rm(j, Y);
    }));
  }, dg = (p, y, _, T) => M(p, (P) => {
    const I = fd(y, P, _, Ee);
    return Ji(P, T, I);
  }), md = (p, y, _) => {
    const T = y.colDelta < 0 ? dg : en, P = y.rowDelta < 0 ? Ap : en, I = xs(p), j = Vr(p[0]), Y = Xe(I, (Ce) => Ce === j - 1), ne = T(p, Math.abs(y.colDelta), _, Y ? j - 1 : j), ve = xs(ne);
    return P(ne, Math.abs(y.rowDelta), _, tn(ve, wt));
  }, Oo = (p, y, _, T) => {
    const P = gt(T, ya(p[y], _).element), I = p[y];
    return p.length > 1 && Vr(I) > 1 && (_ > 0 && P(Ls(I, _ - 1)) || _ < I.cells.length - 1 && P(Ls(I, _ + 1)) || y > 0 && P(Ls(p[y - 1], _)) || y < p.length - 1 && P(Ls(p[y + 1], _)));
  }, Sr = (p, y, _) => mn(_, (T) => T >= p.column && T <= Vr(y[0]) + p.column), xi = (p, y, _, T, P) => {
    ((ve, Ce, ge, Te) => {
      Ce > 0 && Ce < ve[0].cells.length && Et(ve, (Ae) => {
        const Ge = Ae.cells[Ce - 1];
        let $e = 0;
        const lt = Te();
        for (; Ae.cells.length > Ce + $e && ge(Ge.element, Ae.cells[Ce + $e].element); )
          nd(Ae, Ce + $e, Ms(lt, !0, Ae.cells[Ce + $e].isLocked)), $e++;
      });
    })(y, p, P, T.cell);
    const I = dd(_, y), j = md(_, I, T), Y = dd(y, j), ne = md(y, Y, T);
    return M(ne, (ve, Ce) => Ji(ve, p, j[Ce].cells));
  }, vr = (p, y, _, T, P) => {
    ((Bt, xt, Lt, Vt) => {
      const rn = zs(Bt).rows;
      if (xt > 0 && xt < rn.length) {
        const Vn = ((Un, Do) => dt(Un, (Gn, Ro) => Xe(Gn, (xo) => Do(xo.element, Ro.element)) ? Gn : Gn.concat([Ro]), []))(rn[xt - 1].cells, Lt);
        Et(Vn, (Un) => {
          let Do = Se.none();
          for (let Gn = xt; Gn < rn.length; Gn++)
            for (let Ro = 0; Ro < Vr(rn[0]); Ro++) {
              const xo = rn[Gn], zr = ya(xo, Ro);
              Lt(zr.element, Un.element) && (Do.isNone() && (Do = Se.some(Vt())), Do.each((Wt) => {
                nd(xo, Ro, Ms(Wt, !0, zr.isLocked));
              }));
            }
        });
      }
    })(y, p, P, T.cell);
    const I = xs(y), j = jm(y, _), Y = { ...j, colDelta: j.colDelta - I.length }, ne = md(y, Y, T), { cols: ve, rows: Ce } = zs(ne), ge = xs(ne), Te = jm(_, y), Ae = { ...Te, colDelta: Te.colDelta + ge.length }, Ge = (lt = T, pt = ge, M(_, (Bt) => dt(pt, (xt, Lt) => {
      const Vt = fd(1, Bt, lt, wt)[0];
      return Zs(xt, Lt, Vt);
    }, Bt))), $e = md(Ge, Ae, T);
    var lt, pt;
    return [...ve, ...Ce.slice(0, p), ...$e, ...Ce.slice(p, Ce.length)];
  }, fg = (p, y, _, T, P) => {
    const { rows: I, cols: j } = zs(p), Y = I.slice(0, y), ne = I.slice(y);
    return [...j, ...Y, ((ve, Ce, ge, Te) => Qi(ve, (Ae) => Te(Ae, ge), Ce))(I[_], (ve, Ce) => y > 0 && y < I.length && T(Ls(I[y - 1], Ce), Ls(I[y], Ce)) ? ya(I[y], Ce) : Ms(P(ve.element, T), !0, ve.isLocked), T, P), ...ne];
  }, $s = (p, y, _, T, P) => M(p, (I) => {
    const j = y > 0 && y < Vr(I) && T(Ls(I, y - 1), Ls(I, y)), Y = ((ne, ve, Ce, ge, Te, Ae, Ge) => {
      if (Ce !== "colgroup" && ge)
        return ya(ne, ve);
      {
        const $e = ya(ne, Te);
        return Ms(Ge($e.element, Ae), !0, !1);
      }
    })(I, y, I.section, j, _, T, P);
    return Zs(I, y, Y);
  }), _s = (p, y, _, T) => ((P, I, j, Y) => Ls(P[I], j) !== void 0 && I > 0 && Y(Ls(P[I - 1], j), Ls(P[I], j)))(p, y, _, T) || ((P, I, j) => I > 0 && j(Ls(P, I - 1), Ls(P, I)))(p[y], _, T), nl = (p, y, _, T) => {
    const P = (I) => ((j) => j === "row" ? xf(y) : hu(y))(I) ? `${I}group` : I;
    return p ? tl(y) ? P(_) : null : T && tl(y) ? P(_ === "row" ? "col" : "row") : null;
  }, jc = (p, y, _) => Ms(_(p.element, y), !0, p.isLocked), pd = (p, y, _, T, P, I, j) => M(p, (Y, ne) => ((ve, Ce) => {
    const ge = ve.cells, Te = M(ge, (Ae, Ge) => {
      if ((($e) => Xe(y, (lt) => _($e.element, lt.element)))(Ae)) {
        const $e = j(Ae, ne, Ge) ? P(Ae, _, T) : Ae;
        return I($e, ne, Ge).each((lt) => {
          var pt, Bt;
          pt = $e.element, Bt = { scope: Se.from(lt) }, er(Bt, (xt, Lt) => {
            xt.fold(() => {
              _n(pt, Lt);
            }, (Vt) => {
              $r(pt.dom, Lt, Vt);
            });
          });
        }), $e;
      }
      return Ae;
    });
    return ni(ve.element, Te, ve.section, ve.isNew);
  })(Y)), zu = (p, y, _) => yo(p, (T, P) => _s(p, P, y, _) ? [] : [ya(T, y)]), dm = (p, y, _, T, P) => {
    const I = zs(p).rows, j = yo(y, (Ce) => zu(I, Ce, T)), Y = M(I, (Ce) => cm(Ce.cells)), ne = ((Ce, ge) => Ct(ge, en) && cm(Ce) ? wt : (Te, Ae, Ge) => !(xn(Te.element) === "th" && ge[Ae]))(j, Y), ve = ((Ce, ge) => (Te, Ae) => Se.some(nl(Ce, Te.element, "row", ge[Ae])))(_, Y);
    return pd(p, j, T, P, jc, ve, ne);
  }, mg = (p, y, _, T) => {
    const P = zs(p).rows, I = M(y, (j) => ya(P[j.row], j.column));
    return pd(p, I, _, T, jc, Se.none, wt);
  }, fm = (p) => {
    if (!he(p))
      throw new Error("cases must be an array");
    if (p.length === 0)
      throw new Error("there must be at least one case");
    const y = [], _ = {};
    return Et(p, (T, P) => {
      const I = Go(T);
      if (I.length !== 1)
        throw new Error("one and only one name per case");
      const j = I[0], Y = T[j];
      if (_[j] !== void 0)
        throw new Error("duplicate key detected:" + j);
      if (j === "cata")
        throw new Error("cannot have a case named cata (sorry)");
      if (!he(Y))
        throw new Error("case arguments must be an array");
      y.push(j), _[j] = (...ne) => {
        const ve = ne.length;
        if (ve !== Y.length)
          throw new Error("Wrong number of arguments to case " + j + ". Expected " + Y.length + " (" + Y + "), got " + ve);
        return { fold: (...Ce) => {
          if (Ce.length !== p.length)
            throw new Error("Wrong number of arguments to fold. Expected " + p.length + ", got " + Ce.length);
          return Ce[P].apply(null, ne);
        }, match: (Ce) => {
          const ge = Go(Ce);
          if (y.length !== ge.length)
            throw new Error("Wrong number of arguments to match. Expected: " + y.join(",") + `
Actual: ` + ge.join(","));
          if (!Ct(y, (Te) => jn(ge, Te)))
            throw new Error("Not all branches were specified when using match. Specified: " + ge.join(", ") + `
Required: ` + y.join(", "));
          return Ce[j].apply(null, ne);
        }, log: (Ce) => {
          console.log(Ce, { constructors: y, constructor: j, params: ne });
        } };
      };
    }), _;
  }, Af = { ...fm([{ none: [] }, { only: ["index"] }, { left: ["index", "next"] }, { middle: ["prev", "index", "next"] }, { right: ["prev", "index"] }]) }, ah = (p, y, _) => {
    let T = 0;
    for (let P = p; P < y; P++)
      T += _[P] !== void 0 ? _[P] : 0;
    return T;
  }, Zm = (p, y) => {
    const _ = Cc(p);
    return M(_, (T) => {
      const P = ah(T.row, T.row + T.rowspan, y);
      return { element: T.element, height: P, rowspan: T.rowspan };
    });
  }, Ry = (p, y, _) => {
    const T = ((P, I) => ca(P) ? ((j, Y) => {
      const ne = To(j);
      return M(ne, (ve, Ce) => ({ element: ve.element, width: Y[Ce], colspan: ve.colspan }));
    })(P, I) : ((j, Y) => {
      const ne = Cc(j);
      return M(ne, (ve) => {
        const Ce = ah(ve.column, ve.column + ve.colspan, Y);
        return { element: ve.element, width: Ce, colspan: ve.colspan };
      });
    })(P, I))(p, y);
    Et(T, (P) => {
      _.setElementWidth(P.element, P.width);
    });
  }, gd = (p, y, _, T, P) => {
    const I = la(p), j = P.getCellDelta(y), Y = P.getWidths(I, P), ne = _ === I.grid.columns - 1, ve = T.clampTableDelta(Y, _, j, P.minCellWidth(), ne), Ce = ((Te, Ae, Ge, $e, lt) => {
      const pt = Te.slice(0), Bt = ((Lt, Vt) => Lt.length === 0 ? Af.none() : Lt.length === 1 ? Af.only(0) : Vt === 0 ? Af.left(0, 1) : Vt === Lt.length - 1 ? Af.right(Vt - 1, Vt) : Vt > 0 && Vt < Lt.length - 1 ? Af.middle(Vt - 1, Vt, Vt + 1) : Af.none())(Te, Ae), xt = Rt(M(pt, Rt(0)));
      return Bt.fold(xt, (Lt) => $e.singleColumnWidth(pt[Lt], Ge), (Lt, Vt) => lt.calcLeftEdgeDeltas(pt, Lt, Vt, Ge, $e.minCellWidth(), $e.isRelative), (Lt, Vt, rn) => lt.calcMiddleDeltas(pt, Lt, Vt, rn, Ge, $e.minCellWidth(), $e.isRelative), (Lt, Vt) => lt.calcRightEdgeDeltas(pt, Lt, Vt, Ge, $e.minCellWidth(), $e.isRelative));
    })(Y, _, ve, P, T), ge = M(Ce, (Te, Ae) => Te + Y[Ae]);
    Ry(I, ge, P), T.resizeTable(P.adjustTableWidth, ve, ne);
  }, Os = (p) => dt(p, (y, _) => Xe(y, (T) => T.column === _.column) ? y : y.concat([_]), []).sort((y, _) => y.column - _.column), nb = Zr("col"), ob = Zr("colgroup"), rb = (p) => xn(p) === "tr" || ob(p), Nl = (p) => ({ element: p, colspan: fl(p, "colspan", 1), rowspan: fl(p, "rowspan", 1) }), Yr = (p) => cn(p, "scope").map((y) => y.substr(0, 3)), Ml = (p, y = Nl) => {
    const _ = (P) => {
      if (rb(P))
        return ob((I = { element: P }).element) ? p.colgroup(I) : p.row(I);
      {
        const j = P, Y = ((ne) => nb(ne.element) ? p.col(ne) : p.cell(ne))(y(j));
        return T = Se.some({ item: j, replacement: Y }), Y;
      }
      var I;
    };
    let T = Se.none();
    return { getOrInit: (P, I) => T.fold(() => _(P), (j) => I(P, j.item) ? j.replacement : _(P)) };
  }, pg = (p) => (y) => {
    const _ = [], T = (P) => {
      const I = p === "td" ? { scope: null } : {}, j = y.replace(P, p, I);
      return _.push({ item: P, sub: j }), j;
    };
    return { replaceOrInit: (P, I) => {
      if (rb(P) || nb(P))
        return P;
      {
        const j = P;
        return ((Y, ne) => Bn(_, (ve) => ne(ve.item, Y)))(j, I).fold(() => T(j), (Y) => I(P, Y.item) ? Y.sub : T(j));
      }
    } };
  }, sb = (p) => ({ unmerge: (y) => {
    const _ = Yr(y);
    return _.each((T) => Po(y, "scope", T)), () => {
      const T = p.cell({ element: y, colspan: 1, rowspan: 1 });
      return Ts(T, "width"), Ts(y, "width"), _.each((P) => Po(T, "scope", P)), T;
    };
  }, merge: (y) => (Ts(y[0], "width"), (() => {
    const _ = Rr(M(y, Yr));
    if (_.length === 0)
      return Se.none();
    {
      const T = _[0], P = ["row", "col"];
      return Xe(_, (I) => I !== T && jn(P, I)) ? Se.none() : Se.from(T);
    }
  })().fold(() => _n(y[0], "scope"), (_) => Po(y[0], "scope", _ + "group")), Rt(y[0])) }), Ny = ["body", "p", "div", "article", "aside", "figcaption", "figure", "footer", "header", "nav", "section", "ol", "ul", "table", "thead", "tfoot", "tbody", "caption", "tr", "td", "th", "h1", "h2", "h3", "h4", "h5", "h6", "blockquote", "pre", "address"], ih = Zd(), Va = (p) => ((y, _) => {
    const T = y.property().name(_);
    return jn(Ny, T);
  })(ih, p), hd = (p) => ((y, _) => {
    const T = y.property().name(_);
    return jn(["ol", "ul"], T);
  })(ih, p), fa = (p) => {
    const y = Zr("br"), _ = (P) => ou(P).bind((I) => {
      const j = qi(I).map((Y) => !!Va(Y) || !!((ne, ve) => jn(["br", "img", "hr", "input"], ne.property().name(ve)))(ih, Y) && xn(Y) !== "img").getOr(!1);
      return Wi(I).map((Y) => {
        return j === !0 || xn(ne = Y) === "li" || kc(ne, hd).isSome() || y(I) || Va(Y) && !kr(P, Y) ? [] : [Nt.fromTag("br")];
        var ne;
      });
    }).getOr([]), T = (() => {
      const P = yo(p, (I) => {
        const j = Ei(I);
        return ((Y) => Ct(Y, (ne) => y(ne) || ho(ne) && Nr(ne).trim().length === 0))(j) ? [] : j.concat(_(I));
      });
      return P.length === 0 ? [Nt.fromTag("br")] : P;
    })();
    wc(p[0]), Ti(p[0], T);
  }, Ou = (p) => bn(p, !0), Df = (p) => {
    An(p).length === 0 && pi(p);
  }, Qd = (p, y) => ({ grid: p, cursor: y }), wi = (p, y, _) => {
    const T = ((P, I, j) => {
      var Y, ne;
      const ve = zs(P).rows;
      return Se.from((ne = (Y = ve[I]) === null || Y === void 0 ? void 0 : Y.cells[j]) === null || ne === void 0 ? void 0 : ne.element).filter(Ou).orThunk(() => ((Ce) => K(Ce, (ge) => K(ge.cells, (Te) => {
        const Ae = Te.element;
        return Wa(Ou(Ae), Ae);
      })))(ve));
    })(p, y, _);
    return Qd(p, T);
  }, Rf = (p) => dt(p, (y, _) => Xe(y, (T) => T.row === _.row) ? y : y.concat([_]), []).sort((y, _) => y.row - _.row), lh = (p, y) => (_, T, P, I, j) => {
    const Y = Rf(T), ne = M(Y, (Ce) => Ce.row), ve = ((Ce, ge, Te, Ae, Ge, $e, lt) => {
      const { cols: pt, rows: Bt } = zs(Ce), xt = Bt[ge[0]], Lt = yo(ge, (Gn) => ((Ro, xo, zr) => {
        const Wt = Ro[xo];
        return yo(Wt.cells, (Hi, ja) => _s(Ro, xo, ja, zr) ? [] : [Hi]);
      })(Bt, Gn, Ge)), Vt = M(xt.cells, (Gn, Ro) => cm(zu(Bt, Ro, Ge))), rn = [...Bt];
      Et(ge, (Gn) => {
        rn[Gn] = lt.transformRow(Bt[Gn], Te);
      });
      const Vn = [...pt, ...rn], Un = ((Gn, Ro) => Ct(Ro, en) && cm(Gn.cells) ? wt : (xo, zr, Wt) => !(xn(xo.element) === "th" && Ro[Wt]))(xt, Vt), Do = ((Gn, Ro) => (xo, zr, Wt) => Se.some(nl(Gn, xo.element, "col", Ro[Wt])))(Ae, Vt);
      return pd(Vn, Lt, Ge, $e, lt.transformCell, Do, Un);
    })(_, ne, p, y, P, I.replaceOrInit, j);
    return wi(ve, T[0].row, T[0].column);
  }, ab = lh("thead", !0), Wm = lh("tbody", !1), ch = lh("tfoot", !1), Dp = (p, y, _) => {
    const T = ((I, j) => Cr(I, () => j))(p, _.section), P = od(T);
    return on(P, y, !0);
  }, qm = (p, y, _, T) => ((P, I, j, Y) => {
    const ne = od(I), ve = Y.getWidths(ne, Y);
    Ry(ne, ve, Y);
  })(0, y, 0, T.sizing), gg = (p, y, _, T) => ((P, I, j, Y, ne) => {
    const ve = od(I), Ce = Y.getWidths(ve, Y), ge = Y.pixelWidth(), { newSizes: Te, delta: Ae } = ne.calcRedestributedWidths(Ce, ge, j.pixelDelta, Y.isRelative);
    Ry(ve, Te, Y), Y.adjustTableWidth(Ae);
  })(0, y, _, T.sizing, T.resize), ef = (p, y) => Xe(y, (_) => _.column === 0 && _.isLocked), hg = (p, y) => Xe(y, (_) => _.column + _.colspan >= p.grid.columns && _.isLocked), Au = (p, y) => {
    const _ = Oi(p), T = Os(y);
    return dt(T, (P, I) => P + _[I.column].map(td).getOr(0), 0);
  }, Rp = (p) => (y, _) => as(y, _).filter((T) => !(p ? ef : hg)(y, T)).map((T) => ({ details: T, pixelDelta: Au(y, T) })), Vo = (p) => (y, _) => fr(y, _).filter((T) => !(p ? ef : hg)(y, T.cells)), fc = pg("th"), bd = pg("td"), bg = _o((p, y, _, T) => {
    const P = y[0].row, I = Rf(y), j = lo(I, (Y, ne) => ({ grid: fg(Y.grid, P, ne.row + Y.delta, _, T.getOrInit), delta: Y.delta + 1 }), { grid: p, delta: 0 }).grid;
    return wi(j, P, y[0].column);
  }, as, it, it, Ml), ms = _o((p, y, _, T) => {
    const P = Rf(y), I = P[P.length - 1], j = I.row + I.rowspan, Y = lo(P, (ne, ve) => fg(ne, j, ve.row, _, T.getOrInit), p);
    return wi(Y, j, y[0].column);
  }, as, it, it, Ml), My = _o((p, y, _, T) => {
    const P = y.details, I = Os(P), j = I[0].column, Y = lo(I, (ne, ve) => ({ grid: $s(ne.grid, j, ve.column + ne.delta, _, T.getOrInit), delta: ne.delta + 1 }), { grid: p, delta: 0 }).grid;
    return wi(Y, P[0].row, j);
  }, Rp(!0), gg, it, Ml), By = _o((p, y, _, T) => {
    const P = y.details, I = P[P.length - 1], j = I.column + I.colspan, Y = Os(P), ne = lo(Y, (ve, Ce) => $s(ve, j, Ce.column, _, T.getOrInit), p);
    return wi(ne, P[0].row, j);
  }, Rp(!1), gg, it, Ml), ol = _o((p, y, _, T) => {
    const P = Os(y.details), I = ((Y, ne) => yo(Y, (ve) => {
      const Ce = ve.cells, ge = lo(ne, (Te, Ae) => Ae >= 0 && Ae < Te.length ? Te.slice(0, Ae).concat(Te.slice(Ae + 1)) : Te, Ce);
      return ge.length > 0 ? [ni(ve.element, ge, ve.section, ve.isNew)] : [];
    }))(p, M(P, (Y) => Y.column)), j = I.length > 0 ? I[0].cells.length - 1 : 0;
    return wi(I, P[0].row, Math.min(P[0].column, j));
  }, (p, y) => Ha(p, y).map((_) => ({ details: _, pixelDelta: -Au(p, _) })), gg, Df, Ml), mc = _o((p, y, _, T) => {
    const P = Rf(y), I = ((Y, ne, ve) => {
      const { rows: Ce, cols: ge } = zs(Y);
      return [...ge, ...Ce.slice(0, ne), ...Ce.slice(ve + 1)];
    })(p, P[0].row, P[P.length - 1].row), j = I.length > 0 ? I.length - 1 : 0;
    return wi(I, Math.min(y[0].row, j), y[0].column);
  }, as, it, Df, Ml), uh = _o((p, y, _, T) => {
    const P = Os(y), I = M(P, (Y) => Y.column), j = dm(p, I, !0, _, T.replaceOrInit);
    return wi(j, y[0].row, y[0].column);
  }, Ha, it, it, fc), dh = _o((p, y, _, T) => {
    const P = Os(y), I = M(P, (Y) => Y.column), j = dm(p, I, !1, _, T.replaceOrInit);
    return wi(j, y[0].row, y[0].column);
  }, Ha, it, it, bd), Ly = _o(ab, Ha, it, it, fc), ib = _o(Wm, Ha, it, it, bd), K1 = _o(ch, Ha, it, it, bd), lb = _o((p, y, _, T) => {
    const P = mg(p, y, _, T.replaceOrInit);
    return wi(P, y[0].row, y[0].column);
  }, Ha, it, it, fc), Nf = _o((p, y, _, T) => {
    const P = mg(p, y, _, T.replaceOrInit);
    return wi(P, y[0].row, y[0].column);
  }, Ha, it, it, bd), Np = _o((p, y, _, T) => {
    const P = y.cells;
    fa(P);
    const I = ((j, Y, ne, ve) => {
      const Ce = zs(j).rows;
      if (Ce.length === 0)
        return j;
      for (let ge = Y.startRow; ge <= Y.finishRow; ge++)
        for (let Te = Y.startCol; Te <= Y.finishCol; Te++) {
          const Ae = Ce[ge], Ge = ya(Ae, Te).isLocked;
          nd(Ae, Te, Ms(ve(), !1, Ge));
        }
      return j;
    })(p, y.bounds, 0, T.merge(P));
    return Qd(I, Se.from(P[0]));
  }, (p, y) => ((_, T) => T.mergable)(0, y).filter((_) => Xa(p, _.cells)), qm, it, sb), tf = _o((p, y, _, T) => {
    const P = lo(y, (I, j) => su(I, j, _, T.unmerge(j)), p);
    return Qd(P, Se.from(y[0]));
  }, (p, y) => ((_, T) => T.unmergable)(0, y).filter((_) => Xa(p, _)), qm, it, sb), Dc = _o((p, y, _, T) => {
    const P = ((Y, ne) => {
      const ve = la(Y);
      return on(ve, ne, !0);
    })(y.clipboard, y.generators);
    var I, j;
    return ((Y, ne, ve, Ce, ge) => {
      const Te = xs(ne), Ae = ((pt, Bt, xt) => {
        const Lt = Vr(Bt[0]), Vt = zs(Bt).cols.length + pt.row, rn = un(Lt - pt.column, (Vn) => Vn + pt.column);
        return { row: Vt, column: Bn(rn, (Vn) => Ct(xt, (Un) => Un !== Vn)).getOr(Lt - 1) };
      })(Y, ne, Te), Ge = zs(ve).rows, $e = Sr(Ae, Ge, Te);
      return ((pt, Bt, xt) => {
        if (pt.row >= Bt.length || pt.column > Vr(Bt[0]))
          return or.error("invalid start address out of table bounds, row: " + pt.row + ", column: " + pt.column);
        const Lt = Bt.slice(pt.row), Vt = Lt[0].cells.slice(pt.column), rn = Vr(xt[0]), Vn = xt.length;
        return or.value({ rowDelta: Lt.length - Vn, colDelta: Vt.length - rn });
      })(Ae, ne, Ge).map((pt) => {
        const Bt = { ...pt, colDelta: pt.colDelta - $e.length }, xt = md(ne, Bt, Ce), Lt = xs(xt), Vt = Sr(Ae, Ge, Lt);
        return ((rn, Vn, Un, Do, Gn, Ro) => {
          const xo = rn.row, zr = rn.column, Wt = xo + Un.length, Hi = zr + Vr(Un[0]) + Ro.length, ja = tn(Ro, wt);
          for (let ai = xo; ai < Wt; ai++) {
            let Dn = 0;
            for (let ii = zr; ii < Hi; ii++) {
              if (ja[ii]) {
                Dn++;
                continue;
              }
              Oo(Vn, ai, ii, Gn) && su(Vn, Ls(Vn[ai], ii), Gn, Do.cell);
              const yl = ii - zr - Dn, Ng = ya(Un[ai - xo], yl), Ah = Ng.element, hs = Do.replace(Ah);
              nd(Vn[ai], ii, Ms(hs, !0, Ng.isLocked));
            }
          }
          return Vn;
        })(Ae, xt, Ge, Ce, ge, Vt);
      });
    })((I = y.row, j = y.column, { row: I, column: j }), p, P, y.generators, _).fold(() => Qd(p, Se.some(y.element)), (Y) => wi(Y, y.row, y.column));
  }, (p, y) => Ft(y.element).bind((_) => uo(p, _).map((T) => ({ ...T, generators: y.generators, clipboard: y.clipboard }))), qm, it, Ml), ki = _o((p, y, _, T) => {
    const P = zs(p).rows, I = y.cells[0].column, j = P[y.cells[0].row], Y = Dp(y.clipboard, y.generators, j), ne = xi(I, p, Y, y.generators, _);
    return wi(ne, y.cells[0].row, y.cells[0].column);
  }, Vo(!0), it, it, Ml), Du = _o((p, y, _, T) => {
    const P = zs(p).rows, I = y.cells[y.cells.length - 1].column + y.cells[y.cells.length - 1].colspan, j = P[y.cells[0].row], Y = Dp(y.clipboard, y.generators, j), ne = xi(I, p, Y, y.generators, _);
    return wi(ne, y.cells[0].row, y.cells[0].column);
  }, Vo(!1), it, it, Ml), Ao = _o((p, y, _, T) => {
    const P = zs(p).rows, I = y.cells[0].row, j = P[I], Y = Dp(y.clipboard, y.generators, j), ne = vr(I, p, Y, y.generators, _);
    return wi(ne, y.cells[0].row, y.cells[0].column);
  }, fr, it, it, Ml), fh = _o((p, y, _, T) => {
    const P = zs(p).rows, I = y.cells[y.cells.length - 1].row + y.cells[y.cells.length - 1].rowspan, j = P[y.cells[0].row], Y = Dp(y.clipboard, y.generators, j), ne = vr(I, p, Y, y.generators, _);
    return wi(ne, y.cells[0].row, y.cells[0].column);
  }, fr, it, it, Ml), cb = (p, y) => {
    const _ = la(p);
    return as(_, y).bind((T) => {
      const P = T[T.length - 1], I = T[0].column, j = P.column + P.colspan, Y = Tt(M(_.all, (ne) => mn(ne.cells, (ve) => ve.column >= I && ve.column < j)));
      return Tu(Y);
    }).getOr("");
  }, Mf = (p, y) => {
    const _ = la(p);
    return as(_, y).bind(Tu).getOr("");
  }, mh = (p, y) => {
    const _ = la(p);
    return as(_, y).bind((T) => {
      const P = T[T.length - 1], I = T[0].row, j = P.row + P.rowspan;
      return ((Y) => {
        const ne = M(Y, (ge) => Jd(ge).type), ve = jn(ne, "header"), Ce = jn(ne, "footer");
        if (ve || Ce) {
          const ge = jn(ne, "body");
          return !ve || ge || Ce ? ve || ge || !Ce ? Se.none() : Se.some("footer") : Se.some("header");
        }
        return Se.some("body");
      })(_.all.slice(I, j));
    }).getOr("");
  }, yg = (p, y) => p.dispatch("NewRow", { node: y }), Bi = (p, y) => p.dispatch("NewCell", { node: y }), Tr = (p, y, _) => {
    p.dispatch("TableModified", { ..._, table: y });
  }, rl = { structure: !1, style: !0 }, ps = { structure: !0, style: !1 }, Zl = { structure: !0, style: !0 }, ma = (p, y) => Ac(p) ? pr(y) : Cf(p) ? Ka(y) : jd(y), Li = (p, y, _) => {
    const T = (Ce) => xn(Hn(Ce)) === "table", P = de(p), I = Yo(p) ? it : Yd, j = (Ce) => {
      switch (Hc(p)) {
        case "section":
          return zf();
        case "sectionCells":
          return tb();
        case "cells":
          return C();
        default:
          return ((ge, Te) => {
            var Ae;
            switch ((Ae = la(ge), K(Ae.all, (Ge) => {
              const $e = Jd(Ge);
              return $e.type === "header" ? Se.from($e.subType) : Se.none();
            })).getOr(Te)) {
              case "section":
                return hn();
              case "sectionCells":
                return Op();
              case "cells":
                return Vm();
            }
          })(Ce, "section");
      }
    }, Y = (Ce, ge, Te, Ae) => (Ge, $e, lt = !1) => {
      yr(Ge);
      const pt = Nt.fromDom(p.getDoc()), Bt = yi(Te, pt, P), xt = { sizing: ma(p, Ge), resize: Yo(p) ? eb() : hl(), section: j(Ge) };
      return ge(Ge) ? Ce(Ge, $e, Bt, xt).bind((Lt) => {
        y.refresh(Ge.dom), Et(Lt.newRows, (rn) => {
          yg(p, rn.dom);
        }), Et(Lt.newCells, (rn) => {
          Bi(p, rn.dom);
        });
        const Vt = ((rn, Vn) => Vn.cursor.fold(() => {
          const Un = An(rn);
          return Pn(Un).filter(sa).map((Do) => {
            _.clearSelectedCells(rn.dom);
            const Gn = p.dom.createRng();
            return Gn.selectNode(Do.dom), p.selection.setRng(Gn), Po(Do, "data-mce-selected", "1"), Gn;
          });
        }, (Un) => {
          const Do = ld(cd, Un), Gn = p.dom.createRng();
          return Gn.setStart(Do.element.dom, Do.offset), Gn.setEnd(Do.element.dom, Do.offset), p.selection.setRng(Gn), _.clearSelectedCells(rn.dom), Se.some(Gn);
        }))(Ge, Lt);
        return sa(Ge) && (yr(Ge), lt || Tr(p, Ge.dom, Ae)), Vt.map((rn) => ({ rng: rn, effect: Ae }));
      }) : Se.none();
    }, ne = Y(mc, (Ce) => !T(p) || Hm(Ce).rows > 1, it, ps), ve = Y(ol, (Ce) => !T(p) || Hm(Ce).columns > 1, it, ps);
    return { deleteRow: ne, deleteColumn: ve, insertRowsBefore: Y(bg, wt, it, ps), insertRowsAfter: Y(ms, wt, it, ps), insertColumnsBefore: Y(My, wt, I, ps), insertColumnsAfter: Y(By, wt, I, ps), mergeCells: Y(Np, wt, it, ps), unmergeCells: Y(tf, wt, it, ps), pasteColsBefore: Y(ki, wt, it, ps), pasteColsAfter: Y(Du, wt, it, ps), pasteRowsBefore: Y(Ao, wt, it, ps), pasteRowsAfter: Y(fh, wt, it, ps), pasteCells: Y(Dc, wt, it, Zl), makeCellsHeader: Y(lb, wt, it, ps), unmakeCellsHeader: Y(Nf, wt, it, ps), makeColumnsHeader: Y(uh, wt, it, ps), unmakeColumnsHeader: Y(dh, wt, it, ps), makeRowsHeader: Y(Ly, wt, it, ps), makeRowsBody: Y(ib, wt, it, ps), makeRowsFooter: Y(K1, wt, it, ps), getTableRowType: mh, getTableCellType: Mf, getTableColType: cb };
  }, ph = (p, y, _) => {
    const T = fl(p, y, 1);
    _ === 1 || T <= 1 ? _n(p, y) : Po(p, y, Math.min(_, T));
  }, Py = (p, y) => (_) => {
    const T = _.column + _.colspan - 1, P = _.column;
    return T >= p && P < y;
  }, vg = fm([{ invalid: ["raw"] }, { pixels: ["value"] }, { percent: ["value"] }]), nf = (p, y, _) => {
    const T = _.substring(0, _.length - p.length), P = parseFloat(T);
    return T === P.toString() ? y(P) : vg.invalid(_);
  }, Pi = { ...vg, from: (p) => gi(p, "%") ? nf("%", vg.percent, p) : gi(p, "px") ? nf("px", vg.pixels, p) : vg.invalid(p) }, xg = (p, y, _) => {
    const T = Pi.from(_), P = Ct(p, (I) => I === "0px") ? ((I, j) => {
      const Y = I.fold(() => Rt(""), (ne) => Rt(ne / j + "px"), () => Rt(100 / j + "%"));
      return un(j, Y);
    })(T, p.length) : ((I, j, Y) => I.fold(() => j, (ne) => ((ve, Ce, ge) => {
      const Te = ge / Ce;
      return M(ve, (Ae) => Pi.from(Ae).fold(() => Ae, (Ge) => Ge * Te + "px", (Ge) => Ge / 100 * ge + "px"));
    })(j, Y, ne), (ne) => ((ve, Ce) => M(ve, (ge) => Pi.from(ge).fold(() => ge, (Te) => Te / Ce * 100 + "%", (Te) => Te + "%")))(j, Y)))(T, p, y);
    return vv(P);
  }, gh = (p, y) => p.length === 0 ? y : lo(p, (_, T) => Pi.from(T).fold(Rt(0), en, en) + _, 0), Iy = (p, y) => Pi.from(p).fold(Rt(p), (_) => _ + y + "px", (_) => _ + y + "%"), vv = (p) => {
    if (p.length === 0)
      return p;
    const y = lo(p, (T, P) => {
      const I = Pi.from(P).fold(() => ({ value: P, remainder: 0 }), (j) => ((Y, ne) => {
        const ve = Math.floor(Y);
        return { value: ve + "px", remainder: Y - ve };
      })(j), (j) => ({ value: j + "%", remainder: 0 }));
      return { output: [I.value].concat(T.output), remainder: T.remainder + I.remainder };
    }, { output: [], remainder: 0 }), _ = y.output;
    return _.slice(0, _.length - 1).concat([Iy(_[_.length - 1], Math.round(y.remainder))]);
  }, wg = Pi.from, Bf = (p) => wg(p).fold(Rt("px"), Rt("px"), Rt("%")), au = (p, y, _) => {
    const T = la(p), P = T.all, I = Cc(T), j = To(T);
    y.each((Y) => {
      const ne = Bf(Y), ve = ia(p), Ce = ((Te, Ae) => st(Te, Ae, Qs, zl))(T, p), ge = xg(Ce, ve, Y);
      ca(T) ? ((Te, Ae, Ge) => {
        Et(Ae, ($e, lt) => {
          const pt = gh([Te[lt]], te());
          Bs($e.element, "width", pt + Ge);
        });
      })(ge, j, ne) : ((Te, Ae, Ge) => {
        Et(Ae, ($e) => {
          const lt = Te.slice($e.column, $e.colspan + $e.column), pt = gh(lt, te());
          Bs($e.element, "width", pt + Ge);
        });
      })(ge, I, ne), Bs(p, "width", Y);
    }), _.each((Y) => {
      const ne = Bf(Y), ve = ri(p), Ce = ((ge, Te, Ae) => Is(ge, Te, Ae, ua, zl))(T, p, Nn);
      ((ge, Te, Ae, Ge) => {
        Et(Ae, ($e) => {
          const lt = ge.slice($e.row, $e.rowspan + $e.row), pt = gh(lt, ze());
          Bs($e.element, "height", pt + Ge);
        }), Et(Te, ($e, lt) => {
          Bs($e.element, "height", ge[lt]);
        });
      })(xg(Ce, ve, Y), P, I, ne), Bs(p, "height", Y);
    });
  }, $t = (p) => Tl(p).exists((y) => Pr.test(y)), Fy = (p) => Tl(p).exists((y) => Tc.test(y)), _i = (p) => Tl(p).isNone(), hh = (p) => {
    _n(p, "width");
  }, Gm = (p) => {
    const y = nu(p);
    au(p, Se.some(y), Se.none()), hh(p);
  }, of = (p) => {
    const y = ((_) => ia(_) + "px")(p);
    au(p, Se.some(y), Se.none()), hh(p);
  }, pc = (p) => {
    Ts(p, "width");
    const y = so(p), _ = y.length > 0 ? y : An(p);
    Et(_, (T) => {
      Ts(T, "width"), hh(T);
    }), hh(p);
  }, xv = { styles: { "border-collapse": "collapse", width: "100%" }, attributes: { border: "1" }, colGroups: !1 }, gc = (p, y, _, T) => un(p, (P) => ((I, j, Y, ne) => {
    const ve = Nt.fromTag("tr");
    for (let Ce = 0; Ce < I; Ce++) {
      const ge = Nt.fromTag(ne < j || Ce < Y ? "th" : "td");
      Ce < Y && Po(ge, "scope", "row"), ne < j && Po(ge, "scope", "col"), es(ge, Nt.fromTag("br")), es(ve, ge);
    }
    return ve;
  })(y, _, T, P)), ub = (p, y) => {
    p.selection.select(y.dom, !0), p.selection.collapse(!0);
  }, mm = (p, y, _, T, P) => {
    const I = ((Y) => {
      const ne = Y.options, ve = ne.get("table_default_styles");
      return ne.isSet("table_default_styles") ? ve : ((Ce, ge) => da(Ce) || !F(Ce) ? ge : Cf(Ce) ? { ...ge, width: lc(Ce) } : { ...ge, width: zc })(Y, ve);
    })(p), j = { styles: I, attributes: _e(p), colGroups: Oe(p) };
    return p.undoManager.ignore(() => {
      const Y = ((ve, Ce, ge, Te, Ae, Ge = xv) => {
        const $e = Nt.fromTag("table"), lt = Ae !== "cells";
        sc($e, Ge.styles), ha($e, Ge.attributes), Ge.colGroups && es($e, ((Lt) => {
          const Vt = Nt.fromTag("colgroup");
          return un(Lt, () => es(Vt, Nt.fromTag("col"))), Vt;
        })(Ce));
        const pt = Math.min(ve, ge);
        if (lt && ge > 0) {
          const Lt = Nt.fromTag("thead");
          es($e, Lt);
          const Vt = gc(ge, Ce, Ae === "sectionCells" ? pt : 0, Te);
          Ti(Lt, Vt);
        }
        const Bt = Nt.fromTag("tbody");
        es($e, Bt);
        const xt = gc(lt ? ve - pt : ve, Ce, lt ? 0 : ge, Te);
        return Ti(Bt, xt), $e;
      })(_, y, P, T, Hc(p), j);
      Po(Y, "data-mce-id", "__mce");
      const ne = ((ve) => {
        const Ce = Nt.fromTag("div"), ge = Nt.fromDom(ve.dom.cloneNode(!0));
        return es(Ce, ge), ((Te) => Te.dom.innerHTML)(Ce);
      })(Y);
      p.insertContent(ne), p.addVisual();
    }), Ma(Hn(p), 'table[data-mce-id="__mce"]').map((Y) => (Cf(p) ? of(Y) : da(p) ? pc(Y) : (Ac(p) || ((ne) => ue(ne) && ne.indexOf("%") !== -1)(I.width)) && Gm(Y), yr(Y), _n(Y, "data-mce-id"), ((ne, ve) => {
      Et(ul(ve, "tr"), (Ce) => {
        yg(ne, Ce.dom), Et(ul(Ce, "th,td"), (ge) => {
          Bi(ne, ge.dom);
        });
      });
    })(p, Y), ((ne, ve) => {
      Ma(ve, "td,th").each(gt(ub, ne));
    })(p, Y), Y.dom)).getOrNull();
  };
  var Zc = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
  const iu = "x-tinymce/dom-table-", Mp = iu + "rows", Wl = iu + "columns", db = (p) => {
    const y = Zc.FakeClipboardItem(p);
    Zc.write([y]);
  }, ql = (p) => {
    var y;
    const _ = (y = Zc.read()) !== null && y !== void 0 ? y : [];
    return K(_, (T) => Se.from(T.getType(p)));
  }, rf = (p) => {
    ql(p).isSome() && Zc.clear();
  }, $y = (p) => {
    p.fold(wv, (y) => db({ [Mp]: y }));
  }, bh = () => ql(Mp), wv = () => rf(Mp), Hy = (p) => {
    p.fold(Uy, (y) => db({ [Wl]: y }));
  }, Vy = () => ql(Wl), Uy = () => rf(Wl), yh = (p) => zp(ws(p), En(p)).filter(Ni), Y1 = (p, y) => {
    const _ = En(p), T = (ge) => Zn(ge, _), P = (ge) => ((Te) => Ef(ws(Te), En(Te)).filter(Ni))(p).bind((Te) => T(Te).map((Ae) => ge(Ae, Te))), I = (ge) => {
      p.focus();
    }, j = (ge, Te = !1) => P((Ae, Ge) => {
      const $e = pn(uc(p), Ae, Ge);
      ge(Ae, $e, Te).each(I);
    }), Y = () => P((ge, Te) => ((Ae, Ge, $e) => {
      const lt = la(Ae);
      return as(lt, Ge).bind((pt) => {
        const Bt = on(lt, $e, !1), xt = zs(Bt).rows.slice(pt[0].row, pt[pt.length - 1].row + pt[pt.length - 1].rowspan), Lt = yo(xt, (rn) => {
          const Vn = mn(rn.cells, (Un) => !Un.isLocked);
          return Vn.length > 0 ? [{ ...rn, cells: Vn }] : [];
        }), Vt = Tn(Lt);
        return Wa(Vt.length > 0, Vt);
      }).map((pt) => M(pt, (Bt) => {
        const xt = vf(Bt.element);
        return Et(Bt.cells, (Lt) => {
          const Vt = rc(Lt.element);
          q(Vt, "colspan", Lt.colspan, 1), q(Vt, "rowspan", Lt.rowspan, 1), es(xt, Vt);
        }), xt;
      }));
    })(ge, pn(uc(p), ge, Te), yi(it, Nt.fromDom(p.getDoc()), Se.none()))), ne = () => P((ge, Te) => ((Ae, Ge) => {
      const $e = la(Ae);
      return Ha($e, Ge).map((lt) => {
        const pt = lt[lt.length - 1], Bt = lt[0].column, xt = pt.column + pt.colspan, Lt = ((rn, Vn, Un) => {
          if (ca(rn)) {
            const Do = mn(To(rn), Py(Vn, Un)), Gn = M(Do, (xo) => {
              const zr = rc(xo.element);
              return ph(zr, "span", Un - Vn), zr;
            }), Ro = Nt.fromTag("colgroup");
            return Ti(Ro, Gn), [Ro];
          }
          return [];
        })($e, Bt, xt), Vt = ((rn, Vn, Un) => M(rn.all, (Do) => {
          const Gn = mn(Do.cells, Py(Vn, Un)), Ro = M(Gn, (zr) => {
            const Wt = rc(zr.element);
            return ph(Wt, "colspan", Un - Vn), Wt;
          }), xo = Nt.fromTag("tr");
          return Ti(xo, Ro), xo;
        }))($e, Bt, xt);
        return [...Lt, ...Vt];
      });
    })(ge, pn(uc(p), ge, Te))), ve = (ge, Te) => Te().each((Ae) => {
      const Ge = M(Ae, ($e) => rc($e));
      P(($e, lt) => {
        const pt = dr(Nt.fromDom(p.getDoc())), Bt = ((xt, Lt, Vt, rn) => ({ selection: Dl(xt), clipboard: Vt, generators: rn }))(uc(p), 0, Ge, pt);
        ge($e, Bt).each(I);
      });
    }), Ce = (ge) => (Te, Ae) => ((Ge, $e) => oo(Ge, $e) ? Se.from(Ge[$e]) : Se.none())(Ae, "type").each((Ge) => {
      j(ge(Ge), Ae.no_events);
    });
    er({ mceTableSplitCells: () => j(y.unmergeCells), mceTableMergeCells: () => j(y.mergeCells), mceTableInsertRowBefore: () => j(y.insertRowsBefore), mceTableInsertRowAfter: () => j(y.insertRowsAfter), mceTableInsertColBefore: () => j(y.insertColumnsBefore), mceTableInsertColAfter: () => j(y.insertColumnsAfter), mceTableDeleteCol: () => j(y.deleteColumn), mceTableDeleteRow: () => j(y.deleteRow), mceTableCutCol: () => ne().each((ge) => {
      Hy(ge), j(y.deleteColumn);
    }), mceTableCutRow: () => Y().each((ge) => {
      $y(ge), j(y.deleteRow);
    }), mceTableCopyCol: () => ne().each((ge) => Hy(ge)), mceTableCopyRow: () => Y().each((ge) => $y(ge)), mceTablePasteColBefore: () => ve(y.pasteColsBefore, Vy), mceTablePasteColAfter: () => ve(y.pasteColsAfter, Vy), mceTablePasteRowBefore: () => ve(y.pasteRowsBefore, bh), mceTablePasteRowAfter: () => ve(y.pasteRowsAfter, bh), mceTableDelete: () => yh(p).each((ge) => {
      Zn(ge, _).filter(an(_)).each((Te) => {
        const Ae = Nt.fromText("");
        if (Xt(Te, Ae), pi(Te), p.dom.isEmpty(p.getBody()))
          p.setContent(""), p.selection.setCursorLocation();
        else {
          const Ge = p.dom.createRng();
          Ge.setStart(Ae.dom, 0), Ge.setEnd(Ae.dom, 0), p.selection.setRng(Ge), p.nodeChanged();
        }
      });
    }), mceTableCellToggleClass: (ge, Te) => {
      P((Ae) => {
        const Ge = uc(p), $e = Ct(Ge, (pt) => p.formatter.match("tablecellclass", { value: Te }, pt.dom)), lt = $e ? p.formatter.remove : p.formatter.apply;
        Et(Ge, (pt) => lt("tablecellclass", { value: Te }, pt.dom)), Tr(p, Ae.dom, rl);
      });
    }, mceTableToggleClass: (ge, Te) => {
      P((Ae) => {
        p.formatter.toggle("tableclass", { value: Te }, Ae.dom), Tr(p, Ae.dom, rl);
      });
    }, mceTableToggleCaption: () => {
      yh(p).each((ge) => {
        Zn(ge, _).each((Te) => {
          us(Te, "caption").fold(() => {
            const Ae = Nt.fromTag("caption");
            es(Ae, Nt.fromText("Caption")), ((Ge, $e, lt) => {
              Cl(Ge, 0).fold(() => {
                es(Ge, $e);
              }, (pt) => {
                Xc(pt, $e);
              });
            })(Te, Ae), p.selection.setCursorLocation(Ae.dom, 0);
          }, (Ae) => {
            Zr("caption")(ge) && mi("td", Te).each((Ge) => p.selection.setCursorLocation(Ge.dom, 0)), pi(Ae);
          }), Tr(p, Te.dom, ps);
        });
      });
    }, mceTableSizingMode: (ge, Te) => ((Ae) => yh(p).each((Ge) => {
      da(p) || Cf(p) || Ac(p) || Zn(Ge, _).each(($e) => {
        Ae !== "relative" || $t($e) ? Ae !== "fixed" || Fy($e) ? Ae !== "responsive" || _i($e) || pc($e) : of($e) : Gm($e), yr($e), Tr(p, $e.dom, ps);
      });
    }))(Te), mceTableCellType: Ce((ge) => ge === "th" ? y.makeCellsHeader : y.unmakeCellsHeader), mceTableColType: Ce((ge) => ge === "th" ? y.makeColumnsHeader : y.unmakeColumnsHeader), mceTableRowType: Ce((ge) => {
      switch (ge) {
        case "header":
          return y.makeRowsHeader;
        case "footer":
          return y.makeRowsFooter;
        default:
          return y.makeRowsBody;
      }
    }) }, (ge, Te) => p.addCommand(Te, ge)), p.addCommand("mceInsertTable", (ge, Te) => {
      ((Ae, Ge, $e, lt = {}) => {
        const pt = (Bt) => jt(Bt) && Bt > 0;
        if (pt(Ge) && pt($e)) {
          const Bt = lt.headerRows || 0, xt = lt.headerColumns || 0;
          return mm(Ae, $e, Ge, xt, Bt);
        }
        console.error("Invalid values for mceInsertTable - rows and columns values are required to insert a table.");
      })(p, Te.rows, Te.columns, Te.options);
    }), p.addCommand("mceTableApplyCellStyle", (ge, Te) => {
      const Ae = (lt) => "tablecell" + lt.toLowerCase().replace("-", "");
      if (!ce(Te))
        return;
      const Ge = mn(uc(p), Ni);
      if (Ge.length === 0)
        return;
      const $e = ((lt, pt) => {
        const Bt = {};
        return ((xt, Lt, Vt, rn) => {
          er(xt, (Vn, Un) => {
            (Lt(Vn, Un) ? Vt : rn)(Vn, Un);
          });
        })(lt, pt, ((xt) => (Lt, Vt) => {
          xt[Vt] = Lt;
        })(Bt), it), Bt;
      })(Te, (lt, pt) => p.formatter.has(Ae(pt)) && ue(lt));
      ((lt) => {
        for (const pt in lt)
          if (Zi.call(lt, pt))
            return !1;
        return !0;
      })($e) || (er($e, (lt, pt) => {
        const Bt = Ae(pt);
        Et(Ge, (xt) => {
          lt === "" ? p.formatter.remove(Bt, { value: null }, xt.dom, !0) : p.formatter.apply(Bt, { value: lt }, xt.dom);
        });
      }), T(Ge[0]).each((lt) => Tr(p, lt.dom, rl)));
    });
  }, Km = fm([{ before: ["element"] }, { on: ["element", "offset"] }, { after: ["element"] }]), bl = { before: Km.before, on: Km.on, after: Km.after, cata: (p, y, _, T) => p.fold(y, _, T), getStart: (p) => p.fold(en, en, en) }, Ym = (p, y) => ({ selection: p, kill: y }), Lf = (p, y) => {
    const _ = p.document.createRange();
    return _.selectNode(y.dom), _;
  }, As = (p, y) => {
    const _ = p.document.createRange();
    return pm(_, y), _;
  }, pm = (p, y) => p.selectNodeContents(y.dom), sl = (p, y, _) => {
    const T = p.document.createRange();
    var P;
    return P = T, y.fold((I) => {
      P.setStartBefore(I.dom);
    }, (I, j) => {
      P.setStart(I.dom, j);
    }, (I) => {
      P.setStartAfter(I.dom);
    }), ((I, j) => {
      j.fold((Y) => {
        I.setEndBefore(Y.dom);
      }, (Y, ne) => {
        I.setEnd(Y.dom, ne);
      }, (Y) => {
        I.setEndAfter(Y.dom);
      });
    })(T, _), T;
  }, kg = (p, y, _, T, P) => {
    const I = p.document.createRange();
    return I.setStart(y.dom, _), I.setEnd(T.dom, P), I;
  }, fb = (p) => ({ left: p.left, top: p.top, right: p.right, bottom: p.bottom, width: p.width, height: p.height }), _g = fm([{ ltr: ["start", "soffset", "finish", "foffset"] }, { rtl: ["start", "soffset", "finish", "foffset"] }]), gm = (p, y, _) => y(Nt.fromDom(_.startContainer), _.startOffset, Nt.fromDom(_.endContainer), _.endOffset), mb = (p, y) => {
    const _ = ((T, P) => P.match({ domRange: (I) => ({ ltr: Rt(I), rtl: Se.none }), relative: (I, j) => ({ ltr: ml(() => sl(T, I, j)), rtl: ml(() => Se.some(sl(T, j, I))) }), exact: (I, j, Y, ne) => ({ ltr: ml(() => kg(T, I, j, Y, ne)), rtl: ml(() => Se.some(kg(T, Y, ne, I, j))) }) }))(p, y);
    return ((T, P) => {
      const I = P.ltr();
      return I.collapsed ? P.rtl().filter((j) => j.collapsed === !1).map((j) => _g.rtl(Nt.fromDom(j.endContainer), j.endOffset, Nt.fromDom(j.startContainer), j.startOffset)).getOrThunk(() => gm(0, _g.ltr, I)) : gm(0, _g.ltr, I);
    })(0, _);
  }, hm = (p, y) => mb(p, y).match({ ltr: (_, T, P, I) => {
    const j = p.document.createRange();
    return j.setStart(_.dom, T), j.setEnd(P.dom, I), j;
  }, rtl: (_, T, P, I) => {
    const j = p.document.createRange();
    return j.setStart(P.dom, I), j.setEnd(_.dom, T), j;
  } });
  _g.ltr, _g.rtl;
  const Bp = (p, y, _, T) => ({ start: p, soffset: y, finish: _, foffset: T }), Lp = (p, y, _, T) => ({ start: bl.on(p, y), finish: bl.on(_, T) }), pb = (p, y) => {
    const _ = hm(p, y);
    return Bp(Nt.fromDom(_.startContainer), _.startOffset, Nt.fromDom(_.endContainer), _.endOffset);
  }, gb = Lp, gs = (p, y, _, T, P) => kr(_, T) ? Se.none() : Wd(_, T, y).bind((I) => {
    const j = I.boxes.getOr([]);
    return j.length > 1 ? (P(p, j, I.start, I.finish), Se.some(Ym(Se.some(gb(_, 0, _, Ya(_))), !0))) : Se.none();
  }), Ii = (p, y) => ({ item: p, mode: y }), vh = (p, y, _, T = bm) => p.property().parent(y).map((P) => Ii(P, T)), bm = (p, y, _, T = Pf) => _.sibling(p, y).map((P) => Ii(P, T)), Pf = (p, y, _, T = Pf) => {
    const P = p.property().children(y);
    return _.first(P).map((I) => Ii(I, T));
  }, jy = [{ current: vh, next: bm, fallback: Se.none() }, { current: bm, next: Pf, fallback: Se.some(vh) }, { current: Pf, next: Pf, fallback: Se.some(bm) }], Gl = (p, y, _, T, P = jy) => Bn(P, (I) => I.current === _).bind((I) => I.current(p, y, T, I.next).orThunk(() => I.fallback.bind((j) => Gl(p, y, j, T)))), Ja = (p, y, _, T, P, I) => Gl(p, y, T, P).bind((j) => I(j.item) ? Se.none() : _(j.item) ? Se.some(j.item) : Ja(p, j.item, _, j.mode, P, I)), X1 = (p) => (y) => p.property().children(y).length === 0, ym = (p, y, _, T) => Ja(p, y, _, bm, { sibling: (P, I) => P.query().prevSibling(I), first: (P) => P.length > 0 ? Se.some(P[P.length - 1]) : Se.none() }, T), Pp = (p, y, _, T) => Ja(p, y, _, bm, { sibling: (P, I) => P.query().nextSibling(I), first: (P) => P.length > 0 ? Se.some(P[0]) : Se.none() }, T), Xm = Zd(), hb = (p, y) => ((_, T, P) => ym(_, T, X1(_), P))(Xm, p, y), bb = (p, y) => ((_, T, P) => Pp(_, T, X1(_), P))(Xm, p, y), Zy = fm([{ none: ["message"] }, { success: [] }, { failedUp: ["cell"] }, { failedDown: ["cell"] }]), Cw = (p) => Us(p, "tr"), Cg = { ...Zy, verify: (p, y, _, T, P, I, j) => Us(T, "td,th", j).bind((Y) => Us(y, "td,th", j).map((ne) => kr(Y, ne) ? kr(T, Y) && Ya(Y) === P ? I(ne) : Zy.none("in same cell") : sh(Cw, [Y, ne]).fold(() => ((ve, Ce, ge) => {
    const Te = ve.getRect(Ce), Ae = ve.getRect(ge);
    return Ae.right > Te.left && Ae.left < Te.right;
  })(p, ne, Y) ? Zy.success() : I(ne), (ve) => I(ne)))).getOr(Zy.none("default")), cata: (p, y, _, T, P) => p.fold(y, _, T, P) }, Wy = Zr("br"), J1 = (p, y, _) => y(p, _).bind((T) => ho(T) && Nr(T).trim().length === 0 ? J1(T, y, _) : Se.some(T)), Sw = (p, y, _, T) => ((P, I) => Cl(P, I).filter(Wy).orThunk(() => Cl(P, I - 1).filter(Wy)))(y, _).bind((P) => T.traverse(P).fold(() => J1(P, T.gather, p).map(T.relative), (I) => ((j) => Wi(j).bind((Y) => {
    const ne = Ei(Y);
    return ((ve, Ce) => jr(ve, gt(kr, Ce)))(ne, j).map((ve) => ((Ce, ge, Te, Ae) => ({ parent: Ce, children: ge, element: Te, index: Ae }))(Y, ne, j, ve));
  }))(I).map((j) => bl.on(j.parent, j.index)))), yb = (p, y) => ({ left: p.left, top: p.top + y, right: p.right, bottom: p.bottom + y }), Rc = (p, y) => ({ left: p.left, top: p.top - y, right: p.right, bottom: p.bottom - y }), Bl = (p, y, _) => ({ left: p.left + y, top: p.top + _, right: p.right + y, bottom: p.bottom + _ }), vb = (p) => ({ left: p.left, top: p.top, right: p.right, bottom: p.bottom }), xb = (p, y) => Se.some(p.getRect(y)), sf = (p, y, _) => Mr(y) ? xb(p, y).map(vb) : ho(y) ? ((T, P, I) => I >= 0 && I < Ya(P) ? T.getRangedRect(P, I, P, I + 1) : I > 0 ? T.getRangedRect(P, I - 1, P, I) : Se.none())(p, y, _).map(vb) : Se.none(), xh = (p, y) => Mr(y) ? xb(p, y).map(vb) : ho(y) ? p.getRangedRect(y, 0, y, Ya(y)).map(vb) : Se.none(), Ru = fm([{ none: [] }, { retry: ["caret"] }]), If = (p, y, _) => gu(y, Va).fold(Ee, (T) => xh(p, T).exists((P) => ((I, j) => I.left < j.left || Math.abs(j.right - I.left) < 1 || I.left > j.right)(_, P))), Jm = { point: (p) => p.bottom, adjuster: (p, y, _, T, P) => {
    const I = yb(P, 5);
    return Math.abs(_.bottom - T.bottom) < 1 || _.top > P.bottom ? Ru.retry(I) : _.top === P.bottom ? Ru.retry(yb(P, 1)) : If(p, y, P) ? Ru.retry(Bl(I, 5, 0)) : Ru.none();
  }, move: yb, gather: bb }, vm = (p, y, _, T, P) => P === 0 ? Se.some(T) : ((I, j, Y) => I.elementFromPoint(j, Y).filter((ne) => xn(ne) === "table").isSome())(p, T.left, y.point(T)) ? ((I, j, Y, ne, ve) => vm(I, j, Y, j.move(ne, 5), ve))(p, y, _, T, P - 1) : p.situsFromPoint(T.left, y.point(T)).bind((I) => I.start.fold(Se.none, (j) => xh(p, j).bind((Y) => y.adjuster(p, j, Y, _, T).fold(Se.none, (ne) => vm(p, y, _, ne, P - 1))).orThunk(() => Se.some(T)), Se.none)), xm = (p, y, _) => {
    const T = p.move(_, 5), P = vm(y, p, _, T, 100).getOr(T);
    return ((I, j, Y) => I.point(j) > Y.getInnerHeight() ? Se.some(I.point(j) - Y.getInnerHeight()) : I.point(j) < 0 ? Se.some(-I.point(j)) : Se.none())(p, P, y).fold(() => y.situsFromPoint(P.left, p.point(P)), (I) => (y.scrollBy(0, I), y.situsFromPoint(P.left, p.point(P) - I)));
  }, yd = { tryUp: gt(xm, { point: (p) => p.top, adjuster: (p, y, _, T, P) => {
    const I = Rc(P, 5);
    return Math.abs(_.top - T.top) < 1 || _.bottom < P.top ? Ru.retry(I) : _.bottom === P.top ? Ru.retry(Rc(P, 1)) : If(p, y, P) ? Ru.retry(Bl(I, 5, 0)) : Ru.none();
  }, move: Rc, gather: hb }), tryDown: gt(xm, Jm), getJumpSize: Rt(5) }, Sg = (p, y, _) => p.getSelection().bind((T) => ((P, I, j, Y) => (Wy(I) ? ((ve, Ce, ge) => ge.traverse(Ce).orThunk(() => J1(Ce, ge.gather, ve)).map(ge.relative))(P, I, Y) : Sw(P, I, j, Y)).map((ve) => ({ start: ve, finish: ve })))(y, T.finish, T.foffset, _).fold(() => Se.some($a(T.finish, T.foffset)), (P) => {
    const I = p.fromSitus(P);
    return j = Cg.verify(p, T.finish, T.foffset, I.finish, I.foffset, _.failure, y), Cg.cata(j, (Y) => Se.none(), () => Se.none(), (Y) => Se.some($a(Y, 0)), (Y) => Se.some($a(Y, Ya(Y))));
    var j;
  })), wh = (p, y, _, T, P, I) => I === 0 ? Se.none() : qy(p, y, _, T, P).bind((j) => {
    const Y = p.fromSitus(j), ne = Cg.verify(p, _, T, Y.finish, Y.foffset, P.failure, y);
    return Cg.cata(ne, () => Se.none(), () => Se.some(j), (ve) => kr(_, ve) && T === 0 ? wb(p, _, T, Rc, P) : wh(p, y, ve, 0, P, I - 1), (ve) => kr(_, ve) && T === Ya(ve) ? wb(p, _, T, yb, P) : wh(p, y, ve, Ya(ve), P, I - 1));
  }), wb = (p, y, _, T, P) => sf(p, y, _).bind((I) => Kl(p, P, T(I, yd.getJumpSize()))), Kl = (p, y, _) => {
    const T = _c().browser;
    return T.isChromium() || T.isSafari() || T.isFirefox() ? y.retry(p, _) : Se.none();
  }, qy = (p, y, _, T, P) => sf(p, _, T).bind((I) => Kl(p, P, I)), Gy = (p, y, _, T, P) => Us(T, "td,th", y).bind((I) => Us(I, "table", y).bind((j) => ((Y, ne) => kc(Y, (ve) => Wi(ve).exists((Ce) => kr(Ce, ne)), void 0).isSome())(P, j) ? ((Y, ne, ve) => Sg(Y, ne, ve).bind((Ce) => wh(Y, ne, Ce.element, Ce.offset, ve, 20).map(Y.fromSitus)))(p, y, _).bind((Y) => Us(Y.finish, "td,th", y).map((ne) => ({ start: I, finish: ne, range: Y }))) : Se.none())), kb = (p, y, _, T, P, I) => I(T, y).orThunk(() => Gy(p, y, _, T, P).map((j) => {
    const Y = j.range;
    return Ym(Se.some(gb(Y.start, Y.soffset, Y.finish, Y.foffset)), !0);
  })), kv = (p, y) => Us(p, "tr", y).bind((_) => Us(_, "table", y).bind((T) => {
    const P = ul(T, "tr");
    return kr(_, P[0]) ? ((I, j, Y) => ym(Xm, I, (ne) => ou(ne).isSome(), Y))(T, 0, y).map((I) => {
      const j = Ya(I);
      return Ym(Se.some(gb(I, j, I, j)), !0);
    }) : Se.none();
  })), kh = (p, y) => Us(p, "tr", y).bind((_) => Us(_, "table", y).bind((T) => {
    const P = ul(T, "tr");
    return kr(_, P[P.length - 1]) ? ((I, j, Y) => Pp(Xm, I, (ne) => za(ne).isSome(), Y))(T, 0, y).map((I) => Ym(Se.some(gb(I, 0, I, 0)), !0)) : Se.none();
  })), Ky = (p, y, _, T, P, I, j) => Gy(p, _, T, P, I).bind((Y) => gs(y, _, Y.start, Y.finish, j)), wm = (p) => {
    let y = p;
    return { get: () => y, set: (_) => {
      y = _;
    } };
  }, km = () => {
    const p = ((y) => {
      const _ = wm(Se.none()), T = () => _.get().each(y);
      return { clear: () => {
        T(), _.set(Se.none());
      }, isSet: () => _.get().isSome(), get: () => _.get(), set: (P) => {
        T(), _.set(Se.some(P));
      } };
    })(it);
    return { ...p, on: (y) => p.get().each(y) };
  }, Q1 = (p, y) => Us(p, "td,th", y), _b = (p) => oc(p).exists(bn), Cb = { traverse: qi, gather: bb, relative: bl.before, retry: yd.tryDown, failure: Cg.failedDown }, _m = { traverse: Yn, gather: hb, relative: bl.before, retry: yd.tryUp, failure: Cg.failedUp }, Qm = (p) => (y) => y === p, Sb = Qm(38), _h = Qm(40), ep = (p) => p >= 37 && p <= 40, tp = { isBackward: Qm(37), isForward: Qm(39) }, Ip = { isBackward: Qm(39), isForward: Qm(37) }, af = fm([{ domRange: ["rng"] }, { relative: ["startSitu", "finishSitu"] }, { exact: ["start", "soffset", "finish", "foffset"] }]), np = { domRange: af.domRange, relative: af.relative, exact: af.exact, exactFromRange: (p) => af.exact(p.start, p.soffset, p.finish, p.foffset), getWin: (p) => {
    const y = ((_) => _.match({ domRange: (T) => Nt.fromDom(T.startContainer), relative: (T, P) => bl.getStart(T), exact: (T, P, I, j) => T }))(p);
    return Nt.fromDom(_l(y).dom.defaultView);
  }, range: Bp }, _v = document.caretPositionFromPoint ? (p, y, _) => {
    var T, P;
    return Se.from((P = (T = p.dom).caretPositionFromPoint) === null || P === void 0 ? void 0 : P.call(T, y, _)).bind((I) => {
      if (I.offsetNode === null)
        return Se.none();
      const j = p.dom.createRange();
      return j.setStart(I.offsetNode, I.offset), j.collapse(), Se.some(j);
    });
  } : document.caretRangeFromPoint ? (p, y, _) => {
    var T, P;
    return Se.from((P = (T = p.dom).caretRangeFromPoint) === null || P === void 0 ? void 0 : P.call(T, y, _));
  } : Se.none, Ch = (p, y) => {
    const _ = xn(p);
    return _ === "input" ? bl.after(p) : jn(["br", "img"], _) ? y === 0 ? bl.before(p) : bl.after(p) : bl.on(p, y);
  }, op = (p) => Se.from(p.getSelection()), Fp = (p, y) => {
    op(p).each((_) => {
      _.removeAllRanges(), _.addRange(y);
    });
  }, Eb = (p, y, _, T, P) => {
    const I = kg(p, y, _, T, P);
    Fp(p, I);
  }, Yy = (p, y) => mb(p, y).match({ ltr: (_, T, P, I) => {
    Eb(p, _, T, P, I);
  }, rtl: (_, T, P, I) => {
    op(p).each((j) => {
      if (j.setBaseAndExtent)
        j.setBaseAndExtent(_.dom, T, P.dom, I);
      else if (j.extend)
        try {
          ((Y, ne, ve, Ce, ge, Te) => {
            ne.collapse(ve.dom, Ce), ne.extend(ge.dom, Te);
          })(0, j, _, T, P, I);
        } catch {
          Eb(p, P, I, _, T);
        }
      else
        Eb(p, P, I, _, T);
    });
  } }), Xy = (p, y, _, T, P) => {
    const I = ((j, Y, ne, ve) => {
      const Ce = Ch(j, Y), ge = Ch(ne, ve);
      return np.relative(Ce, ge);
    })(y, _, T, P);
    Yy(p, I);
  }, Ll = (p, y, _) => {
    const T = ((P, I) => {
      const j = P.fold(bl.before, Ch, bl.after), Y = I.fold(bl.before, Ch, bl.after);
      return np.relative(j, Y);
    })(y, _);
    Yy(p, T);
  }, Tb = (p) => {
    if (p.rangeCount > 0) {
      const y = p.getRangeAt(0), _ = p.getRangeAt(p.rangeCount - 1);
      return Se.some(Bp(Nt.fromDom(y.startContainer), y.startOffset, Nt.fromDom(_.endContainer), _.endOffset));
    }
    return Se.none();
  }, lf = (p) => {
    if (p.anchorNode === null || p.focusNode === null)
      return Tb(p);
    {
      const y = Nt.fromDom(p.anchorNode), _ = Nt.fromDom(p.focusNode);
      return ((T, P, I, j) => {
        const Y = ((ve, Ce, ge, Te) => {
          const Ae = xc(ve).dom.createRange();
          return Ae.setStart(ve.dom, Ce), Ae.setEnd(ge.dom, Te), Ae;
        })(T, P, I, j), ne = kr(T, I) && P === j;
        return Y.collapsed && !ne;
      })(y, p.anchorOffset, _, p.focusOffset) ? Se.some(Bp(y, p.anchorOffset, _, p.focusOffset)) : Tb(p);
    }
  }, Nu = (p, y, _ = !0) => {
    const T = (_ ? As : Lf)(p, y);
    Fp(p, T);
  }, Jy = (p) => ((y) => op(y).filter((_) => _.rangeCount > 0).bind(lf))(p).map((y) => np.exact(y.start, y.soffset, y.finish, y.foffset)), Sh = (p) => ({ elementFromPoint: (y, _) => Nt.fromPoint(Nt.fromDom(p.document), y, _), getRect: (y) => y.dom.getBoundingClientRect(), getRangedRect: (y, _, T, P) => {
    const I = np.exact(y, _, T, P);
    return ((j, Y) => ((ne) => {
      const ve = ne.getClientRects(), Ce = ve.length > 0 ? ve[0] : ne.getBoundingClientRect();
      return Ce.width > 0 || Ce.height > 0 ? Se.some(Ce).map(fb) : Se.none();
    })(hm(j, Y)))(p, I);
  }, getSelection: () => Jy(p).map((y) => pb(p, y)), fromSitus: (y) => {
    const _ = np.relative(y.start, y.finish);
    return pb(p, _);
  }, situsFromPoint: (y, _) => ((T, P, I) => ((j, Y, ne) => {
    const ve = Nt.fromDom(j.document);
    return _v(ve, Y, ne).map((Ce) => Bp(Nt.fromDom(Ce.startContainer), Ce.startOffset, Nt.fromDom(Ce.endContainer), Ce.endOffset));
  })(T, P, I))(p, y, _).map((T) => Lp(T.start, T.soffset, T.finish, T.foffset)), clearSelection: () => {
    ((y) => {
      op(y).each((_) => _.removeAllRanges());
    })(p);
  }, collapseSelection: (y = !1) => {
    Jy(p).each((_) => _.fold((T) => T.collapse(y), (T, P) => {
      const I = y ? T : P;
      Ll(p, I, I);
    }, (T, P, I, j) => {
      const Y = y ? T : I, ne = y ? P : j;
      Xy(p, Y, ne, Y, ne);
    }));
  }, setSelection: (y) => {
    Xy(p, y.start, y.soffset, y.finish, y.foffset);
  }, setRelativeSelection: (y, _) => {
    Ll(p, y, _);
  }, selectNode: (y) => {
    Nu(p, y, !1);
  }, selectContents: (y) => {
    Nu(p, y);
  }, getInnerHeight: () => p.innerHeight, getScrollY: () => ((y) => {
    const _ = y !== void 0 ? y.dom : document, T = _.body.scrollLeft || _.documentElement.scrollLeft, P = _.body.scrollTop || _.documentElement.scrollTop;
    return Sc(T, P);
  })(Nt.fromDom(p.document)).top, scrollBy: (y, _) => {
    ((T, P, I) => {
      const j = (I !== void 0 ? I.dom : document).defaultView;
      j && j.scrollBy(T, P);
    })(y, _, Nt.fromDom(p.document));
  } }), rp = (p, y) => ({ rows: p, cols: y }), sp = (p) => gu(p, Ra).exists(bn), zb = (p, y) => sp(p) || sp(y), Ob = (p) => p.dom.classList !== void 0, Cm = (p, y) => ((_, T, P) => {
    const I = ((j, Y) => {
      const ne = ro(j, Y);
      return ne === void 0 || ne === "" ? [] : ne.split(" ");
    })(_, T).concat([P]);
    return Po(_, T, I.join(" ")), !0;
  })(p, "class", y), ap = (p, y) => {
    Ob(p) ? p.dom.classList.add(y) : Cm(p, y);
  }, Eh = (p, y) => Ob(p) && p.dom.classList.contains(y), ip = () => ({ tag: "none" }), Th = (p) => ({ tag: "multiple", elements: p }), zh = (p) => ({ tag: "single", element: p }), Eg = (p) => {
    const y = Nt.fromDom(((Y) => {
      if (Md() && Ye(Y.target)) {
        const ne = Nt.fromDom(Y.target);
        if (Mr(ne) && Ye(ne.dom.shadowRoot) && Y.composed && Y.composedPath) {
          const ve = Y.composedPath();
          if (ve)
            return Pn(ve);
        }
      }
      return Se.from(Y.target);
    })(p).getOr(p.target)), _ = () => p.stopPropagation(), T = () => p.preventDefault(), P = (I = T, j = _, (...Y) => I(j.apply(null, Y)));
    var I, j;
    return ((Y, ne, ve, Ce, ge, Te, Ae) => ({ target: Y, x: ne, y: ve, stop: Ce, prevent: ge, kill: Te, raw: Ae }))(y, p.clientX, p.clientY, _, T, P, p);
  }, Ab = (p, y, _, T) => {
    p.dom.removeEventListener(y, _, T);
  }, $p = wt, Ff = (p, y, _) => ((T, P, I, j) => ((Y, ne, ve, Ce, ge) => {
    const Te = ((Ae, Ge) => ($e) => {
      Ae($e) && Ge(Eg($e));
    })(ve, Ce);
    return Y.dom.addEventListener(ne, Te, ge), { unbind: gt(Ab, Y, ne, Te, ge) };
  })(T, P, I, j, !1))(p, y, $p, _), Sm = Eg, Tg = (p) => !Eh(Nt.fromDom(p.target), "ephox-snooker-resizer-bar"), Db = (p, y) => {
    const _ = (P = Io.selectedSelector, { get: () => qd(Nt.fromDom(p.getBody()), P).fold(() => Ef(ws(p), En(p)).fold(ip, zh), Th) }), T = ((I, j, Y) => {
      const ne = (Te) => {
        _n(Te, I.selected), _n(Te, I.firstSelected), _n(Te, I.lastSelected);
      }, ve = (Te) => {
        Po(Te, I.selected, "1");
      }, Ce = (Te) => {
        ge(Te), Y();
      }, ge = (Te) => {
        const Ae = ul(Te, `${I.selectedSelector},${I.firstSelectedSelector},${I.lastSelectedSelector}`);
        Et(Ae, ne);
      };
      return { clearBeforeUpdate: ge, clear: Ce, selectRange: (Te, Ae, Ge, $e) => {
        Ce(Te), Et(Ae, ve), Po(Ge, I.firstSelected, "1"), Po($e, I.lastSelected, "1"), j(Ae, Ge, $e);
      }, selectedSelector: I.selectedSelector, firstSelectedSelector: I.firstSelectedSelector, lastSelectedSelector: I.lastSelectedSelector };
    })(Io, (I, j, Y) => {
      Zn(j).each((ne) => {
        const ve = de(p), Ce = yi(it, Nt.fromDom(p.getDoc()), ve), ge = ((Te, Ae, Ge) => {
          const $e = la(Te);
          return as($e, Ae).map((lt) => {
            const pt = on($e, Ge, !1), { rows: Bt } = zs(pt), xt = ((Vt, rn) => {
              const Vn = Vt.slice(0, rn[rn.length - 1].row + 1), Un = Tn(Vn);
              return yo(Un, (Do) => {
                const Gn = Do.cells.slice(0, rn[rn.length - 1].column + 1);
                return M(Gn, (Ro) => Ro.element);
              });
            })(Bt, lt), Lt = ((Vt, rn) => {
              const Vn = Vt.slice(rn[0].row + rn[0].rowspan - 1, Vt.length), Un = Tn(Vn);
              return yo(Un, (Do) => {
                const Gn = Do.cells.slice(rn[0].column + rn[0].colspan - 1, Do.cells.length);
                return M(Gn, (Ro) => Ro.element);
              });
            })(Bt, lt);
            return { upOrLeftCells: xt, downOrRightCells: Lt };
          });
        })(ne, { selection: uc(p) }, Ce);
        ((Te, Ae, Ge, $e, lt) => {
          Te.dispatch("TableSelectionChange", { cells: Ae, start: Ge, finish: $e, otherCells: lt });
        })(p, I, j, Y, ge);
      });
    }, () => ((I) => {
      I.dispatch("TableSelectionClear");
    })(p));
    var P;
    return p.on("init", (I) => {
      const j = p.getWin(), Y = Hn(p), ne = En(p), ve = (($e, lt, pt, Bt) => {
        const xt = ((Lt, Vt, rn, Vn) => {
          const Un = km(), Do = Un.clear, Gn = (Ro) => {
            Un.on((xo) => {
              Vn.clearBeforeUpdate(Vt), Q1(Ro.target, rn).each((zr) => {
                Wd(xo, zr, rn).each((Wt) => {
                  const Hi = Wt.boxes.getOr([]);
                  if (Hi.length === 1) {
                    const ja = Hi[0], ai = ao(ja) === "false", Dn = dl(zt(Ro.target), ja, kr);
                    ai && Dn && (Vn.selectRange(Vt, Hi, ja, ja), Lt.selectContents(ja));
                  } else
                    Hi.length > 1 && (Vn.selectRange(Vt, Hi, Wt.start, Wt.finish), Lt.selectContents(zr));
                });
              });
            });
          };
          return { clearstate: Do, mousedown: (Ro) => {
            Vn.clear(Vt), Q1(Ro.target, rn).filter(_b).each(Un.set);
          }, mouseover: (Ro) => {
            Gn(Ro);
          }, mouseup: (Ro) => {
            Gn(Ro), Do();
          } };
        })(Sh($e), lt, pt, Bt);
        return { clearstate: xt.clearstate, mousedown: xt.mousedown, mouseover: xt.mouseover, mouseup: xt.mouseup };
      })(j, Y, ne, T), Ce = (($e, lt, pt, Bt) => {
        const xt = Sh($e), Lt = () => (Bt.clear(lt), Se.none());
        return { keydown: (Vt, rn, Vn, Un, Do, Gn) => {
          const Ro = Vt.raw, xo = Ro.which, zr = Ro.shiftKey === !0;
          return Uc(lt, Bt.selectedSelector).fold(() => (ep(xo) && !zr && Bt.clearBeforeUpdate(lt), ep(xo) && zr && !zb(rn, Un) ? Se.none : _h(xo) && zr ? gt(Ky, xt, lt, pt, Cb, Un, rn, Bt.selectRange) : Sb(xo) && zr ? gt(Ky, xt, lt, pt, _m, Un, rn, Bt.selectRange) : _h(xo) ? gt(kb, xt, pt, Cb, Un, rn, kh) : Sb(xo) ? gt(kb, xt, pt, _m, Un, rn, kv) : Se.none), (Hi) => {
            const ja = (ai) => () => K(ai, (ii) => ((yl, Ng, Ah, hs, Dh) => Fm(hs, yl, Ng, Dh.firstSelectedSelector, Dh.lastSelectedSelector).map((li) => (Dh.clearBeforeUpdate(Ah), Dh.selectRange(Ah, li.boxes, li.start, li.finish), li.boxes)))(ii.rows, ii.cols, lt, Hi, Bt)).fold(() => At(lt, Bt.firstSelectedSelector, Bt.lastSelectedSelector).map((ii) => {
              const yl = _h(xo) || Gn.isForward(xo) ? bl.after : bl.before;
              return xt.setRelativeSelection(bl.on(ii.first, 0), yl(ii.table)), Bt.clear(lt), Ym(Se.none(), !0);
            }), (ii) => Se.some(Ym(Se.none(), !0)));
            return ep(xo) && zr && !zb(rn, Un) ? Se.none : _h(xo) && zr ? ja([rp(1, 0)]) : Sb(xo) && zr ? ja([rp(-1, 0)]) : Gn.isBackward(xo) && zr ? ja([rp(0, -1), rp(-1, 0)]) : Gn.isForward(xo) && zr ? ja([rp(0, 1), rp(1, 0)]) : ep(xo) && !zr ? Lt : Se.none;
          })();
        }, keyup: (Vt, rn, Vn, Un, Do) => Uc(lt, Bt.selectedSelector).fold(() => {
          const Gn = Vt.raw, Ro = Gn.which;
          return Gn.shiftKey === !0 && ep(Ro) && zb(rn, Un) ? ((xo, zr, Wt, Hi, ja, ai, Dn) => kr(Wt, ja) && Hi === ai ? Se.none() : Us(Wt, "td,th", zr).bind((ii) => Us(ja, "td,th", zr).bind((yl) => gs(xo, zr, ii, yl, Dn))))(lt, pt, rn, Vn, Un, Do, Bt.selectRange) : Se.none();
        }, Se.none) };
      })(j, Y, ne, T), ge = (($e, lt, pt, Bt) => {
        const xt = Sh($e);
        return (Lt, Vt) => {
          Bt.clearBeforeUpdate(lt), Wd(Lt, Vt, pt).each((rn) => {
            const Vn = rn.boxes.getOr([]);
            Bt.selectRange(lt, Vn, rn.start, rn.finish), xt.selectContents(Vt), xt.collapseSelection();
          });
        };
      })(j, Y, ne, T);
      p.on("TableSelectorChange", ($e) => ge($e.start, $e.finish));
      const Te = ($e, lt) => {
        ((pt) => pt.raw.shiftKey === !0)($e) && (lt.kill && $e.kill(), lt.selection.each((pt) => {
          const Bt = np.relative(pt.start, pt.finish), xt = hm(j, Bt);
          p.selection.setRng(xt);
        }));
      }, Ae = ($e) => $e.button === 0, Ge = (() => {
        const $e = wm(Nt.fromDom(Y)), lt = wm(0);
        return { touchEnd: (pt) => {
          const Bt = Nt.fromDom(pt.target);
          if (Zr("td")(Bt) || Zr("th")(Bt)) {
            const xt = $e.get(), Lt = lt.get();
            kr(xt, Bt) && pt.timeStamp - Lt < 300 && (pt.preventDefault(), ge(Bt, Bt));
          }
          $e.set(Bt), lt.set(pt.timeStamp);
        } };
      })();
      p.on("dragstart", ($e) => {
        ve.clearstate();
      }), p.on("mousedown", ($e) => {
        Ae($e) && Tg($e) && ve.mousedown(Sm($e));
      }), p.on("mouseover", ($e) => {
        var lt;
        (lt = $e).buttons !== void 0 && !(1 & lt.buttons) || !Tg($e) || ve.mouseover(Sm($e));
      }), p.on("mouseup", ($e) => {
        Ae($e) && Tg($e) && ve.mouseup(Sm($e));
      }), p.on("touchend", Ge.touchEnd), p.on("keyup", ($e) => {
        const lt = Sm($e);
        if (lt.raw.shiftKey && ep(lt.raw.which)) {
          const pt = p.selection.getRng(), Bt = Nt.fromDom(pt.startContainer), xt = Nt.fromDom(pt.endContainer);
          Ce.keyup(lt, Bt, pt.startOffset, xt, pt.endOffset).each((Lt) => {
            Te(lt, Lt);
          });
        }
      }), p.on("keydown", ($e) => {
        const lt = Sm($e);
        y.hide();
        const pt = p.selection.getRng(), Bt = Nt.fromDom(pt.startContainer), xt = Nt.fromDom(pt.endContainer), Lt = xu(tp, Ip)(Nt.fromDom(p.selection.getStart()));
        Ce.keydown(lt, Bt, pt.startOffset, xt, pt.endOffset, Lt).each((Vt) => {
          Te(lt, Vt);
        }), y.show();
      }), p.on("NodeChange", () => {
        const $e = p.selection, lt = Nt.fromDom($e.getStart()), pt = Nt.fromDom($e.getEnd());
        sh(Zn, [lt, pt]).fold(() => T.clear(Y), it);
      });
    }), p.on("PreInit", () => {
      p.serializer.addTempAttr(Io.firstSelected), p.serializer.addTempAttr(Io.lastSelected);
    }), { getSelectedCells: () => ((I, j, Y, ne) => {
      switch (I.tag) {
        case "none":
          return j();
        case "single":
          return ((ve) => [ve.dom])(I.element);
        case "multiple":
          return ((ve) => M(ve, (Ce) => Ce.dom))(I.elements);
      }
    })(_.get(), Rt([])), clearSelectedCells: (I) => T.clear(Nt.fromDom(I)) };
  }, vd = (p) => {
    let y = [];
    return { bind: (_) => {
      if (_ === void 0)
        throw new Error("Event bind error: undefined handler");
      y.push(_);
    }, unbind: (_) => {
      y = mn(y, (T) => T !== _);
    }, trigger: (..._) => {
      const T = {};
      Et(p, (P, I) => {
        T[P] = _[I];
      }), Et(y, (P) => {
        P(T);
      });
    } };
  }, Hp = (p) => ({ registry: Qr(p, (y) => ({ bind: y.bind, unbind: y.unbind })), trigger: Qr(p, (y) => y.trigger) }), zg = (p) => p.slice(0).sort(), zo = (p, y) => {
    const _ = mn(y, (T) => !jn(p, T));
    _.length > 0 && ((T) => {
      throw new Error("Unsupported keys for object: " + zg(T).join(", "));
    })(_);
  }, Pl = (p) => ((y, _) => ((T, P, I) => {
    if (P.length === 0)
      throw new Error("You must specify at least one required field.");
    return ((j, Y) => {
      if (!he(Y))
        throw new Error("The " + j + " fields must be an array. Was: " + Y + ".");
      Et(Y, (ne) => {
        if (!ue(ne))
          throw new Error("The value " + ne + " in the " + j + " fields was not a string.");
      });
    })("required", P), ((j) => {
      const Y = zg(j);
      Bn(Y, (ne, ve) => ve < Y.length - 1 && ne === Y[ve + 1]).each((ne) => {
        throw new Error("The field: " + ne + " occurs more than once in the combined fields: [" + Y.join(", ") + "].");
      });
    })(P), (j) => {
      const Y = Go(j);
      Ct(P, (ve) => jn(Y, ve)) || ((ve, Ce) => {
        throw new Error("All required keys (" + zg(ve).join(", ") + ") were not specified. Specified keys were: " + zg(Ce).join(", ") + ".");
      })(P, Y), T(P, Y);
      const ne = mn(P, (ve) => !I.validate(j[ve], ve));
      return ne.length > 0 && ((ve, Ce) => {
        throw new Error("All values need to be of type: " + Ce + ". Keys (" + zg(ve).join(", ") + ") were not.");
      })(ne, I.label), j;
    };
  })(y, _, { validate: yt, label: "function" }))(zo, p), Og = Pl(["compare", "extract", "mutate", "sink"]), nt = Pl(["element", "start", "stop", "destroy"]), Ag = Pl(["forceDrop", "drop", "move", "delayDrop"]), Rb = () => {
    const p = (() => {
      const T = Hp({ move: vd(["info"]) });
      return { onEvent: it, reset: it, events: T.registry };
    })(), y = (() => {
      let T = Se.none();
      const P = Hp({ move: vd(["info"]) });
      return { onEvent: (I, j) => {
        j.extract(I).each((Y) => {
          ((ve, Ce) => {
            const ge = T.map((Te) => ve.compare(Te, Ce));
            return T = Se.some(Ce), ge;
          })(j, Y).each((ve) => {
            P.trigger.move(ve);
          });
        });
      }, reset: () => {
        T = Se.none();
      }, events: P.registry };
    })();
    let _ = p;
    return { on: () => {
      _.reset(), _ = y;
    }, off: () => {
      _.reset(), _ = p;
    }, isOn: () => _ === y, onEvent: (T, P) => {
      _.onEvent(T, P);
    }, events: y.events };
  }, e0 = (p) => {
    const y = p.replace(/\./g, "-");
    return { resolve: (_) => y + "-" + _ };
  }, Dg = e0("ephox-dragster").resolve;
  var Mu = Og({ compare: (p, y) => Sc(y.left - p.left, y.top - p.top), extract: (p) => Se.some(Sc(p.x, p.y)), sink: (p, y) => {
    const _ = ((Y) => {
      const ne = { layerClass: Dg("blocker"), ...Y }, ve = Nt.fromTag("div");
      return Po(ve, "role", "presentation"), sc(ve, { position: "fixed", left: "0px", top: "0px", width: "100%", height: "100%" }), ap(ve, Dg("blocker")), ap(ve, ne.layerClass), { element: Rt(ve), destroy: () => {
        pi(ve);
      } };
    })(y), T = Ff(_.element(), "mousedown", p.forceDrop), P = Ff(_.element(), "mouseup", p.drop), I = Ff(_.element(), "mousemove", p.move), j = Ff(_.element(), "mouseout", p.delayDrop);
    return nt({ element: _.element, start: (Y) => {
      es(Y, _.element());
    }, stop: () => {
      pi(_.element());
    }, destroy: () => {
      _.destroy(), P.unbind(), I.unbind(), j.unbind(), T.unbind();
    } });
  }, mutate: (p, y) => {
    p.mutate(y.left, y.top);
  } });
  const Rg = e0("ephox-snooker").resolve, Nb = Rg("resizer-bar"), Qy = Rg("resizer-rows"), Oh = Rg("resizer-cols"), Mb = (p) => {
    const y = ul(p.parent(), "." + Nb);
    Et(y, pi);
  }, e1 = (p, y, _) => {
    const T = p.origin();
    Et(y, (P) => {
      P.each((I) => {
        const j = _(T, I);
        ap(j, Nb), es(p.parent(), j);
      });
    });
  }, t0 = (p, y, _, T, P) => {
    const I = tu(_), j = y.isResizable, Y = T.length > 0 ? Nn.positions(T, _) : [], ne = Y.length > 0 ? ((ge, Te) => yo(ge.all, (Ae, Ge) => Te(Ae.element) ? [Ge] : []))(p, j) : [];
    ((ge, Te, Ae, Ge) => {
      e1(ge, Te, ($e, lt) => {
        const pt = ((Bt, xt, Lt, Vt, rn) => {
          const Vn = Nt.fromTag("div");
          return sc(Vn, { position: "absolute", left: xt + "px", top: Lt - 3.5 + "px", height: "7px", width: Vt + "px" }), ha(Vn, { "data-row": Bt, role: "presentation" }), Vn;
        })(lt.row, Ae.left - $e.left, lt.y - $e.top, Ge);
        return ap(pt, Qy), pt;
      });
    })(y, mn(Y, (ge, Te) => Xe(ne, (Ae) => Te === Ae)), I, td(_));
    const ve = P.length > 0 ? Di.positions(P, _) : [], Ce = ve.length > 0 ? ((ge, Te) => {
      const Ae = [];
      return un(ge.grid.columns, (Ge) => {
        rd(ge, Ge).map(($e) => $e.element).forall(Te) && Ae.push(Ge);
      }), mn(Ae, (Ge) => {
        const $e = vu(ge, (lt) => lt.column === Ge);
        return Ct($e, (lt) => Te(lt.element));
      });
    })(p, j) : [];
    ((ge, Te, Ae, Ge) => {
      e1(ge, Te, ($e, lt) => {
        const pt = ((Bt, xt, Lt, Vt, rn) => {
          const Vn = Nt.fromTag("div");
          return sc(Vn, { position: "absolute", left: xt - 3.5 + "px", top: Lt + "px", height: rn + "px", width: "7px" }), ha(Vn, { "data-column": Bt, role: "presentation" }), Vn;
        })(lt.col, lt.x - $e.left, Ae.top - $e.top, 0, Ge);
        return ap(pt, Oh), pt;
      });
    })(y, mn(ve, (ge, Te) => Xe(Ce, (Ae) => Te === Ae)), I, Sp(_));
  }, Bb = (p, y) => {
    if (Mb(p), p.isResizable(y)) {
      const _ = la(y), T = Fc(_), P = Oi(_);
      t0(_, p, y, T, P);
    }
  }, n0 = (p, y) => {
    const _ = ul(p.parent(), "." + Nb);
    Et(_, y);
  }, xd = (p) => {
    n0(p, (y) => {
      Bs(y, "display", "none");
    });
  }, Cv = (p) => {
    n0(p, (y) => {
      Bs(y, "display", "block");
    });
  }, ln = Rg("resizer-bar-dragging"), pa = (p) => {
    const y = (() => {
      const ge = Hp({ drag: vd(["xDelta", "yDelta", "target"]) });
      let Te = Se.none();
      const Ae = (() => {
        const Ge = Hp({ drag: vd(["xDelta", "yDelta"]) });
        return { mutate: ($e, lt) => {
          Ge.trigger.drag($e, lt);
        }, events: Ge.registry };
      })();
      return Ae.events.drag.bind((Ge) => {
        Te.each(($e) => {
          ge.trigger.drag(Ge.xDelta, Ge.yDelta, $e);
        });
      }), { assign: (Ge) => {
        Te = Se.some(Ge);
      }, get: () => Te, mutate: Ae.mutate, events: ge.registry };
    })(), _ = ((ge, Te = {}) => {
      var Ae;
      return ((Ge, $e, lt) => {
        let pt = !1;
        const Bt = Hp({ start: vd([]), stop: vd([]) }), xt = Rb(), Lt = () => {
          Vn.stop(), xt.isOn() && (xt.off(), Bt.trigger.stop());
        }, Vt = ((Un, Do) => {
          let Gn = null;
          const Ro = () => {
            pe(Gn) || (clearTimeout(Gn), Gn = null);
          };
          return { cancel: Ro, throttle: (...xo) => {
            Ro(), Gn = setTimeout(() => {
              Gn = null, Un.apply(null, xo);
            }, 200);
          } };
        })(Lt);
        xt.events.move.bind((Un) => {
          $e.mutate(Ge, Un.info);
        });
        const rn = (Un) => (...Do) => {
          pt && Un.apply(null, Do);
        }, Vn = $e.sink(Ag({ forceDrop: Lt, drop: rn(Lt), move: rn((Un) => {
          Vt.cancel(), xt.onEvent(Un, $e);
        }), delayDrop: rn(Vt.throttle) }), lt);
        return { element: Vn.element, go: (Un) => {
          Vn.start(Un), xt.on(), Bt.trigger.start();
        }, on: () => {
          pt = !0;
        }, off: () => {
          pt = !1;
        }, isActive: () => pt, destroy: () => {
          Vn.destroy();
        }, events: Bt.registry };
      })(ge, (Ae = Te.mode) !== null && Ae !== void 0 ? Ae : Mu, Te);
    })(y, {});
    let T = Se.none();
    const P = (ge, Te) => Se.from(ro(ge, Te));
    y.events.drag.bind((ge) => {
      P(ge.target, "data-row").each((Te) => {
        const Ae = ar(ge.target, "top");
        Bs(ge.target, "top", Ae + ge.yDelta + "px");
      }), P(ge.target, "data-column").each((Te) => {
        const Ae = ar(ge.target, "left");
        Bs(ge.target, "left", Ae + ge.xDelta + "px");
      });
    });
    const I = (ge, Te) => ar(ge, Te) - fl(ge, "data-initial-" + Te, 0);
    _.events.stop.bind(() => {
      y.get().each((ge) => {
        T.each((Te) => {
          P(ge, "data-row").each((Ae) => {
            const Ge = I(ge, "top");
            _n(ge, "data-initial-top"), Ce.trigger.adjustHeight(Te, Ge, parseInt(Ae, 10));
          }), P(ge, "data-column").each((Ae) => {
            const Ge = I(ge, "left");
            _n(ge, "data-initial-left"), Ce.trigger.adjustWidth(Te, Ge, parseInt(Ae, 10));
          }), Bb(p, Te);
        });
      });
    });
    const j = (ge, Te) => {
      Ce.trigger.startAdjust(), y.assign(ge), Po(ge, "data-initial-" + Te, ar(ge, Te)), ap(ge, ln), Bs(ge, "opacity", "0.2"), _.go(p.parent());
    }, Y = Ff(p.parent(), "mousedown", (ge) => {
      var Te;
      Te = ge.target, Eh(Te, Qy) && j(ge.target, "top"), ((Ae) => Eh(Ae, Oh))(ge.target) && j(ge.target, "left");
    }), ne = (ge) => kr(ge, p.view()), ve = Ff(p.view(), "mouseover", (ge) => {
      var Te;
      (Te = ge.target, Us(Te, "table", ne).filter(bn)).fold(() => {
        sa(ge.target) && Mb(p);
      }, (Ae) => {
        _.isActive() && (T = Se.some(Ae), Bb(p, Ae));
      });
    }), Ce = Hp({ adjustHeight: vd(["table", "delta", "row"]), adjustWidth: vd(["table", "delta", "column"]), startAdjust: vd([]) });
    return { destroy: () => {
      Y.unbind(), ve.unbind(), _.destroy(), Mb(p);
    }, refresh: (ge) => {
      Bb(p, ge);
    }, on: _.on, off: _.off, hideBars: gt(xd, p), showBars: gt(Cv, p), events: Ce.registry };
  }, ir = (p, y, _) => {
    const T = Nn, P = Di, I = pa(p), j = Hp({ beforeResize: vd(["table", "type"]), afterResize: vd(["table", "type"]), startDrag: vd([]) });
    return I.events.adjustHeight.bind((Y) => {
      const ne = Y.table;
      j.trigger.beforeResize(ne, "row"), ((ve, Ce, ge, Te) => {
        const Ae = la(ve), Ge = ((xt, Lt, Vt) => Is(xt, Lt, Vt, ic, (rn) => rn.getOrThunk(ze)))(Ae, ve, Te), $e = M(Ge, (xt, Lt) => ge === Lt ? Math.max(Ce + xt, ze()) : xt), lt = Zm(Ae, $e), pt = ((xt, Lt) => M(xt.all, (Vt, rn) => ({ element: Vt.element, height: Lt[rn] })))(Ae, $e);
        Et(pt, (xt) => {
          am(xt.element, xt.height);
        }), Et(lt, (xt) => {
          am(xt.element, xt.height);
        });
        const Bt = lo($e, (xt, Lt) => xt + Lt, 0);
        am(ve, Bt);
      })(ne, T.delta(Y.delta, ne), Y.row, T), j.trigger.afterResize(ne, "row");
    }), I.events.startAdjust.bind((Y) => {
      j.trigger.startDrag();
    }), I.events.adjustWidth.bind((Y) => {
      const ne = Y.table;
      j.trigger.beforeResize(ne, "col");
      const ve = P.delta(Y.delta, ne), Ce = _(ne);
      gd(ne, ve, Y.column, y, Ce), j.trigger.afterResize(ne, "col");
    }), { on: I.on, off: I.off, refreshBars: I.refresh, hideBars: I.hideBars, showBars: I.showBars, destroy: I.destroy, events: j.registry };
  }, Fi = (p) => Ye(p) && p.nodeName === "TABLE", $i = "bar-", Ua = (p) => ro(p, "data-mce-resize") !== "false", Lb = (p) => {
    const y = km(), _ = km(), T = km();
    let P, I;
    const j = (ne) => ma(p, ne), Y = () => ls(p) ? hl() : eb();
    return p.on("init", () => {
      const ne = ((ve, Ce) => ve.inline ? ((ge, Te, Ae) => ({ parent: Rt(Te), view: Rt(ge), origin: Rt(Sc(0, 0)), isResizable: Ae }))(Nt.fromDom(ve.getBody()), (() => {
        const ge = Nt.fromTag("div");
        return sc(ge, { position: "static", height: "0", width: "0", padding: "0", margin: "0", border: "0" }), es(nm(Nt.fromDom(document)), ge), ge;
      })(), Ce) : ((ge, Te) => {
        const Ae = Ns(ge) ? ((Ge) => Nt.fromDom(_l(Ge).dom.documentElement))(ge) : ge;
        return { parent: Rt(Ae), view: Rt(ge), origin: Rt(Sc(0, 0)), isResizable: Te };
      })(Nt.fromDom(ve.getDoc()), Ce))(p, Ua);
      if (T.set(ne), ((ve) => {
        const Ce = ve.options.get("object_resizing");
        return jn(Ce.split(","), "table");
      })(p) && z(p)) {
        const ve = Y(), Ce = ir(ne, ve, j);
        Ce.on(), Ce.events.startDrag.bind((ge) => {
          y.set(p.selection.getRng());
        }), Ce.events.beforeResize.bind((ge) => {
          const Te = ge.table.dom;
          ((Ae, Ge, $e, lt, pt) => {
            Ae.dispatch("ObjectResizeStart", { target: Ge, width: $e, height: lt, origin: pt });
          })(p, Te, Ri(Te), _u(Te), $i + ge.type);
        }), Ce.events.afterResize.bind((ge) => {
          const Te = ge.table, Ae = Te.dom;
          yr(Te), y.on((Ge) => {
            p.selection.setRng(Ge), p.focus();
          }), ((Ge, $e, lt, pt, Bt) => {
            Ge.dispatch("ObjectResized", { target: $e, width: lt, height: pt, origin: Bt });
          })(p, Ae, Ri(Ae), _u(Ae), $i + ge.type), p.undoManager.add();
        }), _.set(Ce);
      }
    }), p.on("ObjectResizeStart", (ne) => {
      const ve = ne.target;
      if (Fi(ve)) {
        const Ce = Nt.fromDom(ve);
        Et(p.dom.select(".mce-clonedresizable"), (ge) => {
          p.dom.addClass(ge, "mce-" + Oc(p) + "-columns");
        }), !Fy(Ce) && Cf(p) ? of(Ce) : !$t(Ce) && Ac(p) && Gm(Ce), _i(Ce) && eo(ne.origin, $i) && Gm(Ce), P = ne.width, I = da(p) ? "" : ((ge, Te) => {
          const Ae = ge.dom.getStyle(Te, "width") || ge.dom.getAttrib(Te, "width");
          return Se.from(Ae).filter(Sa);
        })(p, ve).getOr("");
      }
    }), p.on("ObjectResized", (ne) => {
      const ve = ne.target;
      if (Fi(ve)) {
        const Ce = Nt.fromDom(ve), ge = ne.origin;
        eo(ge, "corner-") && ((Te, Ae, Ge) => {
          const $e = gi(Ae, "e");
          if (I === "" && Gm(Te), Ge !== P && I !== "") {
            Bs(Te, "width", I);
            const lt = Y(), pt = j(Te), Bt = ls(p) || $e ? ((xt) => Hm(xt).columns)(Te) - 1 : 0;
            gd(Te, Ge - P, Bt, lt, pt);
          } else if (((lt) => /^(\d+(\.\d+)?)%$/.test(lt))(I)) {
            const lt = parseFloat(I.replace("%", ""));
            Bs(Te, "width", Ge * lt / P + "%");
          }
          ((lt) => /^(\d+(\.\d+)?)px$/.test(lt))(I) && ((lt) => {
            const pt = la(lt);
            ca(pt) || Et(An(lt), (Bt) => {
              const xt = qn(Bt, "width");
              Bs(Bt, "width", xt), _n(Bt, "width");
            });
          })(Te);
        })(Ce, ge, ne.width), yr(Ce), Tr(p, Ce.dom, rl);
      }
    }), p.on("SwitchMode", () => {
      _.on((ne) => {
        p.mode.isReadOnly() ? ne.hideBars() : ne.showBars();
      });
    }), p.on("dragstart dragend", (ne) => {
      _.on((ve) => {
        ne.type === "dragstart" ? (ve.hideBars(), ve.off()) : (ve.on(), ve.showBars());
      });
    }), p.on("remove", () => {
      _.on((ne) => {
        ne.destroy();
      }), T.on((ne) => {
        ((ve, Ce) => {
          ve.inline && pi(Ce.parent());
        })(p, ne);
      });
    }), { refresh: (ne) => {
      _.on((ve) => ve.refreshBars(Nt.fromDom(ne)));
    }, hide: () => {
      _.on((ne) => ne.hideBars());
    }, show: () => {
      _.on((ne) => ne.showBars());
    } };
  }, wd = (p) => {
    ((P) => {
      const I = P.options.register;
      I("table_clone_elements", { processor: "string[]" }), I("table_use_colgroups", { processor: "boolean", default: !0 }), I("table_header_type", { processor: (j) => {
        const Y = jn(["section", "cells", "sectionCells", "auto"], j);
        return Y ? { value: j, valid: Y } : { valid: !1, message: "Must be one of: section, cells, sectionCells or auto." };
      }, default: "section" }), I("table_sizing_mode", { processor: "string", default: "auto" }), I("table_default_attributes", { processor: "object", default: { border: "1" } }), I("table_default_styles", { processor: "object", default: { "border-collapse": "collapse" } }), I("table_column_resizing", { processor: (j) => {
        const Y = jn(["preservetable", "resizetable"], j);
        return Y ? { value: j, valid: Y } : { valid: !1, message: "Must be preservetable, or resizetable." };
      }, default: "preservetable" }), I("table_resize_bars", { processor: "boolean", default: !0 }), I("table_style_by_css", { processor: "boolean", default: !0 }), I("table_merge_content_on_paste", { processor: "boolean", default: !0 });
    })(p);
    const y = Lb(p), _ = Db(p, y), T = Li(p, y, _);
    return Y1(p, T), ((P, I) => {
      const j = En(P), Y = (ne) => Ef(ws(P)).bind((ve) => Zn(ve, j).map((Ce) => {
        const ge = pn(uc(P), Ce, ve);
        return ne(Ce, ge);
      })).getOr("");
      er({ mceTableRowType: () => Y(I.getTableRowType), mceTableCellType: () => Y(I.getTableCellType), mceTableColType: () => Y(I.getTableColType) }, (ne, ve) => P.addQueryValueHandler(ve, ne));
    })(p, T), Bo(p, T), { getSelectedCells: _.getSelectedCells, clearSelectedCells: _.clearSelectedCells };
  };
  v.add("dom", (p) => ({ table: wd(p) }));
})();
tinymce.Resource.add("ui/default/skin.css", `.tox{box-shadow:none;box-sizing:content-box;color:#222f3e;cursor:auto;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:16px;font-style:normal;font-weight:400;line-height:normal;-webkit-tap-highlight-color:transparent;text-decoration:none;text-shadow:none;text-transform:none;vertical-align:initial;white-space:normal}.tox :not(svg):not(rect){box-sizing:inherit;color:inherit;cursor:inherit;direction:inherit;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;line-height:inherit;-webkit-tap-highlight-color:inherit;text-align:inherit;text-decoration:inherit;text-shadow:inherit;text-transform:inherit;vertical-align:inherit;white-space:inherit}.tox :not(svg):not(rect){background:0 0;border:0;box-shadow:none;float:none;height:auto;margin:0;max-width:none;outline:0;padding:0;position:static;width:auto}.tox:not([dir=rtl]){direction:ltr;text-align:left}.tox[dir=rtl]{direction:rtl;text-align:right}.tox-tinymce{border:2px solid #eee;border-radius:10px;box-shadow:none;box-sizing:border-box;display:flex;flex-direction:column;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;overflow:hidden;position:relative;visibility:inherit!important}.tox.tox-tinymce-inline{border:none;box-shadow:none;overflow:initial}.tox.tox-tinymce-inline .tox-editor-container{overflow:initial}.tox.tox-tinymce-inline .tox-editor-header{background-color:#fff;border:2px solid #eee;border-radius:10px;box-shadow:none;overflow:hidden}.tox-tinymce-aux{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;z-index:1300}.tox-tinymce :focus,.tox-tinymce-aux :focus{outline:0}button::-moz-focus-inner{border:0}.tox[dir=rtl] .tox-icon--flip svg{transform:rotateY(180deg)}.tox .accessibility-issue__header{align-items:center;display:flex;margin-bottom:4px}.tox .accessibility-issue__description{align-items:stretch;border-radius:6px;display:flex;justify-content:space-between}.tox .accessibility-issue__description>div{padding-bottom:4px}.tox .accessibility-issue__description>div>div{align-items:center;display:flex;margin-bottom:4px}.tox .accessibility-issue__description>div>div .tox-icon svg{display:block}.tox .accessibility-issue__repair{margin-top:16px}.tox .tox-dialog__body-content .accessibility-issue--info .accessibility-issue__description{background-color:rgba(0,101,216,.1);color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--info .tox-form__group h2{color:#006ce7}.tox .tox-dialog__body-content .accessibility-issue--info .tox-icon svg{fill:#006ce7}.tox .tox-dialog__body-content .accessibility-issue--info a.tox-button--naked.tox-button--icon{background-color:#006ce7;color:#fff}.tox .tox-dialog__body-content .accessibility-issue--info a.tox-button--naked.tox-button--icon:focus,.tox .tox-dialog__body-content .accessibility-issue--info a.tox-button--naked.tox-button--icon:hover{background-color:#0060ce}.tox .tox-dialog__body-content .accessibility-issue--info a.tox-button--naked.tox-button--icon:active{background-color:#0054b4}.tox .tox-dialog__body-content .accessibility-issue--warn .accessibility-issue__description{background-color:rgba(255,165,0,.08);color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--warn .tox-form__group h2{color:#8f5d00}.tox .tox-dialog__body-content .accessibility-issue--warn .tox-icon svg{fill:#8f5d00}.tox .tox-dialog__body-content .accessibility-issue--warn a.tox-button--naked.tox-button--icon{background-color:#ffe89d;color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--warn a.tox-button--naked.tox-button--icon:focus,.tox .tox-dialog__body-content .accessibility-issue--warn a.tox-button--naked.tox-button--icon:hover{background-color:#f2d574;color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--warn a.tox-button--naked.tox-button--icon:active{background-color:#e8c657;color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--error .accessibility-issue__description{background-color:rgba(204,0,0,.1);color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--error .tox-form__group h2{color:#c00}.tox .tox-dialog__body-content .accessibility-issue--error .tox-icon svg{fill:#c00}.tox .tox-dialog__body-content .accessibility-issue--error a.tox-button--naked.tox-button--icon{background-color:#f2bfbf;color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--error a.tox-button--naked.tox-button--icon:focus,.tox .tox-dialog__body-content .accessibility-issue--error a.tox-button--naked.tox-button--icon:hover{background-color:#e9a4a4;color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--error a.tox-button--naked.tox-button--icon:active{background-color:#ee9494;color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--success .accessibility-issue__description{background-color:rgba(120,171,70,.1);color:#222f3e}.tox .tox-dialog__body-content .accessibility-issue--success .accessibility-issue__description>:last-child{display:none}.tox .tox-dialog__body-content .accessibility-issue--success .tox-form__group h2{color:#527530}.tox .tox-dialog__body-content .accessibility-issue--success .tox-icon svg{fill:#527530}.tox .tox-dialog__body-content .accessibility-issue__header .tox-form__group h1,.tox .tox-dialog__body-content .tox-form__group .accessibility-issue__description h2{font-size:14px;margin-top:0}.tox:not([dir=rtl]) .tox-dialog__body-content .accessibility-issue__header .tox-button{margin-left:4px}.tox:not([dir=rtl]) .tox-dialog__body-content .accessibility-issue__header>:nth-last-child(2){margin-left:auto}.tox:not([dir=rtl]) .tox-dialog__body-content .accessibility-issue__description{padding:4px 4px 4px 8px}.tox[dir=rtl] .tox-dialog__body-content .accessibility-issue__header .tox-button{margin-right:4px}.tox[dir=rtl] .tox-dialog__body-content .accessibility-issue__header>:nth-last-child(2){margin-right:auto}.tox[dir=rtl] .tox-dialog__body-content .accessibility-issue__description{padding:4px 8px 4px 4px}.tox .tox-advtemplate .tox-form__grid{flex:1}.tox .tox-advtemplate .tox-form__grid>div:first-child{display:flex;flex-direction:column;width:30%}.tox .tox-advtemplate .tox-form__grid>div:first-child>div:nth-child(2){flex-basis:0;flex-grow:1;overflow:auto}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox .tox-advtemplate .tox-form__grid>div:first-child{width:100%}}.tox .tox-advtemplate iframe{border-color:#eee;border-radius:10px;border-style:solid;border-width:1px;margin:0 10px}.tox .tox-anchorbar{display:flex;flex:0 0 auto}.tox .tox-bottom-anchorbar{display:flex;flex:0 0 auto}.tox .tox-bar{display:flex;flex:0 0 auto}.tox .tox-button{background-color:#006ce7;background-image:none;background-position:0 0;background-repeat:repeat;border-color:#006ce7;border-radius:6px;border-style:solid;border-width:1px;box-shadow:none;box-sizing:border-box;color:#fff;cursor:pointer;display:inline-block;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:14px;font-style:normal;font-weight:700;letter-spacing:normal;line-height:24px;margin:0;outline:0;padding:4px 16px;position:relative;text-align:center;text-decoration:none;text-transform:none;white-space:nowrap}.tox .tox-button::before{border-radius:6px;bottom:-1px;box-shadow:inset 0 0 0 2px #fff,0 0 0 1px #006ce7,0 0 0 3px rgba(0,108,231,.25);content:'';left:-1px;opacity:0;pointer-events:none;position:absolute;right:-1px;top:-1px}.tox .tox-button[disabled]{background-color:#006ce7;background-image:none;border-color:#006ce7;box-shadow:none;color:rgba(255,255,255,.5);cursor:not-allowed}.tox .tox-button:focus:not(:disabled){background-color:#0060ce;background-image:none;border-color:#0060ce;box-shadow:none;color:#fff}.tox .tox-button:focus-visible:not(:disabled)::before{opacity:1}.tox .tox-button:hover:not(:disabled){background-color:#0060ce;background-image:none;border-color:#0060ce;box-shadow:none;color:#fff}.tox .tox-button:active:not(:disabled){background-color:#0054b4;background-image:none;border-color:#0054b4;box-shadow:none;color:#fff}.tox .tox-button.tox-button--enabled{background-color:#0054b4;background-image:none;border-color:#0054b4;box-shadow:none;color:#fff}.tox .tox-button.tox-button--enabled[disabled]{background-color:#0054b4;background-image:none;border-color:#0054b4;box-shadow:none;color:rgba(255,255,255,.5);cursor:not-allowed}.tox .tox-button.tox-button--enabled:focus:not(:disabled){background-color:#00489b;background-image:none;border-color:#00489b;box-shadow:none;color:#fff}.tox .tox-button.tox-button--enabled:hover:not(:disabled){background-color:#00489b;background-image:none;border-color:#00489b;box-shadow:none;color:#fff}.tox .tox-button.tox-button--enabled:active:not(:disabled){background-color:#003c81;background-image:none;border-color:#003c81;box-shadow:none;color:#fff}.tox .tox-button--icon-and-text,.tox .tox-button.tox-button--icon-and-text,.tox .tox-button.tox-button--secondary.tox-button--icon-and-text{display:flex;padding:5px 4px}.tox .tox-button--icon-and-text .tox-icon svg,.tox .tox-button.tox-button--icon-and-text .tox-icon svg,.tox .tox-button.tox-button--secondary.tox-button--icon-and-text .tox-icon svg{display:block;fill:currentColor}.tox .tox-button--secondary{background-color:#f0f0f0;background-image:none;background-position:0 0;background-repeat:repeat;border-color:#f0f0f0;border-radius:6px;border-style:solid;border-width:1px;box-shadow:none;color:#222f3e;font-size:14px;font-style:normal;font-weight:700;letter-spacing:normal;outline:0;padding:4px 16px;text-decoration:none;text-transform:none}.tox .tox-button--secondary[disabled]{background-color:#f0f0f0;background-image:none;border-color:#f0f0f0;box-shadow:none;color:rgba(34,47,62,.5)}.tox .tox-button--secondary:focus:not(:disabled){background-color:#e3e3e3;background-image:none;border-color:#e3e3e3;box-shadow:none;color:#222f3e}.tox .tox-button--secondary:hover:not(:disabled){background-color:#e3e3e3;background-image:none;border-color:#e3e3e3;box-shadow:none;color:#222f3e}.tox .tox-button--secondary:active:not(:disabled){background-color:#d6d6d6;background-image:none;border-color:#d6d6d6;box-shadow:none;color:#222f3e}.tox .tox-button--secondary.tox-button--enabled{background-color:#a8c8ed;background-image:none;border-color:#a8c8ed;box-shadow:none;color:#222f3e}.tox .tox-button--secondary.tox-button--enabled[disabled]{background-color:#a8c8ed;background-image:none;border-color:#a8c8ed;box-shadow:none;color:rgba(34,47,62,.5)}.tox .tox-button--secondary.tox-button--enabled:focus:not(:disabled){background-color:#93bbe9;background-image:none;border-color:#93bbe9;box-shadow:none;color:#222f3e}.tox .tox-button--secondary.tox-button--enabled:hover:not(:disabled){background-color:#93bbe9;background-image:none;border-color:#93bbe9;box-shadow:none;color:#222f3e}.tox .tox-button--secondary.tox-button--enabled:active:not(:disabled){background-color:#7daee4;background-image:none;border-color:#7daee4;box-shadow:none;color:#222f3e}.tox .tox-button--icon,.tox .tox-button.tox-button--icon,.tox .tox-button.tox-button--secondary.tox-button--icon{padding:4px}.tox .tox-button--icon .tox-icon svg,.tox .tox-button.tox-button--icon .tox-icon svg,.tox .tox-button.tox-button--secondary.tox-button--icon .tox-icon svg{display:block;fill:currentColor}.tox .tox-button-link{background:0;border:none;box-sizing:border-box;cursor:pointer;display:inline-block;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:16px;font-weight:400;line-height:1.3;margin:0;padding:0;white-space:nowrap}.tox .tox-button-link--sm{font-size:14px}.tox .tox-button--naked{background-color:transparent;border-color:transparent;box-shadow:unset;color:#222f3e}.tox .tox-button--naked[disabled]{background-color:rgba(34,47,62,.12);border-color:transparent;box-shadow:unset;color:rgba(34,47,62,.5)}.tox .tox-button--naked:hover:not(:disabled){background-color:rgba(34,47,62,.12);border-color:transparent;box-shadow:unset;color:#222f3e}.tox .tox-button--naked:focus:not(:disabled){background-color:rgba(34,47,62,.12);border-color:transparent;box-shadow:unset;color:#222f3e}.tox .tox-button--naked:active:not(:disabled){background-color:rgba(34,47,62,.18);border-color:transparent;box-shadow:unset;color:#222f3e}.tox .tox-button--naked .tox-icon svg{fill:currentColor}.tox .tox-button--naked.tox-button--icon:hover:not(:disabled){color:#222f3e}.tox .tox-checkbox{align-items:center;border-radius:6px;cursor:pointer;display:flex;height:36px;min-width:36px}.tox .tox-checkbox__input{height:1px;overflow:hidden;position:absolute;top:auto;width:1px}.tox .tox-checkbox__icons{align-items:center;border-radius:6px;box-shadow:0 0 0 2px transparent;box-sizing:content-box;display:flex;height:24px;justify-content:center;padding:calc(4px - 1px);width:24px}.tox .tox-checkbox__icons .tox-checkbox-icon__unchecked svg{display:block;fill:rgba(34,47,62,.3)}.tox .tox-checkbox__icons .tox-checkbox-icon__indeterminate svg{display:none;fill:#006ce7}.tox .tox-checkbox__icons .tox-checkbox-icon__checked svg{display:none;fill:#006ce7}.tox .tox-checkbox--disabled{color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-checkbox--disabled .tox-checkbox__icons .tox-checkbox-icon__checked svg{fill:rgba(34,47,62,.5)}.tox .tox-checkbox--disabled .tox-checkbox__icons .tox-checkbox-icon__unchecked svg{fill:rgba(34,47,62,.5)}.tox .tox-checkbox--disabled .tox-checkbox__icons .tox-checkbox-icon__indeterminate svg{fill:rgba(34,47,62,.5)}.tox input.tox-checkbox__input:checked+.tox-checkbox__icons .tox-checkbox-icon__unchecked svg{display:none}.tox input.tox-checkbox__input:checked+.tox-checkbox__icons .tox-checkbox-icon__checked svg{display:block}.tox input.tox-checkbox__input:indeterminate+.tox-checkbox__icons .tox-checkbox-icon__unchecked svg{display:none}.tox input.tox-checkbox__input:indeterminate+.tox-checkbox__icons .tox-checkbox-icon__indeterminate svg{display:block}.tox input.tox-checkbox__input:focus+.tox-checkbox__icons{border-radius:6px;box-shadow:inset 0 0 0 1px #006ce7;padding:calc(4px - 1px)}.tox:not([dir=rtl]) .tox-checkbox__label{margin-left:4px}.tox:not([dir=rtl]) .tox-checkbox__input{left:-10000px}.tox:not([dir=rtl]) .tox-bar .tox-checkbox{margin-left:4px}.tox[dir=rtl] .tox-checkbox__label{margin-right:4px}.tox[dir=rtl] .tox-checkbox__input{right:-10000px}.tox[dir=rtl] .tox-bar .tox-checkbox{margin-right:4px}.tox .tox-collection--toolbar .tox-collection__group{display:flex;padding:0}.tox .tox-collection--grid .tox-collection__group{display:flex;flex-wrap:wrap;max-height:208px;overflow-x:hidden;overflow-y:auto;padding:0}.tox .tox-collection--list .tox-collection__group{border-bottom-width:0;border-color:#e3e3e3;border-left-width:0;border-right-width:0;border-style:solid;border-top-width:1px;padding:4px 0}.tox .tox-collection--list .tox-collection__group:first-child{border-top-width:0}.tox .tox-collection__group-heading{background-color:#fcfcfc;color:rgba(34,47,62,.7);cursor:default;font-size:12px;font-style:normal;font-weight:400;margin-bottom:4px;margin-top:-4px;padding:4px 8px;text-transform:none;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.tox .tox-collection__item{align-items:center;border-radius:3px;color:#222f3e;display:flex;-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.tox .tox-collection--list .tox-collection__item{padding:4px 8px}.tox .tox-collection--toolbar .tox-collection__item{border-radius:3px;padding:4px}.tox .tox-collection--grid .tox-collection__item{border-radius:3px;padding:4px}.tox .tox-collection--list .tox-collection__item--enabled{background-color:#fff;color:#222f3e}.tox .tox-collection--list .tox-collection__item--active{background-color:#cce2fa}.tox .tox-collection--toolbar .tox-collection__item--enabled{background-color:#a6ccf7;color:#222f3e}.tox .tox-collection--toolbar .tox-collection__item--active{background-color:#cce2fa}.tox .tox-collection--grid .tox-collection__item--enabled{background-color:#a6ccf7;color:#222f3e}.tox .tox-collection--grid .tox-collection__item--active:not(.tox-collection__item--state-disabled){background-color:#cce2fa;color:#222f3e}.tox .tox-collection--list .tox-collection__item--active:not(.tox-collection__item--state-disabled){color:#222f3e}.tox .tox-collection--toolbar .tox-collection__item--active:not(.tox-collection__item--state-disabled){color:#222f3e}.tox .tox-collection__item-checkmark,.tox .tox-collection__item-icon{align-items:center;display:flex;height:24px;justify-content:center;width:24px}.tox .tox-collection__item-checkmark svg,.tox .tox-collection__item-icon svg{fill:currentColor}.tox .tox-collection--toolbar-lg .tox-collection__item-icon{height:48px;width:48px}.tox .tox-collection__item-label{color:currentColor;display:inline-block;flex:1;font-size:14px;font-style:normal;font-weight:400;line-height:24px;max-width:100%;text-transform:none;word-break:break-all}.tox .tox-collection__item-accessory{color:rgba(34,47,62,.7);display:inline-block;font-size:14px;height:24px;line-height:24px;text-transform:none}.tox .tox-collection__item-caret{align-items:center;display:flex;min-height:24px}.tox .tox-collection__item-caret::after{content:'';font-size:0;min-height:inherit}.tox .tox-collection__item-caret svg{fill:#222f3e}.tox .tox-collection__item--state-disabled{background-color:transparent;color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-collection__item--state-disabled .tox-collection__item-caret svg{fill:rgba(34,47,62,.5)}.tox .tox-collection--list .tox-collection__item:not(.tox-collection__item--enabled) .tox-collection__item-checkmark svg{display:none}.tox .tox-collection--list .tox-collection__item:not(.tox-collection__item--enabled) .tox-collection__item-accessory+.tox-collection__item-checkmark{display:none}.tox .tox-collection--horizontal{background-color:#fff;border:1px solid #e3e3e3;border-radius:6px;box-shadow:0 0 2px 0 rgba(34,47,62,.2),0 4px 8px 0 rgba(34,47,62,.15);display:flex;flex:0 0 auto;flex-shrink:0;flex-wrap:nowrap;margin-bottom:0;overflow-x:auto;padding:0}.tox .tox-collection--horizontal .tox-collection__group{align-items:center;display:flex;flex-wrap:nowrap;margin:0;padding:0 4px}.tox .tox-collection--horizontal .tox-collection__item{height:28px;margin:6px 1px 5px 0;padding:0 4px}.tox .tox-collection--horizontal .tox-collection__item-label{white-space:nowrap}.tox .tox-collection--horizontal .tox-collection__item-caret{margin-left:4px}.tox .tox-collection__item-container{display:flex}.tox .tox-collection__item-container--row{align-items:center;flex:1 1 auto;flex-direction:row}.tox .tox-collection__item-container--row.tox-collection__item-container--align-left{margin-right:auto}.tox .tox-collection__item-container--row.tox-collection__item-container--align-right{justify-content:flex-end;margin-left:auto}.tox .tox-collection__item-container--row.tox-collection__item-container--valign-top{align-items:flex-start;margin-bottom:auto}.tox .tox-collection__item-container--row.tox-collection__item-container--valign-middle{align-items:center}.tox .tox-collection__item-container--row.tox-collection__item-container--valign-bottom{align-items:flex-end;margin-top:auto}.tox .tox-collection__item-container--column{align-self:center;flex:1 1 auto;flex-direction:column}.tox .tox-collection__item-container--column.tox-collection__item-container--align-left{align-items:flex-start}.tox .tox-collection__item-container--column.tox-collection__item-container--align-right{align-items:flex-end}.tox .tox-collection__item-container--column.tox-collection__item-container--valign-top{align-self:flex-start}.tox .tox-collection__item-container--column.tox-collection__item-container--valign-middle{align-self:center}.tox .tox-collection__item-container--column.tox-collection__item-container--valign-bottom{align-self:flex-end}.tox:not([dir=rtl]) .tox-collection--horizontal .tox-collection__group:not(:last-of-type){border-right:1px solid transparent}.tox:not([dir=rtl]) .tox-collection--list .tox-collection__item>:not(:first-child){margin-left:8px}.tox:not([dir=rtl]) .tox-collection--list .tox-collection__item>.tox-collection__item-label:first-child{margin-left:4px}.tox:not([dir=rtl]) .tox-collection__item-accessory{margin-left:16px;text-align:right}.tox:not([dir=rtl]) .tox-collection .tox-collection__item-caret{margin-left:16px}.tox[dir=rtl] .tox-collection--horizontal .tox-collection__group:not(:last-of-type){border-left:1px solid transparent}.tox[dir=rtl] .tox-collection--list .tox-collection__item>:not(:first-child){margin-right:8px}.tox[dir=rtl] .tox-collection--list .tox-collection__item>.tox-collection__item-label:first-child{margin-right:4px}.tox[dir=rtl] .tox-collection__item-accessory{margin-right:16px;text-align:left}.tox[dir=rtl] .tox-collection .tox-collection__item-caret{margin-right:16px;transform:rotateY(180deg)}.tox[dir=rtl] .tox-collection--horizontal .tox-collection__item-caret{margin-right:4px}.tox .tox-color-picker-container{display:flex;flex-direction:row;height:225px;margin:0}.tox .tox-sv-palette{box-sizing:border-box;display:flex;height:100%}.tox .tox-sv-palette-spectrum{height:100%}.tox .tox-sv-palette,.tox .tox-sv-palette-spectrum{width:225px}.tox .tox-sv-palette-thumb{background:0 0;border:1px solid #000;border-radius:50%;box-sizing:content-box;height:12px;position:absolute;width:12px}.tox .tox-sv-palette-inner-thumb{border:1px solid #fff;border-radius:50%;height:10px;position:absolute;width:10px}.tox .tox-hue-slider{box-sizing:border-box;height:100%;width:25px}.tox .tox-hue-slider-spectrum{background:linear-gradient(to bottom,red,#ff0080,#f0f,#8000ff,#00f,#0080ff,#0ff,#00ff80,#0f0,#80ff00,#ff0,#ff8000,red);height:100%;width:100%}.tox .tox-hue-slider,.tox .tox-hue-slider-spectrum{width:20px}.tox .tox-hue-slider-spectrum:focus,.tox .tox-sv-palette-spectrum:focus{outline:#08f solid}.tox .tox-hue-slider-thumb{background:#fff;border:1px solid #000;box-sizing:content-box;height:4px;width:100%}.tox .tox-rgb-form{display:flex;flex-direction:column;justify-content:space-between}.tox .tox-rgb-form div{align-items:center;display:flex;justify-content:space-between;margin-bottom:5px;width:inherit}.tox .tox-rgb-form input{width:6em}.tox .tox-rgb-form input.tox-invalid{border:1px solid red!important}.tox .tox-rgb-form .tox-rgba-preview{border:1px solid #000;flex-grow:2;margin-bottom:0}.tox:not([dir=rtl]) .tox-sv-palette{margin-right:15px}.tox:not([dir=rtl]) .tox-hue-slider{margin-right:15px}.tox:not([dir=rtl]) .tox-hue-slider-thumb{margin-left:-1px}.tox:not([dir=rtl]) .tox-rgb-form label{margin-right:.5em}.tox[dir=rtl] .tox-sv-palette{margin-left:15px}.tox[dir=rtl] .tox-hue-slider{margin-left:15px}.tox[dir=rtl] .tox-hue-slider-thumb{margin-right:-1px}.tox[dir=rtl] .tox-rgb-form label{margin-left:.5em}.tox .tox-toolbar .tox-swatches,.tox .tox-toolbar__overflow .tox-swatches,.tox .tox-toolbar__primary .tox-swatches{margin:5px 0 6px 11px}.tox .tox-collection--list .tox-collection__group .tox-swatches-menu{border:0;margin:-4px -4px}.tox .tox-swatches__row{display:flex}.tox .tox-swatch{height:30px;transition:transform .15s,box-shadow .15s;width:30px}.tox .tox-swatch:focus,.tox .tox-swatch:hover{box-shadow:0 0 0 1px rgba(127,127,127,.3) inset;transform:scale(.8)}.tox .tox-swatch--remove{align-items:center;display:flex;justify-content:center}.tox .tox-swatch--remove svg path{stroke:#e74c3c}.tox .tox-swatches__picker-btn{align-items:center;background-color:transparent;border:0;cursor:pointer;display:flex;height:30px;justify-content:center;outline:0;padding:0;width:30px}.tox .tox-swatches__picker-btn svg{fill:#222f3e;height:24px;width:24px}.tox .tox-swatches__picker-btn:hover{background:#cce2fa}.tox div.tox-swatch:not(.tox-swatch--remove) svg{display:none;fill:#222f3e;height:24px;margin:calc((30px - 24px)/ 2) calc((30px - 24px)/ 2);width:24px}.tox div.tox-swatch:not(.tox-swatch--remove) svg path{fill:#fff;paint-order:stroke;stroke:#222f3e;stroke-width:2px}.tox div.tox-swatch:not(.tox-swatch--remove).tox-collection__item--enabled svg{display:block}.tox:not([dir=rtl]) .tox-swatches__picker-btn{margin-left:auto}.tox[dir=rtl] .tox-swatches__picker-btn{margin-right:auto}.tox .tox-comment-thread{background:#fff;position:relative}.tox .tox-comment-thread>:not(:first-child){margin-top:8px}.tox .tox-comment{background:#fff;border:1px solid #eee;border-radius:6px;box-shadow:0 4px 8px 0 rgba(34,47,62,.1);padding:8px 8px 16px 8px;position:relative}.tox .tox-comment__header{align-items:center;color:#222f3e;display:flex;justify-content:space-between}.tox .tox-comment__date{color:#222f3e;font-size:12px;line-height:18px}.tox .tox-comment__body{color:#222f3e;font-size:14px;font-style:normal;font-weight:400;line-height:1.3;margin-top:8px;position:relative;text-transform:initial}.tox .tox-comment__body textarea{resize:none;white-space:normal;width:100%}.tox .tox-comment__expander{padding-top:8px}.tox .tox-comment__expander p{color:rgba(34,47,62,.7);font-size:14px;font-style:normal}.tox .tox-comment__body p{margin:0}.tox .tox-comment__buttonspacing{padding-top:16px;text-align:center}.tox .tox-comment-thread__overlay::after{background:#fff;bottom:0;content:"";display:flex;left:0;opacity:.9;position:absolute;right:0;top:0;z-index:5}.tox .tox-comment__reply{display:flex;flex-shrink:0;flex-wrap:wrap;justify-content:flex-end;margin-top:8px}.tox .tox-comment__reply>:first-child{margin-bottom:8px;width:100%}.tox .tox-comment__edit{display:flex;flex-wrap:wrap;justify-content:flex-end;margin-top:16px}.tox .tox-comment__gradient::after{background:linear-gradient(rgba(255,255,255,0),#fff);bottom:0;content:"";display:block;height:5em;margin-top:-40px;position:absolute;width:100%}.tox .tox-comment__overlay{background:#fff;bottom:0;display:flex;flex-direction:column;flex-grow:1;left:0;opacity:.9;position:absolute;right:0;text-align:center;top:0;z-index:5}.tox .tox-comment__loading-text{align-items:center;color:#222f3e;display:flex;flex-direction:column;position:relative}.tox .tox-comment__loading-text>div{padding-bottom:16px}.tox .tox-comment__overlaytext{bottom:0;flex-direction:column;font-size:14px;left:0;padding:1em;position:absolute;right:0;top:0;z-index:10}.tox .tox-comment__overlaytext p{background-color:#fff;box-shadow:0 0 8px 8px #fff;color:#222f3e;text-align:center}.tox .tox-comment__overlaytext div:nth-of-type(2){font-size:.8em}.tox .tox-comment__busy-spinner{align-items:center;background-color:#fff;bottom:0;display:flex;justify-content:center;left:0;position:absolute;right:0;top:0;z-index:20}.tox .tox-comment__scroll{display:flex;flex-direction:column;flex-shrink:1;overflow:auto}.tox .tox-conversations{margin:8px}.tox:not([dir=rtl]) .tox-comment__edit{margin-left:8px}.tox:not([dir=rtl]) .tox-comment__buttonspacing>:last-child,.tox:not([dir=rtl]) .tox-comment__edit>:last-child,.tox:not([dir=rtl]) .tox-comment__reply>:last-child{margin-left:8px}.tox[dir=rtl] .tox-comment__edit{margin-right:8px}.tox[dir=rtl] .tox-comment__buttonspacing>:last-child,.tox[dir=rtl] .tox-comment__edit>:last-child,.tox[dir=rtl] .tox-comment__reply>:last-child{margin-right:8px}.tox .tox-user{align-items:center;display:flex}.tox .tox-user__avatar svg{fill:rgba(34,47,62,.7)}.tox .tox-user__avatar img{border-radius:50%;height:36px;object-fit:cover;vertical-align:middle;width:36px}.tox .tox-user__name{color:#222f3e;font-size:14px;font-style:normal;font-weight:700;line-height:18px;text-transform:none}.tox:not([dir=rtl]) .tox-user__avatar img,.tox:not([dir=rtl]) .tox-user__avatar svg{margin-right:8px}.tox:not([dir=rtl]) .tox-user__avatar+.tox-user__name{margin-left:8px}.tox[dir=rtl] .tox-user__avatar img,.tox[dir=rtl] .tox-user__avatar svg{margin-left:8px}.tox[dir=rtl] .tox-user__avatar+.tox-user__name{margin-right:8px}.tox .tox-dialog-wrap{align-items:center;bottom:0;display:flex;justify-content:center;left:0;position:fixed;right:0;top:0;z-index:1100}.tox .tox-dialog-wrap__backdrop{background-color:rgba(255,255,255,.75);bottom:0;left:0;position:absolute;right:0;top:0;z-index:1}.tox .tox-dialog-wrap__backdrop--opaque{background-color:#fff}.tox .tox-dialog{background-color:#fff;border-color:#eee;border-radius:10px;border-style:solid;border-width:0;box-shadow:0 16px 16px -10px rgba(34,47,62,.15),0 0 40px 1px rgba(34,47,62,.15);display:flex;flex-direction:column;max-height:100%;max-width:480px;overflow:hidden;position:relative;width:95vw;z-index:2}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox .tox-dialog{align-self:flex-start;margin:8px auto;max-height:calc(100vh - 8px * 2);width:calc(100vw - 16px)}}.tox .tox-dialog-inline{z-index:1100}.tox .tox-dialog__header{align-items:center;background-color:#fff;border-bottom:none;color:#222f3e;display:flex;font-size:16px;justify-content:space-between;padding:8px 16px 0 16px;position:relative}.tox .tox-dialog__header .tox-button{z-index:1}.tox .tox-dialog__draghandle{cursor:grab;height:100%;left:0;position:absolute;top:0;width:100%}.tox .tox-dialog__draghandle:active{cursor:grabbing}.tox .tox-dialog__dismiss{margin-left:auto}.tox .tox-dialog__title{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:20px;font-style:normal;font-weight:400;line-height:1.3;margin:0;text-transform:none}.tox .tox-dialog__body{color:#222f3e;display:flex;flex:1;font-size:16px;font-style:normal;font-weight:400;line-height:1.3;min-width:0;text-align:left;text-transform:none}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox .tox-dialog__body{flex-direction:column}}.tox .tox-dialog__body-nav{align-items:flex-start;display:flex;flex-direction:column;flex-shrink:0;padding:16px 16px}@media only screen and (min-width:768px){.tox .tox-dialog__body-nav{max-width:11em}}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox .tox-dialog__body-nav{flex-direction:row;-webkit-overflow-scrolling:touch;overflow-x:auto;padding-bottom:0}}.tox .tox-dialog__body-nav-item{border-bottom:2px solid transparent;color:rgba(34,47,62,.7);display:inline-block;flex-shrink:0;font-size:14px;line-height:1.3;margin-bottom:8px;max-width:13em;text-decoration:none}.tox .tox-dialog__body-nav-item:focus{background-color:rgba(0,108,231,.1)}.tox .tox-dialog__body-nav-item--active{border-bottom:2px solid #006ce7;color:#006ce7}.tox .tox-dialog__body-content{box-sizing:border-box;display:flex;flex:1;flex-direction:column;max-height:min(650px,calc(100vh - 110px));overflow:auto;-webkit-overflow-scrolling:touch;padding:16px 16px}.tox .tox-dialog__body-content>*{margin-bottom:0;margin-top:16px}.tox .tox-dialog__body-content>:first-child{margin-top:0}.tox .tox-dialog__body-content>:last-child{margin-bottom:0}.tox .tox-dialog__body-content>:only-child{margin-bottom:0;margin-top:0}.tox .tox-dialog__body-content a{color:#006ce7;cursor:pointer;text-decoration:underline}.tox .tox-dialog__body-content a:focus,.tox .tox-dialog__body-content a:hover{color:#003c81;text-decoration:underline}.tox .tox-dialog__body-content a:focus-visible{border-radius:1px;outline:2px solid #006ce7;outline-offset:2px}.tox .tox-dialog__body-content a:active{color:#00244e;text-decoration:underline}.tox .tox-dialog__body-content svg{fill:#222f3e}.tox .tox-dialog__body-content strong{font-weight:700}.tox .tox-dialog__body-content ul{list-style-type:disc}.tox .tox-dialog__body-content dd,.tox .tox-dialog__body-content ol,.tox .tox-dialog__body-content ul{padding-inline-start:2.5rem}.tox .tox-dialog__body-content dl,.tox .tox-dialog__body-content ol,.tox .tox-dialog__body-content ul{margin-bottom:16px}.tox .tox-dialog__body-content dd,.tox .tox-dialog__body-content dl,.tox .tox-dialog__body-content dt,.tox .tox-dialog__body-content ol,.tox .tox-dialog__body-content ul{display:block;margin-inline-end:0;margin-inline-start:0}.tox .tox-dialog__body-content .tox-form__group h1{color:#222f3e;font-size:20px;font-style:normal;font-weight:700;letter-spacing:normal;margin-bottom:16px;margin-top:2rem;text-transform:none}.tox .tox-dialog__body-content .tox-form__group h2{color:#222f3e;font-size:16px;font-style:normal;font-weight:700;letter-spacing:normal;margin-bottom:16px;margin-top:2rem;text-transform:none}.tox .tox-dialog__body-content .tox-form__group p{margin-bottom:16px}.tox .tox-dialog__body-content .tox-form__group h1:first-child,.tox .tox-dialog__body-content .tox-form__group h2:first-child,.tox .tox-dialog__body-content .tox-form__group p:first-child{margin-top:0}.tox .tox-dialog__body-content .tox-form__group h1:last-child,.tox .tox-dialog__body-content .tox-form__group h2:last-child,.tox .tox-dialog__body-content .tox-form__group p:last-child{margin-bottom:0}.tox .tox-dialog__body-content .tox-form__group h1:only-child,.tox .tox-dialog__body-content .tox-form__group h2:only-child,.tox .tox-dialog__body-content .tox-form__group p:only-child{margin-bottom:0;margin-top:0}.tox .tox-dialog__body-content .tox-form__group .tox-label.tox-label--center{text-align:center}.tox .tox-dialog__body-content .tox-form__group .tox-label.tox-label--end{text-align:end}.tox .tox-dialog--width-lg{height:650px;max-width:1200px}.tox .tox-dialog--fullscreen{height:100%;max-width:100%}.tox .tox-dialog--fullscreen .tox-dialog__body-content{max-height:100%}.tox .tox-dialog--width-md{max-width:800px}.tox .tox-dialog--width-md .tox-dialog__body-content{overflow:auto}.tox .tox-dialog__body-content--centered{text-align:center}.tox .tox-dialog__footer{align-items:center;background-color:#fff;border-top:none;display:flex;justify-content:space-between;padding:8px 16px}.tox .tox-dialog__footer-end,.tox .tox-dialog__footer-start{display:flex}.tox .tox-dialog__busy-spinner{align-items:center;background-color:rgba(255,255,255,.75);bottom:0;display:flex;justify-content:center;left:0;position:absolute;right:0;top:0;z-index:3}.tox .tox-dialog__table{border-collapse:collapse;width:100%}.tox .tox-dialog__table thead th{font-weight:700;padding-bottom:8px}.tox .tox-dialog__table thead th:first-child{padding-right:8px}.tox .tox-dialog__table tbody tr{border-bottom:1px solid #626262}.tox .tox-dialog__table tbody tr:last-child{border-bottom:none}.tox .tox-dialog__table td{padding-bottom:8px;padding-top:8px}.tox .tox-dialog__table td:first-child{padding-right:8px}.tox .tox-dialog__iframe{min-height:200px}.tox .tox-dialog__iframe.tox-dialog__iframe--opaque{background:#fff}.tox .tox-navobj-bordered{position:relative}.tox .tox-navobj-bordered::before{border:1px solid #eee;border-radius:6px;content:'';inset:0;opacity:1;pointer-events:none;position:absolute;z-index:1}.tox .tox-navobj-bordered-focus.tox-navobj-bordered::before{border-color:#006ce7;box-shadow:0 0 0 2px rgba(0,108,231,.25);outline:0}.tox .tox-dialog__popups{position:absolute;width:100%;z-index:1100}.tox .tox-dialog__body-iframe{display:flex;flex:1;flex-direction:column}.tox .tox-dialog__body-iframe .tox-navobj{display:flex;flex:1}.tox .tox-dialog__body-iframe .tox-navobj :nth-child(2){flex:1;height:100%}.tox .tox-dialog-dock-fadeout{opacity:0;visibility:hidden}.tox .tox-dialog-dock-fadein{opacity:1;visibility:visible}.tox .tox-dialog-dock-transition{transition:visibility 0s linear .3s,opacity .3s ease}.tox .tox-dialog-dock-transition.tox-dialog-dock-fadein{transition-delay:0s}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox:not([dir=rtl]) .tox-dialog__body-nav{margin-right:0}}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox:not([dir=rtl]) .tox-dialog__body-nav-item:not(:first-child){margin-left:8px}}.tox:not([dir=rtl]) .tox-dialog__footer .tox-dialog__footer-end>*,.tox:not([dir=rtl]) .tox-dialog__footer .tox-dialog__footer-start>*{margin-left:8px}.tox[dir=rtl] .tox-dialog__body{text-align:right}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox[dir=rtl] .tox-dialog__body-nav{margin-left:0}}@media only screen and (max-width:767px){body:not(.tox-force-desktop) .tox[dir=rtl] .tox-dialog__body-nav-item:not(:first-child){margin-right:8px}}.tox[dir=rtl] .tox-dialog__footer .tox-dialog__footer-end>*,.tox[dir=rtl] .tox-dialog__footer .tox-dialog__footer-start>*{margin-right:8px}body.tox-dialog__disable-scroll{overflow:hidden}.tox .tox-dropzone-container{display:flex;flex:1}.tox .tox-dropzone{align-items:center;background:#fff;border:2px dashed #eee;box-sizing:border-box;display:flex;flex-direction:column;flex-grow:1;justify-content:center;min-height:100px;padding:10px}.tox .tox-dropzone p{color:rgba(34,47,62,.7);margin:0 0 16px 0}.tox .tox-edit-area{display:flex;flex:1;overflow:hidden;position:relative}.tox .tox-edit-area::before{border:2px solid #2d6adf;border-radius:4px;content:'';inset:0;opacity:0;pointer-events:none;position:absolute;transition:opacity .15s;z-index:1}.tox .tox-edit-area__iframe{background-color:#fff;border:0;box-sizing:border-box;flex:1;height:100%;position:absolute;width:100%}.tox.tox-edit-focus .tox-edit-area::before{opacity:1}.tox.tox-inline-edit-area{border:1px dotted #eee}.tox .tox-editor-container{display:flex;flex:1 1 auto;flex-direction:column;overflow:hidden}.tox .tox-editor-header{display:grid;grid-template-columns:1fr min-content;z-index:2}.tox:not(.tox-tinymce-inline) .tox-editor-header{background-color:#fff;border-bottom:none;box-shadow:0 2px 2px -2px rgba(34,47,62,.1),0 8px 8px -4px rgba(34,47,62,.07);padding:4px 0}.tox:not(.tox-tinymce-inline) .tox-editor-header:not(.tox-editor-dock-transition){transition:box-shadow .5s}.tox:not(.tox-tinymce-inline).tox-tinymce--toolbar-bottom .tox-editor-header{border-top:1px solid #e3e3e3;box-shadow:none}.tox:not(.tox-tinymce-inline).tox-tinymce--toolbar-sticky-on .tox-editor-header{background-color:#fff;box-shadow:0 2px 2px -2px rgba(34,47,62,.2),0 8px 8px -4px rgba(34,47,62,.15);padding:4px 0}.tox:not(.tox-tinymce-inline).tox-tinymce--toolbar-sticky-on.tox-tinymce--toolbar-bottom .tox-editor-header{box-shadow:0 2px 2px -2px rgba(34,47,62,.2),0 8px 8px -4px rgba(34,47,62,.15)}.tox.tox:not(.tox-tinymce-inline) .tox-editor-header.tox-editor-header--empty{background:0 0;border:none;box-shadow:none;padding:0}.tox-editor-dock-fadeout{opacity:0;visibility:hidden}.tox-editor-dock-fadein{opacity:1;visibility:visible}.tox-editor-dock-transition{transition:visibility 0s linear .25s,opacity .25s ease}.tox-editor-dock-transition.tox-editor-dock-fadein{transition-delay:0s}.tox .tox-control-wrap{flex:1;position:relative}.tox .tox-control-wrap:not(.tox-control-wrap--status-invalid) .tox-control-wrap__status-icon-invalid,.tox .tox-control-wrap:not(.tox-control-wrap--status-unknown) .tox-control-wrap__status-icon-unknown,.tox .tox-control-wrap:not(.tox-control-wrap--status-valid) .tox-control-wrap__status-icon-valid{display:none}.tox .tox-control-wrap svg{display:block}.tox .tox-control-wrap__status-icon-wrap{position:absolute;top:50%;transform:translateY(-50%)}.tox .tox-control-wrap__status-icon-invalid svg{fill:#c00}.tox .tox-control-wrap__status-icon-unknown svg{fill:orange}.tox .tox-control-wrap__status-icon-valid svg{fill:green}.tox:not([dir=rtl]) .tox-control-wrap--status-invalid .tox-textfield,.tox:not([dir=rtl]) .tox-control-wrap--status-unknown .tox-textfield,.tox:not([dir=rtl]) .tox-control-wrap--status-valid .tox-textfield{padding-right:32px}.tox:not([dir=rtl]) .tox-control-wrap__status-icon-wrap{right:4px}.tox[dir=rtl] .tox-control-wrap--status-invalid .tox-textfield,.tox[dir=rtl] .tox-control-wrap--status-unknown .tox-textfield,.tox[dir=rtl] .tox-control-wrap--status-valid .tox-textfield{padding-left:32px}.tox[dir=rtl] .tox-control-wrap__status-icon-wrap{left:4px}.tox .tox-autocompleter{max-width:25em}.tox .tox-autocompleter .tox-menu{box-sizing:border-box;max-width:25em}.tox .tox-autocompleter .tox-autocompleter-highlight{font-weight:700}.tox .tox-color-input{display:flex;position:relative;z-index:1}.tox .tox-color-input .tox-textfield{z-index:-1}.tox .tox-color-input span{border-color:rgba(34,47,62,.2);border-radius:6px;border-style:solid;border-width:1px;box-shadow:none;box-sizing:border-box;height:24px;position:absolute;top:6px;width:24px}.tox .tox-color-input span:focus:not([aria-disabled=true]),.tox .tox-color-input span:hover:not([aria-disabled=true]){border-color:#006ce7;cursor:pointer}.tox .tox-color-input span::before{background-image:linear-gradient(45deg,rgba(0,0,0,.25) 25%,transparent 25%),linear-gradient(-45deg,rgba(0,0,0,.25) 25%,transparent 25%),linear-gradient(45deg,transparent 75%,rgba(0,0,0,.25) 75%),linear-gradient(-45deg,transparent 75%,rgba(0,0,0,.25) 75%);background-position:0 0,0 6px,6px -6px,-6px 0;background-size:12px 12px;border:1px solid #fff;border-radius:6px;box-sizing:border-box;content:'';height:24px;left:-1px;position:absolute;top:-1px;width:24px;z-index:-1}.tox .tox-color-input span[aria-disabled=true]{cursor:not-allowed}.tox:not([dir=rtl]) .tox-color-input .tox-textfield{padding-left:36px}.tox:not([dir=rtl]) .tox-color-input span{left:6px}.tox[dir=rtl] .tox-color-input .tox-textfield{padding-right:36px}.tox[dir=rtl] .tox-color-input span{right:6px}.tox .tox-label,.tox .tox-toolbar-label{color:rgba(34,47,62,.7);display:block;font-size:14px;font-style:normal;font-weight:400;line-height:1.3;padding:0 8px 0 0;text-transform:none;white-space:nowrap}.tox .tox-toolbar-label{padding:0 8px}.tox[dir=rtl] .tox-label{padding:0 0 0 8px}.tox .tox-form{display:flex;flex:1;flex-direction:column}.tox .tox-form__group{box-sizing:border-box;margin-bottom:4px}.tox .tox-form-group--maximize{flex:1}.tox .tox-form__group--error{color:#c00}.tox .tox-form__group--collection{display:flex}.tox .tox-form__grid{display:flex;flex-direction:row;flex-wrap:wrap;justify-content:space-between}.tox .tox-form__grid--2col>.tox-form__group{width:calc(50% - (8px / 2))}.tox .tox-form__grid--3col>.tox-form__group{width:calc(100% / 3 - (8px / 2))}.tox .tox-form__grid--4col>.tox-form__group{width:calc(25% - (8px / 2))}.tox .tox-form__controls-h-stack{align-items:center;display:flex}.tox .tox-form__group--inline{align-items:center;display:flex}.tox .tox-form__group--stretched{display:flex;flex:1;flex-direction:column}.tox .tox-form__group--stretched .tox-textarea{flex:1}.tox .tox-form__group--stretched .tox-navobj{display:flex;flex:1}.tox .tox-form__group--stretched .tox-navobj :nth-child(2){flex:1;height:100%}.tox:not([dir=rtl]) .tox-form__controls-h-stack>:not(:first-child){margin-left:4px}.tox[dir=rtl] .tox-form__controls-h-stack>:not(:first-child){margin-right:4px}.tox .tox-lock.tox-locked .tox-lock-icon__unlock,.tox .tox-lock:not(.tox-locked) .tox-lock-icon__lock{display:none}.tox .tox-listboxfield .tox-listbox--select,.tox .tox-textarea,.tox .tox-textarea-wrap .tox-textarea:focus,.tox .tox-textfield,.tox .tox-toolbar-textfield{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:#fff;border-color:#eee;border-radius:6px;border-style:solid;border-width:1px;box-shadow:none;box-sizing:border-box;color:#222f3e;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:16px;line-height:24px;margin:0;min-height:34px;outline:0;padding:5px 5.5px;resize:none;width:100%}.tox .tox-textarea[disabled],.tox .tox-textfield[disabled]{background-color:#f2f2f2;color:rgba(34,47,62,.85);cursor:not-allowed}.tox .tox-custom-editor:focus-within,.tox .tox-listboxfield .tox-listbox--select:focus,.tox .tox-textarea-wrap:focus-within,.tox .tox-textarea:focus,.tox .tox-textfield:focus{background-color:#fff;border-color:#006ce7;box-shadow:0 0 0 2px rgba(0,108,231,.25);outline:0}.tox .tox-toolbar-textfield{border-width:0;margin-bottom:3px;margin-top:2px;max-width:250px}.tox .tox-naked-btn{background-color:transparent;border:0;border-color:transparent;box-shadow:unset;color:#006ce7;cursor:pointer;display:block;margin:0;padding:0}.tox .tox-naked-btn svg{display:block;fill:#222f3e}.tox:not([dir=rtl]) .tox-toolbar-textfield+*{margin-left:4px}.tox[dir=rtl] .tox-toolbar-textfield+*{margin-right:4px}.tox .tox-listboxfield{cursor:pointer;position:relative}.tox .tox-listboxfield .tox-listbox--select[disabled]{background-color:#f2f2f2;color:rgba(34,47,62,.85);cursor:not-allowed}.tox .tox-listbox__select-label{cursor:default;flex:1;margin:0 4px}.tox .tox-listbox__select-chevron{align-items:center;display:flex;justify-content:center;width:16px}.tox .tox-listbox__select-chevron svg{fill:#222f3e}.tox .tox-listboxfield .tox-listbox--select{align-items:center;display:flex}.tox:not([dir=rtl]) .tox-listboxfield svg{right:8px}.tox[dir=rtl] .tox-listboxfield svg{left:8px}.tox .tox-selectfield{cursor:pointer;position:relative}.tox .tox-selectfield select{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:#fff;border-color:#eee;border-radius:6px;border-style:solid;border-width:1px;box-shadow:none;box-sizing:border-box;color:#222f3e;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif;font-size:16px;line-height:24px;margin:0;min-height:34px;outline:0;padding:5px 5.5px;resize:none;width:100%}.tox .tox-selectfield select[disabled]{background-color:#f2f2f2;color:rgba(34,47,62,.85);cursor:not-allowed}.tox .tox-selectfield select::-ms-expand{display:none}.tox .tox-selectfield select:focus{background-color:#fff;border-color:#006ce7;box-shadow:0 0 0 2px rgba(0,108,231,.25);outline:0}.tox .tox-selectfield svg{pointer-events:none;position:absolute;top:50%;transform:translateY(-50%)}.tox:not([dir=rtl]) .tox-selectfield select[size="0"],.tox:not([dir=rtl]) .tox-selectfield select[size="1"]{padding-right:24px}.tox:not([dir=rtl]) .tox-selectfield svg{right:8px}.tox[dir=rtl] .tox-selectfield select[size="0"],.tox[dir=rtl] .tox-selectfield select[size="1"]{padding-left:24px}.tox[dir=rtl] .tox-selectfield svg{left:8px}.tox .tox-textarea-wrap{border-color:#eee;border-radius:6px;border-style:solid;border-width:1px;display:flex;flex:1;overflow:hidden}.tox .tox-textarea{-webkit-appearance:textarea;-moz-appearance:textarea;appearance:textarea;white-space:pre-wrap}.tox .tox-textarea-wrap .tox-textarea{border:none}.tox .tox-textarea-wrap .tox-textarea:focus{border:none}.tox-fullscreen{border:0;height:100%;margin:0;overflow:hidden;overscroll-behavior:none;padding:0;touch-action:pinch-zoom;width:100%}.tox.tox-tinymce.tox-fullscreen .tox-statusbar__resize-handle{display:none}.tox-shadowhost.tox-fullscreen,.tox.tox-tinymce.tox-fullscreen{left:0;position:fixed;top:0;z-index:1200}.tox.tox-tinymce.tox-fullscreen{background-color:transparent}.tox-fullscreen .tox.tox-tinymce-aux,.tox-fullscreen~.tox.tox-tinymce-aux{z-index:1201}.tox .tox-help__more-link{list-style:none;margin-top:1em}.tox .tox-imagepreview{background-color:#666;height:380px;overflow:hidden;position:relative;width:100%}.tox .tox-imagepreview.tox-imagepreview__loaded{overflow:auto}.tox .tox-imagepreview__container{display:flex;left:100vw;position:absolute;top:100vw}.tox .tox-imagepreview__image{background:url(data:image/gif;base64,R0lGODdhDAAMAIABAMzMzP///ywAAAAADAAMAAACFoQfqYeabNyDMkBQb81Uat85nxguUAEAOw==)}.tox .tox-image-tools .tox-spacer{flex:1}.tox .tox-image-tools .tox-bar{align-items:center;display:flex;height:60px;justify-content:center}.tox .tox-image-tools .tox-imagepreview,.tox .tox-image-tools .tox-imagepreview+.tox-bar{margin-top:8px}.tox .tox-image-tools .tox-croprect-block{background:#000;opacity:.5;position:absolute;zoom:1}.tox .tox-image-tools .tox-croprect-handle{border:2px solid #fff;height:20px;left:0;position:absolute;top:0;width:20px}.tox .tox-image-tools .tox-croprect-handle-move{border:0;cursor:move;position:absolute}.tox .tox-image-tools .tox-croprect-handle-nw{border-width:2px 0 0 2px;cursor:nw-resize;left:100px;margin:-2px 0 0 -2px;top:100px}.tox .tox-image-tools .tox-croprect-handle-ne{border-width:2px 2px 0 0;cursor:ne-resize;left:200px;margin:-2px 0 0 -20px;top:100px}.tox .tox-image-tools .tox-croprect-handle-sw{border-width:0 0 2px 2px;cursor:sw-resize;left:100px;margin:-20px 2px 0 -2px;top:200px}.tox .tox-image-tools .tox-croprect-handle-se{border-width:0 2px 2px 0;cursor:se-resize;left:200px;margin:-20px 0 0 -20px;top:200px}.tox .tox-insert-table-picker{display:flex;flex-wrap:wrap;width:170px}.tox .tox-insert-table-picker>div{border-color:#eee;border-style:solid;border-width:0 1px 1px 0;box-sizing:border-box;height:17px;width:17px}.tox .tox-collection--list .tox-collection__group .tox-insert-table-picker{margin:-4px -4px}.tox .tox-insert-table-picker .tox-insert-table-picker__selected{background-color:rgba(0,108,231,.5);border-color:rgba(0,108,231,.5)}.tox .tox-insert-table-picker__label{color:rgba(34,47,62,.7);display:block;font-size:14px;padding:4px;text-align:center;width:100%}.tox:not([dir=rtl]) .tox-insert-table-picker>div:nth-child(10n){border-right:0}.tox[dir=rtl] .tox-insert-table-picker>div:nth-child(10n+1){border-right:0}.tox .tox-menu{background-color:#fff;border:1px solid transparent;border-radius:6px;box-shadow:0 0 2px 0 rgba(34,47,62,.2),0 4px 8px 0 rgba(34,47,62,.15);display:inline-block;overflow:hidden;vertical-align:top;z-index:1150}.tox .tox-menu.tox-collection.tox-collection--list{padding:0 4px}.tox .tox-menu.tox-collection.tox-collection--toolbar{padding:8px}.tox .tox-menu.tox-collection.tox-collection--grid{padding:8px}@media only screen and (min-width:768px){.tox .tox-menu .tox-collection__item-label{overflow-wrap:break-word;word-break:normal}.tox .tox-dialog__popups .tox-menu .tox-collection__item-label{word-break:break-all}}.tox .tox-menu__label blockquote,.tox .tox-menu__label code,.tox .tox-menu__label h1,.tox .tox-menu__label h2,.tox .tox-menu__label h3,.tox .tox-menu__label h4,.tox .tox-menu__label h5,.tox .tox-menu__label h6,.tox .tox-menu__label p{margin:0}.tox .tox-menubar{background:repeating-linear-gradient(transparent 0 1px,transparent 1px 39px) center top 39px/100% calc(100% - 39px) no-repeat;background-color:#fff;display:flex;flex:0 0 auto;flex-shrink:0;flex-wrap:wrap;grid-column:1/-1;grid-row:1;padding:0 11px 0 12px}.tox .tox-promotion+.tox-menubar{grid-column:1}.tox .tox-promotion{background:repeating-linear-gradient(transparent 0 1px,transparent 1px 39px) center top 39px/100% calc(100% - 39px) no-repeat;background-color:#fff;grid-column:2;grid-row:1;padding-inline-end:8px;padding-inline-start:4px;padding-top:5px}.tox .tox-promotion-link{align-items:unsafe center;background-color:#e8f1f8;border-radius:5px;color:#086be6;cursor:pointer;display:flex;font-size:14px;height:26.6px;padding:4px 8px;white-space:nowrap}.tox .tox-promotion-link:hover{background-color:#b4d7ff}.tox .tox-promotion-link:focus{background-color:#d9edf7}.tox .tox-mbtn{align-items:center;background:0 0;border:0;border-radius:3px;box-shadow:none;color:#222f3e;display:flex;flex:0 0 auto;font-size:14px;font-style:normal;font-weight:400;height:28px;justify-content:center;margin:5px 1px 6px 0;outline:0;overflow:hidden;padding:0 4px;text-transform:none;width:auto}.tox .tox-mbtn[disabled]{background-color:transparent;border:0;box-shadow:none;color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-mbtn:focus:not(:disabled){background:#cce2fa;border:0;box-shadow:none;color:#222f3e}.tox .tox-mbtn--active{background:#a6ccf7;border:0;box-shadow:none;color:#222f3e}.tox .tox-mbtn:hover:not(:disabled):not(.tox-mbtn--active){background:#cce2fa;border:0;box-shadow:none;color:#222f3e}.tox .tox-mbtn__select-label{cursor:default;font-weight:400;margin:0 4px}.tox .tox-mbtn[disabled] .tox-mbtn__select-label{cursor:not-allowed}.tox .tox-mbtn__select-chevron{align-items:center;display:flex;justify-content:center;width:16px;display:none}.tox .tox-notification{border-radius:6px;border-style:solid;border-width:1px;box-shadow:none;box-sizing:border-box;display:grid;font-size:14px;font-weight:400;grid-template-columns:minmax(40px,1fr) auto minmax(40px,1fr);margin-top:4px;opacity:0;padding:4px;transition:transform .1s ease-in,opacity 150ms ease-in}.tox .tox-notification p{font-size:14px;font-weight:400}.tox .tox-notification a{cursor:pointer;text-decoration:underline}.tox .tox-notification--in{opacity:1}.tox .tox-notification--success{background-color:#e4eeda;border-color:#d7e6c8;color:#222f3e}.tox .tox-notification--success p{color:#222f3e}.tox .tox-notification--success a{color:#517342}.tox .tox-notification--success svg{fill:#222f3e}.tox .tox-notification--error{background-color:#f5cccc;border-color:#f0b3b3;color:#222f3e}.tox .tox-notification--error p{color:#222f3e}.tox .tox-notification--error a{color:#77181f}.tox .tox-notification--error svg{fill:#222f3e}.tox .tox-notification--warn,.tox .tox-notification--warning{background-color:#fff5cc;border-color:#fff0b3;color:#222f3e}.tox .tox-notification--warn p,.tox .tox-notification--warning p{color:#222f3e}.tox .tox-notification--warn a,.tox .tox-notification--warning a{color:#7a6e25}.tox .tox-notification--warn svg,.tox .tox-notification--warning svg{fill:#222f3e}.tox .tox-notification--info{background-color:#d6e7fb;border-color:#c1dbf9;color:#222f3e}.tox .tox-notification--info p{color:#222f3e}.tox .tox-notification--info a{color:#2a64a6}.tox .tox-notification--info svg{fill:#222f3e}.tox .tox-notification__body{align-self:center;color:#222f3e;font-size:14px;grid-column-end:3;grid-column-start:2;grid-row-end:2;grid-row-start:1;text-align:center;white-space:normal;word-break:break-all;word-break:break-word}.tox .tox-notification__body>*{margin:0}.tox .tox-notification__body>*+*{margin-top:1rem}.tox .tox-notification__icon{align-self:center;grid-column-end:2;grid-column-start:1;grid-row-end:2;grid-row-start:1;justify-self:end}.tox .tox-notification__icon svg{display:block}.tox .tox-notification__dismiss{align-self:start;grid-column-end:4;grid-column-start:3;grid-row-end:2;grid-row-start:1;justify-self:end}.tox .tox-notification .tox-progress-bar{grid-column-end:4;grid-column-start:1;grid-row-end:3;grid-row-start:2;justify-self:center}.tox .tox-pop{display:inline-block;position:relative}.tox .tox-pop--resizing{transition:width .1s ease}.tox .tox-pop--resizing .tox-toolbar,.tox .tox-pop--resizing .tox-toolbar__group{flex-wrap:nowrap}.tox .tox-pop--transition{transition:.15s ease;transition-property:left,right,top,bottom}.tox .tox-pop--transition::after,.tox .tox-pop--transition::before{transition:all .15s,visibility 0s,opacity 75ms ease 75ms}.tox .tox-pop__dialog{background-color:#fff;border:1px solid #eee;border-radius:6px;box-shadow:0 0 2px 0 rgba(34,47,62,.2),0 4px 8px 0 rgba(34,47,62,.15);min-width:0;overflow:hidden}.tox .tox-pop__dialog>:not(.tox-toolbar){margin:4px 4px 4px 8px}.tox .tox-pop__dialog .tox-toolbar{background-color:transparent;margin-bottom:-1px}.tox .tox-pop::after,.tox .tox-pop::before{border-style:solid;content:'';display:block;height:0;opacity:1;position:absolute;width:0}.tox .tox-pop.tox-pop--inset::after,.tox .tox-pop.tox-pop--inset::before{opacity:0;transition:all 0s .15s,visibility 0s,opacity 75ms ease}.tox .tox-pop.tox-pop--bottom::after,.tox .tox-pop.tox-pop--bottom::before{left:50%;top:100%}.tox .tox-pop.tox-pop--bottom::after{border-color:#fff transparent transparent transparent;border-width:8px;margin-left:-8px;margin-top:-1px}.tox .tox-pop.tox-pop--bottom::before{border-color:#eee transparent transparent transparent;border-width:9px;margin-left:-9px}.tox .tox-pop.tox-pop--top::after,.tox .tox-pop.tox-pop--top::before{left:50%;top:0;transform:translateY(-100%)}.tox .tox-pop.tox-pop--top::after{border-color:transparent transparent #fff transparent;border-width:8px;margin-left:-8px;margin-top:1px}.tox .tox-pop.tox-pop--top::before{border-color:transparent transparent #eee transparent;border-width:9px;margin-left:-9px}.tox .tox-pop.tox-pop--left::after,.tox .tox-pop.tox-pop--left::before{left:0;top:calc(50% - 1px);transform:translateY(-50%)}.tox .tox-pop.tox-pop--left::after{border-color:transparent #fff transparent transparent;border-width:8px;margin-left:-15px}.tox .tox-pop.tox-pop--left::before{border-color:transparent #eee transparent transparent;border-width:10px;margin-left:-19px}.tox .tox-pop.tox-pop--right::after,.tox .tox-pop.tox-pop--right::before{left:100%;top:calc(50% + 1px);transform:translateY(-50%)}.tox .tox-pop.tox-pop--right::after{border-color:transparent transparent transparent #fff;border-width:8px;margin-left:-1px}.tox .tox-pop.tox-pop--right::before{border-color:transparent transparent transparent #eee;border-width:10px;margin-left:-1px}.tox .tox-pop.tox-pop--align-left::after,.tox .tox-pop.tox-pop--align-left::before{left:20px}.tox .tox-pop.tox-pop--align-right::after,.tox .tox-pop.tox-pop--align-right::before{left:calc(100% - 20px)}.tox .tox-sidebar-wrap{display:flex;flex-direction:row;flex-grow:1;min-height:0}.tox .tox-sidebar{background-color:#fff;display:flex;flex-direction:row;justify-content:flex-end}.tox .tox-sidebar__slider{display:flex;overflow:hidden}.tox .tox-sidebar__pane-container{display:flex}.tox .tox-sidebar__pane{display:flex}.tox .tox-sidebar--sliding-closed{opacity:0}.tox .tox-sidebar--sliding-open{opacity:1}.tox .tox-sidebar--sliding-growing,.tox .tox-sidebar--sliding-shrinking{transition:width .5s ease,opacity .5s ease}.tox .tox-selector{background-color:#4099ff;border-color:#4099ff;border-style:solid;border-width:1px;box-sizing:border-box;display:inline-block;height:10px;position:absolute;width:10px}.tox.tox-platform-touch .tox-selector{height:12px;width:12px}.tox .tox-slider{align-items:center;display:flex;flex:1;height:24px;justify-content:center;position:relative}.tox .tox-slider__rail{background-color:transparent;border:1px solid #eee;border-radius:6px;height:10px;min-width:120px;width:100%}.tox .tox-slider__handle{background-color:#006ce7;border:2px solid #0054b4;border-radius:6px;box-shadow:none;height:24px;left:50%;position:absolute;top:50%;transform:translateX(-50%) translateY(-50%);width:14px}.tox .tox-form__controls-h-stack>.tox-slider:not(:first-of-type){margin-inline-start:8px}.tox .tox-form__controls-h-stack>.tox-form__group+.tox-slider{margin-inline-start:32px}.tox .tox-form__controls-h-stack>.tox-slider+.tox-form__group{margin-inline-start:32px}.tox .tox-source-code{overflow:auto}.tox .tox-spinner{display:flex}.tox .tox-spinner>div{animation:tam-bouncing-dots 1.5s ease-in-out 0s infinite both;background-color:rgba(34,47,62,.7);border-radius:100%;height:8px;width:8px}.tox .tox-spinner>div:nth-child(1){animation-delay:-.32s}.tox .tox-spinner>div:nth-child(2){animation-delay:-.16s}@keyframes tam-bouncing-dots{0%,100%,80%{transform:scale(0)}40%{transform:scale(1)}}.tox:not([dir=rtl]) .tox-spinner>div:not(:first-child){margin-left:4px}.tox[dir=rtl] .tox-spinner>div:not(:first-child){margin-right:4px}.tox .tox-statusbar{align-items:center;background-color:#fff;border-top:1px solid #e3e3e3;color:rgba(34,47,62,.7);display:flex;flex:0 0 auto;font-size:14px;font-weight:400;height:25px;overflow:hidden;padding:0 8px;position:relative;text-transform:none}.tox .tox-statusbar__path{display:flex;flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tox .tox-statusbar__right-container{display:flex;justify-content:flex-end;white-space:nowrap}.tox .tox-statusbar__help-text{text-align:center}.tox .tox-statusbar__text-container{display:flex;flex:1 1 auto;justify-content:space-between;overflow:hidden}@media only screen and (min-width:768px){.tox .tox-statusbar__text-container.tox-statusbar__text-container-3-cols>.tox-statusbar__help-text,.tox .tox-statusbar__text-container.tox-statusbar__text-container-3-cols>.tox-statusbar__path,.tox .tox-statusbar__text-container.tox-statusbar__text-container-3-cols>.tox-statusbar__right-container{flex:0 0 calc(100% / 3)}}.tox .tox-statusbar__text-container.tox-statusbar__text-container--flex-end{justify-content:flex-end}.tox .tox-statusbar__text-container.tox-statusbar__text-container--flex-start{justify-content:flex-start}.tox .tox-statusbar__text-container.tox-statusbar__text-container--space-around{justify-content:space-around}.tox .tox-statusbar__path>*{display:inline;white-space:nowrap}.tox .tox-statusbar__wordcount{flex:0 0 auto;margin-left:1ch}@media only screen and (max-width:767px){.tox .tox-statusbar__text-container .tox-statusbar__help-text{display:none}.tox .tox-statusbar__text-container .tox-statusbar__help-text:only-child{display:block}}.tox .tox-statusbar a,.tox .tox-statusbar__path-item,.tox .tox-statusbar__wordcount{color:rgba(34,47,62,.7);text-decoration:none}.tox .tox-statusbar a:focus:not(:disabled):not([aria-disabled=true]),.tox .tox-statusbar a:hover:not(:disabled):not([aria-disabled=true]),.tox .tox-statusbar__path-item:focus:not(:disabled):not([aria-disabled=true]),.tox .tox-statusbar__path-item:hover:not(:disabled):not([aria-disabled=true]),.tox .tox-statusbar__wordcount:focus:not(:disabled):not([aria-disabled=true]),.tox .tox-statusbar__wordcount:hover:not(:disabled):not([aria-disabled=true]){color:#222f3e;cursor:pointer}.tox .tox-statusbar__branding svg{fill:rgba(34,47,62,.8);height:1.14em;vertical-align:-.28em;width:3.6em}.tox .tox-statusbar__branding a:focus:not(:disabled):not([aria-disabled=true]) svg,.tox .tox-statusbar__branding a:hover:not(:disabled):not([aria-disabled=true]) svg{fill:#222f3e}.tox .tox-statusbar__resize-handle{align-items:flex-end;align-self:stretch;cursor:nwse-resize;display:flex;flex:0 0 auto;justify-content:flex-end;margin-left:auto;margin-right:-8px;padding-bottom:3px;padding-left:1ch;padding-right:3px}.tox .tox-statusbar__resize-handle svg{display:block;fill:rgba(34,47,62,.5)}.tox .tox-statusbar__resize-handle:focus svg{background-color:#dee0e2;border-radius:1px 1px 5px 1px;box-shadow:0 0 0 2px #dee0e2}.tox:not([dir=rtl]) .tox-statusbar__path>*{margin-right:4px}.tox:not([dir=rtl]) .tox-statusbar__branding{margin-left:2ch}.tox[dir=rtl] .tox-statusbar{flex-direction:row-reverse}.tox[dir=rtl] .tox-statusbar__path>*{margin-left:4px}.tox .tox-throbber{z-index:1299}.tox .tox-throbber__busy-spinner{align-items:center;background-color:rgba(255,255,255,.6);bottom:0;display:flex;justify-content:center;left:0;position:absolute;right:0;top:0}.tox .tox-tbtn{align-items:center;background:0 0;border:0;border-radius:3px;box-shadow:none;color:#222f3e;display:flex;flex:0 0 auto;font-size:14px;font-style:normal;font-weight:400;height:28px;justify-content:center;margin:6px 1px 5px 0;outline:0;overflow:hidden;padding:0;text-transform:none;width:34px}.tox .tox-tbtn svg{display:block;fill:#222f3e}.tox .tox-tbtn.tox-tbtn-more{padding-left:5px;padding-right:5px;width:inherit}.tox .tox-tbtn:focus{background:#cce2fa;border:0;box-shadow:none}.tox .tox-tbtn:hover{background:#cce2fa;border:0;box-shadow:none;color:#222f3e}.tox .tox-tbtn:hover svg{fill:#222f3e}.tox .tox-tbtn:active{background:#a6ccf7;border:0;box-shadow:none;color:#222f3e}.tox .tox-tbtn:active svg{fill:#222f3e}.tox .tox-tbtn--disabled .tox-tbtn--enabled svg{fill:rgba(34,47,62,.5)}.tox .tox-tbtn--disabled,.tox .tox-tbtn--disabled:hover,.tox .tox-tbtn:disabled,.tox .tox-tbtn:disabled:hover{background:0 0;border:0;box-shadow:none;color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-tbtn--disabled svg,.tox .tox-tbtn--disabled:hover svg,.tox .tox-tbtn:disabled svg,.tox .tox-tbtn:disabled:hover svg{fill:rgba(34,47,62,.5)}.tox .tox-tbtn--enabled,.tox .tox-tbtn--enabled:hover{background:#a6ccf7;border:0;box-shadow:none;color:#222f3e}.tox .tox-tbtn--enabled:hover>*,.tox .tox-tbtn--enabled>*{transform:none}.tox .tox-tbtn--enabled svg,.tox .tox-tbtn--enabled:hover svg{fill:#222f3e}.tox .tox-tbtn--enabled.tox-tbtn--disabled svg,.tox .tox-tbtn--enabled:hover.tox-tbtn--disabled svg{fill:rgba(34,47,62,.5)}.tox .tox-tbtn:focus:not(.tox-tbtn--disabled){color:#222f3e}.tox .tox-tbtn:focus:not(.tox-tbtn--disabled) svg{fill:#222f3e}.tox .tox-tbtn:active>*{transform:none}.tox .tox-tbtn--md{height:42px;width:51px}.tox .tox-tbtn--lg{flex-direction:column;height:56px;width:68px}.tox .tox-tbtn--return{align-self:stretch;height:unset;width:16px}.tox .tox-tbtn--labeled{padding:0 4px;width:unset}.tox .tox-tbtn__vlabel{display:block;font-size:10px;font-weight:400;letter-spacing:-.025em;margin-bottom:4px;white-space:nowrap}.tox .tox-number-input{border-radius:3px;display:flex;margin:6px 1px 5px 0;padding:0 4px;width:auto}.tox .tox-number-input .tox-input-wrapper{background:#f7f7f7;display:flex;pointer-events:none;text-align:center}.tox .tox-number-input .tox-input-wrapper:focus{background:#cce2fa}.tox .tox-number-input input{border-radius:3px;color:#222f3e;font-size:14px;margin:2px 0;pointer-events:all;width:60px}.tox .tox-number-input input:hover{background:#cce2fa;color:#222f3e}.tox .tox-number-input input:focus{background:#fff;color:#222f3e}.tox .tox-number-input input:disabled{background:0 0;border:0;box-shadow:none;color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-number-input button{background:#f7f7f7;color:#222f3e;height:28px;text-align:center;width:24px}.tox .tox-number-input button svg{display:block;fill:#222f3e;margin:0 auto;transform:scale(.67)}.tox .tox-number-input button:focus{background:#cce2fa}.tox .tox-number-input button:hover{background:#cce2fa;border:0;box-shadow:none;color:#222f3e}.tox .tox-number-input button:hover svg{fill:#222f3e}.tox .tox-number-input button:active{background:#a6ccf7;border:0;box-shadow:none;color:#222f3e}.tox .tox-number-input button:active svg{fill:#222f3e}.tox .tox-number-input button:disabled{background:0 0;border:0;box-shadow:none;color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-number-input button:disabled svg{fill:rgba(34,47,62,.5)}.tox .tox-number-input button.minus{border-radius:3px 0 0 3px}.tox .tox-number-input button.plus{border-radius:0 3px 3px 0}.tox .tox-number-input:focus:not(:active)>.tox-input-wrapper,.tox .tox-number-input:focus:not(:active)>button{background:#cce2fa}.tox .tox-tbtn--select{margin:6px 1px 5px 0;padding:0 4px;width:auto}.tox .tox-tbtn__select-label{cursor:default;font-weight:400;height:initial;margin:0 4px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tox .tox-tbtn__select-chevron{align-items:center;display:flex;justify-content:center;width:16px}.tox .tox-tbtn__select-chevron svg{fill:rgba(34,47,62,.5)}.tox .tox-tbtn--bespoke{background:#f7f7f7}.tox .tox-tbtn--bespoke+.tox-tbtn--bespoke{margin-inline-start:4px}.tox .tox-tbtn--bespoke .tox-tbtn__select-label{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:7em}.tox .tox-tbtn--disabled .tox-tbtn__select-label,.tox .tox-tbtn--select:disabled .tox-tbtn__select-label{cursor:not-allowed}.tox .tox-split-button{border:0;border-radius:3px;box-sizing:border-box;display:flex;margin:6px 1px 5px 0;overflow:hidden}.tox .tox-split-button:hover{box-shadow:0 0 0 1px #cce2fa inset}.tox .tox-split-button:focus{background:#cce2fa;box-shadow:none;color:#222f3e}.tox .tox-split-button>*{border-radius:0}.tox .tox-split-button__chevron{width:16px}.tox .tox-split-button__chevron svg{fill:rgba(34,47,62,.5)}.tox .tox-split-button .tox-tbtn{margin:0}.tox .tox-split-button.tox-tbtn--disabled .tox-tbtn:focus,.tox .tox-split-button.tox-tbtn--disabled .tox-tbtn:hover,.tox .tox-split-button.tox-tbtn--disabled:focus,.tox .tox-split-button.tox-tbtn--disabled:hover{background:0 0;box-shadow:none;color:rgba(34,47,62,.5)}.tox.tox-platform-touch .tox-split-button .tox-tbtn--select{padding:0 0}.tox.tox-platform-touch .tox-split-button .tox-tbtn:not(.tox-tbtn--select):first-child{width:30px}.tox.tox-platform-touch .tox-split-button__chevron{width:20px}.tox .tox-split-button.tox-tbtn--disabled svg #tox-icon-highlight-bg-color__color,.tox .tox-split-button.tox-tbtn--disabled svg #tox-icon-text-color__color{opacity:.6}.tox .tox-toolbar-overlord{background-color:#fff}.tox .tox-toolbar,.tox .tox-toolbar__overflow,.tox .tox-toolbar__primary{background-attachment:local;background-color:#fff;background-image:repeating-linear-gradient(#e3e3e3 0 1px,transparent 1px 39px);background-position:center top 40px;background-repeat:no-repeat;background-size:calc(100% - 11px * 2) calc(100% - 41px);display:flex;flex:0 0 auto;flex-shrink:0;flex-wrap:wrap;padding:0 0;transform:perspective(1px)}.tox .tox-toolbar-overlord>.tox-toolbar,.tox .tox-toolbar-overlord>.tox-toolbar__overflow,.tox .tox-toolbar-overlord>.tox-toolbar__primary{background-position:center top 0;background-size:calc(100% - 11px * 2) calc(100% - 0px)}.tox .tox-toolbar__overflow.tox-toolbar__overflow--closed{height:0;opacity:0;padding-bottom:0;padding-top:0;visibility:hidden}.tox .tox-toolbar__overflow--growing{transition:height .3s ease,opacity .2s linear .1s}.tox .tox-toolbar__overflow--shrinking{transition:opacity .3s ease,height .2s linear .1s,visibility 0s linear .3s}.tox .tox-anchorbar,.tox .tox-toolbar-overlord{grid-column:1/-1}.tox .tox-menubar+.tox-toolbar,.tox .tox-menubar+.tox-toolbar-overlord{border-top:1px solid transparent;margin-top:-1px;padding-bottom:1px;padding-top:1px}.tox .tox-toolbar--scrolling{flex-wrap:nowrap;overflow-x:auto}.tox .tox-pop .tox-toolbar{border-width:0}.tox .tox-toolbar--no-divider{background-image:none}.tox .tox-toolbar-overlord .tox-toolbar:not(.tox-toolbar--scrolling):first-child,.tox .tox-toolbar-overlord .tox-toolbar__primary{background-position:center top 39px}.tox .tox-editor-header>.tox-toolbar--scrolling,.tox .tox-toolbar-overlord .tox-toolbar--scrolling:first-child{background-image:none}.tox.tox-tinymce-aux .tox-toolbar__overflow{background-color:#fff;background-position:center top 43px;background-size:calc(100% - 8px * 2) calc(100% - 51px);border:none;border-radius:6px;box-shadow:0 0 2px 0 rgba(34,47,62,.2),0 4px 8px 0 rgba(34,47,62,.15);overscroll-behavior:none;padding:4px 0}.tox-pop .tox-pop__dialog .tox-toolbar{background-position:center top 43px;background-size:calc(100% - 11px * 2) calc(100% - 51px);padding:4px 0}.tox .tox-toolbar__group{align-items:center;display:flex;flex-wrap:wrap;margin:0 0;padding:0 11px 0 12px}.tox .tox-toolbar__group--pull-right{margin-left:auto}.tox .tox-toolbar--scrolling .tox-toolbar__group{flex-shrink:0;flex-wrap:nowrap}.tox:not([dir=rtl]) .tox-toolbar__group:not(:last-of-type){border-right:1px solid transparent}.tox[dir=rtl] .tox-toolbar__group:not(:last-of-type){border-left:1px solid transparent}.tox .tox-tooltip{display:inline-block;padding:8px;position:relative}.tox .tox-tooltip__body{background-color:#222f3e;border-radius:6px;box-shadow:0 2px 4px rgba(34,47,62,.3);color:rgba(255,255,255,.75);font-size:14px;font-style:normal;font-weight:400;padding:4px 8px;text-transform:none}.tox .tox-tooltip__arrow{position:absolute}.tox .tox-tooltip--down .tox-tooltip__arrow{border-left:8px solid transparent;border-right:8px solid transparent;border-top:8px solid #222f3e;bottom:0;left:50%;position:absolute;transform:translateX(-50%)}.tox .tox-tooltip--up .tox-tooltip__arrow{border-bottom:8px solid #222f3e;border-left:8px solid transparent;border-right:8px solid transparent;left:50%;position:absolute;top:0;transform:translateX(-50%)}.tox .tox-tooltip--right .tox-tooltip__arrow{border-bottom:8px solid transparent;border-left:8px solid #222f3e;border-top:8px solid transparent;position:absolute;right:0;top:50%;transform:translateY(-50%)}.tox .tox-tooltip--left .tox-tooltip__arrow{border-bottom:8px solid transparent;border-right:8px solid #222f3e;border-top:8px solid transparent;left:0;position:absolute;top:50%;transform:translateY(-50%)}.tox .tox-tree{display:flex;flex-direction:column}.tox .tox-tree .tox-trbtn{align-items:center;background:0 0;border:0;border-radius:4px;box-shadow:none;color:#222f3e;display:flex;flex:0 0 auto;font-size:14px;font-style:normal;font-weight:400;height:28px;margin-bottom:4px;margin-top:4px;outline:0;overflow:hidden;padding:0;padding-left:8px;text-transform:none}.tox .tox-tree .tox-trbtn .tox-tree__label{cursor:default;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tox .tox-tree .tox-trbtn svg{display:block;fill:#222f3e}.tox .tox-tree .tox-trbtn:focus{background:#cce2fa;border:0;box-shadow:none}.tox .tox-tree .tox-trbtn:hover{background:#cce2fa;border:0;box-shadow:none;color:#222f3e}.tox .tox-tree .tox-trbtn:hover svg{fill:#222f3e}.tox .tox-tree .tox-trbtn:active{background:#a6ccf7;border:0;box-shadow:none;color:#222f3e}.tox .tox-tree .tox-trbtn:active svg{fill:#222f3e}.tox .tox-tree .tox-trbtn--disabled,.tox .tox-tree .tox-trbtn--disabled:hover,.tox .tox-tree .tox-trbtn:disabled,.tox .tox-tree .tox-trbtn:disabled:hover{background:0 0;border:0;box-shadow:none;color:rgba(34,47,62,.5);cursor:not-allowed}.tox .tox-tree .tox-trbtn--disabled svg,.tox .tox-tree .tox-trbtn--disabled:hover svg,.tox .tox-tree .tox-trbtn:disabled svg,.tox .tox-tree .tox-trbtn:disabled:hover svg{fill:rgba(34,47,62,.5)}.tox .tox-tree .tox-trbtn--enabled,.tox .tox-tree .tox-trbtn--enabled:hover{background:#a6ccf7;border:0;box-shadow:none;color:#222f3e}.tox .tox-tree .tox-trbtn--enabled:hover>*,.tox .tox-tree .tox-trbtn--enabled>*{transform:none}.tox .tox-tree .tox-trbtn--enabled svg,.tox .tox-tree .tox-trbtn--enabled:hover svg{fill:#222f3e}.tox .tox-tree .tox-trbtn:focus:not(.tox-trbtn--disabled){color:#222f3e}.tox .tox-tree .tox-trbtn:focus:not(.tox-trbtn--disabled) svg{fill:#222f3e}.tox .tox-tree .tox-trbtn:active>*{transform:none}.tox .tox-tree .tox-trbtn--return{align-self:stretch;height:unset;width:16px}.tox .tox-tree .tox-trbtn--labeled{padding:0 4px;width:unset}.tox .tox-tree .tox-trbtn__vlabel{display:block;font-size:10px;font-weight:400;letter-spacing:-.025em;margin-bottom:4px;white-space:nowrap}.tox .tox-tree .tox-tree--directory{display:flex;flex-direction:column}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label{font-weight:700}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label .tox-mbtn{margin-left:auto}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label .tox-mbtn svg{fill:transparent}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label .tox-mbtn.tox-mbtn--active svg,.tox .tox-tree .tox-tree--directory .tox-tree--directory__label .tox-mbtn:focus svg{fill:#222f3e}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:focus .tox-mbtn svg,.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:hover .tox-mbtn svg{fill:#222f3e}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:hover:has(.tox-mbtn:hover){background-color:transparent;color:#222f3e}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:hover:has(.tox-mbtn:hover) .tox-chevron svg{fill:#222f3e}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label .tox-chevron{margin-right:6px}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:has(+.tox-tree--directory__children--growing) .tox-chevron,.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:has(+.tox-tree--directory__children--shrinking) .tox-chevron{transition:transform .5s ease-in-out}.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:has(+.tox-tree--directory__children--growing) .tox-chevron,.tox .tox-tree .tox-tree--directory .tox-tree--directory__label:has(+.tox-tree--directory__children--open) .tox-chevron{transform:rotate(90deg)}.tox .tox-tree .tox-tree--leaf__label{font-weight:400}.tox .tox-tree .tox-tree--leaf__label .tox-mbtn{margin-left:auto}.tox .tox-tree .tox-tree--leaf__label .tox-mbtn svg{fill:transparent}.tox .tox-tree .tox-tree--leaf__label .tox-mbtn.tox-mbtn--active svg,.tox .tox-tree .tox-tree--leaf__label .tox-mbtn:focus svg{fill:#222f3e}.tox .tox-tree .tox-tree--leaf__label:hover .tox-mbtn svg{fill:#222f3e}.tox .tox-tree .tox-tree--leaf__label:hover:has(.tox-mbtn:hover){background-color:transparent;color:#222f3e}.tox .tox-tree .tox-tree--leaf__label:hover:has(.tox-mbtn:hover) .tox-chevron svg{fill:#222f3e}.tox .tox-tree .tox-tree--directory__children{overflow:hidden;padding-left:16px}.tox .tox-tree .tox-tree--directory__children.tox-tree--directory__children--growing,.tox .tox-tree .tox-tree--directory__children.tox-tree--directory__children--shrinking{transition:height .5s ease-in-out}.tox .tox-tree .tox-trbtn.tox-tree--leaf__label{display:flex;justify-content:space-between}.tox .tox-view-wrap,.tox .tox-view-wrap__slot-container{background-color:#fff;display:flex;flex:1;flex-direction:column}.tox .tox-view{display:flex;flex:1 1 auto;flex-direction:column;overflow:hidden}.tox .tox-view__header{align-items:center;display:flex;font-size:16px;justify-content:space-between;padding:8px 8px 0 8px;position:relative}.tox .tox-view--mobile.tox-view__header,.tox .tox-view--mobile.tox-view__toolbar{padding:8px}.tox .tox-view--scrolling{flex-wrap:nowrap;overflow-x:auto}.tox .tox-view__toolbar{display:flex;flex-direction:row;gap:8px;justify-content:space-between;padding:8px 8px 0 8px}.tox .tox-view__toolbar__group{display:flex;flex-direction:row;gap:12px}.tox .tox-view__header-end,.tox .tox-view__header-start{display:flex}.tox .tox-view__pane{height:100%;padding:8px;width:100%}.tox .tox-view__pane_panel{border:1px solid #eee;border-radius:6px}.tox:not([dir=rtl]) .tox-view__header .tox-view__header-end>*,.tox:not([dir=rtl]) .tox-view__header .tox-view__header-start>*{margin-left:8px}.tox[dir=rtl] .tox-view__header .tox-view__header-end>*,.tox[dir=rtl] .tox-view__header .tox-view__header-start>*{margin-right:8px}.tox .tox-well{border:1px solid #eee;border-radius:6px;padding:8px;width:100%}.tox .tox-well>:first-child{margin-top:0}.tox .tox-well>:last-child{margin-bottom:0}.tox .tox-well>:only-child{margin:0}.tox .tox-custom-editor{border:1px solid #eee;border-radius:6px;display:flex;flex:1;overflow:hidden;position:relative}.tox .tox-dialog-loading::before{background-color:rgba(0,0,0,.5);content:"";height:100%;position:absolute;width:100%;z-index:1000}.tox .tox-tab{cursor:pointer}.tox .tox-dialog__content-js{display:flex;flex:1}.tox .tox-dialog__body-content .tox-collection{display:flex;flex:1}`);
(function() {
  var v = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const L = (Et, ht, mn) => {
    const lo = ht === "UL" ? "InsertUnorderedList" : "InsertOrderedList";
    Et.execCommand(lo, !1, mn === !1 ? null : { "list-style-type": mn });
  }, N = (Et) => {
    Et.addCommand("ApplyUnorderedListStyle", (ht, mn) => {
      L(Et, "UL", mn["list-style-type"]);
    }), Et.addCommand("ApplyOrderedListStyle", (ht, mn) => {
      L(Et, "OL", mn["list-style-type"]);
    });
  }, W = (Et) => (ht) => ht.options.get(Et), ue = (Et) => {
    const ht = Et.options.register;
    ht("advlist_number_styles", {
      processor: "string[]",
      default: "default,lower-alpha,lower-greek,lower-roman,upper-alpha,upper-roman".split(",")
    }), ht("advlist_bullet_styles", {
      processor: "string[]",
      default: "default,circle,square".split(",")
    });
  }, ce = W("advlist_number_styles"), he = W("advlist_bullet_styles"), pe = (Et) => Et == null, Me = (Et) => !pe(Et);
  var Ze = tinymce.util.Tools.resolve("tinymce.util.Tools");
  class Ye {
    constructor(ht, mn) {
      this.tag = ht, this.value = mn;
    }
    static some(ht) {
      return new Ye(!0, ht);
    }
    static none() {
      return Ye.singletonNone;
    }
    fold(ht, mn) {
      return this.tag ? mn(this.value) : ht();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(ht) {
      return this.tag ? Ye.some(ht(this.value)) : Ye.none();
    }
    bind(ht) {
      return this.tag ? ht(this.value) : Ye.none();
    }
    exists(ht) {
      return this.tag && ht(this.value);
    }
    forall(ht) {
      return !this.tag || ht(this.value);
    }
    filter(ht) {
      return !this.tag || ht(this.value) ? this : Ye.none();
    }
    getOr(ht) {
      return this.tag ? this.value : ht;
    }
    or(ht) {
      return this.tag ? this : ht;
    }
    getOrThunk(ht) {
      return this.tag ? this.value : ht();
    }
    orThunk(ht) {
      return this.tag ? this : ht();
    }
    getOrDie(ht) {
      if (this.tag)
        return this.value;
      throw new Error(ht ?? "Called getOrDie on None");
    }
    static from(ht) {
      return Me(ht) ? Ye.some(ht) : Ye.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(ht) {
      this.tag && ht(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Ye.singletonNone = new Ye(!1);
  const yt = (Et, ht, mn) => {
    for (let lo = 0, dt = Et.length; lo < dt; lo++) {
      const Bn = Et[lo];
      if (ht(Bn, lo))
        return Ye.some(Bn);
      if (mn(Bn, lo))
        break;
    }
    return Ye.none();
  }, jt = (Et) => /\btox\-/.test(Et.className), it = (Et, ht) => Et.dom.isChildOf(ht, Et.getBody()), Rt = (Et) => (ht) => Me(ht) && Et.test(ht.nodeName), en = Rt(/^(OL|UL|DL)$/), Gt = Rt(/^(TH|TD)$/), gt = (Et, ht, mn) => yt(ht, (lo) => en(lo) && !jt(lo), Gt).exists((lo) => lo.nodeName === mn && it(Et, lo)), an = (Et) => {
    const ht = Et.dom.getParent(Et.selection.getNode(), "ol,ul"), mn = Et.dom.getStyle(ht, "listStyleType");
    return Ye.from(mn);
  }, Ot = (Et, ht) => ht !== null && !Et.dom.isEditable(ht), Ee = (Et, ht) => {
    const mn = Et.dom.getParent(ht, "ol,ul,dl");
    return Ot(Et, mn) && Et.selection.isEditable();
  }, wt = (Et, ht) => {
    const mn = Et.selection.getNode();
    return ht({
      parents: Et.dom.getParents(mn),
      element: mn
    }), Et.on("NodeChange", ht), () => Et.off("NodeChange", ht);
  }, Se = (Et) => Et.replace(/\-/g, " ").replace(/\b\w/g, (ht) => ht.toUpperCase()), We = (Et) => pe(Et) || Et === "default" ? "" : Et, Cn = (Et, ht) => (mn) => {
    const lo = (Bn, jr) => {
      const Tt = Bn.selection.getStart(!0);
      mn.setActive(gt(Bn, jr, ht)), mn.setEnabled(!Ee(Bn, Tt) && Bn.selection.isEditable());
    };
    return wt(Et, (Bn) => lo(Et, Bn.parents));
  }, ko = (Et, ht, mn, lo, dt, Bn) => {
    Et.ui.registry.addSplitButton(ht, {
      tooltip: mn,
      icon: dt === "OL" ? "ordered-list" : "unordered-list",
      presets: "listpreview",
      columns: 3,
      fetch: (jr) => {
        const Tt = Ze.map(Bn, (yo) => {
          const Ct = dt === "OL" ? "num" : "bull", tn = yo === "disc" || yo === "decimal" ? "default" : yo, oa = We(yo), Pn = Se(yo);
          return {
            type: "choiceitem",
            value: oa,
            icon: "list-" + Ct + "-" + tn,
            text: Pn
          };
        });
        jr(Tt);
      },
      onAction: () => Et.execCommand(lo),
      onItemAction: (jr, Tt) => {
        L(Et, dt, Tt);
      },
      select: (jr) => an(Et).map((yo) => jr === yo).getOr(!1),
      onSetup: Cn(Et, dt)
    });
  }, jn = (Et, ht, mn, lo, dt, Bn) => {
    Et.ui.registry.addToggleButton(ht, {
      active: !1,
      tooltip: mn,
      icon: dt === "OL" ? "ordered-list" : "unordered-list",
      onSetup: Cn(Et, dt),
      onAction: () => Et.queryCommandState(lo) || Bn === "" ? Et.execCommand(lo) : L(Et, dt, Bn)
    });
  }, Xe = (Et, ht, mn, lo, dt, Bn) => {
    Bn.length > 1 ? ko(Et, ht, mn, lo, dt, Bn) : jn(Et, ht, mn, lo, dt, We(Bn[0]));
  }, un = (Et) => {
    Xe(Et, "numlist", "Numbered list", "InsertOrderedList", "OL", ce(Et)), Xe(Et, "bullist", "Bullet list", "InsertUnorderedList", "UL", he(Et));
  };
  var M = () => {
    v.add("advlist", (Et) => {
      Et.hasPlugin("lists") ? (ue(Et), un(Et), N(Et)) : console.error("Please use the Lists plugin together with the Advanced List plugin.");
    });
  };
  M();
})();
(function() {
  var v = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const L = (pe, Me) => {
    pe.focus(), pe.undoManager.transact(() => {
      pe.setContent(Me);
    }), pe.selection.setCursorLocation(), pe.nodeChanged();
  }, N = (pe) => pe.getContent({ source_view: !0 }), W = (pe) => {
    const Me = N(pe);
    pe.windowManager.open({
      title: "Source Code",
      size: "large",
      body: {
        type: "panel",
        items: [{
          type: "textarea",
          name: "code"
        }]
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: { code: Me },
      onSubmit: (Ze) => {
        L(pe, Ze.getData().code), Ze.close();
      }
    });
  }, ue = (pe) => {
    pe.addCommand("mceCodeEditor", () => {
      W(pe);
    });
  }, ce = (pe) => {
    const Me = () => pe.execCommand("mceCodeEditor");
    pe.ui.registry.addButton("code", {
      icon: "sourcecode",
      tooltip: "Source code",
      onAction: Me
    }), pe.ui.registry.addMenuItem("code", {
      icon: "sourcecode",
      text: "Source code",
      onAction: Me
    });
  };
  var he = () => {
    v.add("code", (pe) => (ue(pe), ce(pe), {}));
  };
  he();
})();
(function() {
  var v = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const L = (kt) => (It) => kt === It, N = L(null), W = L(void 0), ue = (kt) => kt == null, ce = (kt) => !ue(kt), he = () => {
  }, Me = ((kt) => () => kt)(!1);
  class Ze {
    constructor(It, ct) {
      this.tag = It, this.value = ct;
    }
    static some(It) {
      return new Ze(!0, It);
    }
    static none() {
      return Ze.singletonNone;
    }
    fold(It, ct) {
      return this.tag ? ct(this.value) : It();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(It) {
      return this.tag ? Ze.some(It(this.value)) : Ze.none();
    }
    bind(It) {
      return this.tag ? It(this.value) : Ze.none();
    }
    exists(It) {
      return this.tag && It(this.value);
    }
    forall(It) {
      return !this.tag || It(this.value);
    }
    filter(It) {
      return !this.tag || It(this.value) ? this : Ze.none();
    }
    getOr(It) {
      return this.tag ? this.value : It;
    }
    or(It) {
      return this.tag ? this : It;
    }
    getOrThunk(It) {
      return this.tag ? this.value : It();
    }
    orThunk(It) {
      return this.tag ? this : It();
    }
    getOrDie(It) {
      if (this.tag)
        return this.value;
      throw new Error(It ?? "Called getOrDie on None");
    }
    static from(It) {
      return ce(It) ? Ze.some(It) : Ze.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(It) {
      this.tag && It(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Ze.singletonNone = new Ze(!1);
  const Ye = (kt, It) => {
    for (let ct = 0, xn = kt.length; ct < xn; ct++) {
      const co = kt[ct];
      if (It(co, ct))
        return !0;
    }
    return !1;
  }, yt = (kt, It) => {
    const ct = kt.length, xn = new Array(ct);
    for (let co = 0; co < ct; co++) {
      const Ko = kt[co];
      xn[co] = It(Ko, co);
    }
    return xn;
  }, jt = (kt, It) => {
    for (let ct = 0, xn = kt.length; ct < xn; ct++) {
      const co = kt[ct];
      It(co, ct);
    }
  }, it = (kt) => {
    let It = kt;
    return {
      get: () => It,
      set: (co) => {
        It = co;
      }
    };
  }, Rt = (kt, It) => {
    let ct = null;
    const xn = () => {
      N(ct) || (clearTimeout(ct), ct = null);
    };
    return {
      cancel: xn,
      throttle: (...Ko) => {
        xn(), ct = setTimeout(() => {
          ct = null, kt.apply(null, Ko);
        }, It);
      }
    };
  }, en = (kt, It) => {
    kt.insertContent(It);
  }, Gt = Object.keys, gt = Object.hasOwnProperty, an = (kt, It) => {
    const ct = Gt(kt);
    for (let xn = 0, co = ct.length; xn < co; xn++) {
      const Ko = ct[xn], po = kt[Ko];
      It(po, Ko);
    }
  }, Ot = (kt, It) => Ee(kt, (ct, xn) => ({
    k: xn,
    v: It(ct, xn)
  })), Ee = (kt, It) => {
    const ct = {};
    return an(kt, (xn, co) => {
      const Ko = It(xn, co);
      ct[Ko.k] = Ko.v;
    }), ct;
  }, wt = (kt, It) => gt.call(kt, It), Cn = ((kt) => (...It) => {
    if (It.length === 0)
      throw new Error("Can't merge zero objects");
    const ct = {};
    for (let xn = 0; xn < It.length; xn++) {
      const co = It[xn];
      for (const Ko in co)
        wt(co, Ko) && (ct[Ko] = kt(ct[Ko], co[Ko]));
    }
    return ct;
  })((kt, It) => It), ko = (kt) => {
    const It = it(Ze.none()), ct = () => It.get().each(kt);
    return {
      clear: () => {
        ct(), It.set(Ze.none());
      },
      isSet: () => It.get().isSome(),
      get: () => It.get(),
      set: (Ra) => {
        ct(), It.set(Ze.some(Ra));
      }
    };
  }, jn = () => {
    const kt = ko(he);
    return {
      ...kt,
      on: (ct) => kt.get().each(ct)
    };
  }, Xe = (kt, It, ct) => It === "" || kt.length >= It.length && kt.substr(ct, ct + It.length) === It, un = (kt, It, ct = 0, xn) => {
    const co = kt.indexOf(It, ct);
    return co !== -1 ? W(xn) ? !0 : co + It.length <= xn : !1;
  }, M = (kt, It) => Xe(kt, It, 0);
  var Et = tinymce.util.Tools.resolve("tinymce.Resource");
  const ht = "tinymce.plugins.emoticons", mn = (kt) => (It) => It.options.get(kt), lo = (kt, It) => {
    const ct = kt.options.register;
    ct("emoticons_database", {
      processor: "string",
      default: "emojis"
    }), ct("emoticons_database_url", {
      processor: "string",
      default: `${It}/js/${dt(kt)}${kt.suffix}.js`
    }), ct("emoticons_database_id", {
      processor: "string",
      default: ht
    }), ct("emoticons_append", {
      processor: "object",
      default: {}
    }), ct("emoticons_images_url", {
      processor: "string",
      default: "https://twemoji.maxcdn.com/v/13.0.1/72x72/"
    });
  }, dt = mn("emoticons_database"), Bn = mn("emoticons_database_url"), jr = mn("emoticons_database_id"), Tt = mn("emoticons_append"), yo = mn("emoticons_images_url"), Ct = "All", tn = {
    symbols: "Symbols",
    people: "People",
    animals_and_nature: "Animals and Nature",
    food_and_drink: "Food and Drink",
    activity: "Activity",
    travel_and_places: "Travel and Places",
    objects: "Objects",
    flags: "Flags",
    user: "User Defined"
  }, oa = (kt, It) => wt(kt, It) ? kt[It] : It, Pn = (kt) => {
    const It = Tt(kt);
    return Ot(It, (ct) => ({
      keywords: [],
      category: "user",
      ...ct
    }));
  }, Mo = (kt, It, ct) => {
    const xn = jn(), co = jn(), Ko = yo(kt), po = ($r) => M($r.char, "<img") ? $r.char.replace(/src="([^"]+)"/, (Po, ha) => `src="${Ko}${ha}"`) : $r.char, Ra = ($r) => {
      const Po = {}, ha = [];
      an($r, (ro, cn) => {
        const _n = {
          title: cn,
          keywords: ro.keywords,
          char: po(ro),
          category: oa(tn, ro.category)
        }, Ys = Po[_n.category] !== void 0 ? Po[_n.category] : [];
        Po[_n.category] = Ys.concat([_n]), ha.push(_n);
      }), xn.set(Po), co.set(ha);
    };
    kt.on("init", () => {
      Et.load(ct, It).then(($r) => {
        const Po = Pn(kt);
        Ra(Cn($r, Po));
      }, ($r) => {
        console.log(`Failed to load emojis: ${$r}`), xn.set({}), co.set([]);
      });
    });
    const Mr = ($r) => $r === Ct ? ho() : xn.get().bind((Po) => Ze.from(Po[$r])).getOr([]), ho = () => co.get().getOr([]), Ns = () => [Ct].concat(Gt(xn.get().getOr({}))), Ca = () => Zr() ? Promise.resolve(!0) : new Promise(($r, Po) => {
      let ha = 15;
      const ro = setInterval(() => {
        Zr() ? (clearInterval(ro), $r(!0)) : (ha--, ha < 0 && (console.log("Could not load emojis from url: " + It), clearInterval(ro), Po(!1)));
      }, 100);
    }), Zr = () => xn.isSet() && co.isSet();
    return {
      listCategories: Ns,
      hasLoaded: Zr,
      waitForLoad: Ca,
      listAll: ho,
      listCategory: Mr
    };
  }, K = (kt, It) => un(kt.title.toLowerCase(), It) || Ye(kt.keywords, (ct) => un(ct.toLowerCase(), It)), Go = (kt, It, ct) => {
    const xn = [], co = It.toLowerCase(), Ko = ct.fold(() => Me, (po) => (Ra) => Ra >= po);
    for (let po = 0; po < kt.length && !((It.length === 0 || K(kt[po], co)) && (xn.push({
      value: kt[po].char,
      text: kt[po].title,
      icon: kt[po].char
    }), Ko(xn.length))); po++)
      ;
    return xn;
  }, Zi = "pattern", er = (kt, It) => {
    const ct = {
      pattern: "",
      results: Go(It.listAll(), "", Ze.some(300))
    }, xn = it(Ct), co = (Ns) => {
      const Ca = Ns.getData(), Zr = xn.get(), $r = It.listCategory(Zr), Po = Go($r, Ca[Zi], Zr === Ct ? Ze.some(300) : Ze.none());
      Ns.setData({ results: Po });
    }, Ko = Rt((Ns) => {
      co(Ns);
    }, 200), po = {
      label: "Search",
      type: "input",
      name: Zi
    }, Ra = {
      type: "collection",
      name: "results"
    }, Mr = () => ({
      title: "Emojis",
      size: "normal",
      body: {
        type: "tabpanel",
        tabs: yt(It.listCategories(), (Ca) => ({
          title: Ca,
          name: Ca,
          items: [
            po,
            Ra
          ]
        }))
      },
      initialData: ct,
      onTabChange: (Ca, Zr) => {
        xn.set(Zr.newTabName), Ko.throttle(Ca);
      },
      onChange: Ko.throttle,
      onAction: (Ca, Zr) => {
        Zr.name === "results" && (en(kt, Zr.value), Ca.close());
      },
      buttons: [{
        type: "cancel",
        text: "Close",
        primary: !0
      }]
    }), ho = kt.windowManager.open(Mr());
    ho.focus(Zi), It.hasLoaded() || (ho.block("Loading emojis..."), It.waitForLoad().then(() => {
      ho.redial(Mr()), Ko.throttle(ho), ho.focus(Zi), ho.unblock();
    }).catch((Ns) => {
      ho.redial({
        title: "Emojis",
        body: {
          type: "panel",
          items: [{
            type: "alertbanner",
            level: "error",
            icon: "warning",
            text: "Could not load emojis"
          }]
        },
        buttons: [{
          type: "cancel",
          text: "Close",
          primary: !0
        }],
        initialData: {
          pattern: "",
          results: []
        }
      }), ho.focus(Zi), ho.unblock();
    }));
  }, Qr = (kt, It) => {
    kt.addCommand("mceEmoticons", () => er(kt, It));
  }, nc = (kt) => {
    kt.on("PreInit", () => {
      kt.parser.addAttributeFilter("data-emoticon", (It) => {
        jt(It, (ct) => {
          ct.attr("data-mce-resize", "false"), ct.attr("data-mce-placeholder", "1");
        });
      });
    });
  }, So = (kt, It) => {
    kt.ui.registry.addAutocompleter("emoticons", {
      trigger: ":",
      columns: "auto",
      minChars: 2,
      fetch: (ct, xn) => It.waitForLoad().then(() => {
        const co = It.listAll();
        return Go(co, ct, Ze.some(xn));
      }),
      onAction: (ct, xn, co) => {
        kt.selection.setRng(xn), kt.insertContent(co), ct.hide();
      }
    });
  }, cr = (kt) => (It) => {
    const ct = () => {
      It.setEnabled(kt.selection.isEditable());
    };
    return kt.on("NodeChange", ct), ct(), () => {
      kt.off("NodeChange", ct);
    };
  }, oo = (kt) => {
    const It = () => kt.execCommand("mceEmoticons");
    kt.ui.registry.addButton("emoticons", {
      tooltip: "Emojis",
      icon: "emoji",
      onAction: It,
      onSetup: cr(kt)
    }), kt.ui.registry.addMenuItem("emoticons", {
      text: "Emojis...",
      icon: "emoji",
      onAction: It,
      onSetup: cr(kt)
    });
  };
  var ut = () => {
    v.add("emoticons", (kt, It) => {
      lo(kt, It);
      const ct = Bn(kt), xn = jr(kt), co = Mo(kt, ct, xn);
      Qr(kt, co), oo(kt), So(kt, co), nc(kt);
    });
  };
  ut();
})();
window.tinymce.Resource.add("tinymce.plugins.emoticons", { grinning: { keywords: ["face", "smile", "happy", "joy", ":D", "grin"], char: "😀", fitzpatrick_scale: !1, category: "people" }, grimacing: { keywords: ["face", "grimace", "teeth"], char: "😬", fitzpatrick_scale: !1, category: "people" }, grin: { keywords: ["face", "happy", "smile", "joy", "kawaii"], char: "😁", fitzpatrick_scale: !1, category: "people" }, joy: { keywords: ["face", "cry", "tears", "weep", "happy", "happytears", "haha"], char: "😂", fitzpatrick_scale: !1, category: "people" }, rofl: { keywords: ["face", "rolling", "floor", "laughing", "lol", "haha"], char: "🤣", fitzpatrick_scale: !1, category: "people" }, partying: { keywords: ["face", "celebration", "woohoo"], char: "🥳", fitzpatrick_scale: !1, category: "people" }, smiley: { keywords: ["face", "happy", "joy", "haha", ":D", ":)", "smile", "funny"], char: "😃", fitzpatrick_scale: !1, category: "people" }, smile: { keywords: ["face", "happy", "joy", "funny", "haha", "laugh", "like", ":D", ":)"], char: "😄", fitzpatrick_scale: !1, category: "people" }, sweat_smile: { keywords: ["face", "hot", "happy", "laugh", "sweat", "smile", "relief"], char: "😅", fitzpatrick_scale: !1, category: "people" }, laughing: { keywords: ["happy", "joy", "lol", "satisfied", "haha", "face", "glad", "XD", "laugh"], char: "😆", fitzpatrick_scale: !1, category: "people" }, innocent: { keywords: ["face", "angel", "heaven", "halo"], char: "😇", fitzpatrick_scale: !1, category: "people" }, wink: { keywords: ["face", "happy", "mischievous", "secret", ";)", "smile", "eye"], char: "😉", fitzpatrick_scale: !1, category: "people" }, blush: { keywords: ["face", "smile", "happy", "flushed", "crush", "embarrassed", "shy", "joy"], char: "😊", fitzpatrick_scale: !1, category: "people" }, slightly_smiling_face: { keywords: ["face", "smile"], char: "🙂", fitzpatrick_scale: !1, category: "people" }, upside_down_face: { keywords: ["face", "flipped", "silly", "smile"], char: "🙃", fitzpatrick_scale: !1, category: "people" }, relaxed: { keywords: ["face", "blush", "massage", "happiness"], char: "☺️", fitzpatrick_scale: !1, category: "people" }, yum: { keywords: ["happy", "joy", "tongue", "smile", "face", "silly", "yummy", "nom", "delicious", "savouring"], char: "😋", fitzpatrick_scale: !1, category: "people" }, relieved: { keywords: ["face", "relaxed", "phew", "massage", "happiness"], char: "😌", fitzpatrick_scale: !1, category: "people" }, heart_eyes: { keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "crush", "heart"], char: "😍", fitzpatrick_scale: !1, category: "people" }, smiling_face_with_three_hearts: { keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "crush", "hearts", "adore"], char: "🥰", fitzpatrick_scale: !1, category: "people" }, kissing_heart: { keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "kiss"], char: "😘", fitzpatrick_scale: !1, category: "people" }, kissing: { keywords: ["love", "like", "face", "3", "valentines", "infatuation", "kiss"], char: "😗", fitzpatrick_scale: !1, category: "people" }, kissing_smiling_eyes: { keywords: ["face", "affection", "valentines", "infatuation", "kiss"], char: "😙", fitzpatrick_scale: !1, category: "people" }, kissing_closed_eyes: { keywords: ["face", "love", "like", "affection", "valentines", "infatuation", "kiss"], char: "😚", fitzpatrick_scale: !1, category: "people" }, stuck_out_tongue_winking_eye: { keywords: ["face", "prank", "childish", "playful", "mischievous", "smile", "wink", "tongue"], char: "😜", fitzpatrick_scale: !1, category: "people" }, zany: { keywords: ["face", "goofy", "crazy"], char: "🤪", fitzpatrick_scale: !1, category: "people" }, raised_eyebrow: { keywords: ["face", "distrust", "scepticism", "disapproval", "disbelief", "surprise"], char: "🤨", fitzpatrick_scale: !1, category: "people" }, monocle: { keywords: ["face", "stuffy", "wealthy"], char: "🧐", fitzpatrick_scale: !1, category: "people" }, stuck_out_tongue_closed_eyes: { keywords: ["face", "prank", "playful", "mischievous", "smile", "tongue"], char: "😝", fitzpatrick_scale: !1, category: "people" }, stuck_out_tongue: { keywords: ["face", "prank", "childish", "playful", "mischievous", "smile", "tongue"], char: "😛", fitzpatrick_scale: !1, category: "people" }, money_mouth_face: { keywords: ["face", "rich", "dollar", "money"], char: "🤑", fitzpatrick_scale: !1, category: "people" }, nerd_face: { keywords: ["face", "nerdy", "geek", "dork"], char: "🤓", fitzpatrick_scale: !1, category: "people" }, sunglasses: { keywords: ["face", "cool", "smile", "summer", "beach", "sunglass"], char: "😎", fitzpatrick_scale: !1, category: "people" }, star_struck: { keywords: ["face", "smile", "starry", "eyes", "grinning"], char: "🤩", fitzpatrick_scale: !1, category: "people" }, clown_face: { keywords: ["face"], char: "🤡", fitzpatrick_scale: !1, category: "people" }, cowboy_hat_face: { keywords: ["face", "cowgirl", "hat"], char: "🤠", fitzpatrick_scale: !1, category: "people" }, hugs: { keywords: ["face", "smile", "hug"], char: "🤗", fitzpatrick_scale: !1, category: "people" }, smirk: { keywords: ["face", "smile", "mean", "prank", "smug", "sarcasm"], char: "😏", fitzpatrick_scale: !1, category: "people" }, no_mouth: { keywords: ["face", "hellokitty"], char: "😶", fitzpatrick_scale: !1, category: "people" }, neutral_face: { keywords: ["indifference", "meh", ":|", "neutral"], char: "😐", fitzpatrick_scale: !1, category: "people" }, expressionless: { keywords: ["face", "indifferent", "-_-", "meh", "deadpan"], char: "😑", fitzpatrick_scale: !1, category: "people" }, unamused: { keywords: ["indifference", "bored", "straight face", "serious", "sarcasm", "unimpressed", "skeptical", "dubious", "side_eye"], char: "😒", fitzpatrick_scale: !1, category: "people" }, roll_eyes: { keywords: ["face", "eyeroll", "frustrated"], char: "🙄", fitzpatrick_scale: !1, category: "people" }, thinking: { keywords: ["face", "hmmm", "think", "consider"], char: "🤔", fitzpatrick_scale: !1, category: "people" }, lying_face: { keywords: ["face", "lie", "pinocchio"], char: "🤥", fitzpatrick_scale: !1, category: "people" }, hand_over_mouth: { keywords: ["face", "whoops", "shock", "surprise"], char: "🤭", fitzpatrick_scale: !1, category: "people" }, shushing: { keywords: ["face", "quiet", "shhh"], char: "🤫", fitzpatrick_scale: !1, category: "people" }, symbols_over_mouth: { keywords: ["face", "swearing", "cursing", "cussing", "profanity", "expletive"], char: "🤬", fitzpatrick_scale: !1, category: "people" }, exploding_head: { keywords: ["face", "shocked", "mind", "blown"], char: "🤯", fitzpatrick_scale: !1, category: "people" }, flushed: { keywords: ["face", "blush", "shy", "flattered"], char: "😳", fitzpatrick_scale: !1, category: "people" }, disappointed: { keywords: ["face", "sad", "upset", "depressed", ":("], char: "😞", fitzpatrick_scale: !1, category: "people" }, worried: { keywords: ["face", "concern", "nervous", ":("], char: "😟", fitzpatrick_scale: !1, category: "people" }, angry: { keywords: ["mad", "face", "annoyed", "frustrated"], char: "😠", fitzpatrick_scale: !1, category: "people" }, rage: { keywords: ["angry", "mad", "hate", "despise"], char: "😡", fitzpatrick_scale: !1, category: "people" }, pensive: { keywords: ["face", "sad", "depressed", "upset"], char: "😔", fitzpatrick_scale: !1, category: "people" }, confused: { keywords: ["face", "indifference", "huh", "weird", "hmmm", ":/"], char: "😕", fitzpatrick_scale: !1, category: "people" }, slightly_frowning_face: { keywords: ["face", "frowning", "disappointed", "sad", "upset"], char: "🙁", fitzpatrick_scale: !1, category: "people" }, frowning_face: { keywords: ["face", "sad", "upset", "frown"], char: "☹", fitzpatrick_scale: !1, category: "people" }, persevere: { keywords: ["face", "sick", "no", "upset", "oops"], char: "😣", fitzpatrick_scale: !1, category: "people" }, confounded: { keywords: ["face", "confused", "sick", "unwell", "oops", ":S"], char: "😖", fitzpatrick_scale: !1, category: "people" }, tired_face: { keywords: ["sick", "whine", "upset", "frustrated"], char: "😫", fitzpatrick_scale: !1, category: "people" }, weary: { keywords: ["face", "tired", "sleepy", "sad", "frustrated", "upset"], char: "😩", fitzpatrick_scale: !1, category: "people" }, pleading: { keywords: ["face", "begging", "mercy"], char: "🥺", fitzpatrick_scale: !1, category: "people" }, triumph: { keywords: ["face", "gas", "phew", "proud", "pride"], char: "😤", fitzpatrick_scale: !1, category: "people" }, open_mouth: { keywords: ["face", "surprise", "impressed", "wow", "whoa", ":O"], char: "😮", fitzpatrick_scale: !1, category: "people" }, scream: { keywords: ["face", "munch", "scared", "omg"], char: "😱", fitzpatrick_scale: !1, category: "people" }, fearful: { keywords: ["face", "scared", "terrified", "nervous", "oops", "huh"], char: "😨", fitzpatrick_scale: !1, category: "people" }, cold_sweat: { keywords: ["face", "nervous", "sweat"], char: "😰", fitzpatrick_scale: !1, category: "people" }, hushed: { keywords: ["face", "woo", "shh"], char: "😯", fitzpatrick_scale: !1, category: "people" }, frowning: { keywords: ["face", "aw", "what"], char: "😦", fitzpatrick_scale: !1, category: "people" }, anguished: { keywords: ["face", "stunned", "nervous"], char: "😧", fitzpatrick_scale: !1, category: "people" }, cry: { keywords: ["face", "tears", "sad", "depressed", "upset", ":'("], char: "😢", fitzpatrick_scale: !1, category: "people" }, disappointed_relieved: { keywords: ["face", "phew", "sweat", "nervous"], char: "😥", fitzpatrick_scale: !1, category: "people" }, drooling_face: { keywords: ["face"], char: "🤤", fitzpatrick_scale: !1, category: "people" }, sleepy: { keywords: ["face", "tired", "rest", "nap"], char: "😪", fitzpatrick_scale: !1, category: "people" }, sweat: { keywords: ["face", "hot", "sad", "tired", "exercise"], char: "😓", fitzpatrick_scale: !1, category: "people" }, hot: { keywords: ["face", "feverish", "heat", "red", "sweating"], char: "🥵", fitzpatrick_scale: !1, category: "people" }, cold: { keywords: ["face", "blue", "freezing", "frozen", "frostbite", "icicles"], char: "🥶", fitzpatrick_scale: !1, category: "people" }, sob: { keywords: ["face", "cry", "tears", "sad", "upset", "depressed"], char: "😭", fitzpatrick_scale: !1, category: "people" }, dizzy_face: { keywords: ["spent", "unconscious", "xox", "dizzy"], char: "😵", fitzpatrick_scale: !1, category: "people" }, astonished: { keywords: ["face", "xox", "surprised", "poisoned"], char: "😲", fitzpatrick_scale: !1, category: "people" }, zipper_mouth_face: { keywords: ["face", "sealed", "zipper", "secret"], char: "🤐", fitzpatrick_scale: !1, category: "people" }, nauseated_face: { keywords: ["face", "vomit", "gross", "green", "sick", "throw up", "ill"], char: "🤢", fitzpatrick_scale: !1, category: "people" }, sneezing_face: { keywords: ["face", "gesundheit", "sneeze", "sick", "allergy"], char: "🤧", fitzpatrick_scale: !1, category: "people" }, vomiting: { keywords: ["face", "sick"], char: "🤮", fitzpatrick_scale: !1, category: "people" }, mask: { keywords: ["face", "sick", "ill", "disease"], char: "😷", fitzpatrick_scale: !1, category: "people" }, face_with_thermometer: { keywords: ["sick", "temperature", "thermometer", "cold", "fever"], char: "🤒", fitzpatrick_scale: !1, category: "people" }, face_with_head_bandage: { keywords: ["injured", "clumsy", "bandage", "hurt"], char: "🤕", fitzpatrick_scale: !1, category: "people" }, woozy: { keywords: ["face", "dizzy", "intoxicated", "tipsy", "wavy"], char: "🥴", fitzpatrick_scale: !1, category: "people" }, sleeping: { keywords: ["face", "tired", "sleepy", "night", "zzz"], char: "😴", fitzpatrick_scale: !1, category: "people" }, zzz: { keywords: ["sleepy", "tired", "dream"], char: "💤", fitzpatrick_scale: !1, category: "people" }, poop: { keywords: ["hankey", "shitface", "fail", "turd", "shit"], char: "💩", fitzpatrick_scale: !1, category: "people" }, smiling_imp: { keywords: ["devil", "horns"], char: "😈", fitzpatrick_scale: !1, category: "people" }, imp: { keywords: ["devil", "angry", "horns"], char: "👿", fitzpatrick_scale: !1, category: "people" }, japanese_ogre: { keywords: ["monster", "red", "mask", "halloween", "scary", "creepy", "devil", "demon", "japanese", "ogre"], char: "👹", fitzpatrick_scale: !1, category: "people" }, japanese_goblin: { keywords: ["red", "evil", "mask", "monster", "scary", "creepy", "japanese", "goblin"], char: "👺", fitzpatrick_scale: !1, category: "people" }, skull: { keywords: ["dead", "skeleton", "creepy", "death"], char: "💀", fitzpatrick_scale: !1, category: "people" }, ghost: { keywords: ["halloween", "spooky", "scary"], char: "👻", fitzpatrick_scale: !1, category: "people" }, alien: { keywords: ["UFO", "paul", "weird", "outer_space"], char: "👽", fitzpatrick_scale: !1, category: "people" }, robot: { keywords: ["computer", "machine", "bot"], char: "🤖", fitzpatrick_scale: !1, category: "people" }, smiley_cat: { keywords: ["animal", "cats", "happy", "smile"], char: "😺", fitzpatrick_scale: !1, category: "people" }, smile_cat: { keywords: ["animal", "cats", "smile"], char: "😸", fitzpatrick_scale: !1, category: "people" }, joy_cat: { keywords: ["animal", "cats", "haha", "happy", "tears"], char: "😹", fitzpatrick_scale: !1, category: "people" }, heart_eyes_cat: { keywords: ["animal", "love", "like", "affection", "cats", "valentines", "heart"], char: "😻", fitzpatrick_scale: !1, category: "people" }, smirk_cat: { keywords: ["animal", "cats", "smirk"], char: "😼", fitzpatrick_scale: !1, category: "people" }, kissing_cat: { keywords: ["animal", "cats", "kiss"], char: "😽", fitzpatrick_scale: !1, category: "people" }, scream_cat: { keywords: ["animal", "cats", "munch", "scared", "scream"], char: "🙀", fitzpatrick_scale: !1, category: "people" }, crying_cat_face: { keywords: ["animal", "tears", "weep", "sad", "cats", "upset", "cry"], char: "😿", fitzpatrick_scale: !1, category: "people" }, pouting_cat: { keywords: ["animal", "cats"], char: "😾", fitzpatrick_scale: !1, category: "people" }, palms_up: { keywords: ["hands", "gesture", "cupped", "prayer"], char: "🤲", fitzpatrick_scale: !0, category: "people" }, raised_hands: { keywords: ["gesture", "hooray", "yea", "celebration", "hands"], char: "🙌", fitzpatrick_scale: !0, category: "people" }, clap: { keywords: ["hands", "praise", "applause", "congrats", "yay"], char: "👏", fitzpatrick_scale: !0, category: "people" }, wave: { keywords: ["hands", "gesture", "goodbye", "solong", "farewell", "hello", "hi", "palm"], char: "👋", fitzpatrick_scale: !0, category: "people" }, call_me_hand: { keywords: ["hands", "gesture"], char: "🤙", fitzpatrick_scale: !0, category: "people" }, "+1": { keywords: ["thumbsup", "yes", "awesome", "good", "agree", "accept", "cool", "hand", "like"], char: "👍", fitzpatrick_scale: !0, category: "people" }, "-1": { keywords: ["thumbsdown", "no", "dislike", "hand"], char: "👎", fitzpatrick_scale: !0, category: "people" }, facepunch: { keywords: ["angry", "violence", "fist", "hit", "attack", "hand"], char: "👊", fitzpatrick_scale: !0, category: "people" }, fist: { keywords: ["fingers", "hand", "grasp"], char: "✊", fitzpatrick_scale: !0, category: "people" }, fist_left: { keywords: ["hand", "fistbump"], char: "🤛", fitzpatrick_scale: !0, category: "people" }, fist_right: { keywords: ["hand", "fistbump"], char: "🤜", fitzpatrick_scale: !0, category: "people" }, v: { keywords: ["fingers", "ohyeah", "hand", "peace", "victory", "two"], char: "✌", fitzpatrick_scale: !0, category: "people" }, ok_hand: { keywords: ["fingers", "limbs", "perfect", "ok", "okay"], char: "👌", fitzpatrick_scale: !0, category: "people" }, raised_hand: { keywords: ["fingers", "stop", "highfive", "palm", "ban"], char: "✋", fitzpatrick_scale: !0, category: "people" }, raised_back_of_hand: { keywords: ["fingers", "raised", "backhand"], char: "🤚", fitzpatrick_scale: !0, category: "people" }, open_hands: { keywords: ["fingers", "butterfly", "hands", "open"], char: "👐", fitzpatrick_scale: !0, category: "people" }, muscle: { keywords: ["arm", "flex", "hand", "summer", "strong", "biceps"], char: "💪", fitzpatrick_scale: !0, category: "people" }, pray: { keywords: ["please", "hope", "wish", "namaste", "highfive"], char: "🙏", fitzpatrick_scale: !0, category: "people" }, foot: { keywords: ["kick", "stomp"], char: "🦶", fitzpatrick_scale: !0, category: "people" }, leg: { keywords: ["kick", "limb"], char: "🦵", fitzpatrick_scale: !0, category: "people" }, handshake: { keywords: ["agreement", "shake"], char: "🤝", fitzpatrick_scale: !1, category: "people" }, point_up: { keywords: ["hand", "fingers", "direction", "up"], char: "☝", fitzpatrick_scale: !0, category: "people" }, point_up_2: { keywords: ["fingers", "hand", "direction", "up"], char: "👆", fitzpatrick_scale: !0, category: "people" }, point_down: { keywords: ["fingers", "hand", "direction", "down"], char: "👇", fitzpatrick_scale: !0, category: "people" }, point_left: { keywords: ["direction", "fingers", "hand", "left"], char: "👈", fitzpatrick_scale: !0, category: "people" }, point_right: { keywords: ["fingers", "hand", "direction", "right"], char: "👉", fitzpatrick_scale: !0, category: "people" }, fu: { keywords: ["hand", "fingers", "rude", "middle", "flipping"], char: "🖕", fitzpatrick_scale: !0, category: "people" }, raised_hand_with_fingers_splayed: { keywords: ["hand", "fingers", "palm"], char: "🖐", fitzpatrick_scale: !0, category: "people" }, love_you: { keywords: ["hand", "fingers", "gesture"], char: "🤟", fitzpatrick_scale: !0, category: "people" }, metal: { keywords: ["hand", "fingers", "evil_eye", "sign_of_horns", "rock_on"], char: "🤘", fitzpatrick_scale: !0, category: "people" }, crossed_fingers: { keywords: ["good", "lucky"], char: "🤞", fitzpatrick_scale: !0, category: "people" }, vulcan_salute: { keywords: ["hand", "fingers", "spock", "star trek"], char: "🖖", fitzpatrick_scale: !0, category: "people" }, writing_hand: { keywords: ["lower_left_ballpoint_pen", "stationery", "write", "compose"], char: "✍", fitzpatrick_scale: !0, category: "people" }, selfie: { keywords: ["camera", "phone"], char: "🤳", fitzpatrick_scale: !0, category: "people" }, nail_care: { keywords: ["beauty", "manicure", "finger", "fashion", "nail"], char: "💅", fitzpatrick_scale: !0, category: "people" }, lips: { keywords: ["mouth", "kiss"], char: "👄", fitzpatrick_scale: !1, category: "people" }, tooth: { keywords: ["teeth", "dentist"], char: "🦷", fitzpatrick_scale: !1, category: "people" }, tongue: { keywords: ["mouth", "playful"], char: "👅", fitzpatrick_scale: !1, category: "people" }, ear: { keywords: ["face", "hear", "sound", "listen"], char: "👂", fitzpatrick_scale: !0, category: "people" }, nose: { keywords: ["smell", "sniff"], char: "👃", fitzpatrick_scale: !0, category: "people" }, eye: { keywords: ["face", "look", "see", "watch", "stare"], char: "👁", fitzpatrick_scale: !1, category: "people" }, eyes: { keywords: ["look", "watch", "stalk", "peek", "see"], char: "👀", fitzpatrick_scale: !1, category: "people" }, brain: { keywords: ["smart", "intelligent"], char: "🧠", fitzpatrick_scale: !1, category: "people" }, bust_in_silhouette: { keywords: ["user", "person", "human"], char: "👤", fitzpatrick_scale: !1, category: "people" }, busts_in_silhouette: { keywords: ["user", "person", "human", "group", "team"], char: "👥", fitzpatrick_scale: !1, category: "people" }, speaking_head: { keywords: ["user", "person", "human", "sing", "say", "talk"], char: "🗣", fitzpatrick_scale: !1, category: "people" }, baby: { keywords: ["child", "boy", "girl", "toddler"], char: "👶", fitzpatrick_scale: !0, category: "people" }, child: { keywords: ["gender-neutral", "young"], char: "🧒", fitzpatrick_scale: !0, category: "people" }, boy: { keywords: ["man", "male", "guy", "teenager"], char: "👦", fitzpatrick_scale: !0, category: "people" }, girl: { keywords: ["female", "woman", "teenager"], char: "👧", fitzpatrick_scale: !0, category: "people" }, adult: { keywords: ["gender-neutral", "person"], char: "🧑", fitzpatrick_scale: !0, category: "people" }, man: { keywords: ["mustache", "father", "dad", "guy", "classy", "sir", "moustache"], char: "👨", fitzpatrick_scale: !0, category: "people" }, woman: { keywords: ["female", "girls", "lady"], char: "👩", fitzpatrick_scale: !0, category: "people" }, blonde_woman: { keywords: ["woman", "female", "girl", "blonde", "person"], char: "👱‍♀️", fitzpatrick_scale: !0, category: "people" }, blonde_man: { keywords: ["man", "male", "boy", "blonde", "guy", "person"], char: "👱", fitzpatrick_scale: !0, category: "people" }, bearded_person: { keywords: ["person", "bewhiskered"], char: "🧔", fitzpatrick_scale: !0, category: "people" }, older_adult: { keywords: ["human", "elder", "senior", "gender-neutral"], char: "🧓", fitzpatrick_scale: !0, category: "people" }, older_man: { keywords: ["human", "male", "men", "old", "elder", "senior"], char: "👴", fitzpatrick_scale: !0, category: "people" }, older_woman: { keywords: ["human", "female", "women", "lady", "old", "elder", "senior"], char: "👵", fitzpatrick_scale: !0, category: "people" }, man_with_gua_pi_mao: { keywords: ["male", "boy", "chinese"], char: "👲", fitzpatrick_scale: !0, category: "people" }, woman_with_headscarf: { keywords: ["female", "hijab", "mantilla", "tichel"], char: "🧕", fitzpatrick_scale: !0, category: "people" }, woman_with_turban: { keywords: ["female", "indian", "hinduism", "arabs", "woman"], char: "👳‍♀️", fitzpatrick_scale: !0, category: "people" }, man_with_turban: { keywords: ["male", "indian", "hinduism", "arabs"], char: "👳", fitzpatrick_scale: !0, category: "people" }, policewoman: { keywords: ["woman", "police", "law", "legal", "enforcement", "arrest", "911", "female"], char: "👮‍♀️", fitzpatrick_scale: !0, category: "people" }, policeman: { keywords: ["man", "police", "law", "legal", "enforcement", "arrest", "911"], char: "👮", fitzpatrick_scale: !0, category: "people" }, construction_worker_woman: { keywords: ["female", "human", "wip", "build", "construction", "worker", "labor", "woman"], char: "👷‍♀️", fitzpatrick_scale: !0, category: "people" }, construction_worker_man: { keywords: ["male", "human", "wip", "guy", "build", "construction", "worker", "labor"], char: "👷", fitzpatrick_scale: !0, category: "people" }, guardswoman: { keywords: ["uk", "gb", "british", "female", "royal", "woman"], char: "💂‍♀️", fitzpatrick_scale: !0, category: "people" }, guardsman: { keywords: ["uk", "gb", "british", "male", "guy", "royal"], char: "💂", fitzpatrick_scale: !0, category: "people" }, female_detective: { keywords: ["human", "spy", "detective", "female", "woman"], char: "🕵️‍♀️", fitzpatrick_scale: !0, category: "people" }, male_detective: { keywords: ["human", "spy", "detective"], char: "🕵", fitzpatrick_scale: !0, category: "people" }, woman_health_worker: { keywords: ["doctor", "nurse", "therapist", "healthcare", "woman", "human"], char: "👩‍⚕️", fitzpatrick_scale: !0, category: "people" }, man_health_worker: { keywords: ["doctor", "nurse", "therapist", "healthcare", "man", "human"], char: "👨‍⚕️", fitzpatrick_scale: !0, category: "people" }, woman_farmer: { keywords: ["rancher", "gardener", "woman", "human"], char: "👩‍🌾", fitzpatrick_scale: !0, category: "people" }, man_farmer: { keywords: ["rancher", "gardener", "man", "human"], char: "👨‍🌾", fitzpatrick_scale: !0, category: "people" }, woman_cook: { keywords: ["chef", "woman", "human"], char: "👩‍🍳", fitzpatrick_scale: !0, category: "people" }, man_cook: { keywords: ["chef", "man", "human"], char: "👨‍🍳", fitzpatrick_scale: !0, category: "people" }, woman_student: { keywords: ["graduate", "woman", "human"], char: "👩‍🎓", fitzpatrick_scale: !0, category: "people" }, man_student: { keywords: ["graduate", "man", "human"], char: "👨‍🎓", fitzpatrick_scale: !0, category: "people" }, woman_singer: { keywords: ["rockstar", "entertainer", "woman", "human"], char: "👩‍🎤", fitzpatrick_scale: !0, category: "people" }, man_singer: { keywords: ["rockstar", "entertainer", "man", "human"], char: "👨‍🎤", fitzpatrick_scale: !0, category: "people" }, woman_teacher: { keywords: ["instructor", "professor", "woman", "human"], char: "👩‍🏫", fitzpatrick_scale: !0, category: "people" }, man_teacher: { keywords: ["instructor", "professor", "man", "human"], char: "👨‍🏫", fitzpatrick_scale: !0, category: "people" }, woman_factory_worker: { keywords: ["assembly", "industrial", "woman", "human"], char: "👩‍🏭", fitzpatrick_scale: !0, category: "people" }, man_factory_worker: { keywords: ["assembly", "industrial", "man", "human"], char: "👨‍🏭", fitzpatrick_scale: !0, category: "people" }, woman_technologist: { keywords: ["coder", "developer", "engineer", "programmer", "software", "woman", "human", "laptop", "computer"], char: "👩‍💻", fitzpatrick_scale: !0, category: "people" }, man_technologist: { keywords: ["coder", "developer", "engineer", "programmer", "software", "man", "human", "laptop", "computer"], char: "👨‍💻", fitzpatrick_scale: !0, category: "people" }, woman_office_worker: { keywords: ["business", "manager", "woman", "human"], char: "👩‍💼", fitzpatrick_scale: !0, category: "people" }, man_office_worker: { keywords: ["business", "manager", "man", "human"], char: "👨‍💼", fitzpatrick_scale: !0, category: "people" }, woman_mechanic: { keywords: ["plumber", "woman", "human", "wrench"], char: "👩‍🔧", fitzpatrick_scale: !0, category: "people" }, man_mechanic: { keywords: ["plumber", "man", "human", "wrench"], char: "👨‍🔧", fitzpatrick_scale: !0, category: "people" }, woman_scientist: { keywords: ["biologist", "chemist", "engineer", "physicist", "woman", "human"], char: "👩‍🔬", fitzpatrick_scale: !0, category: "people" }, man_scientist: { keywords: ["biologist", "chemist", "engineer", "physicist", "man", "human"], char: "👨‍🔬", fitzpatrick_scale: !0, category: "people" }, woman_artist: { keywords: ["painter", "woman", "human"], char: "👩‍🎨", fitzpatrick_scale: !0, category: "people" }, man_artist: { keywords: ["painter", "man", "human"], char: "👨‍🎨", fitzpatrick_scale: !0, category: "people" }, woman_firefighter: { keywords: ["fireman", "woman", "human"], char: "👩‍🚒", fitzpatrick_scale: !0, category: "people" }, man_firefighter: { keywords: ["fireman", "man", "human"], char: "👨‍🚒", fitzpatrick_scale: !0, category: "people" }, woman_pilot: { keywords: ["aviator", "plane", "woman", "human"], char: "👩‍✈️", fitzpatrick_scale: !0, category: "people" }, man_pilot: { keywords: ["aviator", "plane", "man", "human"], char: "👨‍✈️", fitzpatrick_scale: !0, category: "people" }, woman_astronaut: { keywords: ["space", "rocket", "woman", "human"], char: "👩‍🚀", fitzpatrick_scale: !0, category: "people" }, man_astronaut: { keywords: ["space", "rocket", "man", "human"], char: "👨‍🚀", fitzpatrick_scale: !0, category: "people" }, woman_judge: { keywords: ["justice", "court", "woman", "human"], char: "👩‍⚖️", fitzpatrick_scale: !0, category: "people" }, man_judge: { keywords: ["justice", "court", "man", "human"], char: "👨‍⚖️", fitzpatrick_scale: !0, category: "people" }, woman_superhero: { keywords: ["woman", "female", "good", "heroine", "superpowers"], char: "🦸‍♀️", fitzpatrick_scale: !0, category: "people" }, man_superhero: { keywords: ["man", "male", "good", "hero", "superpowers"], char: "🦸‍♂️", fitzpatrick_scale: !0, category: "people" }, woman_supervillain: { keywords: ["woman", "female", "evil", "bad", "criminal", "heroine", "superpowers"], char: "🦹‍♀️", fitzpatrick_scale: !0, category: "people" }, man_supervillain: { keywords: ["man", "male", "evil", "bad", "criminal", "hero", "superpowers"], char: "🦹‍♂️", fitzpatrick_scale: !0, category: "people" }, mrs_claus: { keywords: ["woman", "female", "xmas", "mother christmas"], char: "🤶", fitzpatrick_scale: !0, category: "people" }, santa: { keywords: ["festival", "man", "male", "xmas", "father christmas"], char: "🎅", fitzpatrick_scale: !0, category: "people" }, sorceress: { keywords: ["woman", "female", "mage", "witch"], char: "🧙‍♀️", fitzpatrick_scale: !0, category: "people" }, wizard: { keywords: ["man", "male", "mage", "sorcerer"], char: "🧙‍♂️", fitzpatrick_scale: !0, category: "people" }, woman_elf: { keywords: ["woman", "female"], char: "🧝‍♀️", fitzpatrick_scale: !0, category: "people" }, man_elf: { keywords: ["man", "male"], char: "🧝‍♂️", fitzpatrick_scale: !0, category: "people" }, woman_vampire: { keywords: ["woman", "female"], char: "🧛‍♀️", fitzpatrick_scale: !0, category: "people" }, man_vampire: { keywords: ["man", "male", "dracula"], char: "🧛‍♂️", fitzpatrick_scale: !0, category: "people" }, woman_zombie: { keywords: ["woman", "female", "undead", "walking dead"], char: "🧟‍♀️", fitzpatrick_scale: !1, category: "people" }, man_zombie: { keywords: ["man", "male", "dracula", "undead", "walking dead"], char: "🧟‍♂️", fitzpatrick_scale: !1, category: "people" }, woman_genie: { keywords: ["woman", "female"], char: "🧞‍♀️", fitzpatrick_scale: !1, category: "people" }, man_genie: { keywords: ["man", "male"], char: "🧞‍♂️", fitzpatrick_scale: !1, category: "people" }, mermaid: { keywords: ["woman", "female", "merwoman", "ariel"], char: "🧜‍♀️", fitzpatrick_scale: !0, category: "people" }, merman: { keywords: ["man", "male", "triton"], char: "🧜‍♂️", fitzpatrick_scale: !0, category: "people" }, woman_fairy: { keywords: ["woman", "female"], char: "🧚‍♀️", fitzpatrick_scale: !0, category: "people" }, man_fairy: { keywords: ["man", "male"], char: "🧚‍♂️", fitzpatrick_scale: !0, category: "people" }, angel: { keywords: ["heaven", "wings", "halo"], char: "👼", fitzpatrick_scale: !0, category: "people" }, pregnant_woman: { keywords: ["baby"], char: "🤰", fitzpatrick_scale: !0, category: "people" }, breastfeeding: { keywords: ["nursing", "baby"], char: "🤱", fitzpatrick_scale: !0, category: "people" }, princess: { keywords: ["girl", "woman", "female", "blond", "crown", "royal", "queen"], char: "👸", fitzpatrick_scale: !0, category: "people" }, prince: { keywords: ["boy", "man", "male", "crown", "royal", "king"], char: "🤴", fitzpatrick_scale: !0, category: "people" }, bride_with_veil: { keywords: ["couple", "marriage", "wedding", "woman", "bride"], char: "👰", fitzpatrick_scale: !0, category: "people" }, man_in_tuxedo: { keywords: ["couple", "marriage", "wedding", "groom"], char: "🤵", fitzpatrick_scale: !0, category: "people" }, running_woman: { keywords: ["woman", "walking", "exercise", "race", "running", "female"], char: "🏃‍♀️", fitzpatrick_scale: !0, category: "people" }, running_man: { keywords: ["man", "walking", "exercise", "race", "running"], char: "🏃", fitzpatrick_scale: !0, category: "people" }, walking_woman: { keywords: ["human", "feet", "steps", "woman", "female"], char: "🚶‍♀️", fitzpatrick_scale: !0, category: "people" }, walking_man: { keywords: ["human", "feet", "steps"], char: "🚶", fitzpatrick_scale: !0, category: "people" }, dancer: { keywords: ["female", "girl", "woman", "fun"], char: "💃", fitzpatrick_scale: !0, category: "people" }, man_dancing: { keywords: ["male", "boy", "fun", "dancer"], char: "🕺", fitzpatrick_scale: !0, category: "people" }, dancing_women: { keywords: ["female", "bunny", "women", "girls"], char: "👯", fitzpatrick_scale: !1, category: "people" }, dancing_men: { keywords: ["male", "bunny", "men", "boys"], char: "👯‍♂️", fitzpatrick_scale: !1, category: "people" }, couple: { keywords: ["pair", "people", "human", "love", "date", "dating", "like", "affection", "valentines", "marriage"], char: "👫", fitzpatrick_scale: !1, category: "people" }, two_men_holding_hands: { keywords: ["pair", "couple", "love", "like", "bromance", "friendship", "people", "human"], char: "👬", fitzpatrick_scale: !1, category: "people" }, two_women_holding_hands: { keywords: ["pair", "friendship", "couple", "love", "like", "female", "people", "human"], char: "👭", fitzpatrick_scale: !1, category: "people" }, bowing_woman: { keywords: ["woman", "female", "girl"], char: "🙇‍♀️", fitzpatrick_scale: !0, category: "people" }, bowing_man: { keywords: ["man", "male", "boy"], char: "🙇", fitzpatrick_scale: !0, category: "people" }, man_facepalming: { keywords: ["man", "male", "boy", "disbelief"], char: "🤦‍♂️", fitzpatrick_scale: !0, category: "people" }, woman_facepalming: { keywords: ["woman", "female", "girl", "disbelief"], char: "🤦‍♀️", fitzpatrick_scale: !0, category: "people" }, woman_shrugging: { keywords: ["woman", "female", "girl", "confused", "indifferent", "doubt"], char: "🤷", fitzpatrick_scale: !0, category: "people" }, man_shrugging: { keywords: ["man", "male", "boy", "confused", "indifferent", "doubt"], char: "🤷‍♂️", fitzpatrick_scale: !0, category: "people" }, tipping_hand_woman: { keywords: ["female", "girl", "woman", "human", "information"], char: "💁", fitzpatrick_scale: !0, category: "people" }, tipping_hand_man: { keywords: ["male", "boy", "man", "human", "information"], char: "💁‍♂️", fitzpatrick_scale: !0, category: "people" }, no_good_woman: { keywords: ["female", "girl", "woman", "nope"], char: "🙅", fitzpatrick_scale: !0, category: "people" }, no_good_man: { keywords: ["male", "boy", "man", "nope"], char: "🙅‍♂️", fitzpatrick_scale: !0, category: "people" }, ok_woman: { keywords: ["women", "girl", "female", "pink", "human", "woman"], char: "🙆", fitzpatrick_scale: !0, category: "people" }, ok_man: { keywords: ["men", "boy", "male", "blue", "human", "man"], char: "🙆‍♂️", fitzpatrick_scale: !0, category: "people" }, raising_hand_woman: { keywords: ["female", "girl", "woman"], char: "🙋", fitzpatrick_scale: !0, category: "people" }, raising_hand_man: { keywords: ["male", "boy", "man"], char: "🙋‍♂️", fitzpatrick_scale: !0, category: "people" }, pouting_woman: { keywords: ["female", "girl", "woman"], char: "🙎", fitzpatrick_scale: !0, category: "people" }, pouting_man: { keywords: ["male", "boy", "man"], char: "🙎‍♂️", fitzpatrick_scale: !0, category: "people" }, frowning_woman: { keywords: ["female", "girl", "woman", "sad", "depressed", "discouraged", "unhappy"], char: "🙍", fitzpatrick_scale: !0, category: "people" }, frowning_man: { keywords: ["male", "boy", "man", "sad", "depressed", "discouraged", "unhappy"], char: "🙍‍♂️", fitzpatrick_scale: !0, category: "people" }, haircut_woman: { keywords: ["female", "girl", "woman"], char: "💇", fitzpatrick_scale: !0, category: "people" }, haircut_man: { keywords: ["male", "boy", "man"], char: "💇‍♂️", fitzpatrick_scale: !0, category: "people" }, massage_woman: { keywords: ["female", "girl", "woman", "head"], char: "💆", fitzpatrick_scale: !0, category: "people" }, massage_man: { keywords: ["male", "boy", "man", "head"], char: "💆‍♂️", fitzpatrick_scale: !0, category: "people" }, woman_in_steamy_room: { keywords: ["female", "woman", "spa", "steamroom", "sauna"], char: "🧖‍♀️", fitzpatrick_scale: !0, category: "people" }, man_in_steamy_room: { keywords: ["male", "man", "spa", "steamroom", "sauna"], char: "🧖‍♂️", fitzpatrick_scale: !0, category: "people" }, couple_with_heart_woman_man: { keywords: ["pair", "love", "like", "affection", "human", "dating", "valentines", "marriage"], char: "💑", fitzpatrick_scale: !1, category: "people" }, couple_with_heart_woman_woman: { keywords: ["pair", "love", "like", "affection", "human", "dating", "valentines", "marriage"], char: "👩‍❤️‍👩", fitzpatrick_scale: !1, category: "people" }, couple_with_heart_man_man: { keywords: ["pair", "love", "like", "affection", "human", "dating", "valentines", "marriage"], char: "👨‍❤️‍👨", fitzpatrick_scale: !1, category: "people" }, couplekiss_man_woman: { keywords: ["pair", "valentines", "love", "like", "dating", "marriage"], char: "💏", fitzpatrick_scale: !1, category: "people" }, couplekiss_woman_woman: { keywords: ["pair", "valentines", "love", "like", "dating", "marriage"], char: "👩‍❤️‍💋‍👩", fitzpatrick_scale: !1, category: "people" }, couplekiss_man_man: { keywords: ["pair", "valentines", "love", "like", "dating", "marriage"], char: "👨‍❤️‍💋‍👨", fitzpatrick_scale: !1, category: "people" }, family_man_woman_boy: { keywords: ["home", "parents", "child", "mom", "dad", "father", "mother", "people", "human"], char: "👪", fitzpatrick_scale: !1, category: "people" }, family_man_woman_girl: { keywords: ["home", "parents", "people", "human", "child"], char: "👨‍👩‍👧", fitzpatrick_scale: !1, category: "people" }, family_man_woman_girl_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "👨‍👩‍👧‍👦", fitzpatrick_scale: !1, category: "people" }, family_man_woman_boy_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "👨‍👩‍👦‍👦", fitzpatrick_scale: !1, category: "people" }, family_man_woman_girl_girl: { keywords: ["home", "parents", "people", "human", "children"], char: "👨‍👩‍👧‍👧", fitzpatrick_scale: !1, category: "people" }, family_woman_woman_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "👩‍👩‍👦", fitzpatrick_scale: !1, category: "people" }, family_woman_woman_girl: { keywords: ["home", "parents", "people", "human", "children"], char: "👩‍👩‍👧", fitzpatrick_scale: !1, category: "people" }, family_woman_woman_girl_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "👩‍👩‍👧‍👦", fitzpatrick_scale: !1, category: "people" }, family_woman_woman_boy_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "👩‍👩‍👦‍👦", fitzpatrick_scale: !1, category: "people" }, family_woman_woman_girl_girl: { keywords: ["home", "parents", "people", "human", "children"], char: "👩‍👩‍👧‍👧", fitzpatrick_scale: !1, category: "people" }, family_man_man_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "👨‍👨‍👦", fitzpatrick_scale: !1, category: "people" }, family_man_man_girl: { keywords: ["home", "parents", "people", "human", "children"], char: "👨‍👨‍👧", fitzpatrick_scale: !1, category: "people" }, family_man_man_girl_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "👨‍👨‍👧‍👦", fitzpatrick_scale: !1, category: "people" }, family_man_man_boy_boy: { keywords: ["home", "parents", "people", "human", "children"], char: "👨‍👨‍👦‍👦", fitzpatrick_scale: !1, category: "people" }, family_man_man_girl_girl: { keywords: ["home", "parents", "people", "human", "children"], char: "👨‍👨‍👧‍👧", fitzpatrick_scale: !1, category: "people" }, family_woman_boy: { keywords: ["home", "parent", "people", "human", "child"], char: "👩‍👦", fitzpatrick_scale: !1, category: "people" }, family_woman_girl: { keywords: ["home", "parent", "people", "human", "child"], char: "👩‍👧", fitzpatrick_scale: !1, category: "people" }, family_woman_girl_boy: { keywords: ["home", "parent", "people", "human", "children"], char: "👩‍👧‍👦", fitzpatrick_scale: !1, category: "people" }, family_woman_boy_boy: { keywords: ["home", "parent", "people", "human", "children"], char: "👩‍👦‍👦", fitzpatrick_scale: !1, category: "people" }, family_woman_girl_girl: { keywords: ["home", "parent", "people", "human", "children"], char: "👩‍👧‍👧", fitzpatrick_scale: !1, category: "people" }, family_man_boy: { keywords: ["home", "parent", "people", "human", "child"], char: "👨‍👦", fitzpatrick_scale: !1, category: "people" }, family_man_girl: { keywords: ["home", "parent", "people", "human", "child"], char: "👨‍👧", fitzpatrick_scale: !1, category: "people" }, family_man_girl_boy: { keywords: ["home", "parent", "people", "human", "children"], char: "👨‍👧‍👦", fitzpatrick_scale: !1, category: "people" }, family_man_boy_boy: { keywords: ["home", "parent", "people", "human", "children"], char: "👨‍👦‍👦", fitzpatrick_scale: !1, category: "people" }, family_man_girl_girl: { keywords: ["home", "parent", "people", "human", "children"], char: "👨‍👧‍👧", fitzpatrick_scale: !1, category: "people" }, yarn: { keywords: ["ball", "crochet", "knit"], char: "🧶", fitzpatrick_scale: !1, category: "people" }, thread: { keywords: ["needle", "sewing", "spool", "string"], char: "🧵", fitzpatrick_scale: !1, category: "people" }, coat: { keywords: ["jacket"], char: "🧥", fitzpatrick_scale: !1, category: "people" }, labcoat: { keywords: ["doctor", "experiment", "scientist", "chemist"], char: "🥼", fitzpatrick_scale: !1, category: "people" }, womans_clothes: { keywords: ["fashion", "shopping_bags", "female"], char: "👚", fitzpatrick_scale: !1, category: "people" }, tshirt: { keywords: ["fashion", "cloth", "casual", "shirt", "tee"], char: "👕", fitzpatrick_scale: !1, category: "people" }, jeans: { keywords: ["fashion", "shopping"], char: "👖", fitzpatrick_scale: !1, category: "people" }, necktie: { keywords: ["shirt", "suitup", "formal", "fashion", "cloth", "business"], char: "👔", fitzpatrick_scale: !1, category: "people" }, dress: { keywords: ["clothes", "fashion", "shopping"], char: "👗", fitzpatrick_scale: !1, category: "people" }, bikini: { keywords: ["swimming", "female", "woman", "girl", "fashion", "beach", "summer"], char: "👙", fitzpatrick_scale: !1, category: "people" }, kimono: { keywords: ["dress", "fashion", "women", "female", "japanese"], char: "👘", fitzpatrick_scale: !1, category: "people" }, lipstick: { keywords: ["female", "girl", "fashion", "woman"], char: "💄", fitzpatrick_scale: !1, category: "people" }, kiss: { keywords: ["face", "lips", "love", "like", "affection", "valentines"], char: "💋", fitzpatrick_scale: !1, category: "people" }, footprints: { keywords: ["feet", "tracking", "walking", "beach"], char: "👣", fitzpatrick_scale: !1, category: "people" }, flat_shoe: { keywords: ["ballet", "slip-on", "slipper"], char: "🥿", fitzpatrick_scale: !1, category: "people" }, high_heel: { keywords: ["fashion", "shoes", "female", "pumps", "stiletto"], char: "👠", fitzpatrick_scale: !1, category: "people" }, sandal: { keywords: ["shoes", "fashion", "flip flops"], char: "👡", fitzpatrick_scale: !1, category: "people" }, boot: { keywords: ["shoes", "fashion"], char: "👢", fitzpatrick_scale: !1, category: "people" }, mans_shoe: { keywords: ["fashion", "male"], char: "👞", fitzpatrick_scale: !1, category: "people" }, athletic_shoe: { keywords: ["shoes", "sports", "sneakers"], char: "👟", fitzpatrick_scale: !1, category: "people" }, hiking_boot: { keywords: ["backpacking", "camping", "hiking"], char: "🥾", fitzpatrick_scale: !1, category: "people" }, socks: { keywords: ["stockings", "clothes"], char: "🧦", fitzpatrick_scale: !1, category: "people" }, gloves: { keywords: ["hands", "winter", "clothes"], char: "🧤", fitzpatrick_scale: !1, category: "people" }, scarf: { keywords: ["neck", "winter", "clothes"], char: "🧣", fitzpatrick_scale: !1, category: "people" }, womans_hat: { keywords: ["fashion", "accessories", "female", "lady", "spring"], char: "👒", fitzpatrick_scale: !1, category: "people" }, tophat: { keywords: ["magic", "gentleman", "classy", "circus"], char: "🎩", fitzpatrick_scale: !1, category: "people" }, billed_hat: { keywords: ["cap", "baseball"], char: "🧢", fitzpatrick_scale: !1, category: "people" }, rescue_worker_helmet: { keywords: ["construction", "build"], char: "⛑", fitzpatrick_scale: !1, category: "people" }, mortar_board: { keywords: ["school", "college", "degree", "university", "graduation", "cap", "hat", "legal", "learn", "education"], char: "🎓", fitzpatrick_scale: !1, category: "people" }, crown: { keywords: ["king", "kod", "leader", "royalty", "lord"], char: "👑", fitzpatrick_scale: !1, category: "people" }, school_satchel: { keywords: ["student", "education", "bag", "backpack"], char: "🎒", fitzpatrick_scale: !1, category: "people" }, luggage: { keywords: ["packing", "travel"], char: "🧳", fitzpatrick_scale: !1, category: "people" }, pouch: { keywords: ["bag", "accessories", "shopping"], char: "👝", fitzpatrick_scale: !1, category: "people" }, purse: { keywords: ["fashion", "accessories", "money", "sales", "shopping"], char: "👛", fitzpatrick_scale: !1, category: "people" }, handbag: { keywords: ["fashion", "accessory", "accessories", "shopping"], char: "👜", fitzpatrick_scale: !1, category: "people" }, briefcase: { keywords: ["business", "documents", "work", "law", "legal", "job", "career"], char: "💼", fitzpatrick_scale: !1, category: "people" }, eyeglasses: { keywords: ["fashion", "accessories", "eyesight", "nerdy", "dork", "geek"], char: "👓", fitzpatrick_scale: !1, category: "people" }, dark_sunglasses: { keywords: ["face", "cool", "accessories"], char: "🕶", fitzpatrick_scale: !1, category: "people" }, goggles: { keywords: ["eyes", "protection", "safety"], char: "🥽", fitzpatrick_scale: !1, category: "people" }, ring: { keywords: ["wedding", "propose", "marriage", "valentines", "diamond", "fashion", "jewelry", "gem", "engagement"], char: "💍", fitzpatrick_scale: !1, category: "people" }, closed_umbrella: { keywords: ["weather", "rain", "drizzle"], char: "🌂", fitzpatrick_scale: !1, category: "people" }, dog: { keywords: ["animal", "friend", "nature", "woof", "puppy", "pet", "faithful"], char: "🐶", fitzpatrick_scale: !1, category: "animals_and_nature" }, cat: { keywords: ["animal", "meow", "nature", "pet", "kitten"], char: "🐱", fitzpatrick_scale: !1, category: "animals_and_nature" }, mouse: { keywords: ["animal", "nature", "cheese_wedge", "rodent"], char: "🐭", fitzpatrick_scale: !1, category: "animals_and_nature" }, hamster: { keywords: ["animal", "nature"], char: "🐹", fitzpatrick_scale: !1, category: "animals_and_nature" }, rabbit: { keywords: ["animal", "nature", "pet", "spring", "magic", "bunny"], char: "🐰", fitzpatrick_scale: !1, category: "animals_and_nature" }, fox_face: { keywords: ["animal", "nature", "face"], char: "🦊", fitzpatrick_scale: !1, category: "animals_and_nature" }, bear: { keywords: ["animal", "nature", "wild"], char: "🐻", fitzpatrick_scale: !1, category: "animals_and_nature" }, panda_face: { keywords: ["animal", "nature", "panda"], char: "🐼", fitzpatrick_scale: !1, category: "animals_and_nature" }, koala: { keywords: ["animal", "nature"], char: "🐨", fitzpatrick_scale: !1, category: "animals_and_nature" }, tiger: { keywords: ["animal", "cat", "danger", "wild", "nature", "roar"], char: "🐯", fitzpatrick_scale: !1, category: "animals_and_nature" }, lion: { keywords: ["animal", "nature"], char: "🦁", fitzpatrick_scale: !1, category: "animals_and_nature" }, cow: { keywords: ["beef", "ox", "animal", "nature", "moo", "milk"], char: "🐮", fitzpatrick_scale: !1, category: "animals_and_nature" }, pig: { keywords: ["animal", "oink", "nature"], char: "🐷", fitzpatrick_scale: !1, category: "animals_and_nature" }, pig_nose: { keywords: ["animal", "oink"], char: "🐽", fitzpatrick_scale: !1, category: "animals_and_nature" }, frog: { keywords: ["animal", "nature", "croak", "toad"], char: "🐸", fitzpatrick_scale: !1, category: "animals_and_nature" }, squid: { keywords: ["animal", "nature", "ocean", "sea"], char: "🦑", fitzpatrick_scale: !1, category: "animals_and_nature" }, octopus: { keywords: ["animal", "creature", "ocean", "sea", "nature", "beach"], char: "🐙", fitzpatrick_scale: !1, category: "animals_and_nature" }, shrimp: { keywords: ["animal", "ocean", "nature", "seafood"], char: "🦐", fitzpatrick_scale: !1, category: "animals_and_nature" }, monkey_face: { keywords: ["animal", "nature", "circus"], char: "🐵", fitzpatrick_scale: !1, category: "animals_and_nature" }, gorilla: { keywords: ["animal", "nature", "circus"], char: "🦍", fitzpatrick_scale: !1, category: "animals_and_nature" }, see_no_evil: { keywords: ["monkey", "animal", "nature", "haha"], char: "🙈", fitzpatrick_scale: !1, category: "animals_and_nature" }, hear_no_evil: { keywords: ["animal", "monkey", "nature"], char: "🙉", fitzpatrick_scale: !1, category: "animals_and_nature" }, speak_no_evil: { keywords: ["monkey", "animal", "nature", "omg"], char: "🙊", fitzpatrick_scale: !1, category: "animals_and_nature" }, monkey: { keywords: ["animal", "nature", "banana", "circus"], char: "🐒", fitzpatrick_scale: !1, category: "animals_and_nature" }, chicken: { keywords: ["animal", "cluck", "nature", "bird"], char: "🐔", fitzpatrick_scale: !1, category: "animals_and_nature" }, penguin: { keywords: ["animal", "nature"], char: "🐧", fitzpatrick_scale: !1, category: "animals_and_nature" }, bird: { keywords: ["animal", "nature", "fly", "tweet", "spring"], char: "🐦", fitzpatrick_scale: !1, category: "animals_and_nature" }, baby_chick: { keywords: ["animal", "chicken", "bird"], char: "🐤", fitzpatrick_scale: !1, category: "animals_and_nature" }, hatching_chick: { keywords: ["animal", "chicken", "egg", "born", "baby", "bird"], char: "🐣", fitzpatrick_scale: !1, category: "animals_and_nature" }, hatched_chick: { keywords: ["animal", "chicken", "baby", "bird"], char: "🐥", fitzpatrick_scale: !1, category: "animals_and_nature" }, duck: { keywords: ["animal", "nature", "bird", "mallard"], char: "🦆", fitzpatrick_scale: !1, category: "animals_and_nature" }, eagle: { keywords: ["animal", "nature", "bird"], char: "🦅", fitzpatrick_scale: !1, category: "animals_and_nature" }, owl: { keywords: ["animal", "nature", "bird", "hoot"], char: "🦉", fitzpatrick_scale: !1, category: "animals_and_nature" }, bat: { keywords: ["animal", "nature", "blind", "vampire"], char: "🦇", fitzpatrick_scale: !1, category: "animals_and_nature" }, wolf: { keywords: ["animal", "nature", "wild"], char: "🐺", fitzpatrick_scale: !1, category: "animals_and_nature" }, boar: { keywords: ["animal", "nature"], char: "🐗", fitzpatrick_scale: !1, category: "animals_and_nature" }, horse: { keywords: ["animal", "brown", "nature"], char: "🐴", fitzpatrick_scale: !1, category: "animals_and_nature" }, unicorn: { keywords: ["animal", "nature", "mystical"], char: "🦄", fitzpatrick_scale: !1, category: "animals_and_nature" }, honeybee: { keywords: ["animal", "insect", "nature", "bug", "spring", "honey"], char: "🐝", fitzpatrick_scale: !1, category: "animals_and_nature" }, bug: { keywords: ["animal", "insect", "nature", "worm"], char: "🐛", fitzpatrick_scale: !1, category: "animals_and_nature" }, butterfly: { keywords: ["animal", "insect", "nature", "caterpillar"], char: "🦋", fitzpatrick_scale: !1, category: "animals_and_nature" }, snail: { keywords: ["slow", "animal", "shell"], char: "🐌", fitzpatrick_scale: !1, category: "animals_and_nature" }, beetle: { keywords: ["animal", "insect", "nature", "ladybug"], char: "🐞", fitzpatrick_scale: !1, category: "animals_and_nature" }, ant: { keywords: ["animal", "insect", "nature", "bug"], char: "🐜", fitzpatrick_scale: !1, category: "animals_and_nature" }, grasshopper: { keywords: ["animal", "cricket", "chirp"], char: "🦗", fitzpatrick_scale: !1, category: "animals_and_nature" }, spider: { keywords: ["animal", "arachnid"], char: "🕷", fitzpatrick_scale: !1, category: "animals_and_nature" }, scorpion: { keywords: ["animal", "arachnid"], char: "🦂", fitzpatrick_scale: !1, category: "animals_and_nature" }, crab: { keywords: ["animal", "crustacean"], char: "🦀", fitzpatrick_scale: !1, category: "animals_and_nature" }, snake: { keywords: ["animal", "evil", "nature", "hiss", "python"], char: "🐍", fitzpatrick_scale: !1, category: "animals_and_nature" }, lizard: { keywords: ["animal", "nature", "reptile"], char: "🦎", fitzpatrick_scale: !1, category: "animals_and_nature" }, "t-rex": { keywords: ["animal", "nature", "dinosaur", "tyrannosaurus", "extinct"], char: "🦖", fitzpatrick_scale: !1, category: "animals_and_nature" }, sauropod: { keywords: ["animal", "nature", "dinosaur", "brachiosaurus", "brontosaurus", "diplodocus", "extinct"], char: "🦕", fitzpatrick_scale: !1, category: "animals_and_nature" }, turtle: { keywords: ["animal", "slow", "nature", "tortoise"], char: "🐢", fitzpatrick_scale: !1, category: "animals_and_nature" }, tropical_fish: { keywords: ["animal", "swim", "ocean", "beach", "nemo"], char: "🐠", fitzpatrick_scale: !1, category: "animals_and_nature" }, fish: { keywords: ["animal", "food", "nature"], char: "🐟", fitzpatrick_scale: !1, category: "animals_and_nature" }, blowfish: { keywords: ["animal", "nature", "food", "sea", "ocean"], char: "🐡", fitzpatrick_scale: !1, category: "animals_and_nature" }, dolphin: { keywords: ["animal", "nature", "fish", "sea", "ocean", "flipper", "fins", "beach"], char: "🐬", fitzpatrick_scale: !1, category: "animals_and_nature" }, shark: { keywords: ["animal", "nature", "fish", "sea", "ocean", "jaws", "fins", "beach"], char: "🦈", fitzpatrick_scale: !1, category: "animals_and_nature" }, whale: { keywords: ["animal", "nature", "sea", "ocean"], char: "🐳", fitzpatrick_scale: !1, category: "animals_and_nature" }, whale2: { keywords: ["animal", "nature", "sea", "ocean"], char: "🐋", fitzpatrick_scale: !1, category: "animals_and_nature" }, crocodile: { keywords: ["animal", "nature", "reptile", "lizard", "alligator"], char: "🐊", fitzpatrick_scale: !1, category: "animals_and_nature" }, leopard: { keywords: ["animal", "nature"], char: "🐆", fitzpatrick_scale: !1, category: "animals_and_nature" }, zebra: { keywords: ["animal", "nature", "stripes", "safari"], char: "🦓", fitzpatrick_scale: !1, category: "animals_and_nature" }, tiger2: { keywords: ["animal", "nature", "roar"], char: "🐅", fitzpatrick_scale: !1, category: "animals_and_nature" }, water_buffalo: { keywords: ["animal", "nature", "ox", "cow"], char: "🐃", fitzpatrick_scale: !1, category: "animals_and_nature" }, ox: { keywords: ["animal", "cow", "beef"], char: "🐂", fitzpatrick_scale: !1, category: "animals_and_nature" }, cow2: { keywords: ["beef", "ox", "animal", "nature", "moo", "milk"], char: "🐄", fitzpatrick_scale: !1, category: "animals_and_nature" }, deer: { keywords: ["animal", "nature", "horns", "venison"], char: "🦌", fitzpatrick_scale: !1, category: "animals_and_nature" }, dromedary_camel: { keywords: ["animal", "hot", "desert", "hump"], char: "🐪", fitzpatrick_scale: !1, category: "animals_and_nature" }, camel: { keywords: ["animal", "nature", "hot", "desert", "hump"], char: "🐫", fitzpatrick_scale: !1, category: "animals_and_nature" }, giraffe: { keywords: ["animal", "nature", "spots", "safari"], char: "🦒", fitzpatrick_scale: !1, category: "animals_and_nature" }, elephant: { keywords: ["animal", "nature", "nose", "th", "circus"], char: "🐘", fitzpatrick_scale: !1, category: "animals_and_nature" }, rhinoceros: { keywords: ["animal", "nature", "horn"], char: "🦏", fitzpatrick_scale: !1, category: "animals_and_nature" }, goat: { keywords: ["animal", "nature"], char: "🐐", fitzpatrick_scale: !1, category: "animals_and_nature" }, ram: { keywords: ["animal", "sheep", "nature"], char: "🐏", fitzpatrick_scale: !1, category: "animals_and_nature" }, sheep: { keywords: ["animal", "nature", "wool", "shipit"], char: "🐑", fitzpatrick_scale: !1, category: "animals_and_nature" }, racehorse: { keywords: ["animal", "gamble", "luck"], char: "🐎", fitzpatrick_scale: !1, category: "animals_and_nature" }, pig2: { keywords: ["animal", "nature"], char: "🐖", fitzpatrick_scale: !1, category: "animals_and_nature" }, rat: { keywords: ["animal", "mouse", "rodent"], char: "🐀", fitzpatrick_scale: !1, category: "animals_and_nature" }, mouse2: { keywords: ["animal", "nature", "rodent"], char: "🐁", fitzpatrick_scale: !1, category: "animals_and_nature" }, rooster: { keywords: ["animal", "nature", "chicken"], char: "🐓", fitzpatrick_scale: !1, category: "animals_and_nature" }, turkey: { keywords: ["animal", "bird"], char: "🦃", fitzpatrick_scale: !1, category: "animals_and_nature" }, dove: { keywords: ["animal", "bird"], char: "🕊", fitzpatrick_scale: !1, category: "animals_and_nature" }, dog2: { keywords: ["animal", "nature", "friend", "doge", "pet", "faithful"], char: "🐕", fitzpatrick_scale: !1, category: "animals_and_nature" }, poodle: { keywords: ["dog", "animal", "101", "nature", "pet"], char: "🐩", fitzpatrick_scale: !1, category: "animals_and_nature" }, cat2: { keywords: ["animal", "meow", "pet", "cats"], char: "🐈", fitzpatrick_scale: !1, category: "animals_and_nature" }, rabbit2: { keywords: ["animal", "nature", "pet", "magic", "spring"], char: "🐇", fitzpatrick_scale: !1, category: "animals_and_nature" }, chipmunk: { keywords: ["animal", "nature", "rodent", "squirrel"], char: "🐿", fitzpatrick_scale: !1, category: "animals_and_nature" }, hedgehog: { keywords: ["animal", "nature", "spiny"], char: "🦔", fitzpatrick_scale: !1, category: "animals_and_nature" }, raccoon: { keywords: ["animal", "nature"], char: "🦝", fitzpatrick_scale: !1, category: "animals_and_nature" }, llama: { keywords: ["animal", "nature", "alpaca"], char: "🦙", fitzpatrick_scale: !1, category: "animals_and_nature" }, hippopotamus: { keywords: ["animal", "nature"], char: "🦛", fitzpatrick_scale: !1, category: "animals_and_nature" }, kangaroo: { keywords: ["animal", "nature", "australia", "joey", "hop", "marsupial"], char: "🦘", fitzpatrick_scale: !1, category: "animals_and_nature" }, badger: { keywords: ["animal", "nature", "honey"], char: "🦡", fitzpatrick_scale: !1, category: "animals_and_nature" }, swan: { keywords: ["animal", "nature", "bird"], char: "🦢", fitzpatrick_scale: !1, category: "animals_and_nature" }, peacock: { keywords: ["animal", "nature", "peahen", "bird"], char: "🦚", fitzpatrick_scale: !1, category: "animals_and_nature" }, parrot: { keywords: ["animal", "nature", "bird", "pirate", "talk"], char: "🦜", fitzpatrick_scale: !1, category: "animals_and_nature" }, lobster: { keywords: ["animal", "nature", "bisque", "claws", "seafood"], char: "🦞", fitzpatrick_scale: !1, category: "animals_and_nature" }, mosquito: { keywords: ["animal", "nature", "insect", "malaria"], char: "🦟", fitzpatrick_scale: !1, category: "animals_and_nature" }, paw_prints: { keywords: ["animal", "tracking", "footprints", "dog", "cat", "pet", "feet"], char: "🐾", fitzpatrick_scale: !1, category: "animals_and_nature" }, dragon: { keywords: ["animal", "myth", "nature", "chinese", "green"], char: "🐉", fitzpatrick_scale: !1, category: "animals_and_nature" }, dragon_face: { keywords: ["animal", "myth", "nature", "chinese", "green"], char: "🐲", fitzpatrick_scale: !1, category: "animals_and_nature" }, cactus: { keywords: ["vegetable", "plant", "nature"], char: "🌵", fitzpatrick_scale: !1, category: "animals_and_nature" }, christmas_tree: { keywords: ["festival", "vacation", "december", "xmas", "celebration"], char: "🎄", fitzpatrick_scale: !1, category: "animals_and_nature" }, evergreen_tree: { keywords: ["plant", "nature"], char: "🌲", fitzpatrick_scale: !1, category: "animals_and_nature" }, deciduous_tree: { keywords: ["plant", "nature"], char: "🌳", fitzpatrick_scale: !1, category: "animals_and_nature" }, palm_tree: { keywords: ["plant", "vegetable", "nature", "summer", "beach", "mojito", "tropical"], char: "🌴", fitzpatrick_scale: !1, category: "animals_and_nature" }, seedling: { keywords: ["plant", "nature", "grass", "lawn", "spring"], char: "🌱", fitzpatrick_scale: !1, category: "animals_and_nature" }, herb: { keywords: ["vegetable", "plant", "medicine", "weed", "grass", "lawn"], char: "🌿", fitzpatrick_scale: !1, category: "animals_and_nature" }, shamrock: { keywords: ["vegetable", "plant", "nature", "irish", "clover"], char: "☘", fitzpatrick_scale: !1, category: "animals_and_nature" }, four_leaf_clover: { keywords: ["vegetable", "plant", "nature", "lucky", "irish"], char: "🍀", fitzpatrick_scale: !1, category: "animals_and_nature" }, bamboo: { keywords: ["plant", "nature", "vegetable", "panda", "pine_decoration"], char: "🎍", fitzpatrick_scale: !1, category: "animals_and_nature" }, tanabata_tree: { keywords: ["plant", "nature", "branch", "summer"], char: "🎋", fitzpatrick_scale: !1, category: "animals_and_nature" }, leaves: { keywords: ["nature", "plant", "tree", "vegetable", "grass", "lawn", "spring"], char: "🍃", fitzpatrick_scale: !1, category: "animals_and_nature" }, fallen_leaf: { keywords: ["nature", "plant", "vegetable", "leaves"], char: "🍂", fitzpatrick_scale: !1, category: "animals_and_nature" }, maple_leaf: { keywords: ["nature", "plant", "vegetable", "ca", "fall"], char: "🍁", fitzpatrick_scale: !1, category: "animals_and_nature" }, ear_of_rice: { keywords: ["nature", "plant"], char: "🌾", fitzpatrick_scale: !1, category: "animals_and_nature" }, hibiscus: { keywords: ["plant", "vegetable", "flowers", "beach"], char: "🌺", fitzpatrick_scale: !1, category: "animals_and_nature" }, sunflower: { keywords: ["nature", "plant", "fall"], char: "🌻", fitzpatrick_scale: !1, category: "animals_and_nature" }, rose: { keywords: ["flowers", "valentines", "love", "spring"], char: "🌹", fitzpatrick_scale: !1, category: "animals_and_nature" }, wilted_flower: { keywords: ["plant", "nature", "flower"], char: "🥀", fitzpatrick_scale: !1, category: "animals_and_nature" }, tulip: { keywords: ["flowers", "plant", "nature", "summer", "spring"], char: "🌷", fitzpatrick_scale: !1, category: "animals_and_nature" }, blossom: { keywords: ["nature", "flowers", "yellow"], char: "🌼", fitzpatrick_scale: !1, category: "animals_and_nature" }, cherry_blossom: { keywords: ["nature", "plant", "spring", "flower"], char: "🌸", fitzpatrick_scale: !1, category: "animals_and_nature" }, bouquet: { keywords: ["flowers", "nature", "spring"], char: "💐", fitzpatrick_scale: !1, category: "animals_and_nature" }, mushroom: { keywords: ["plant", "vegetable"], char: "🍄", fitzpatrick_scale: !1, category: "animals_and_nature" }, chestnut: { keywords: ["food", "squirrel"], char: "🌰", fitzpatrick_scale: !1, category: "animals_and_nature" }, jack_o_lantern: { keywords: ["halloween", "light", "pumpkin", "creepy", "fall"], char: "🎃", fitzpatrick_scale: !1, category: "animals_and_nature" }, shell: { keywords: ["nature", "sea", "beach"], char: "🐚", fitzpatrick_scale: !1, category: "animals_and_nature" }, spider_web: { keywords: ["animal", "insect", "arachnid", "silk"], char: "🕸", fitzpatrick_scale: !1, category: "animals_and_nature" }, earth_americas: { keywords: ["globe", "world", "USA", "international"], char: "🌎", fitzpatrick_scale: !1, category: "animals_and_nature" }, earth_africa: { keywords: ["globe", "world", "international"], char: "🌍", fitzpatrick_scale: !1, category: "animals_and_nature" }, earth_asia: { keywords: ["globe", "world", "east", "international"], char: "🌏", fitzpatrick_scale: !1, category: "animals_and_nature" }, full_moon: { keywords: ["nature", "yellow", "twilight", "planet", "space", "night", "evening", "sleep"], char: "🌕", fitzpatrick_scale: !1, category: "animals_and_nature" }, waning_gibbous_moon: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep", "waxing_gibbous_moon"], char: "🌖", fitzpatrick_scale: !1, category: "animals_and_nature" }, last_quarter_moon: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "🌗", fitzpatrick_scale: !1, category: "animals_and_nature" }, waning_crescent_moon: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "🌘", fitzpatrick_scale: !1, category: "animals_and_nature" }, new_moon: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "🌑", fitzpatrick_scale: !1, category: "animals_and_nature" }, waxing_crescent_moon: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "🌒", fitzpatrick_scale: !1, category: "animals_and_nature" }, first_quarter_moon: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "🌓", fitzpatrick_scale: !1, category: "animals_and_nature" }, waxing_gibbous_moon: { keywords: ["nature", "night", "sky", "gray", "twilight", "planet", "space", "evening", "sleep"], char: "🌔", fitzpatrick_scale: !1, category: "animals_and_nature" }, new_moon_with_face: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "🌚", fitzpatrick_scale: !1, category: "animals_and_nature" }, full_moon_with_face: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "🌝", fitzpatrick_scale: !1, category: "animals_and_nature" }, first_quarter_moon_with_face: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "🌛", fitzpatrick_scale: !1, category: "animals_and_nature" }, last_quarter_moon_with_face: { keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], char: "🌜", fitzpatrick_scale: !1, category: "animals_and_nature" }, sun_with_face: { keywords: ["nature", "morning", "sky"], char: "🌞", fitzpatrick_scale: !1, category: "animals_and_nature" }, crescent_moon: { keywords: ["night", "sleep", "sky", "evening", "magic"], char: "🌙", fitzpatrick_scale: !1, category: "animals_and_nature" }, star: { keywords: ["night", "yellow"], char: "⭐", fitzpatrick_scale: !1, category: "animals_and_nature" }, star2: { keywords: ["night", "sparkle", "awesome", "good", "magic"], char: "🌟", fitzpatrick_scale: !1, category: "animals_and_nature" }, dizzy: { keywords: ["star", "sparkle", "shoot", "magic"], char: "💫", fitzpatrick_scale: !1, category: "animals_and_nature" }, sparkles: { keywords: ["stars", "shine", "shiny", "cool", "awesome", "good", "magic"], char: "✨", fitzpatrick_scale: !1, category: "animals_and_nature" }, comet: { keywords: ["space"], char: "☄", fitzpatrick_scale: !1, category: "animals_and_nature" }, sunny: { keywords: ["weather", "nature", "brightness", "summer", "beach", "spring"], char: "☀️", fitzpatrick_scale: !1, category: "animals_and_nature" }, sun_behind_small_cloud: { keywords: ["weather"], char: "🌤", fitzpatrick_scale: !1, category: "animals_and_nature" }, partly_sunny: { keywords: ["weather", "nature", "cloudy", "morning", "fall", "spring"], char: "⛅", fitzpatrick_scale: !1, category: "animals_and_nature" }, sun_behind_large_cloud: { keywords: ["weather"], char: "🌥", fitzpatrick_scale: !1, category: "animals_and_nature" }, sun_behind_rain_cloud: { keywords: ["weather"], char: "🌦", fitzpatrick_scale: !1, category: "animals_and_nature" }, cloud: { keywords: ["weather", "sky"], char: "☁️", fitzpatrick_scale: !1, category: "animals_and_nature" }, cloud_with_rain: { keywords: ["weather"], char: "🌧", fitzpatrick_scale: !1, category: "animals_and_nature" }, cloud_with_lightning_and_rain: { keywords: ["weather", "lightning"], char: "⛈", fitzpatrick_scale: !1, category: "animals_and_nature" }, cloud_with_lightning: { keywords: ["weather", "thunder"], char: "🌩", fitzpatrick_scale: !1, category: "animals_and_nature" }, zap: { keywords: ["thunder", "weather", "lightning bolt", "fast"], char: "⚡", fitzpatrick_scale: !1, category: "animals_and_nature" }, fire: { keywords: ["hot", "cook", "flame"], char: "🔥", fitzpatrick_scale: !1, category: "animals_and_nature" }, boom: { keywords: ["bomb", "explode", "explosion", "collision", "blown"], char: "💥", fitzpatrick_scale: !1, category: "animals_and_nature" }, snowflake: { keywords: ["winter", "season", "cold", "weather", "christmas", "xmas"], char: "❄️", fitzpatrick_scale: !1, category: "animals_and_nature" }, cloud_with_snow: { keywords: ["weather"], char: "🌨", fitzpatrick_scale: !1, category: "animals_and_nature" }, snowman: { keywords: ["winter", "season", "cold", "weather", "christmas", "xmas", "frozen", "without_snow"], char: "⛄", fitzpatrick_scale: !1, category: "animals_and_nature" }, snowman_with_snow: { keywords: ["winter", "season", "cold", "weather", "christmas", "xmas", "frozen"], char: "☃", fitzpatrick_scale: !1, category: "animals_and_nature" }, wind_face: { keywords: ["gust", "air"], char: "🌬", fitzpatrick_scale: !1, category: "animals_and_nature" }, dash: { keywords: ["wind", "air", "fast", "shoo", "fart", "smoke", "puff"], char: "💨", fitzpatrick_scale: !1, category: "animals_and_nature" }, tornado: { keywords: ["weather", "cyclone", "twister"], char: "🌪", fitzpatrick_scale: !1, category: "animals_and_nature" }, fog: { keywords: ["weather"], char: "🌫", fitzpatrick_scale: !1, category: "animals_and_nature" }, open_umbrella: { keywords: ["weather", "spring"], char: "☂", fitzpatrick_scale: !1, category: "animals_and_nature" }, umbrella: { keywords: ["rainy", "weather", "spring"], char: "☔", fitzpatrick_scale: !1, category: "animals_and_nature" }, droplet: { keywords: ["water", "drip", "faucet", "spring"], char: "💧", fitzpatrick_scale: !1, category: "animals_and_nature" }, sweat_drops: { keywords: ["water", "drip", "oops"], char: "💦", fitzpatrick_scale: !1, category: "animals_and_nature" }, ocean: { keywords: ["sea", "water", "wave", "nature", "tsunami", "disaster"], char: "🌊", fitzpatrick_scale: !1, category: "animals_and_nature" }, green_apple: { keywords: ["fruit", "nature"], char: "🍏", fitzpatrick_scale: !1, category: "food_and_drink" }, apple: { keywords: ["fruit", "mac", "school"], char: "🍎", fitzpatrick_scale: !1, category: "food_and_drink" }, pear: { keywords: ["fruit", "nature", "food"], char: "🍐", fitzpatrick_scale: !1, category: "food_and_drink" }, tangerine: { keywords: ["food", "fruit", "nature", "orange"], char: "🍊", fitzpatrick_scale: !1, category: "food_and_drink" }, lemon: { keywords: ["fruit", "nature"], char: "🍋", fitzpatrick_scale: !1, category: "food_and_drink" }, banana: { keywords: ["fruit", "food", "monkey"], char: "🍌", fitzpatrick_scale: !1, category: "food_and_drink" }, watermelon: { keywords: ["fruit", "food", "picnic", "summer"], char: "🍉", fitzpatrick_scale: !1, category: "food_and_drink" }, grapes: { keywords: ["fruit", "food", "wine"], char: "🍇", fitzpatrick_scale: !1, category: "food_and_drink" }, strawberry: { keywords: ["fruit", "food", "nature"], char: "🍓", fitzpatrick_scale: !1, category: "food_and_drink" }, melon: { keywords: ["fruit", "nature", "food"], char: "🍈", fitzpatrick_scale: !1, category: "food_and_drink" }, cherries: { keywords: ["food", "fruit"], char: "🍒", fitzpatrick_scale: !1, category: "food_and_drink" }, peach: { keywords: ["fruit", "nature", "food"], char: "🍑", fitzpatrick_scale: !1, category: "food_and_drink" }, pineapple: { keywords: ["fruit", "nature", "food"], char: "🍍", fitzpatrick_scale: !1, category: "food_and_drink" }, coconut: { keywords: ["fruit", "nature", "food", "palm"], char: "🥥", fitzpatrick_scale: !1, category: "food_and_drink" }, kiwi_fruit: { keywords: ["fruit", "food"], char: "🥝", fitzpatrick_scale: !1, category: "food_and_drink" }, mango: { keywords: ["fruit", "food", "tropical"], char: "🥭", fitzpatrick_scale: !1, category: "food_and_drink" }, avocado: { keywords: ["fruit", "food"], char: "🥑", fitzpatrick_scale: !1, category: "food_and_drink" }, broccoli: { keywords: ["fruit", "food", "vegetable"], char: "🥦", fitzpatrick_scale: !1, category: "food_and_drink" }, tomato: { keywords: ["fruit", "vegetable", "nature", "food"], char: "🍅", fitzpatrick_scale: !1, category: "food_and_drink" }, eggplant: { keywords: ["vegetable", "nature", "food", "aubergine"], char: "🍆", fitzpatrick_scale: !1, category: "food_and_drink" }, cucumber: { keywords: ["fruit", "food", "pickle"], char: "🥒", fitzpatrick_scale: !1, category: "food_and_drink" }, carrot: { keywords: ["vegetable", "food", "orange"], char: "🥕", fitzpatrick_scale: !1, category: "food_and_drink" }, hot_pepper: { keywords: ["food", "spicy", "chilli", "chili"], char: "🌶", fitzpatrick_scale: !1, category: "food_and_drink" }, potato: { keywords: ["food", "tuber", "vegatable", "starch"], char: "🥔", fitzpatrick_scale: !1, category: "food_and_drink" }, corn: { keywords: ["food", "vegetable", "plant"], char: "🌽", fitzpatrick_scale: !1, category: "food_and_drink" }, leafy_greens: { keywords: ["food", "vegetable", "plant", "bok choy", "cabbage", "kale", "lettuce"], char: "🥬", fitzpatrick_scale: !1, category: "food_and_drink" }, sweet_potato: { keywords: ["food", "nature"], char: "🍠", fitzpatrick_scale: !1, category: "food_and_drink" }, peanuts: { keywords: ["food", "nut"], char: "🥜", fitzpatrick_scale: !1, category: "food_and_drink" }, honey_pot: { keywords: ["bees", "sweet", "kitchen"], char: "🍯", fitzpatrick_scale: !1, category: "food_and_drink" }, croissant: { keywords: ["food", "bread", "french"], char: "🥐", fitzpatrick_scale: !1, category: "food_and_drink" }, bread: { keywords: ["food", "wheat", "breakfast", "toast"], char: "🍞", fitzpatrick_scale: !1, category: "food_and_drink" }, baguette_bread: { keywords: ["food", "bread", "french"], char: "🥖", fitzpatrick_scale: !1, category: "food_and_drink" }, bagel: { keywords: ["food", "bread", "bakery", "schmear"], char: "🥯", fitzpatrick_scale: !1, category: "food_and_drink" }, pretzel: { keywords: ["food", "bread", "twisted"], char: "🥨", fitzpatrick_scale: !1, category: "food_and_drink" }, cheese: { keywords: ["food", "chadder"], char: "🧀", fitzpatrick_scale: !1, category: "food_and_drink" }, egg: { keywords: ["food", "chicken", "breakfast"], char: "🥚", fitzpatrick_scale: !1, category: "food_and_drink" }, bacon: { keywords: ["food", "breakfast", "pork", "pig", "meat"], char: "🥓", fitzpatrick_scale: !1, category: "food_and_drink" }, steak: { keywords: ["food", "cow", "meat", "cut", "chop", "lambchop", "porkchop"], char: "🥩", fitzpatrick_scale: !1, category: "food_and_drink" }, pancakes: { keywords: ["food", "breakfast", "flapjacks", "hotcakes"], char: "🥞", fitzpatrick_scale: !1, category: "food_and_drink" }, poultry_leg: { keywords: ["food", "meat", "drumstick", "bird", "chicken", "turkey"], char: "🍗", fitzpatrick_scale: !1, category: "food_and_drink" }, meat_on_bone: { keywords: ["good", "food", "drumstick"], char: "🍖", fitzpatrick_scale: !1, category: "food_and_drink" }, bone: { keywords: ["skeleton"], char: "🦴", fitzpatrick_scale: !1, category: "food_and_drink" }, fried_shrimp: { keywords: ["food", "animal", "appetizer", "summer"], char: "🍤", fitzpatrick_scale: !1, category: "food_and_drink" }, fried_egg: { keywords: ["food", "breakfast", "kitchen", "egg"], char: "🍳", fitzpatrick_scale: !1, category: "food_and_drink" }, hamburger: { keywords: ["meat", "fast food", "beef", "cheeseburger", "mcdonalds", "burger king"], char: "🍔", fitzpatrick_scale: !1, category: "food_and_drink" }, fries: { keywords: ["chips", "snack", "fast food"], char: "🍟", fitzpatrick_scale: !1, category: "food_and_drink" }, stuffed_flatbread: { keywords: ["food", "flatbread", "stuffed", "gyro"], char: "🥙", fitzpatrick_scale: !1, category: "food_and_drink" }, hotdog: { keywords: ["food", "frankfurter"], char: "🌭", fitzpatrick_scale: !1, category: "food_and_drink" }, pizza: { keywords: ["food", "party"], char: "🍕", fitzpatrick_scale: !1, category: "food_and_drink" }, sandwich: { keywords: ["food", "lunch", "bread"], char: "🥪", fitzpatrick_scale: !1, category: "food_and_drink" }, canned_food: { keywords: ["food", "soup"], char: "🥫", fitzpatrick_scale: !1, category: "food_and_drink" }, spaghetti: { keywords: ["food", "italian", "noodle"], char: "🍝", fitzpatrick_scale: !1, category: "food_and_drink" }, taco: { keywords: ["food", "mexican"], char: "🌮", fitzpatrick_scale: !1, category: "food_and_drink" }, burrito: { keywords: ["food", "mexican"], char: "🌯", fitzpatrick_scale: !1, category: "food_and_drink" }, green_salad: { keywords: ["food", "healthy", "lettuce"], char: "🥗", fitzpatrick_scale: !1, category: "food_and_drink" }, shallow_pan_of_food: { keywords: ["food", "cooking", "casserole", "paella"], char: "🥘", fitzpatrick_scale: !1, category: "food_and_drink" }, ramen: { keywords: ["food", "japanese", "noodle", "chopsticks"], char: "🍜", fitzpatrick_scale: !1, category: "food_and_drink" }, stew: { keywords: ["food", "meat", "soup"], char: "🍲", fitzpatrick_scale: !1, category: "food_and_drink" }, fish_cake: { keywords: ["food", "japan", "sea", "beach", "narutomaki", "pink", "swirl", "kamaboko", "surimi", "ramen"], char: "🍥", fitzpatrick_scale: !1, category: "food_and_drink" }, fortune_cookie: { keywords: ["food", "prophecy"], char: "🥠", fitzpatrick_scale: !1, category: "food_and_drink" }, sushi: { keywords: ["food", "fish", "japanese", "rice"], char: "🍣", fitzpatrick_scale: !1, category: "food_and_drink" }, bento: { keywords: ["food", "japanese", "box"], char: "🍱", fitzpatrick_scale: !1, category: "food_and_drink" }, curry: { keywords: ["food", "spicy", "hot", "indian"], char: "🍛", fitzpatrick_scale: !1, category: "food_and_drink" }, rice_ball: { keywords: ["food", "japanese"], char: "🍙", fitzpatrick_scale: !1, category: "food_and_drink" }, rice: { keywords: ["food", "china", "asian"], char: "🍚", fitzpatrick_scale: !1, category: "food_and_drink" }, rice_cracker: { keywords: ["food", "japanese"], char: "🍘", fitzpatrick_scale: !1, category: "food_and_drink" }, oden: { keywords: ["food", "japanese"], char: "🍢", fitzpatrick_scale: !1, category: "food_and_drink" }, dango: { keywords: ["food", "dessert", "sweet", "japanese", "barbecue", "meat"], char: "🍡", fitzpatrick_scale: !1, category: "food_and_drink" }, shaved_ice: { keywords: ["hot", "dessert", "summer"], char: "🍧", fitzpatrick_scale: !1, category: "food_and_drink" }, ice_cream: { keywords: ["food", "hot", "dessert"], char: "🍨", fitzpatrick_scale: !1, category: "food_and_drink" }, icecream: { keywords: ["food", "hot", "dessert", "summer"], char: "🍦", fitzpatrick_scale: !1, category: "food_and_drink" }, pie: { keywords: ["food", "dessert", "pastry"], char: "🥧", fitzpatrick_scale: !1, category: "food_and_drink" }, cake: { keywords: ["food", "dessert"], char: "🍰", fitzpatrick_scale: !1, category: "food_and_drink" }, cupcake: { keywords: ["food", "dessert", "bakery", "sweet"], char: "🧁", fitzpatrick_scale: !1, category: "food_and_drink" }, moon_cake: { keywords: ["food", "autumn"], char: "🥮", fitzpatrick_scale: !1, category: "food_and_drink" }, birthday: { keywords: ["food", "dessert", "cake"], char: "🎂", fitzpatrick_scale: !1, category: "food_and_drink" }, custard: { keywords: ["dessert", "food"], char: "🍮", fitzpatrick_scale: !1, category: "food_and_drink" }, candy: { keywords: ["snack", "dessert", "sweet", "lolly"], char: "🍬", fitzpatrick_scale: !1, category: "food_and_drink" }, lollipop: { keywords: ["food", "snack", "candy", "sweet"], char: "🍭", fitzpatrick_scale: !1, category: "food_and_drink" }, chocolate_bar: { keywords: ["food", "snack", "dessert", "sweet"], char: "🍫", fitzpatrick_scale: !1, category: "food_and_drink" }, popcorn: { keywords: ["food", "movie theater", "films", "snack"], char: "🍿", fitzpatrick_scale: !1, category: "food_and_drink" }, dumpling: { keywords: ["food", "empanada", "pierogi", "potsticker"], char: "🥟", fitzpatrick_scale: !1, category: "food_and_drink" }, doughnut: { keywords: ["food", "dessert", "snack", "sweet", "donut"], char: "🍩", fitzpatrick_scale: !1, category: "food_and_drink" }, cookie: { keywords: ["food", "snack", "oreo", "chocolate", "sweet", "dessert"], char: "🍪", fitzpatrick_scale: !1, category: "food_and_drink" }, milk_glass: { keywords: ["beverage", "drink", "cow"], char: "🥛", fitzpatrick_scale: !1, category: "food_and_drink" }, beer: { keywords: ["relax", "beverage", "drink", "drunk", "party", "pub", "summer", "alcohol", "booze"], char: "🍺", fitzpatrick_scale: !1, category: "food_and_drink" }, beers: { keywords: ["relax", "beverage", "drink", "drunk", "party", "pub", "summer", "alcohol", "booze"], char: "🍻", fitzpatrick_scale: !1, category: "food_and_drink" }, clinking_glasses: { keywords: ["beverage", "drink", "party", "alcohol", "celebrate", "cheers", "wine", "champagne", "toast"], char: "🥂", fitzpatrick_scale: !1, category: "food_and_drink" }, wine_glass: { keywords: ["drink", "beverage", "drunk", "alcohol", "booze"], char: "🍷", fitzpatrick_scale: !1, category: "food_and_drink" }, tumbler_glass: { keywords: ["drink", "beverage", "drunk", "alcohol", "liquor", "booze", "bourbon", "scotch", "whisky", "glass", "shot"], char: "🥃", fitzpatrick_scale: !1, category: "food_and_drink" }, cocktail: { keywords: ["drink", "drunk", "alcohol", "beverage", "booze", "mojito"], char: "🍸", fitzpatrick_scale: !1, category: "food_and_drink" }, tropical_drink: { keywords: ["beverage", "cocktail", "summer", "beach", "alcohol", "booze", "mojito"], char: "🍹", fitzpatrick_scale: !1, category: "food_and_drink" }, champagne: { keywords: ["drink", "wine", "bottle", "celebration"], char: "🍾", fitzpatrick_scale: !1, category: "food_and_drink" }, sake: { keywords: ["wine", "drink", "drunk", "beverage", "japanese", "alcohol", "booze"], char: "🍶", fitzpatrick_scale: !1, category: "food_and_drink" }, tea: { keywords: ["drink", "bowl", "breakfast", "green", "british"], char: "🍵", fitzpatrick_scale: !1, category: "food_and_drink" }, cup_with_straw: { keywords: ["drink", "soda"], char: "🥤", fitzpatrick_scale: !1, category: "food_and_drink" }, coffee: { keywords: ["beverage", "caffeine", "latte", "espresso"], char: "☕", fitzpatrick_scale: !1, category: "food_and_drink" }, baby_bottle: { keywords: ["food", "container", "milk"], char: "🍼", fitzpatrick_scale: !1, category: "food_and_drink" }, salt: { keywords: ["condiment", "shaker"], char: "🧂", fitzpatrick_scale: !1, category: "food_and_drink" }, spoon: { keywords: ["cutlery", "kitchen", "tableware"], char: "🥄", fitzpatrick_scale: !1, category: "food_and_drink" }, fork_and_knife: { keywords: ["cutlery", "kitchen"], char: "🍴", fitzpatrick_scale: !1, category: "food_and_drink" }, plate_with_cutlery: { keywords: ["food", "eat", "meal", "lunch", "dinner", "restaurant"], char: "🍽", fitzpatrick_scale: !1, category: "food_and_drink" }, bowl_with_spoon: { keywords: ["food", "breakfast", "cereal", "oatmeal", "porridge"], char: "🥣", fitzpatrick_scale: !1, category: "food_and_drink" }, takeout_box: { keywords: ["food", "leftovers"], char: "🥡", fitzpatrick_scale: !1, category: "food_and_drink" }, chopsticks: { keywords: ["food"], char: "🥢", fitzpatrick_scale: !1, category: "food_and_drink" }, soccer: { keywords: ["sports", "football"], char: "⚽", fitzpatrick_scale: !1, category: "activity" }, basketball: { keywords: ["sports", "balls", "NBA"], char: "🏀", fitzpatrick_scale: !1, category: "activity" }, football: { keywords: ["sports", "balls", "NFL"], char: "🏈", fitzpatrick_scale: !1, category: "activity" }, baseball: { keywords: ["sports", "balls"], char: "⚾", fitzpatrick_scale: !1, category: "activity" }, softball: { keywords: ["sports", "balls"], char: "🥎", fitzpatrick_scale: !1, category: "activity" }, tennis: { keywords: ["sports", "balls", "green"], char: "🎾", fitzpatrick_scale: !1, category: "activity" }, volleyball: { keywords: ["sports", "balls"], char: "🏐", fitzpatrick_scale: !1, category: "activity" }, rugby_football: { keywords: ["sports", "team"], char: "🏉", fitzpatrick_scale: !1, category: "activity" }, flying_disc: { keywords: ["sports", "frisbee", "ultimate"], char: "🥏", fitzpatrick_scale: !1, category: "activity" }, "8ball": { keywords: ["pool", "hobby", "game", "luck", "magic"], char: "🎱", fitzpatrick_scale: !1, category: "activity" }, golf: { keywords: ["sports", "business", "flag", "hole", "summer"], char: "⛳", fitzpatrick_scale: !1, category: "activity" }, golfing_woman: { keywords: ["sports", "business", "woman", "female"], char: "🏌️‍♀️", fitzpatrick_scale: !1, category: "activity" }, golfing_man: { keywords: ["sports", "business"], char: "🏌", fitzpatrick_scale: !0, category: "activity" }, ping_pong: { keywords: ["sports", "pingpong"], char: "🏓", fitzpatrick_scale: !1, category: "activity" }, badminton: { keywords: ["sports"], char: "🏸", fitzpatrick_scale: !1, category: "activity" }, goal_net: { keywords: ["sports"], char: "🥅", fitzpatrick_scale: !1, category: "activity" }, ice_hockey: { keywords: ["sports"], char: "🏒", fitzpatrick_scale: !1, category: "activity" }, field_hockey: { keywords: ["sports"], char: "🏑", fitzpatrick_scale: !1, category: "activity" }, lacrosse: { keywords: ["sports", "ball", "stick"], char: "🥍", fitzpatrick_scale: !1, category: "activity" }, cricket: { keywords: ["sports"], char: "🏏", fitzpatrick_scale: !1, category: "activity" }, ski: { keywords: ["sports", "winter", "cold", "snow"], char: "🎿", fitzpatrick_scale: !1, category: "activity" }, skier: { keywords: ["sports", "winter", "snow"], char: "⛷", fitzpatrick_scale: !1, category: "activity" }, snowboarder: { keywords: ["sports", "winter"], char: "🏂", fitzpatrick_scale: !0, category: "activity" }, person_fencing: { keywords: ["sports", "fencing", "sword"], char: "🤺", fitzpatrick_scale: !1, category: "activity" }, women_wrestling: { keywords: ["sports", "wrestlers"], char: "🤼‍♀️", fitzpatrick_scale: !1, category: "activity" }, men_wrestling: { keywords: ["sports", "wrestlers"], char: "🤼‍♂️", fitzpatrick_scale: !1, category: "activity" }, woman_cartwheeling: { keywords: ["gymnastics"], char: "🤸‍♀️", fitzpatrick_scale: !0, category: "activity" }, man_cartwheeling: { keywords: ["gymnastics"], char: "🤸‍♂️", fitzpatrick_scale: !0, category: "activity" }, woman_playing_handball: { keywords: ["sports"], char: "🤾‍♀️", fitzpatrick_scale: !0, category: "activity" }, man_playing_handball: { keywords: ["sports"], char: "🤾‍♂️", fitzpatrick_scale: !0, category: "activity" }, ice_skate: { keywords: ["sports"], char: "⛸", fitzpatrick_scale: !1, category: "activity" }, curling_stone: { keywords: ["sports"], char: "🥌", fitzpatrick_scale: !1, category: "activity" }, skateboard: { keywords: ["board"], char: "🛹", fitzpatrick_scale: !1, category: "activity" }, sled: { keywords: ["sleigh", "luge", "toboggan"], char: "🛷", fitzpatrick_scale: !1, category: "activity" }, bow_and_arrow: { keywords: ["sports"], char: "🏹", fitzpatrick_scale: !1, category: "activity" }, fishing_pole_and_fish: { keywords: ["food", "hobby", "summer"], char: "🎣", fitzpatrick_scale: !1, category: "activity" }, boxing_glove: { keywords: ["sports", "fighting"], char: "🥊", fitzpatrick_scale: !1, category: "activity" }, martial_arts_uniform: { keywords: ["judo", "karate", "taekwondo"], char: "🥋", fitzpatrick_scale: !1, category: "activity" }, rowing_woman: { keywords: ["sports", "hobby", "water", "ship", "woman", "female"], char: "🚣‍♀️", fitzpatrick_scale: !0, category: "activity" }, rowing_man: { keywords: ["sports", "hobby", "water", "ship"], char: "🚣", fitzpatrick_scale: !0, category: "activity" }, climbing_woman: { keywords: ["sports", "hobby", "woman", "female", "rock"], char: "🧗‍♀️", fitzpatrick_scale: !0, category: "activity" }, climbing_man: { keywords: ["sports", "hobby", "man", "male", "rock"], char: "🧗‍♂️", fitzpatrick_scale: !0, category: "activity" }, swimming_woman: { keywords: ["sports", "exercise", "human", "athlete", "water", "summer", "woman", "female"], char: "🏊‍♀️", fitzpatrick_scale: !0, category: "activity" }, swimming_man: { keywords: ["sports", "exercise", "human", "athlete", "water", "summer"], char: "🏊", fitzpatrick_scale: !0, category: "activity" }, woman_playing_water_polo: { keywords: ["sports", "pool"], char: "🤽‍♀️", fitzpatrick_scale: !0, category: "activity" }, man_playing_water_polo: { keywords: ["sports", "pool"], char: "🤽‍♂️", fitzpatrick_scale: !0, category: "activity" }, woman_in_lotus_position: { keywords: ["woman", "female", "meditation", "yoga", "serenity", "zen", "mindfulness"], char: "🧘‍♀️", fitzpatrick_scale: !0, category: "activity" }, man_in_lotus_position: { keywords: ["man", "male", "meditation", "yoga", "serenity", "zen", "mindfulness"], char: "🧘‍♂️", fitzpatrick_scale: !0, category: "activity" }, surfing_woman: { keywords: ["sports", "ocean", "sea", "summer", "beach", "woman", "female"], char: "🏄‍♀️", fitzpatrick_scale: !0, category: "activity" }, surfing_man: { keywords: ["sports", "ocean", "sea", "summer", "beach"], char: "🏄", fitzpatrick_scale: !0, category: "activity" }, bath: { keywords: ["clean", "shower", "bathroom"], char: "🛀", fitzpatrick_scale: !0, category: "activity" }, basketball_woman: { keywords: ["sports", "human", "woman", "female"], char: "⛹️‍♀️", fitzpatrick_scale: !0, category: "activity" }, basketball_man: { keywords: ["sports", "human"], char: "⛹", fitzpatrick_scale: !0, category: "activity" }, weight_lifting_woman: { keywords: ["sports", "training", "exercise", "woman", "female"], char: "🏋️‍♀️", fitzpatrick_scale: !0, category: "activity" }, weight_lifting_man: { keywords: ["sports", "training", "exercise"], char: "🏋", fitzpatrick_scale: !0, category: "activity" }, biking_woman: { keywords: ["sports", "bike", "exercise", "hipster", "woman", "female"], char: "🚴‍♀️", fitzpatrick_scale: !0, category: "activity" }, biking_man: { keywords: ["sports", "bike", "exercise", "hipster"], char: "🚴", fitzpatrick_scale: !0, category: "activity" }, mountain_biking_woman: { keywords: ["transportation", "sports", "human", "race", "bike", "woman", "female"], char: "🚵‍♀️", fitzpatrick_scale: !0, category: "activity" }, mountain_biking_man: { keywords: ["transportation", "sports", "human", "race", "bike"], char: "🚵", fitzpatrick_scale: !0, category: "activity" }, horse_racing: { keywords: ["animal", "betting", "competition", "gambling", "luck"], char: "🏇", fitzpatrick_scale: !0, category: "activity" }, business_suit_levitating: { keywords: ["suit", "business", "levitate", "hover", "jump"], char: "🕴", fitzpatrick_scale: !0, category: "activity" }, trophy: { keywords: ["win", "award", "contest", "place", "ftw", "ceremony"], char: "🏆", fitzpatrick_scale: !1, category: "activity" }, running_shirt_with_sash: { keywords: ["play", "pageant"], char: "🎽", fitzpatrick_scale: !1, category: "activity" }, medal_sports: { keywords: ["award", "winning"], char: "🏅", fitzpatrick_scale: !1, category: "activity" }, medal_military: { keywords: ["award", "winning", "army"], char: "🎖", fitzpatrick_scale: !1, category: "activity" }, "1st_place_medal": { keywords: ["award", "winning", "first"], char: "🥇", fitzpatrick_scale: !1, category: "activity" }, "2nd_place_medal": { keywords: ["award", "second"], char: "🥈", fitzpatrick_scale: !1, category: "activity" }, "3rd_place_medal": { keywords: ["award", "third"], char: "🥉", fitzpatrick_scale: !1, category: "activity" }, reminder_ribbon: { keywords: ["sports", "cause", "support", "awareness"], char: "🎗", fitzpatrick_scale: !1, category: "activity" }, rosette: { keywords: ["flower", "decoration", "military"], char: "🏵", fitzpatrick_scale: !1, category: "activity" }, ticket: { keywords: ["event", "concert", "pass"], char: "🎫", fitzpatrick_scale: !1, category: "activity" }, tickets: { keywords: ["sports", "concert", "entrance"], char: "🎟", fitzpatrick_scale: !1, category: "activity" }, performing_arts: { keywords: ["acting", "theater", "drama"], char: "🎭", fitzpatrick_scale: !1, category: "activity" }, art: { keywords: ["design", "paint", "draw", "colors"], char: "🎨", fitzpatrick_scale: !1, category: "activity" }, circus_tent: { keywords: ["festival", "carnival", "party"], char: "🎪", fitzpatrick_scale: !1, category: "activity" }, woman_juggling: { keywords: ["juggle", "balance", "skill", "multitask"], char: "🤹‍♀️", fitzpatrick_scale: !0, category: "activity" }, man_juggling: { keywords: ["juggle", "balance", "skill", "multitask"], char: "🤹‍♂️", fitzpatrick_scale: !0, category: "activity" }, microphone: { keywords: ["sound", "music", "PA", "sing", "talkshow"], char: "🎤", fitzpatrick_scale: !1, category: "activity" }, headphones: { keywords: ["music", "score", "gadgets"], char: "🎧", fitzpatrick_scale: !1, category: "activity" }, musical_score: { keywords: ["treble", "clef", "compose"], char: "🎼", fitzpatrick_scale: !1, category: "activity" }, musical_keyboard: { keywords: ["piano", "instrument", "compose"], char: "🎹", fitzpatrick_scale: !1, category: "activity" }, drum: { keywords: ["music", "instrument", "drumsticks", "snare"], char: "🥁", fitzpatrick_scale: !1, category: "activity" }, saxophone: { keywords: ["music", "instrument", "jazz", "blues"], char: "🎷", fitzpatrick_scale: !1, category: "activity" }, trumpet: { keywords: ["music", "brass"], char: "🎺", fitzpatrick_scale: !1, category: "activity" }, guitar: { keywords: ["music", "instrument"], char: "🎸", fitzpatrick_scale: !1, category: "activity" }, violin: { keywords: ["music", "instrument", "orchestra", "symphony"], char: "🎻", fitzpatrick_scale: !1, category: "activity" }, clapper: { keywords: ["movie", "film", "record"], char: "🎬", fitzpatrick_scale: !1, category: "activity" }, video_game: { keywords: ["play", "console", "PS4", "controller"], char: "🎮", fitzpatrick_scale: !1, category: "activity" }, space_invader: { keywords: ["game", "arcade", "play"], char: "👾", fitzpatrick_scale: !1, category: "activity" }, dart: { keywords: ["game", "play", "bar", "target", "bullseye"], char: "🎯", fitzpatrick_scale: !1, category: "activity" }, game_die: { keywords: ["dice", "random", "tabletop", "play", "luck"], char: "🎲", fitzpatrick_scale: !1, category: "activity" }, chess_pawn: { keywords: ["expendable"], char: "♟", fitzpatrick_scale: !1, category: "activity" }, slot_machine: { keywords: ["bet", "gamble", "vegas", "fruit machine", "luck", "casino"], char: "🎰", fitzpatrick_scale: !1, category: "activity" }, jigsaw: { keywords: ["interlocking", "puzzle", "piece"], char: "🧩", fitzpatrick_scale: !1, category: "activity" }, bowling: { keywords: ["sports", "fun", "play"], char: "🎳", fitzpatrick_scale: !1, category: "activity" }, red_car: { keywords: ["red", "transportation", "vehicle"], char: "🚗", fitzpatrick_scale: !1, category: "travel_and_places" }, taxi: { keywords: ["uber", "vehicle", "cars", "transportation"], char: "🚕", fitzpatrick_scale: !1, category: "travel_and_places" }, blue_car: { keywords: ["transportation", "vehicle"], char: "🚙", fitzpatrick_scale: !1, category: "travel_and_places" }, bus: { keywords: ["car", "vehicle", "transportation"], char: "🚌", fitzpatrick_scale: !1, category: "travel_and_places" }, trolleybus: { keywords: ["bart", "transportation", "vehicle"], char: "🚎", fitzpatrick_scale: !1, category: "travel_and_places" }, racing_car: { keywords: ["sports", "race", "fast", "formula", "f1"], char: "🏎", fitzpatrick_scale: !1, category: "travel_and_places" }, police_car: { keywords: ["vehicle", "cars", "transportation", "law", "legal", "enforcement"], char: "🚓", fitzpatrick_scale: !1, category: "travel_and_places" }, ambulance: { keywords: ["health", "911", "hospital"], char: "🚑", fitzpatrick_scale: !1, category: "travel_and_places" }, fire_engine: { keywords: ["transportation", "cars", "vehicle"], char: "🚒", fitzpatrick_scale: !1, category: "travel_and_places" }, minibus: { keywords: ["vehicle", "car", "transportation"], char: "🚐", fitzpatrick_scale: !1, category: "travel_and_places" }, truck: { keywords: ["cars", "transportation"], char: "🚚", fitzpatrick_scale: !1, category: "travel_and_places" }, articulated_lorry: { keywords: ["vehicle", "cars", "transportation", "express"], char: "🚛", fitzpatrick_scale: !1, category: "travel_and_places" }, tractor: { keywords: ["vehicle", "car", "farming", "agriculture"], char: "🚜", fitzpatrick_scale: !1, category: "travel_and_places" }, kick_scooter: { keywords: ["vehicle", "kick", "razor"], char: "🛴", fitzpatrick_scale: !1, category: "travel_and_places" }, motorcycle: { keywords: ["race", "sports", "fast"], char: "🏍", fitzpatrick_scale: !1, category: "travel_and_places" }, bike: { keywords: ["sports", "bicycle", "exercise", "hipster"], char: "🚲", fitzpatrick_scale: !1, category: "travel_and_places" }, motor_scooter: { keywords: ["vehicle", "vespa", "sasha"], char: "🛵", fitzpatrick_scale: !1, category: "travel_and_places" }, rotating_light: { keywords: ["police", "ambulance", "911", "emergency", "alert", "error", "pinged", "law", "legal"], char: "🚨", fitzpatrick_scale: !1, category: "travel_and_places" }, oncoming_police_car: { keywords: ["vehicle", "law", "legal", "enforcement", "911"], char: "🚔", fitzpatrick_scale: !1, category: "travel_and_places" }, oncoming_bus: { keywords: ["vehicle", "transportation"], char: "🚍", fitzpatrick_scale: !1, category: "travel_and_places" }, oncoming_automobile: { keywords: ["car", "vehicle", "transportation"], char: "🚘", fitzpatrick_scale: !1, category: "travel_and_places" }, oncoming_taxi: { keywords: ["vehicle", "cars", "uber"], char: "🚖", fitzpatrick_scale: !1, category: "travel_and_places" }, aerial_tramway: { keywords: ["transportation", "vehicle", "ski"], char: "🚡", fitzpatrick_scale: !1, category: "travel_and_places" }, mountain_cableway: { keywords: ["transportation", "vehicle", "ski"], char: "🚠", fitzpatrick_scale: !1, category: "travel_and_places" }, suspension_railway: { keywords: ["vehicle", "transportation"], char: "🚟", fitzpatrick_scale: !1, category: "travel_and_places" }, railway_car: { keywords: ["transportation", "vehicle"], char: "🚃", fitzpatrick_scale: !1, category: "travel_and_places" }, train: { keywords: ["transportation", "vehicle", "carriage", "public", "travel"], char: "🚋", fitzpatrick_scale: !1, category: "travel_and_places" }, monorail: { keywords: ["transportation", "vehicle"], char: "🚝", fitzpatrick_scale: !1, category: "travel_and_places" }, bullettrain_side: { keywords: ["transportation", "vehicle"], char: "🚄", fitzpatrick_scale: !1, category: "travel_and_places" }, bullettrain_front: { keywords: ["transportation", "vehicle", "speed", "fast", "public", "travel"], char: "🚅", fitzpatrick_scale: !1, category: "travel_and_places" }, light_rail: { keywords: ["transportation", "vehicle"], char: "🚈", fitzpatrick_scale: !1, category: "travel_and_places" }, mountain_railway: { keywords: ["transportation", "vehicle"], char: "🚞", fitzpatrick_scale: !1, category: "travel_and_places" }, steam_locomotive: { keywords: ["transportation", "vehicle", "train"], char: "🚂", fitzpatrick_scale: !1, category: "travel_and_places" }, train2: { keywords: ["transportation", "vehicle"], char: "🚆", fitzpatrick_scale: !1, category: "travel_and_places" }, metro: { keywords: ["transportation", "blue-square", "mrt", "underground", "tube"], char: "🚇", fitzpatrick_scale: !1, category: "travel_and_places" }, tram: { keywords: ["transportation", "vehicle"], char: "🚊", fitzpatrick_scale: !1, category: "travel_and_places" }, station: { keywords: ["transportation", "vehicle", "public"], char: "🚉", fitzpatrick_scale: !1, category: "travel_and_places" }, flying_saucer: { keywords: ["transportation", "vehicle", "ufo"], char: "🛸", fitzpatrick_scale: !1, category: "travel_and_places" }, helicopter: { keywords: ["transportation", "vehicle", "fly"], char: "🚁", fitzpatrick_scale: !1, category: "travel_and_places" }, small_airplane: { keywords: ["flight", "transportation", "fly", "vehicle"], char: "🛩", fitzpatrick_scale: !1, category: "travel_and_places" }, airplane: { keywords: ["vehicle", "transportation", "flight", "fly"], char: "✈️", fitzpatrick_scale: !1, category: "travel_and_places" }, flight_departure: { keywords: ["airport", "flight", "landing"], char: "🛫", fitzpatrick_scale: !1, category: "travel_and_places" }, flight_arrival: { keywords: ["airport", "flight", "boarding"], char: "🛬", fitzpatrick_scale: !1, category: "travel_and_places" }, sailboat: { keywords: ["ship", "summer", "transportation", "water", "sailing"], char: "⛵", fitzpatrick_scale: !1, category: "travel_and_places" }, motor_boat: { keywords: ["ship"], char: "🛥", fitzpatrick_scale: !1, category: "travel_and_places" }, speedboat: { keywords: ["ship", "transportation", "vehicle", "summer"], char: "🚤", fitzpatrick_scale: !1, category: "travel_and_places" }, ferry: { keywords: ["boat", "ship", "yacht"], char: "⛴", fitzpatrick_scale: !1, category: "travel_and_places" }, passenger_ship: { keywords: ["yacht", "cruise", "ferry"], char: "🛳", fitzpatrick_scale: !1, category: "travel_and_places" }, rocket: { keywords: ["launch", "ship", "staffmode", "NASA", "outer space", "outer_space", "fly"], char: "🚀", fitzpatrick_scale: !1, category: "travel_and_places" }, artificial_satellite: { keywords: ["communication", "gps", "orbit", "spaceflight", "NASA", "ISS"], char: "🛰", fitzpatrick_scale: !1, category: "travel_and_places" }, seat: { keywords: ["sit", "airplane", "transport", "bus", "flight", "fly"], char: "💺", fitzpatrick_scale: !1, category: "travel_and_places" }, canoe: { keywords: ["boat", "paddle", "water", "ship"], char: "🛶", fitzpatrick_scale: !1, category: "travel_and_places" }, anchor: { keywords: ["ship", "ferry", "sea", "boat"], char: "⚓", fitzpatrick_scale: !1, category: "travel_and_places" }, construction: { keywords: ["wip", "progress", "caution", "warning"], char: "🚧", fitzpatrick_scale: !1, category: "travel_and_places" }, fuelpump: { keywords: ["gas station", "petroleum"], char: "⛽", fitzpatrick_scale: !1, category: "travel_and_places" }, busstop: { keywords: ["transportation", "wait"], char: "🚏", fitzpatrick_scale: !1, category: "travel_and_places" }, vertical_traffic_light: { keywords: ["transportation", "driving"], char: "🚦", fitzpatrick_scale: !1, category: "travel_and_places" }, traffic_light: { keywords: ["transportation", "signal"], char: "🚥", fitzpatrick_scale: !1, category: "travel_and_places" }, checkered_flag: { keywords: ["contest", "finishline", "race", "gokart"], char: "🏁", fitzpatrick_scale: !1, category: "travel_and_places" }, ship: { keywords: ["transportation", "titanic", "deploy"], char: "🚢", fitzpatrick_scale: !1, category: "travel_and_places" }, ferris_wheel: { keywords: ["photo", "carnival", "londoneye"], char: "🎡", fitzpatrick_scale: !1, category: "travel_and_places" }, roller_coaster: { keywords: ["carnival", "playground", "photo", "fun"], char: "🎢", fitzpatrick_scale: !1, category: "travel_and_places" }, carousel_horse: { keywords: ["photo", "carnival"], char: "🎠", fitzpatrick_scale: !1, category: "travel_and_places" }, building_construction: { keywords: ["wip", "working", "progress"], char: "🏗", fitzpatrick_scale: !1, category: "travel_and_places" }, foggy: { keywords: ["photo", "mountain"], char: "🌁", fitzpatrick_scale: !1, category: "travel_and_places" }, tokyo_tower: { keywords: ["photo", "japanese"], char: "🗼", fitzpatrick_scale: !1, category: "travel_and_places" }, factory: { keywords: ["building", "industry", "pollution", "smoke"], char: "🏭", fitzpatrick_scale: !1, category: "travel_and_places" }, fountain: { keywords: ["photo", "summer", "water", "fresh"], char: "⛲", fitzpatrick_scale: !1, category: "travel_and_places" }, rice_scene: { keywords: ["photo", "japan", "asia", "tsukimi"], char: "🎑", fitzpatrick_scale: !1, category: "travel_and_places" }, mountain: { keywords: ["photo", "nature", "environment"], char: "⛰", fitzpatrick_scale: !1, category: "travel_and_places" }, mountain_snow: { keywords: ["photo", "nature", "environment", "winter", "cold"], char: "🏔", fitzpatrick_scale: !1, category: "travel_and_places" }, mount_fuji: { keywords: ["photo", "mountain", "nature", "japanese"], char: "🗻", fitzpatrick_scale: !1, category: "travel_and_places" }, volcano: { keywords: ["photo", "nature", "disaster"], char: "🌋", fitzpatrick_scale: !1, category: "travel_and_places" }, japan: { keywords: ["nation", "country", "japanese", "asia"], char: "🗾", fitzpatrick_scale: !1, category: "travel_and_places" }, camping: { keywords: ["photo", "outdoors", "tent"], char: "🏕", fitzpatrick_scale: !1, category: "travel_and_places" }, tent: { keywords: ["photo", "camping", "outdoors"], char: "⛺", fitzpatrick_scale: !1, category: "travel_and_places" }, national_park: { keywords: ["photo", "environment", "nature"], char: "🏞", fitzpatrick_scale: !1, category: "travel_and_places" }, motorway: { keywords: ["road", "cupertino", "interstate", "highway"], char: "🛣", fitzpatrick_scale: !1, category: "travel_and_places" }, railway_track: { keywords: ["train", "transportation"], char: "🛤", fitzpatrick_scale: !1, category: "travel_and_places" }, sunrise: { keywords: ["morning", "view", "vacation", "photo"], char: "🌅", fitzpatrick_scale: !1, category: "travel_and_places" }, sunrise_over_mountains: { keywords: ["view", "vacation", "photo"], char: "🌄", fitzpatrick_scale: !1, category: "travel_and_places" }, desert: { keywords: ["photo", "warm", "saharah"], char: "🏜", fitzpatrick_scale: !1, category: "travel_and_places" }, beach_umbrella: { keywords: ["weather", "summer", "sunny", "sand", "mojito"], char: "🏖", fitzpatrick_scale: !1, category: "travel_and_places" }, desert_island: { keywords: ["photo", "tropical", "mojito"], char: "🏝", fitzpatrick_scale: !1, category: "travel_and_places" }, city_sunrise: { keywords: ["photo", "good morning", "dawn"], char: "🌇", fitzpatrick_scale: !1, category: "travel_and_places" }, city_sunset: { keywords: ["photo", "evening", "sky", "buildings"], char: "🌆", fitzpatrick_scale: !1, category: "travel_and_places" }, cityscape: { keywords: ["photo", "night life", "urban"], char: "🏙", fitzpatrick_scale: !1, category: "travel_and_places" }, night_with_stars: { keywords: ["evening", "city", "downtown"], char: "🌃", fitzpatrick_scale: !1, category: "travel_and_places" }, bridge_at_night: { keywords: ["photo", "sanfrancisco"], char: "🌉", fitzpatrick_scale: !1, category: "travel_and_places" }, milky_way: { keywords: ["photo", "space", "stars"], char: "🌌", fitzpatrick_scale: !1, category: "travel_and_places" }, stars: { keywords: ["night", "photo"], char: "🌠", fitzpatrick_scale: !1, category: "travel_and_places" }, sparkler: { keywords: ["stars", "night", "shine"], char: "🎇", fitzpatrick_scale: !1, category: "travel_and_places" }, fireworks: { keywords: ["photo", "festival", "carnival", "congratulations"], char: "🎆", fitzpatrick_scale: !1, category: "travel_and_places" }, rainbow: { keywords: ["nature", "happy", "unicorn_face", "photo", "sky", "spring"], char: "🌈", fitzpatrick_scale: !1, category: "travel_and_places" }, houses: { keywords: ["buildings", "photo"], char: "🏘", fitzpatrick_scale: !1, category: "travel_and_places" }, european_castle: { keywords: ["building", "royalty", "history"], char: "🏰", fitzpatrick_scale: !1, category: "travel_and_places" }, japanese_castle: { keywords: ["photo", "building"], char: "🏯", fitzpatrick_scale: !1, category: "travel_and_places" }, stadium: { keywords: ["photo", "place", "sports", "concert", "venue"], char: "🏟", fitzpatrick_scale: !1, category: "travel_and_places" }, statue_of_liberty: { keywords: ["american", "newyork"], char: "🗽", fitzpatrick_scale: !1, category: "travel_and_places" }, house: { keywords: ["building", "home"], char: "🏠", fitzpatrick_scale: !1, category: "travel_and_places" }, house_with_garden: { keywords: ["home", "plant", "nature"], char: "🏡", fitzpatrick_scale: !1, category: "travel_and_places" }, derelict_house: { keywords: ["abandon", "evict", "broken", "building"], char: "🏚", fitzpatrick_scale: !1, category: "travel_and_places" }, office: { keywords: ["building", "bureau", "work"], char: "🏢", fitzpatrick_scale: !1, category: "travel_and_places" }, department_store: { keywords: ["building", "shopping", "mall"], char: "🏬", fitzpatrick_scale: !1, category: "travel_and_places" }, post_office: { keywords: ["building", "envelope", "communication"], char: "🏣", fitzpatrick_scale: !1, category: "travel_and_places" }, european_post_office: { keywords: ["building", "email"], char: "🏤", fitzpatrick_scale: !1, category: "travel_and_places" }, hospital: { keywords: ["building", "health", "surgery", "doctor"], char: "🏥", fitzpatrick_scale: !1, category: "travel_and_places" }, bank: { keywords: ["building", "money", "sales", "cash", "business", "enterprise"], char: "🏦", fitzpatrick_scale: !1, category: "travel_and_places" }, hotel: { keywords: ["building", "accomodation", "checkin"], char: "🏨", fitzpatrick_scale: !1, category: "travel_and_places" }, convenience_store: { keywords: ["building", "shopping", "groceries"], char: "🏪", fitzpatrick_scale: !1, category: "travel_and_places" }, school: { keywords: ["building", "student", "education", "learn", "teach"], char: "🏫", fitzpatrick_scale: !1, category: "travel_and_places" }, love_hotel: { keywords: ["like", "affection", "dating"], char: "🏩", fitzpatrick_scale: !1, category: "travel_and_places" }, wedding: { keywords: ["love", "like", "affection", "couple", "marriage", "bride", "groom"], char: "💒", fitzpatrick_scale: !1, category: "travel_and_places" }, classical_building: { keywords: ["art", "culture", "history"], char: "🏛", fitzpatrick_scale: !1, category: "travel_and_places" }, church: { keywords: ["building", "religion", "christ"], char: "⛪", fitzpatrick_scale: !1, category: "travel_and_places" }, mosque: { keywords: ["islam", "worship", "minaret"], char: "🕌", fitzpatrick_scale: !1, category: "travel_and_places" }, synagogue: { keywords: ["judaism", "worship", "temple", "jewish"], char: "🕍", fitzpatrick_scale: !1, category: "travel_and_places" }, kaaba: { keywords: ["mecca", "mosque", "islam"], char: "🕋", fitzpatrick_scale: !1, category: "travel_and_places" }, shinto_shrine: { keywords: ["temple", "japan", "kyoto"], char: "⛩", fitzpatrick_scale: !1, category: "travel_and_places" }, watch: { keywords: ["time", "accessories"], char: "⌚", fitzpatrick_scale: !1, category: "objects" }, iphone: { keywords: ["technology", "apple", "gadgets", "dial"], char: "📱", fitzpatrick_scale: !1, category: "objects" }, calling: { keywords: ["iphone", "incoming"], char: "📲", fitzpatrick_scale: !1, category: "objects" }, computer: { keywords: ["technology", "laptop", "screen", "display", "monitor"], char: "💻", fitzpatrick_scale: !1, category: "objects" }, keyboard: { keywords: ["technology", "computer", "type", "input", "text"], char: "⌨", fitzpatrick_scale: !1, category: "objects" }, desktop_computer: { keywords: ["technology", "computing", "screen"], char: "🖥", fitzpatrick_scale: !1, category: "objects" }, printer: { keywords: ["paper", "ink"], char: "🖨", fitzpatrick_scale: !1, category: "objects" }, computer_mouse: { keywords: ["click"], char: "🖱", fitzpatrick_scale: !1, category: "objects" }, trackball: { keywords: ["technology", "trackpad"], char: "🖲", fitzpatrick_scale: !1, category: "objects" }, joystick: { keywords: ["game", "play"], char: "🕹", fitzpatrick_scale: !1, category: "objects" }, clamp: { keywords: ["tool"], char: "🗜", fitzpatrick_scale: !1, category: "objects" }, minidisc: { keywords: ["technology", "record", "data", "disk", "90s"], char: "💽", fitzpatrick_scale: !1, category: "objects" }, floppy_disk: { keywords: ["oldschool", "technology", "save", "90s", "80s"], char: "💾", fitzpatrick_scale: !1, category: "objects" }, cd: { keywords: ["technology", "dvd", "disk", "disc", "90s"], char: "💿", fitzpatrick_scale: !1, category: "objects" }, dvd: { keywords: ["cd", "disk", "disc"], char: "📀", fitzpatrick_scale: !1, category: "objects" }, vhs: { keywords: ["record", "video", "oldschool", "90s", "80s"], char: "📼", fitzpatrick_scale: !1, category: "objects" }, camera: { keywords: ["gadgets", "photography"], char: "📷", fitzpatrick_scale: !1, category: "objects" }, camera_flash: { keywords: ["photography", "gadgets"], char: "📸", fitzpatrick_scale: !1, category: "objects" }, video_camera: { keywords: ["film", "record"], char: "📹", fitzpatrick_scale: !1, category: "objects" }, movie_camera: { keywords: ["film", "record"], char: "🎥", fitzpatrick_scale: !1, category: "objects" }, film_projector: { keywords: ["video", "tape", "record", "movie"], char: "📽", fitzpatrick_scale: !1, category: "objects" }, film_strip: { keywords: ["movie"], char: "🎞", fitzpatrick_scale: !1, category: "objects" }, telephone_receiver: { keywords: ["technology", "communication", "dial"], char: "📞", fitzpatrick_scale: !1, category: "objects" }, phone: { keywords: ["technology", "communication", "dial", "telephone"], char: "☎️", fitzpatrick_scale: !1, category: "objects" }, pager: { keywords: ["bbcall", "oldschool", "90s"], char: "📟", fitzpatrick_scale: !1, category: "objects" }, fax: { keywords: ["communication", "technology"], char: "📠", fitzpatrick_scale: !1, category: "objects" }, tv: { keywords: ["technology", "program", "oldschool", "show", "television"], char: "📺", fitzpatrick_scale: !1, category: "objects" }, radio: { keywords: ["communication", "music", "podcast", "program"], char: "📻", fitzpatrick_scale: !1, category: "objects" }, studio_microphone: { keywords: ["sing", "recording", "artist", "talkshow"], char: "🎙", fitzpatrick_scale: !1, category: "objects" }, level_slider: { keywords: ["scale"], char: "🎚", fitzpatrick_scale: !1, category: "objects" }, control_knobs: { keywords: ["dial"], char: "🎛", fitzpatrick_scale: !1, category: "objects" }, compass: { keywords: ["magnetic", "navigation", "orienteering"], char: "🧭", fitzpatrick_scale: !1, category: "objects" }, stopwatch: { keywords: ["time", "deadline"], char: "⏱", fitzpatrick_scale: !1, category: "objects" }, timer_clock: { keywords: ["alarm"], char: "⏲", fitzpatrick_scale: !1, category: "objects" }, alarm_clock: { keywords: ["time", "wake"], char: "⏰", fitzpatrick_scale: !1, category: "objects" }, mantelpiece_clock: { keywords: ["time"], char: "🕰", fitzpatrick_scale: !1, category: "objects" }, hourglass_flowing_sand: { keywords: ["oldschool", "time", "countdown"], char: "⏳", fitzpatrick_scale: !1, category: "objects" }, hourglass: { keywords: ["time", "clock", "oldschool", "limit", "exam", "quiz", "test"], char: "⌛", fitzpatrick_scale: !1, category: "objects" }, satellite: { keywords: ["communication", "future", "radio", "space"], char: "📡", fitzpatrick_scale: !1, category: "objects" }, battery: { keywords: ["power", "energy", "sustain"], char: "🔋", fitzpatrick_scale: !1, category: "objects" }, electric_plug: { keywords: ["charger", "power"], char: "🔌", fitzpatrick_scale: !1, category: "objects" }, bulb: { keywords: ["light", "electricity", "idea"], char: "💡", fitzpatrick_scale: !1, category: "objects" }, flashlight: { keywords: ["dark", "camping", "sight", "night"], char: "🔦", fitzpatrick_scale: !1, category: "objects" }, candle: { keywords: ["fire", "wax"], char: "🕯", fitzpatrick_scale: !1, category: "objects" }, fire_extinguisher: { keywords: ["quench"], char: "🧯", fitzpatrick_scale: !1, category: "objects" }, wastebasket: { keywords: ["bin", "trash", "rubbish", "garbage", "toss"], char: "🗑", fitzpatrick_scale: !1, category: "objects" }, oil_drum: { keywords: ["barrell"], char: "🛢", fitzpatrick_scale: !1, category: "objects" }, money_with_wings: { keywords: ["dollar", "bills", "payment", "sale"], char: "💸", fitzpatrick_scale: !1, category: "objects" }, dollar: { keywords: ["money", "sales", "bill", "currency"], char: "💵", fitzpatrick_scale: !1, category: "objects" }, yen: { keywords: ["money", "sales", "japanese", "dollar", "currency"], char: "💴", fitzpatrick_scale: !1, category: "objects" }, euro: { keywords: ["money", "sales", "dollar", "currency"], char: "💶", fitzpatrick_scale: !1, category: "objects" }, pound: { keywords: ["british", "sterling", "money", "sales", "bills", "uk", "england", "currency"], char: "💷", fitzpatrick_scale: !1, category: "objects" }, moneybag: { keywords: ["dollar", "payment", "coins", "sale"], char: "💰", fitzpatrick_scale: !1, category: "objects" }, credit_card: { keywords: ["money", "sales", "dollar", "bill", "payment", "shopping"], char: "💳", fitzpatrick_scale: !1, category: "objects" }, gem: { keywords: ["blue", "ruby", "diamond", "jewelry"], char: "💎", fitzpatrick_scale: !1, category: "objects" }, balance_scale: { keywords: ["law", "fairness", "weight"], char: "⚖", fitzpatrick_scale: !1, category: "objects" }, toolbox: { keywords: ["tools", "diy", "fix", "maintainer", "mechanic"], char: "🧰", fitzpatrick_scale: !1, category: "objects" }, wrench: { keywords: ["tools", "diy", "ikea", "fix", "maintainer"], char: "🔧", fitzpatrick_scale: !1, category: "objects" }, hammer: { keywords: ["tools", "build", "create"], char: "🔨", fitzpatrick_scale: !1, category: "objects" }, hammer_and_pick: { keywords: ["tools", "build", "create"], char: "⚒", fitzpatrick_scale: !1, category: "objects" }, hammer_and_wrench: { keywords: ["tools", "build", "create"], char: "🛠", fitzpatrick_scale: !1, category: "objects" }, pick: { keywords: ["tools", "dig"], char: "⛏", fitzpatrick_scale: !1, category: "objects" }, nut_and_bolt: { keywords: ["handy", "tools", "fix"], char: "🔩", fitzpatrick_scale: !1, category: "objects" }, gear: { keywords: ["cog"], char: "⚙", fitzpatrick_scale: !1, category: "objects" }, brick: { keywords: ["bricks"], char: "🧱", fitzpatrick_scale: !1, category: "objects" }, chains: { keywords: ["lock", "arrest"], char: "⛓", fitzpatrick_scale: !1, category: "objects" }, magnet: { keywords: ["attraction", "magnetic"], char: "🧲", fitzpatrick_scale: !1, category: "objects" }, gun: { keywords: ["violence", "weapon", "pistol", "revolver"], char: "🔫", fitzpatrick_scale: !1, category: "objects" }, bomb: { keywords: ["boom", "explode", "explosion", "terrorism"], char: "💣", fitzpatrick_scale: !1, category: "objects" }, firecracker: { keywords: ["dynamite", "boom", "explode", "explosion", "explosive"], char: "🧨", fitzpatrick_scale: !1, category: "objects" }, hocho: { keywords: ["knife", "blade", "cutlery", "kitchen", "weapon"], char: "🔪", fitzpatrick_scale: !1, category: "objects" }, dagger: { keywords: ["weapon"], char: "🗡", fitzpatrick_scale: !1, category: "objects" }, crossed_swords: { keywords: ["weapon"], char: "⚔", fitzpatrick_scale: !1, category: "objects" }, shield: { keywords: ["protection", "security"], char: "🛡", fitzpatrick_scale: !1, category: "objects" }, smoking: { keywords: ["kills", "tobacco", "cigarette", "joint", "smoke"], char: "🚬", fitzpatrick_scale: !1, category: "objects" }, skull_and_crossbones: { keywords: ["poison", "danger", "deadly", "scary", "death", "pirate", "evil"], char: "☠", fitzpatrick_scale: !1, category: "objects" }, coffin: { keywords: ["vampire", "dead", "die", "death", "rip", "graveyard", "cemetery", "casket", "funeral", "box"], char: "⚰", fitzpatrick_scale: !1, category: "objects" }, funeral_urn: { keywords: ["dead", "die", "death", "rip", "ashes"], char: "⚱", fitzpatrick_scale: !1, category: "objects" }, amphora: { keywords: ["vase", "jar"], char: "🏺", fitzpatrick_scale: !1, category: "objects" }, crystal_ball: { keywords: ["disco", "party", "magic", "circus", "fortune_teller"], char: "🔮", fitzpatrick_scale: !1, category: "objects" }, prayer_beads: { keywords: ["dhikr", "religious"], char: "📿", fitzpatrick_scale: !1, category: "objects" }, nazar_amulet: { keywords: ["bead", "charm"], char: "🧿", fitzpatrick_scale: !1, category: "objects" }, barber: { keywords: ["hair", "salon", "style"], char: "💈", fitzpatrick_scale: !1, category: "objects" }, alembic: { keywords: ["distilling", "science", "experiment", "chemistry"], char: "⚗", fitzpatrick_scale: !1, category: "objects" }, telescope: { keywords: ["stars", "space", "zoom", "science", "astronomy"], char: "🔭", fitzpatrick_scale: !1, category: "objects" }, microscope: { keywords: ["laboratory", "experiment", "zoomin", "science", "study"], char: "🔬", fitzpatrick_scale: !1, category: "objects" }, hole: { keywords: ["embarrassing"], char: "🕳", fitzpatrick_scale: !1, category: "objects" }, pill: { keywords: ["health", "medicine", "doctor", "pharmacy", "drug"], char: "💊", fitzpatrick_scale: !1, category: "objects" }, syringe: { keywords: ["health", "hospital", "drugs", "blood", "medicine", "needle", "doctor", "nurse"], char: "💉", fitzpatrick_scale: !1, category: "objects" }, dna: { keywords: ["biologist", "genetics", "life"], char: "🧬", fitzpatrick_scale: !1, category: "objects" }, microbe: { keywords: ["amoeba", "bacteria", "germs"], char: "🦠", fitzpatrick_scale: !1, category: "objects" }, petri_dish: { keywords: ["bacteria", "biology", "culture", "lab"], char: "🧫", fitzpatrick_scale: !1, category: "objects" }, test_tube: { keywords: ["chemistry", "experiment", "lab", "science"], char: "🧪", fitzpatrick_scale: !1, category: "objects" }, thermometer: { keywords: ["weather", "temperature", "hot", "cold"], char: "🌡", fitzpatrick_scale: !1, category: "objects" }, broom: { keywords: ["cleaning", "sweeping", "witch"], char: "🧹", fitzpatrick_scale: !1, category: "objects" }, basket: { keywords: ["laundry"], char: "🧺", fitzpatrick_scale: !1, category: "objects" }, toilet_paper: { keywords: ["roll"], char: "🧻", fitzpatrick_scale: !1, category: "objects" }, label: { keywords: ["sale", "tag"], char: "🏷", fitzpatrick_scale: !1, category: "objects" }, bookmark: { keywords: ["favorite", "label", "save"], char: "🔖", fitzpatrick_scale: !1, category: "objects" }, toilet: { keywords: ["restroom", "wc", "washroom", "bathroom", "potty"], char: "🚽", fitzpatrick_scale: !1, category: "objects" }, shower: { keywords: ["clean", "water", "bathroom"], char: "🚿", fitzpatrick_scale: !1, category: "objects" }, bathtub: { keywords: ["clean", "shower", "bathroom"], char: "🛁", fitzpatrick_scale: !1, category: "objects" }, soap: { keywords: ["bar", "bathing", "cleaning", "lather"], char: "🧼", fitzpatrick_scale: !1, category: "objects" }, sponge: { keywords: ["absorbing", "cleaning", "porous"], char: "🧽", fitzpatrick_scale: !1, category: "objects" }, lotion_bottle: { keywords: ["moisturizer", "sunscreen"], char: "🧴", fitzpatrick_scale: !1, category: "objects" }, key: { keywords: ["lock", "door", "password"], char: "🔑", fitzpatrick_scale: !1, category: "objects" }, old_key: { keywords: ["lock", "door", "password"], char: "🗝", fitzpatrick_scale: !1, category: "objects" }, couch_and_lamp: { keywords: ["read", "chill"], char: "🛋", fitzpatrick_scale: !1, category: "objects" }, sleeping_bed: { keywords: ["bed", "rest"], char: "🛌", fitzpatrick_scale: !0, category: "objects" }, bed: { keywords: ["sleep", "rest"], char: "🛏", fitzpatrick_scale: !1, category: "objects" }, door: { keywords: ["house", "entry", "exit"], char: "🚪", fitzpatrick_scale: !1, category: "objects" }, bellhop_bell: { keywords: ["service"], char: "🛎", fitzpatrick_scale: !1, category: "objects" }, teddy_bear: { keywords: ["plush", "stuffed"], char: "🧸", fitzpatrick_scale: !1, category: "objects" }, framed_picture: { keywords: ["photography"], char: "🖼", fitzpatrick_scale: !1, category: "objects" }, world_map: { keywords: ["location", "direction"], char: "🗺", fitzpatrick_scale: !1, category: "objects" }, parasol_on_ground: { keywords: ["weather", "summer"], char: "⛱", fitzpatrick_scale: !1, category: "objects" }, moyai: { keywords: ["rock", "easter island", "moai"], char: "🗿", fitzpatrick_scale: !1, category: "objects" }, shopping: { keywords: ["mall", "buy", "purchase"], char: "🛍", fitzpatrick_scale: !1, category: "objects" }, shopping_cart: { keywords: ["trolley"], char: "🛒", fitzpatrick_scale: !1, category: "objects" }, balloon: { keywords: ["party", "celebration", "birthday", "circus"], char: "🎈", fitzpatrick_scale: !1, category: "objects" }, flags: { keywords: ["fish", "japanese", "koinobori", "carp", "banner"], char: "🎏", fitzpatrick_scale: !1, category: "objects" }, ribbon: { keywords: ["decoration", "pink", "girl", "bowtie"], char: "🎀", fitzpatrick_scale: !1, category: "objects" }, gift: { keywords: ["present", "birthday", "christmas", "xmas"], char: "🎁", fitzpatrick_scale: !1, category: "objects" }, confetti_ball: { keywords: ["festival", "party", "birthday", "circus"], char: "🎊", fitzpatrick_scale: !1, category: "objects" }, tada: { keywords: ["party", "congratulations", "birthday", "magic", "circus", "celebration"], char: "🎉", fitzpatrick_scale: !1, category: "objects" }, dolls: { keywords: ["japanese", "toy", "kimono"], char: "🎎", fitzpatrick_scale: !1, category: "objects" }, wind_chime: { keywords: ["nature", "ding", "spring", "bell"], char: "🎐", fitzpatrick_scale: !1, category: "objects" }, crossed_flags: { keywords: ["japanese", "nation", "country", "border"], char: "🎌", fitzpatrick_scale: !1, category: "objects" }, izakaya_lantern: { keywords: ["light", "paper", "halloween", "spooky"], char: "🏮", fitzpatrick_scale: !1, category: "objects" }, red_envelope: { keywords: ["gift"], char: "🧧", fitzpatrick_scale: !1, category: "objects" }, email: { keywords: ["letter", "postal", "inbox", "communication"], char: "✉️", fitzpatrick_scale: !1, category: "objects" }, envelope_with_arrow: { keywords: ["email", "communication"], char: "📩", fitzpatrick_scale: !1, category: "objects" }, incoming_envelope: { keywords: ["email", "inbox"], char: "📨", fitzpatrick_scale: !1, category: "objects" }, "e-mail": { keywords: ["communication", "inbox"], char: "📧", fitzpatrick_scale: !1, category: "objects" }, love_letter: { keywords: ["email", "like", "affection", "envelope", "valentines"], char: "💌", fitzpatrick_scale: !1, category: "objects" }, postbox: { keywords: ["email", "letter", "envelope"], char: "📮", fitzpatrick_scale: !1, category: "objects" }, mailbox_closed: { keywords: ["email", "communication", "inbox"], char: "📪", fitzpatrick_scale: !1, category: "objects" }, mailbox: { keywords: ["email", "inbox", "communication"], char: "📫", fitzpatrick_scale: !1, category: "objects" }, mailbox_with_mail: { keywords: ["email", "inbox", "communication"], char: "📬", fitzpatrick_scale: !1, category: "objects" }, mailbox_with_no_mail: { keywords: ["email", "inbox"], char: "📭", fitzpatrick_scale: !1, category: "objects" }, package: { keywords: ["mail", "gift", "cardboard", "box", "moving"], char: "📦", fitzpatrick_scale: !1, category: "objects" }, postal_horn: { keywords: ["instrument", "music"], char: "📯", fitzpatrick_scale: !1, category: "objects" }, inbox_tray: { keywords: ["email", "documents"], char: "📥", fitzpatrick_scale: !1, category: "objects" }, outbox_tray: { keywords: ["inbox", "email"], char: "📤", fitzpatrick_scale: !1, category: "objects" }, scroll: { keywords: ["documents", "ancient", "history", "paper"], char: "📜", fitzpatrick_scale: !1, category: "objects" }, page_with_curl: { keywords: ["documents", "office", "paper"], char: "📃", fitzpatrick_scale: !1, category: "objects" }, bookmark_tabs: { keywords: ["favorite", "save", "order", "tidy"], char: "📑", fitzpatrick_scale: !1, category: "objects" }, receipt: { keywords: ["accounting", "expenses"], char: "🧾", fitzpatrick_scale: !1, category: "objects" }, bar_chart: { keywords: ["graph", "presentation", "stats"], char: "📊", fitzpatrick_scale: !1, category: "objects" }, chart_with_upwards_trend: { keywords: ["graph", "presentation", "stats", "recovery", "business", "economics", "money", "sales", "good", "success"], char: "📈", fitzpatrick_scale: !1, category: "objects" }, chart_with_downwards_trend: { keywords: ["graph", "presentation", "stats", "recession", "business", "economics", "money", "sales", "bad", "failure"], char: "📉", fitzpatrick_scale: !1, category: "objects" }, page_facing_up: { keywords: ["documents", "office", "paper", "information"], char: "📄", fitzpatrick_scale: !1, category: "objects" }, date: { keywords: ["calendar", "schedule"], char: "📅", fitzpatrick_scale: !1, category: "objects" }, calendar: { keywords: ["schedule", "date", "planning"], char: "📆", fitzpatrick_scale: !1, category: "objects" }, spiral_calendar: { keywords: ["date", "schedule", "planning"], char: "🗓", fitzpatrick_scale: !1, category: "objects" }, card_index: { keywords: ["business", "stationery"], char: "📇", fitzpatrick_scale: !1, category: "objects" }, card_file_box: { keywords: ["business", "stationery"], char: "🗃", fitzpatrick_scale: !1, category: "objects" }, ballot_box: { keywords: ["election", "vote"], char: "🗳", fitzpatrick_scale: !1, category: "objects" }, file_cabinet: { keywords: ["filing", "organizing"], char: "🗄", fitzpatrick_scale: !1, category: "objects" }, clipboard: { keywords: ["stationery", "documents"], char: "📋", fitzpatrick_scale: !1, category: "objects" }, spiral_notepad: { keywords: ["memo", "stationery"], char: "🗒", fitzpatrick_scale: !1, category: "objects" }, file_folder: { keywords: ["documents", "business", "office"], char: "📁", fitzpatrick_scale: !1, category: "objects" }, open_file_folder: { keywords: ["documents", "load"], char: "📂", fitzpatrick_scale: !1, category: "objects" }, card_index_dividers: { keywords: ["organizing", "business", "stationery"], char: "🗂", fitzpatrick_scale: !1, category: "objects" }, newspaper_roll: { keywords: ["press", "headline"], char: "🗞", fitzpatrick_scale: !1, category: "objects" }, newspaper: { keywords: ["press", "headline"], char: "📰", fitzpatrick_scale: !1, category: "objects" }, notebook: { keywords: ["stationery", "record", "notes", "paper", "study"], char: "📓", fitzpatrick_scale: !1, category: "objects" }, closed_book: { keywords: ["read", "library", "knowledge", "textbook", "learn"], char: "📕", fitzpatrick_scale: !1, category: "objects" }, green_book: { keywords: ["read", "library", "knowledge", "study"], char: "📗", fitzpatrick_scale: !1, category: "objects" }, blue_book: { keywords: ["read", "library", "knowledge", "learn", "study"], char: "📘", fitzpatrick_scale: !1, category: "objects" }, orange_book: { keywords: ["read", "library", "knowledge", "textbook", "study"], char: "📙", fitzpatrick_scale: !1, category: "objects" }, notebook_with_decorative_cover: { keywords: ["classroom", "notes", "record", "paper", "study"], char: "📔", fitzpatrick_scale: !1, category: "objects" }, ledger: { keywords: ["notes", "paper"], char: "📒", fitzpatrick_scale: !1, category: "objects" }, books: { keywords: ["literature", "library", "study"], char: "📚", fitzpatrick_scale: !1, category: "objects" }, open_book: { keywords: ["book", "read", "library", "knowledge", "literature", "learn", "study"], char: "📖", fitzpatrick_scale: !1, category: "objects" }, safety_pin: { keywords: ["diaper"], char: "🧷", fitzpatrick_scale: !1, category: "objects" }, link: { keywords: ["rings", "url"], char: "🔗", fitzpatrick_scale: !1, category: "objects" }, paperclip: { keywords: ["documents", "stationery"], char: "📎", fitzpatrick_scale: !1, category: "objects" }, paperclips: { keywords: ["documents", "stationery"], char: "🖇", fitzpatrick_scale: !1, category: "objects" }, scissors: { keywords: ["stationery", "cut"], char: "✂️", fitzpatrick_scale: !1, category: "objects" }, triangular_ruler: { keywords: ["stationery", "math", "architect", "sketch"], char: "📐", fitzpatrick_scale: !1, category: "objects" }, straight_ruler: { keywords: ["stationery", "calculate", "length", "math", "school", "drawing", "architect", "sketch"], char: "📏", fitzpatrick_scale: !1, category: "objects" }, abacus: { keywords: ["calculation"], char: "🧮", fitzpatrick_scale: !1, category: "objects" }, pushpin: { keywords: ["stationery", "mark", "here"], char: "📌", fitzpatrick_scale: !1, category: "objects" }, round_pushpin: { keywords: ["stationery", "location", "map", "here"], char: "📍", fitzpatrick_scale: !1, category: "objects" }, triangular_flag_on_post: { keywords: ["mark", "milestone", "place"], char: "🚩", fitzpatrick_scale: !1, category: "objects" }, white_flag: { keywords: ["losing", "loser", "lost", "surrender", "give up", "fail"], char: "🏳", fitzpatrick_scale: !1, category: "objects" }, black_flag: { keywords: ["pirate"], char: "🏴", fitzpatrick_scale: !1, category: "objects" }, rainbow_flag: { keywords: ["flag", "rainbow", "pride", "gay", "lgbt", "glbt", "queer", "homosexual", "lesbian", "bisexual", "transgender"], char: "🏳️‍🌈", fitzpatrick_scale: !1, category: "objects" }, closed_lock_with_key: { keywords: ["security", "privacy"], char: "🔐", fitzpatrick_scale: !1, category: "objects" }, lock: { keywords: ["security", "password", "padlock"], char: "🔒", fitzpatrick_scale: !1, category: "objects" }, unlock: { keywords: ["privacy", "security"], char: "🔓", fitzpatrick_scale: !1, category: "objects" }, lock_with_ink_pen: { keywords: ["security", "secret"], char: "🔏", fitzpatrick_scale: !1, category: "objects" }, pen: { keywords: ["stationery", "writing", "write"], char: "🖊", fitzpatrick_scale: !1, category: "objects" }, fountain_pen: { keywords: ["stationery", "writing", "write"], char: "🖋", fitzpatrick_scale: !1, category: "objects" }, black_nib: { keywords: ["pen", "stationery", "writing", "write"], char: "✒️", fitzpatrick_scale: !1, category: "objects" }, memo: { keywords: ["write", "documents", "stationery", "pencil", "paper", "writing", "legal", "exam", "quiz", "test", "study", "compose"], char: "📝", fitzpatrick_scale: !1, category: "objects" }, pencil2: { keywords: ["stationery", "write", "paper", "writing", "school", "study"], char: "✏️", fitzpatrick_scale: !1, category: "objects" }, crayon: { keywords: ["drawing", "creativity"], char: "🖍", fitzpatrick_scale: !1, category: "objects" }, paintbrush: { keywords: ["drawing", "creativity", "art"], char: "🖌", fitzpatrick_scale: !1, category: "objects" }, mag: { keywords: ["search", "zoom", "find", "detective"], char: "🔍", fitzpatrick_scale: !1, category: "objects" }, mag_right: { keywords: ["search", "zoom", "find", "detective"], char: "🔎", fitzpatrick_scale: !1, category: "objects" }, heart: { keywords: ["love", "like", "valentines"], char: "❤️", fitzpatrick_scale: !1, category: "symbols" }, orange_heart: { keywords: ["love", "like", "affection", "valentines"], char: "🧡", fitzpatrick_scale: !1, category: "symbols" }, yellow_heart: { keywords: ["love", "like", "affection", "valentines"], char: "💛", fitzpatrick_scale: !1, category: "symbols" }, green_heart: { keywords: ["love", "like", "affection", "valentines"], char: "💚", fitzpatrick_scale: !1, category: "symbols" }, blue_heart: { keywords: ["love", "like", "affection", "valentines"], char: "💙", fitzpatrick_scale: !1, category: "symbols" }, purple_heart: { keywords: ["love", "like", "affection", "valentines"], char: "💜", fitzpatrick_scale: !1, category: "symbols" }, black_heart: { keywords: ["evil"], char: "🖤", fitzpatrick_scale: !1, category: "symbols" }, broken_heart: { keywords: ["sad", "sorry", "break", "heart", "heartbreak"], char: "💔", fitzpatrick_scale: !1, category: "symbols" }, heavy_heart_exclamation: { keywords: ["decoration", "love"], char: "❣", fitzpatrick_scale: !1, category: "symbols" }, two_hearts: { keywords: ["love", "like", "affection", "valentines", "heart"], char: "💕", fitzpatrick_scale: !1, category: "symbols" }, revolving_hearts: { keywords: ["love", "like", "affection", "valentines"], char: "💞", fitzpatrick_scale: !1, category: "symbols" }, heartbeat: { keywords: ["love", "like", "affection", "valentines", "pink", "heart"], char: "💓", fitzpatrick_scale: !1, category: "symbols" }, heartpulse: { keywords: ["like", "love", "affection", "valentines", "pink"], char: "💗", fitzpatrick_scale: !1, category: "symbols" }, sparkling_heart: { keywords: ["love", "like", "affection", "valentines"], char: "💖", fitzpatrick_scale: !1, category: "symbols" }, cupid: { keywords: ["love", "like", "heart", "affection", "valentines"], char: "💘", fitzpatrick_scale: !1, category: "symbols" }, gift_heart: { keywords: ["love", "valentines"], char: "💝", fitzpatrick_scale: !1, category: "symbols" }, heart_decoration: { keywords: ["purple-square", "love", "like"], char: "💟", fitzpatrick_scale: !1, category: "symbols" }, peace_symbol: { keywords: ["hippie"], char: "☮", fitzpatrick_scale: !1, category: "symbols" }, latin_cross: { keywords: ["christianity"], char: "✝", fitzpatrick_scale: !1, category: "symbols" }, star_and_crescent: { keywords: ["islam"], char: "☪", fitzpatrick_scale: !1, category: "symbols" }, om: { keywords: ["hinduism", "buddhism", "sikhism", "jainism"], char: "🕉", fitzpatrick_scale: !1, category: "symbols" }, wheel_of_dharma: { keywords: ["hinduism", "buddhism", "sikhism", "jainism"], char: "☸", fitzpatrick_scale: !1, category: "symbols" }, star_of_david: { keywords: ["judaism"], char: "✡", fitzpatrick_scale: !1, category: "symbols" }, six_pointed_star: { keywords: ["purple-square", "religion", "jewish", "hexagram"], char: "🔯", fitzpatrick_scale: !1, category: "symbols" }, menorah: { keywords: ["hanukkah", "candles", "jewish"], char: "🕎", fitzpatrick_scale: !1, category: "symbols" }, yin_yang: { keywords: ["balance"], char: "☯", fitzpatrick_scale: !1, category: "symbols" }, orthodox_cross: { keywords: ["suppedaneum", "religion"], char: "☦", fitzpatrick_scale: !1, category: "symbols" }, place_of_worship: { keywords: ["religion", "church", "temple", "prayer"], char: "🛐", fitzpatrick_scale: !1, category: "symbols" }, ophiuchus: { keywords: ["sign", "purple-square", "constellation", "astrology"], char: "⛎", fitzpatrick_scale: !1, category: "symbols" }, aries: { keywords: ["sign", "purple-square", "zodiac", "astrology"], char: "♈", fitzpatrick_scale: !1, category: "symbols" }, taurus: { keywords: ["purple-square", "sign", "zodiac", "astrology"], char: "♉", fitzpatrick_scale: !1, category: "symbols" }, gemini: { keywords: ["sign", "zodiac", "purple-square", "astrology"], char: "♊", fitzpatrick_scale: !1, category: "symbols" }, cancer: { keywords: ["sign", "zodiac", "purple-square", "astrology"], char: "♋", fitzpatrick_scale: !1, category: "symbols" }, leo: { keywords: ["sign", "purple-square", "zodiac", "astrology"], char: "♌", fitzpatrick_scale: !1, category: "symbols" }, virgo: { keywords: ["sign", "zodiac", "purple-square", "astrology"], char: "♍", fitzpatrick_scale: !1, category: "symbols" }, libra: { keywords: ["sign", "purple-square", "zodiac", "astrology"], char: "♎", fitzpatrick_scale: !1, category: "symbols" }, scorpius: { keywords: ["sign", "zodiac", "purple-square", "astrology", "scorpio"], char: "♏", fitzpatrick_scale: !1, category: "symbols" }, sagittarius: { keywords: ["sign", "zodiac", "purple-square", "astrology"], char: "♐", fitzpatrick_scale: !1, category: "symbols" }, capricorn: { keywords: ["sign", "zodiac", "purple-square", "astrology"], char: "♑", fitzpatrick_scale: !1, category: "symbols" }, aquarius: { keywords: ["sign", "purple-square", "zodiac", "astrology"], char: "♒", fitzpatrick_scale: !1, category: "symbols" }, pisces: { keywords: ["purple-square", "sign", "zodiac", "astrology"], char: "♓", fitzpatrick_scale: !1, category: "symbols" }, id: { keywords: ["purple-square", "words"], char: "🆔", fitzpatrick_scale: !1, category: "symbols" }, atom_symbol: { keywords: ["science", "physics", "chemistry"], char: "⚛", fitzpatrick_scale: !1, category: "symbols" }, u7a7a: { keywords: ["kanji", "japanese", "chinese", "empty", "sky", "blue-square"], char: "🈳", fitzpatrick_scale: !1, category: "symbols" }, u5272: { keywords: ["cut", "divide", "chinese", "kanji", "pink-square"], char: "🈹", fitzpatrick_scale: !1, category: "symbols" }, radioactive: { keywords: ["nuclear", "danger"], char: "☢", fitzpatrick_scale: !1, category: "symbols" }, biohazard: { keywords: ["danger"], char: "☣", fitzpatrick_scale: !1, category: "symbols" }, mobile_phone_off: { keywords: ["mute", "orange-square", "silence", "quiet"], char: "📴", fitzpatrick_scale: !1, category: "symbols" }, vibration_mode: { keywords: ["orange-square", "phone"], char: "📳", fitzpatrick_scale: !1, category: "symbols" }, u6709: { keywords: ["orange-square", "chinese", "have", "kanji"], char: "🈶", fitzpatrick_scale: !1, category: "symbols" }, u7121: { keywords: ["nothing", "chinese", "kanji", "japanese", "orange-square"], char: "🈚", fitzpatrick_scale: !1, category: "symbols" }, u7533: { keywords: ["chinese", "japanese", "kanji", "orange-square"], char: "🈸", fitzpatrick_scale: !1, category: "symbols" }, u55b6: { keywords: ["japanese", "opening hours", "orange-square"], char: "🈺", fitzpatrick_scale: !1, category: "symbols" }, u6708: { keywords: ["chinese", "month", "moon", "japanese", "orange-square", "kanji"], char: "🈷️", fitzpatrick_scale: !1, category: "symbols" }, eight_pointed_black_star: { keywords: ["orange-square", "shape", "polygon"], char: "✴️", fitzpatrick_scale: !1, category: "symbols" }, vs: { keywords: ["words", "orange-square"], char: "🆚", fitzpatrick_scale: !1, category: "symbols" }, accept: { keywords: ["ok", "good", "chinese", "kanji", "agree", "yes", "orange-circle"], char: "🉑", fitzpatrick_scale: !1, category: "symbols" }, white_flower: { keywords: ["japanese", "spring"], char: "💮", fitzpatrick_scale: !1, category: "symbols" }, ideograph_advantage: { keywords: ["chinese", "kanji", "obtain", "get", "circle"], char: "🉐", fitzpatrick_scale: !1, category: "symbols" }, secret: { keywords: ["privacy", "chinese", "sshh", "kanji", "red-circle"], char: "㊙️", fitzpatrick_scale: !1, category: "symbols" }, congratulations: { keywords: ["chinese", "kanji", "japanese", "red-circle"], char: "㊗️", fitzpatrick_scale: !1, category: "symbols" }, u5408: { keywords: ["japanese", "chinese", "join", "kanji", "red-square"], char: "🈴", fitzpatrick_scale: !1, category: "symbols" }, u6e80: { keywords: ["full", "chinese", "japanese", "red-square", "kanji"], char: "🈵", fitzpatrick_scale: !1, category: "symbols" }, u7981: { keywords: ["kanji", "japanese", "chinese", "forbidden", "limit", "restricted", "red-square"], char: "🈲", fitzpatrick_scale: !1, category: "symbols" }, a: { keywords: ["red-square", "alphabet", "letter"], char: "🅰️", fitzpatrick_scale: !1, category: "symbols" }, b: { keywords: ["red-square", "alphabet", "letter"], char: "🅱️", fitzpatrick_scale: !1, category: "symbols" }, ab: { keywords: ["red-square", "alphabet"], char: "🆎", fitzpatrick_scale: !1, category: "symbols" }, cl: { keywords: ["alphabet", "words", "red-square"], char: "🆑", fitzpatrick_scale: !1, category: "symbols" }, o2: { keywords: ["alphabet", "red-square", "letter"], char: "🅾️", fitzpatrick_scale: !1, category: "symbols" }, sos: { keywords: ["help", "red-square", "words", "emergency", "911"], char: "🆘", fitzpatrick_scale: !1, category: "symbols" }, no_entry: { keywords: ["limit", "security", "privacy", "bad", "denied", "stop", "circle"], char: "⛔", fitzpatrick_scale: !1, category: "symbols" }, name_badge: { keywords: ["fire", "forbid"], char: "📛", fitzpatrick_scale: !1, category: "symbols" }, no_entry_sign: { keywords: ["forbid", "stop", "limit", "denied", "disallow", "circle"], char: "🚫", fitzpatrick_scale: !1, category: "symbols" }, x: { keywords: ["no", "delete", "remove", "cancel", "red"], char: "❌", fitzpatrick_scale: !1, category: "symbols" }, o: { keywords: ["circle", "round"], char: "⭕", fitzpatrick_scale: !1, category: "symbols" }, stop_sign: { keywords: ["stop"], char: "🛑", fitzpatrick_scale: !1, category: "symbols" }, anger: { keywords: ["angry", "mad"], char: "💢", fitzpatrick_scale: !1, category: "symbols" }, hotsprings: { keywords: ["bath", "warm", "relax"], char: "♨️", fitzpatrick_scale: !1, category: "symbols" }, no_pedestrians: { keywords: ["rules", "crossing", "walking", "circle"], char: "🚷", fitzpatrick_scale: !1, category: "symbols" }, do_not_litter: { keywords: ["trash", "bin", "garbage", "circle"], char: "🚯", fitzpatrick_scale: !1, category: "symbols" }, no_bicycles: { keywords: ["cyclist", "prohibited", "circle"], char: "🚳", fitzpatrick_scale: !1, category: "symbols" }, "non-potable_water": { keywords: ["drink", "faucet", "tap", "circle"], char: "🚱", fitzpatrick_scale: !1, category: "symbols" }, underage: { keywords: ["18", "drink", "pub", "night", "minor", "circle"], char: "🔞", fitzpatrick_scale: !1, category: "symbols" }, no_mobile_phones: { keywords: ["iphone", "mute", "circle"], char: "📵", fitzpatrick_scale: !1, category: "symbols" }, exclamation: { keywords: ["heavy_exclamation_mark", "danger", "surprise", "punctuation", "wow", "warning"], char: "❗", fitzpatrick_scale: !1, category: "symbols" }, grey_exclamation: { keywords: ["surprise", "punctuation", "gray", "wow", "warning"], char: "❕", fitzpatrick_scale: !1, category: "symbols" }, question: { keywords: ["doubt", "confused"], char: "❓", fitzpatrick_scale: !1, category: "symbols" }, grey_question: { keywords: ["doubts", "gray", "huh", "confused"], char: "❔", fitzpatrick_scale: !1, category: "symbols" }, bangbang: { keywords: ["exclamation", "surprise"], char: "‼️", fitzpatrick_scale: !1, category: "symbols" }, interrobang: { keywords: ["wat", "punctuation", "surprise"], char: "⁉️", fitzpatrick_scale: !1, category: "symbols" }, 100: { keywords: ["score", "perfect", "numbers", "century", "exam", "quiz", "test", "pass", "hundred"], char: "💯", fitzpatrick_scale: !1, category: "symbols" }, low_brightness: { keywords: ["sun", "afternoon", "warm", "summer"], char: "🔅", fitzpatrick_scale: !1, category: "symbols" }, high_brightness: { keywords: ["sun", "light"], char: "🔆", fitzpatrick_scale: !1, category: "symbols" }, trident: { keywords: ["weapon", "spear"], char: "🔱", fitzpatrick_scale: !1, category: "symbols" }, fleur_de_lis: { keywords: ["decorative", "scout"], char: "⚜", fitzpatrick_scale: !1, category: "symbols" }, part_alternation_mark: { keywords: ["graph", "presentation", "stats", "business", "economics", "bad"], char: "〽️", fitzpatrick_scale: !1, category: "symbols" }, warning: { keywords: ["exclamation", "wip", "alert", "error", "problem", "issue"], char: "⚠️", fitzpatrick_scale: !1, category: "symbols" }, children_crossing: { keywords: ["school", "warning", "danger", "sign", "driving", "yellow-diamond"], char: "🚸", fitzpatrick_scale: !1, category: "symbols" }, beginner: { keywords: ["badge", "shield"], char: "🔰", fitzpatrick_scale: !1, category: "symbols" }, recycle: { keywords: ["arrow", "environment", "garbage", "trash"], char: "♻️", fitzpatrick_scale: !1, category: "symbols" }, u6307: { keywords: ["chinese", "point", "green-square", "kanji"], char: "🈯", fitzpatrick_scale: !1, category: "symbols" }, chart: { keywords: ["green-square", "graph", "presentation", "stats"], char: "💹", fitzpatrick_scale: !1, category: "symbols" }, sparkle: { keywords: ["stars", "green-square", "awesome", "good", "fireworks"], char: "❇️", fitzpatrick_scale: !1, category: "symbols" }, eight_spoked_asterisk: { keywords: ["star", "sparkle", "green-square"], char: "✳️", fitzpatrick_scale: !1, category: "symbols" }, negative_squared_cross_mark: { keywords: ["x", "green-square", "no", "deny"], char: "❎", fitzpatrick_scale: !1, category: "symbols" }, white_check_mark: { keywords: ["green-square", "ok", "agree", "vote", "election", "answer", "tick"], char: "✅", fitzpatrick_scale: !1, category: "symbols" }, diamond_shape_with_a_dot_inside: { keywords: ["jewel", "blue", "gem", "crystal", "fancy"], char: "💠", fitzpatrick_scale: !1, category: "symbols" }, cyclone: { keywords: ["weather", "swirl", "blue", "cloud", "vortex", "spiral", "whirlpool", "spin", "tornado", "hurricane", "typhoon"], char: "🌀", fitzpatrick_scale: !1, category: "symbols" }, loop: { keywords: ["tape", "cassette"], char: "➿", fitzpatrick_scale: !1, category: "symbols" }, globe_with_meridians: { keywords: ["earth", "international", "world", "internet", "interweb", "i18n"], char: "🌐", fitzpatrick_scale: !1, category: "symbols" }, m: { keywords: ["alphabet", "blue-circle", "letter"], char: "Ⓜ️", fitzpatrick_scale: !1, category: "symbols" }, atm: { keywords: ["money", "sales", "cash", "blue-square", "payment", "bank"], char: "🏧", fitzpatrick_scale: !1, category: "symbols" }, sa: { keywords: ["japanese", "blue-square", "katakana"], char: "🈂️", fitzpatrick_scale: !1, category: "symbols" }, passport_control: { keywords: ["custom", "blue-square"], char: "🛂", fitzpatrick_scale: !1, category: "symbols" }, customs: { keywords: ["passport", "border", "blue-square"], char: "🛃", fitzpatrick_scale: !1, category: "symbols" }, baggage_claim: { keywords: ["blue-square", "airport", "transport"], char: "🛄", fitzpatrick_scale: !1, category: "symbols" }, left_luggage: { keywords: ["blue-square", "travel"], char: "🛅", fitzpatrick_scale: !1, category: "symbols" }, wheelchair: { keywords: ["blue-square", "disabled", "a11y", "accessibility"], char: "♿", fitzpatrick_scale: !1, category: "symbols" }, no_smoking: { keywords: ["cigarette", "blue-square", "smell", "smoke"], char: "🚭", fitzpatrick_scale: !1, category: "symbols" }, wc: { keywords: ["toilet", "restroom", "blue-square"], char: "🚾", fitzpatrick_scale: !1, category: "symbols" }, parking: { keywords: ["cars", "blue-square", "alphabet", "letter"], char: "🅿️", fitzpatrick_scale: !1, category: "symbols" }, potable_water: { keywords: ["blue-square", "liquid", "restroom", "cleaning", "faucet"], char: "🚰", fitzpatrick_scale: !1, category: "symbols" }, mens: { keywords: ["toilet", "restroom", "wc", "blue-square", "gender", "male"], char: "🚹", fitzpatrick_scale: !1, category: "symbols" }, womens: { keywords: ["purple-square", "woman", "female", "toilet", "loo", "restroom", "gender"], char: "🚺", fitzpatrick_scale: !1, category: "symbols" }, baby_symbol: { keywords: ["orange-square", "child"], char: "🚼", fitzpatrick_scale: !1, category: "symbols" }, restroom: { keywords: ["blue-square", "toilet", "refresh", "wc", "gender"], char: "🚻", fitzpatrick_scale: !1, category: "symbols" }, put_litter_in_its_place: { keywords: ["blue-square", "sign", "human", "info"], char: "🚮", fitzpatrick_scale: !1, category: "symbols" }, cinema: { keywords: ["blue-square", "record", "film", "movie", "curtain", "stage", "theater"], char: "🎦", fitzpatrick_scale: !1, category: "symbols" }, signal_strength: { keywords: ["blue-square", "reception", "phone", "internet", "connection", "wifi", "bluetooth", "bars"], char: "📶", fitzpatrick_scale: !1, category: "symbols" }, koko: { keywords: ["blue-square", "here", "katakana", "japanese", "destination"], char: "🈁", fitzpatrick_scale: !1, category: "symbols" }, ng: { keywords: ["blue-square", "words", "shape", "icon"], char: "🆖", fitzpatrick_scale: !1, category: "symbols" }, ok: { keywords: ["good", "agree", "yes", "blue-square"], char: "🆗", fitzpatrick_scale: !1, category: "symbols" }, up: { keywords: ["blue-square", "above", "high"], char: "🆙", fitzpatrick_scale: !1, category: "symbols" }, cool: { keywords: ["words", "blue-square"], char: "🆒", fitzpatrick_scale: !1, category: "symbols" }, new: { keywords: ["blue-square", "words", "start"], char: "🆕", fitzpatrick_scale: !1, category: "symbols" }, free: { keywords: ["blue-square", "words"], char: "🆓", fitzpatrick_scale: !1, category: "symbols" }, zero: { keywords: ["0", "numbers", "blue-square", "null"], char: "0️⃣", fitzpatrick_scale: !1, category: "symbols" }, one: { keywords: ["blue-square", "numbers", "1"], char: "1️⃣", fitzpatrick_scale: !1, category: "symbols" }, two: { keywords: ["numbers", "2", "prime", "blue-square"], char: "2️⃣", fitzpatrick_scale: !1, category: "symbols" }, three: { keywords: ["3", "numbers", "prime", "blue-square"], char: "3️⃣", fitzpatrick_scale: !1, category: "symbols" }, four: { keywords: ["4", "numbers", "blue-square"], char: "4️⃣", fitzpatrick_scale: !1, category: "symbols" }, five: { keywords: ["5", "numbers", "blue-square", "prime"], char: "5️⃣", fitzpatrick_scale: !1, category: "symbols" }, six: { keywords: ["6", "numbers", "blue-square"], char: "6️⃣", fitzpatrick_scale: !1, category: "symbols" }, seven: { keywords: ["7", "numbers", "blue-square", "prime"], char: "7️⃣", fitzpatrick_scale: !1, category: "symbols" }, eight: { keywords: ["8", "blue-square", "numbers"], char: "8️⃣", fitzpatrick_scale: !1, category: "symbols" }, nine: { keywords: ["blue-square", "numbers", "9"], char: "9️⃣", fitzpatrick_scale: !1, category: "symbols" }, keycap_ten: { keywords: ["numbers", "10", "blue-square"], char: "🔟", fitzpatrick_scale: !1, category: "symbols" }, asterisk: { keywords: ["star", "keycap"], char: "*⃣", fitzpatrick_scale: !1, category: "symbols" }, 1234: { keywords: ["numbers", "blue-square"], char: "🔢", fitzpatrick_scale: !1, category: "symbols" }, eject_button: { keywords: ["blue-square"], char: "⏏️", fitzpatrick_scale: !1, category: "symbols" }, arrow_forward: { keywords: ["blue-square", "right", "direction", "play"], char: "▶️", fitzpatrick_scale: !1, category: "symbols" }, pause_button: { keywords: ["pause", "blue-square"], char: "⏸", fitzpatrick_scale: !1, category: "symbols" }, next_track_button: { keywords: ["forward", "next", "blue-square"], char: "⏭", fitzpatrick_scale: !1, category: "symbols" }, stop_button: { keywords: ["blue-square"], char: "⏹", fitzpatrick_scale: !1, category: "symbols" }, record_button: { keywords: ["blue-square"], char: "⏺", fitzpatrick_scale: !1, category: "symbols" }, play_or_pause_button: { keywords: ["blue-square", "play", "pause"], char: "⏯", fitzpatrick_scale: !1, category: "symbols" }, previous_track_button: { keywords: ["backward"], char: "⏮", fitzpatrick_scale: !1, category: "symbols" }, fast_forward: { keywords: ["blue-square", "play", "speed", "continue"], char: "⏩", fitzpatrick_scale: !1, category: "symbols" }, rewind: { keywords: ["play", "blue-square"], char: "⏪", fitzpatrick_scale: !1, category: "symbols" }, twisted_rightwards_arrows: { keywords: ["blue-square", "shuffle", "music", "random"], char: "🔀", fitzpatrick_scale: !1, category: "symbols" }, repeat: { keywords: ["loop", "record"], char: "🔁", fitzpatrick_scale: !1, category: "symbols" }, repeat_one: { keywords: ["blue-square", "loop"], char: "🔂", fitzpatrick_scale: !1, category: "symbols" }, arrow_backward: { keywords: ["blue-square", "left", "direction"], char: "◀️", fitzpatrick_scale: !1, category: "symbols" }, arrow_up_small: { keywords: ["blue-square", "triangle", "direction", "point", "forward", "top"], char: "🔼", fitzpatrick_scale: !1, category: "symbols" }, arrow_down_small: { keywords: ["blue-square", "direction", "bottom"], char: "🔽", fitzpatrick_scale: !1, category: "symbols" }, arrow_double_up: { keywords: ["blue-square", "direction", "top"], char: "⏫", fitzpatrick_scale: !1, category: "symbols" }, arrow_double_down: { keywords: ["blue-square", "direction", "bottom"], char: "⏬", fitzpatrick_scale: !1, category: "symbols" }, arrow_right: { keywords: ["blue-square", "next"], char: "➡️", fitzpatrick_scale: !1, category: "symbols" }, arrow_left: { keywords: ["blue-square", "previous", "back"], char: "⬅️", fitzpatrick_scale: !1, category: "symbols" }, arrow_up: { keywords: ["blue-square", "continue", "top", "direction"], char: "⬆️", fitzpatrick_scale: !1, category: "symbols" }, arrow_down: { keywords: ["blue-square", "direction", "bottom"], char: "⬇️", fitzpatrick_scale: !1, category: "symbols" }, arrow_upper_right: { keywords: ["blue-square", "point", "direction", "diagonal", "northeast"], char: "↗️", fitzpatrick_scale: !1, category: "symbols" }, arrow_lower_right: { keywords: ["blue-square", "direction", "diagonal", "southeast"], char: "↘️", fitzpatrick_scale: !1, category: "symbols" }, arrow_lower_left: { keywords: ["blue-square", "direction", "diagonal", "southwest"], char: "↙️", fitzpatrick_scale: !1, category: "symbols" }, arrow_upper_left: { keywords: ["blue-square", "point", "direction", "diagonal", "northwest"], char: "↖️", fitzpatrick_scale: !1, category: "symbols" }, arrow_up_down: { keywords: ["blue-square", "direction", "way", "vertical"], char: "↕️", fitzpatrick_scale: !1, category: "symbols" }, left_right_arrow: { keywords: ["shape", "direction", "horizontal", "sideways"], char: "↔️", fitzpatrick_scale: !1, category: "symbols" }, arrows_counterclockwise: { keywords: ["blue-square", "sync", "cycle"], char: "🔄", fitzpatrick_scale: !1, category: "symbols" }, arrow_right_hook: { keywords: ["blue-square", "return", "rotate", "direction"], char: "↪️", fitzpatrick_scale: !1, category: "symbols" }, leftwards_arrow_with_hook: { keywords: ["back", "return", "blue-square", "undo", "enter"], char: "↩️", fitzpatrick_scale: !1, category: "symbols" }, arrow_heading_up: { keywords: ["blue-square", "direction", "top"], char: "⤴️", fitzpatrick_scale: !1, category: "symbols" }, arrow_heading_down: { keywords: ["blue-square", "direction", "bottom"], char: "⤵️", fitzpatrick_scale: !1, category: "symbols" }, hash: { keywords: ["symbol", "blue-square", "twitter"], char: "#️⃣", fitzpatrick_scale: !1, category: "symbols" }, information_source: { keywords: ["blue-square", "alphabet", "letter"], char: "ℹ️", fitzpatrick_scale: !1, category: "symbols" }, abc: { keywords: ["blue-square", "alphabet"], char: "🔤", fitzpatrick_scale: !1, category: "symbols" }, abcd: { keywords: ["blue-square", "alphabet"], char: "🔡", fitzpatrick_scale: !1, category: "symbols" }, capital_abcd: { keywords: ["alphabet", "words", "blue-square"], char: "🔠", fitzpatrick_scale: !1, category: "symbols" }, symbols: { keywords: ["blue-square", "music", "note", "ampersand", "percent", "glyphs", "characters"], char: "🔣", fitzpatrick_scale: !1, category: "symbols" }, musical_note: { keywords: ["score", "tone", "sound"], char: "🎵", fitzpatrick_scale: !1, category: "symbols" }, notes: { keywords: ["music", "score"], char: "🎶", fitzpatrick_scale: !1, category: "symbols" }, wavy_dash: { keywords: ["draw", "line", "moustache", "mustache", "squiggle", "scribble"], char: "〰️", fitzpatrick_scale: !1, category: "symbols" }, curly_loop: { keywords: ["scribble", "draw", "shape", "squiggle"], char: "➰", fitzpatrick_scale: !1, category: "symbols" }, heavy_check_mark: { keywords: ["ok", "nike", "answer", "yes", "tick"], char: "✔️", fitzpatrick_scale: !1, category: "symbols" }, arrows_clockwise: { keywords: ["sync", "cycle", "round", "repeat"], char: "🔃", fitzpatrick_scale: !1, category: "symbols" }, heavy_plus_sign: { keywords: ["math", "calculation", "addition", "more", "increase"], char: "➕", fitzpatrick_scale: !1, category: "symbols" }, heavy_minus_sign: { keywords: ["math", "calculation", "subtract", "less"], char: "➖", fitzpatrick_scale: !1, category: "symbols" }, heavy_division_sign: { keywords: ["divide", "math", "calculation"], char: "➗", fitzpatrick_scale: !1, category: "symbols" }, heavy_multiplication_x: { keywords: ["math", "calculation"], char: "✖️", fitzpatrick_scale: !1, category: "symbols" }, infinity: { keywords: ["forever"], char: "♾", fitzpatrick_scale: !1, category: "symbols" }, heavy_dollar_sign: { keywords: ["money", "sales", "payment", "currency", "buck"], char: "💲", fitzpatrick_scale: !1, category: "symbols" }, currency_exchange: { keywords: ["money", "sales", "dollar", "travel"], char: "💱", fitzpatrick_scale: !1, category: "symbols" }, copyright: { keywords: ["ip", "license", "circle", "law", "legal"], char: "©️", fitzpatrick_scale: !1, category: "symbols" }, registered: { keywords: ["alphabet", "circle"], char: "®️", fitzpatrick_scale: !1, category: "symbols" }, tm: { keywords: ["trademark", "brand", "law", "legal"], char: "™️", fitzpatrick_scale: !1, category: "symbols" }, end: { keywords: ["words", "arrow"], char: "🔚", fitzpatrick_scale: !1, category: "symbols" }, back: { keywords: ["arrow", "words", "return"], char: "🔙", fitzpatrick_scale: !1, category: "symbols" }, on: { keywords: ["arrow", "words"], char: "🔛", fitzpatrick_scale: !1, category: "symbols" }, top: { keywords: ["words", "blue-square"], char: "🔝", fitzpatrick_scale: !1, category: "symbols" }, soon: { keywords: ["arrow", "words"], char: "🔜", fitzpatrick_scale: !1, category: "symbols" }, ballot_box_with_check: { keywords: ["ok", "agree", "confirm", "black-square", "vote", "election", "yes", "tick"], char: "☑️", fitzpatrick_scale: !1, category: "symbols" }, radio_button: { keywords: ["input", "old", "music", "circle"], char: "🔘", fitzpatrick_scale: !1, category: "symbols" }, white_circle: { keywords: ["shape", "round"], char: "⚪", fitzpatrick_scale: !1, category: "symbols" }, black_circle: { keywords: ["shape", "button", "round"], char: "⚫", fitzpatrick_scale: !1, category: "symbols" }, red_circle: { keywords: ["shape", "error", "danger"], char: "🔴", fitzpatrick_scale: !1, category: "symbols" }, large_blue_circle: { keywords: ["shape", "icon", "button"], char: "🔵", fitzpatrick_scale: !1, category: "symbols" }, small_orange_diamond: { keywords: ["shape", "jewel", "gem"], char: "🔸", fitzpatrick_scale: !1, category: "symbols" }, small_blue_diamond: { keywords: ["shape", "jewel", "gem"], char: "🔹", fitzpatrick_scale: !1, category: "symbols" }, large_orange_diamond: { keywords: ["shape", "jewel", "gem"], char: "🔶", fitzpatrick_scale: !1, category: "symbols" }, large_blue_diamond: { keywords: ["shape", "jewel", "gem"], char: "🔷", fitzpatrick_scale: !1, category: "symbols" }, small_red_triangle: { keywords: ["shape", "direction", "up", "top"], char: "🔺", fitzpatrick_scale: !1, category: "symbols" }, black_small_square: { keywords: ["shape", "icon"], char: "▪️", fitzpatrick_scale: !1, category: "symbols" }, white_small_square: { keywords: ["shape", "icon"], char: "▫️", fitzpatrick_scale: !1, category: "symbols" }, black_large_square: { keywords: ["shape", "icon", "button"], char: "⬛", fitzpatrick_scale: !1, category: "symbols" }, white_large_square: { keywords: ["shape", "icon", "stone", "button"], char: "⬜", fitzpatrick_scale: !1, category: "symbols" }, small_red_triangle_down: { keywords: ["shape", "direction", "bottom"], char: "🔻", fitzpatrick_scale: !1, category: "symbols" }, black_medium_square: { keywords: ["shape", "button", "icon"], char: "◼️", fitzpatrick_scale: !1, category: "symbols" }, white_medium_square: { keywords: ["shape", "stone", "icon"], char: "◻️", fitzpatrick_scale: !1, category: "symbols" }, black_medium_small_square: { keywords: ["icon", "shape", "button"], char: "◾", fitzpatrick_scale: !1, category: "symbols" }, white_medium_small_square: { keywords: ["shape", "stone", "icon", "button"], char: "◽", fitzpatrick_scale: !1, category: "symbols" }, black_square_button: { keywords: ["shape", "input", "frame"], char: "🔲", fitzpatrick_scale: !1, category: "symbols" }, white_square_button: { keywords: ["shape", "input"], char: "🔳", fitzpatrick_scale: !1, category: "symbols" }, speaker: { keywords: ["sound", "volume", "silence", "broadcast"], char: "🔈", fitzpatrick_scale: !1, category: "symbols" }, sound: { keywords: ["volume", "speaker", "broadcast"], char: "🔉", fitzpatrick_scale: !1, category: "symbols" }, loud_sound: { keywords: ["volume", "noise", "noisy", "speaker", "broadcast"], char: "🔊", fitzpatrick_scale: !1, category: "symbols" }, mute: { keywords: ["sound", "volume", "silence", "quiet"], char: "🔇", fitzpatrick_scale: !1, category: "symbols" }, mega: { keywords: ["sound", "speaker", "volume"], char: "📣", fitzpatrick_scale: !1, category: "symbols" }, loudspeaker: { keywords: ["volume", "sound"], char: "📢", fitzpatrick_scale: !1, category: "symbols" }, bell: { keywords: ["sound", "notification", "christmas", "xmas", "chime"], char: "🔔", fitzpatrick_scale: !1, category: "symbols" }, no_bell: { keywords: ["sound", "volume", "mute", "quiet", "silent"], char: "🔕", fitzpatrick_scale: !1, category: "symbols" }, black_joker: { keywords: ["poker", "cards", "game", "play", "magic"], char: "🃏", fitzpatrick_scale: !1, category: "symbols" }, mahjong: { keywords: ["game", "play", "chinese", "kanji"], char: "🀄", fitzpatrick_scale: !1, category: "symbols" }, spades: { keywords: ["poker", "cards", "suits", "magic"], char: "♠️", fitzpatrick_scale: !1, category: "symbols" }, clubs: { keywords: ["poker", "cards", "magic", "suits"], char: "♣️", fitzpatrick_scale: !1, category: "symbols" }, hearts: { keywords: ["poker", "cards", "magic", "suits"], char: "♥️", fitzpatrick_scale: !1, category: "symbols" }, diamonds: { keywords: ["poker", "cards", "magic", "suits"], char: "♦️", fitzpatrick_scale: !1, category: "symbols" }, flower_playing_cards: { keywords: ["game", "sunset", "red"], char: "🎴", fitzpatrick_scale: !1, category: "symbols" }, thought_balloon: { keywords: ["bubble", "cloud", "speech", "thinking", "dream"], char: "💭", fitzpatrick_scale: !1, category: "symbols" }, right_anger_bubble: { keywords: ["caption", "speech", "thinking", "mad"], char: "🗯", fitzpatrick_scale: !1, category: "symbols" }, speech_balloon: { keywords: ["bubble", "words", "message", "talk", "chatting"], char: "💬", fitzpatrick_scale: !1, category: "symbols" }, left_speech_bubble: { keywords: ["words", "message", "talk", "chatting"], char: "🗨", fitzpatrick_scale: !1, category: "symbols" }, clock1: { keywords: ["time", "late", "early", "schedule"], char: "🕐", fitzpatrick_scale: !1, category: "symbols" }, clock2: { keywords: ["time", "late", "early", "schedule"], char: "🕑", fitzpatrick_scale: !1, category: "symbols" }, clock3: { keywords: ["time", "late", "early", "schedule"], char: "🕒", fitzpatrick_scale: !1, category: "symbols" }, clock4: { keywords: ["time", "late", "early", "schedule"], char: "🕓", fitzpatrick_scale: !1, category: "symbols" }, clock5: { keywords: ["time", "late", "early", "schedule"], char: "🕔", fitzpatrick_scale: !1, category: "symbols" }, clock6: { keywords: ["time", "late", "early", "schedule", "dawn", "dusk"], char: "🕕", fitzpatrick_scale: !1, category: "symbols" }, clock7: { keywords: ["time", "late", "early", "schedule"], char: "🕖", fitzpatrick_scale: !1, category: "symbols" }, clock8: { keywords: ["time", "late", "early", "schedule"], char: "🕗", fitzpatrick_scale: !1, category: "symbols" }, clock9: { keywords: ["time", "late", "early", "schedule"], char: "🕘", fitzpatrick_scale: !1, category: "symbols" }, clock10: { keywords: ["time", "late", "early", "schedule"], char: "🕙", fitzpatrick_scale: !1, category: "symbols" }, clock11: { keywords: ["time", "late", "early", "schedule"], char: "🕚", fitzpatrick_scale: !1, category: "symbols" }, clock12: { keywords: ["time", "noon", "midnight", "midday", "late", "early", "schedule"], char: "🕛", fitzpatrick_scale: !1, category: "symbols" }, clock130: { keywords: ["time", "late", "early", "schedule"], char: "🕜", fitzpatrick_scale: !1, category: "symbols" }, clock230: { keywords: ["time", "late", "early", "schedule"], char: "🕝", fitzpatrick_scale: !1, category: "symbols" }, clock330: { keywords: ["time", "late", "early", "schedule"], char: "🕞", fitzpatrick_scale: !1, category: "symbols" }, clock430: { keywords: ["time", "late", "early", "schedule"], char: "🕟", fitzpatrick_scale: !1, category: "symbols" }, clock530: { keywords: ["time", "late", "early", "schedule"], char: "🕠", fitzpatrick_scale: !1, category: "symbols" }, clock630: { keywords: ["time", "late", "early", "schedule"], char: "🕡", fitzpatrick_scale: !1, category: "symbols" }, clock730: { keywords: ["time", "late", "early", "schedule"], char: "🕢", fitzpatrick_scale: !1, category: "symbols" }, clock830: { keywords: ["time", "late", "early", "schedule"], char: "🕣", fitzpatrick_scale: !1, category: "symbols" }, clock930: { keywords: ["time", "late", "early", "schedule"], char: "🕤", fitzpatrick_scale: !1, category: "symbols" }, clock1030: { keywords: ["time", "late", "early", "schedule"], char: "🕥", fitzpatrick_scale: !1, category: "symbols" }, clock1130: { keywords: ["time", "late", "early", "schedule"], char: "🕦", fitzpatrick_scale: !1, category: "symbols" }, clock1230: { keywords: ["time", "late", "early", "schedule"], char: "🕧", fitzpatrick_scale: !1, category: "symbols" }, afghanistan: { keywords: ["af", "flag", "nation", "country", "banner"], char: "🇦🇫", fitzpatrick_scale: !1, category: "flags" }, aland_islands: { keywords: ["Åland", "islands", "flag", "nation", "country", "banner"], char: "🇦🇽", fitzpatrick_scale: !1, category: "flags" }, albania: { keywords: ["al", "flag", "nation", "country", "banner"], char: "🇦🇱", fitzpatrick_scale: !1, category: "flags" }, algeria: { keywords: ["dz", "flag", "nation", "country", "banner"], char: "🇩🇿", fitzpatrick_scale: !1, category: "flags" }, american_samoa: { keywords: ["american", "ws", "flag", "nation", "country", "banner"], char: "🇦🇸", fitzpatrick_scale: !1, category: "flags" }, andorra: { keywords: ["ad", "flag", "nation", "country", "banner"], char: "🇦🇩", fitzpatrick_scale: !1, category: "flags" }, angola: { keywords: ["ao", "flag", "nation", "country", "banner"], char: "🇦🇴", fitzpatrick_scale: !1, category: "flags" }, anguilla: { keywords: ["ai", "flag", "nation", "country", "banner"], char: "🇦🇮", fitzpatrick_scale: !1, category: "flags" }, antarctica: { keywords: ["aq", "flag", "nation", "country", "banner"], char: "🇦🇶", fitzpatrick_scale: !1, category: "flags" }, antigua_barbuda: { keywords: ["antigua", "barbuda", "flag", "nation", "country", "banner"], char: "🇦🇬", fitzpatrick_scale: !1, category: "flags" }, argentina: { keywords: ["ar", "flag", "nation", "country", "banner"], char: "🇦🇷", fitzpatrick_scale: !1, category: "flags" }, armenia: { keywords: ["am", "flag", "nation", "country", "banner"], char: "🇦🇲", fitzpatrick_scale: !1, category: "flags" }, aruba: { keywords: ["aw", "flag", "nation", "country", "banner"], char: "🇦🇼", fitzpatrick_scale: !1, category: "flags" }, australia: { keywords: ["au", "flag", "nation", "country", "banner"], char: "🇦🇺", fitzpatrick_scale: !1, category: "flags" }, austria: { keywords: ["at", "flag", "nation", "country", "banner"], char: "🇦🇹", fitzpatrick_scale: !1, category: "flags" }, azerbaijan: { keywords: ["az", "flag", "nation", "country", "banner"], char: "🇦🇿", fitzpatrick_scale: !1, category: "flags" }, bahamas: { keywords: ["bs", "flag", "nation", "country", "banner"], char: "🇧🇸", fitzpatrick_scale: !1, category: "flags" }, bahrain: { keywords: ["bh", "flag", "nation", "country", "banner"], char: "🇧🇭", fitzpatrick_scale: !1, category: "flags" }, bangladesh: { keywords: ["bd", "flag", "nation", "country", "banner"], char: "🇧🇩", fitzpatrick_scale: !1, category: "flags" }, barbados: { keywords: ["bb", "flag", "nation", "country", "banner"], char: "🇧🇧", fitzpatrick_scale: !1, category: "flags" }, belarus: { keywords: ["by", "flag", "nation", "country", "banner"], char: "🇧🇾", fitzpatrick_scale: !1, category: "flags" }, belgium: { keywords: ["be", "flag", "nation", "country", "banner"], char: "🇧🇪", fitzpatrick_scale: !1, category: "flags" }, belize: { keywords: ["bz", "flag", "nation", "country", "banner"], char: "🇧🇿", fitzpatrick_scale: !1, category: "flags" }, benin: { keywords: ["bj", "flag", "nation", "country", "banner"], char: "🇧🇯", fitzpatrick_scale: !1, category: "flags" }, bermuda: { keywords: ["bm", "flag", "nation", "country", "banner"], char: "🇧🇲", fitzpatrick_scale: !1, category: "flags" }, bhutan: { keywords: ["bt", "flag", "nation", "country", "banner"], char: "🇧🇹", fitzpatrick_scale: !1, category: "flags" }, bolivia: { keywords: ["bo", "flag", "nation", "country", "banner"], char: "🇧🇴", fitzpatrick_scale: !1, category: "flags" }, caribbean_netherlands: { keywords: ["bonaire", "flag", "nation", "country", "banner"], char: "🇧🇶", fitzpatrick_scale: !1, category: "flags" }, bosnia_herzegovina: { keywords: ["bosnia", "herzegovina", "flag", "nation", "country", "banner"], char: "🇧🇦", fitzpatrick_scale: !1, category: "flags" }, botswana: { keywords: ["bw", "flag", "nation", "country", "banner"], char: "🇧🇼", fitzpatrick_scale: !1, category: "flags" }, brazil: { keywords: ["br", "flag", "nation", "country", "banner"], char: "🇧🇷", fitzpatrick_scale: !1, category: "flags" }, british_indian_ocean_territory: { keywords: ["british", "indian", "ocean", "territory", "flag", "nation", "country", "banner"], char: "🇮🇴", fitzpatrick_scale: !1, category: "flags" }, british_virgin_islands: { keywords: ["british", "virgin", "islands", "bvi", "flag", "nation", "country", "banner"], char: "🇻🇬", fitzpatrick_scale: !1, category: "flags" }, brunei: { keywords: ["bn", "darussalam", "flag", "nation", "country", "banner"], char: "🇧🇳", fitzpatrick_scale: !1, category: "flags" }, bulgaria: { keywords: ["bg", "flag", "nation", "country", "banner"], char: "🇧🇬", fitzpatrick_scale: !1, category: "flags" }, burkina_faso: { keywords: ["burkina", "faso", "flag", "nation", "country", "banner"], char: "🇧🇫", fitzpatrick_scale: !1, category: "flags" }, burundi: { keywords: ["bi", "flag", "nation", "country", "banner"], char: "🇧🇮", fitzpatrick_scale: !1, category: "flags" }, cape_verde: { keywords: ["cabo", "verde", "flag", "nation", "country", "banner"], char: "🇨🇻", fitzpatrick_scale: !1, category: "flags" }, cambodia: { keywords: ["kh", "flag", "nation", "country", "banner"], char: "🇰🇭", fitzpatrick_scale: !1, category: "flags" }, cameroon: { keywords: ["cm", "flag", "nation", "country", "banner"], char: "🇨🇲", fitzpatrick_scale: !1, category: "flags" }, canada: { keywords: ["ca", "flag", "nation", "country", "banner"], char: "🇨🇦", fitzpatrick_scale: !1, category: "flags" }, canary_islands: { keywords: ["canary", "islands", "flag", "nation", "country", "banner"], char: "🇮🇨", fitzpatrick_scale: !1, category: "flags" }, cayman_islands: { keywords: ["cayman", "islands", "flag", "nation", "country", "banner"], char: "🇰🇾", fitzpatrick_scale: !1, category: "flags" }, central_african_republic: { keywords: ["central", "african", "republic", "flag", "nation", "country", "banner"], char: "🇨🇫", fitzpatrick_scale: !1, category: "flags" }, chad: { keywords: ["td", "flag", "nation", "country", "banner"], char: "🇹🇩", fitzpatrick_scale: !1, category: "flags" }, chile: { keywords: ["flag", "nation", "country", "banner"], char: "🇨🇱", fitzpatrick_scale: !1, category: "flags" }, cn: { keywords: ["china", "chinese", "prc", "flag", "country", "nation", "banner"], char: "🇨🇳", fitzpatrick_scale: !1, category: "flags" }, christmas_island: { keywords: ["christmas", "island", "flag", "nation", "country", "banner"], char: "🇨🇽", fitzpatrick_scale: !1, category: "flags" }, cocos_islands: { keywords: ["cocos", "keeling", "islands", "flag", "nation", "country", "banner"], char: "🇨🇨", fitzpatrick_scale: !1, category: "flags" }, colombia: { keywords: ["co", "flag", "nation", "country", "banner"], char: "🇨🇴", fitzpatrick_scale: !1, category: "flags" }, comoros: { keywords: ["km", "flag", "nation", "country", "banner"], char: "🇰🇲", fitzpatrick_scale: !1, category: "flags" }, congo_brazzaville: { keywords: ["congo", "flag", "nation", "country", "banner"], char: "🇨🇬", fitzpatrick_scale: !1, category: "flags" }, congo_kinshasa: { keywords: ["congo", "democratic", "republic", "flag", "nation", "country", "banner"], char: "🇨🇩", fitzpatrick_scale: !1, category: "flags" }, cook_islands: { keywords: ["cook", "islands", "flag", "nation", "country", "banner"], char: "🇨🇰", fitzpatrick_scale: !1, category: "flags" }, costa_rica: { keywords: ["costa", "rica", "flag", "nation", "country", "banner"], char: "🇨🇷", fitzpatrick_scale: !1, category: "flags" }, croatia: { keywords: ["hr", "flag", "nation", "country", "banner"], char: "🇭🇷", fitzpatrick_scale: !1, category: "flags" }, cuba: { keywords: ["cu", "flag", "nation", "country", "banner"], char: "🇨🇺", fitzpatrick_scale: !1, category: "flags" }, curacao: { keywords: ["curaçao", "flag", "nation", "country", "banner"], char: "🇨🇼", fitzpatrick_scale: !1, category: "flags" }, cyprus: { keywords: ["cy", "flag", "nation", "country", "banner"], char: "🇨🇾", fitzpatrick_scale: !1, category: "flags" }, czech_republic: { keywords: ["cz", "flag", "nation", "country", "banner"], char: "🇨🇿", fitzpatrick_scale: !1, category: "flags" }, denmark: { keywords: ["dk", "flag", "nation", "country", "banner"], char: "🇩🇰", fitzpatrick_scale: !1, category: "flags" }, djibouti: { keywords: ["dj", "flag", "nation", "country", "banner"], char: "🇩🇯", fitzpatrick_scale: !1, category: "flags" }, dominica: { keywords: ["dm", "flag", "nation", "country", "banner"], char: "🇩🇲", fitzpatrick_scale: !1, category: "flags" }, dominican_republic: { keywords: ["dominican", "republic", "flag", "nation", "country", "banner"], char: "🇩🇴", fitzpatrick_scale: !1, category: "flags" }, ecuador: { keywords: ["ec", "flag", "nation", "country", "banner"], char: "🇪🇨", fitzpatrick_scale: !1, category: "flags" }, egypt: { keywords: ["eg", "flag", "nation", "country", "banner"], char: "🇪🇬", fitzpatrick_scale: !1, category: "flags" }, el_salvador: { keywords: ["el", "salvador", "flag", "nation", "country", "banner"], char: "🇸🇻", fitzpatrick_scale: !1, category: "flags" }, equatorial_guinea: { keywords: ["equatorial", "gn", "flag", "nation", "country", "banner"], char: "🇬🇶", fitzpatrick_scale: !1, category: "flags" }, eritrea: { keywords: ["er", "flag", "nation", "country", "banner"], char: "🇪🇷", fitzpatrick_scale: !1, category: "flags" }, estonia: { keywords: ["ee", "flag", "nation", "country", "banner"], char: "🇪🇪", fitzpatrick_scale: !1, category: "flags" }, ethiopia: { keywords: ["et", "flag", "nation", "country", "banner"], char: "🇪🇹", fitzpatrick_scale: !1, category: "flags" }, eu: { keywords: ["european", "union", "flag", "banner"], char: "🇪🇺", fitzpatrick_scale: !1, category: "flags" }, falkland_islands: { keywords: ["falkland", "islands", "malvinas", "flag", "nation", "country", "banner"], char: "🇫🇰", fitzpatrick_scale: !1, category: "flags" }, faroe_islands: { keywords: ["faroe", "islands", "flag", "nation", "country", "banner"], char: "🇫🇴", fitzpatrick_scale: !1, category: "flags" }, fiji: { keywords: ["fj", "flag", "nation", "country", "banner"], char: "🇫🇯", fitzpatrick_scale: !1, category: "flags" }, finland: { keywords: ["fi", "flag", "nation", "country", "banner"], char: "🇫🇮", fitzpatrick_scale: !1, category: "flags" }, fr: { keywords: ["banner", "flag", "nation", "france", "french", "country"], char: "🇫🇷", fitzpatrick_scale: !1, category: "flags" }, french_guiana: { keywords: ["french", "guiana", "flag", "nation", "country", "banner"], char: "🇬🇫", fitzpatrick_scale: !1, category: "flags" }, french_polynesia: { keywords: ["french", "polynesia", "flag", "nation", "country", "banner"], char: "🇵🇫", fitzpatrick_scale: !1, category: "flags" }, french_southern_territories: { keywords: ["french", "southern", "territories", "flag", "nation", "country", "banner"], char: "🇹🇫", fitzpatrick_scale: !1, category: "flags" }, gabon: { keywords: ["ga", "flag", "nation", "country", "banner"], char: "🇬🇦", fitzpatrick_scale: !1, category: "flags" }, gambia: { keywords: ["gm", "flag", "nation", "country", "banner"], char: "🇬🇲", fitzpatrick_scale: !1, category: "flags" }, georgia: { keywords: ["ge", "flag", "nation", "country", "banner"], char: "🇬🇪", fitzpatrick_scale: !1, category: "flags" }, de: { keywords: ["german", "nation", "flag", "country", "banner"], char: "🇩🇪", fitzpatrick_scale: !1, category: "flags" }, ghana: { keywords: ["gh", "flag", "nation", "country", "banner"], char: "🇬🇭", fitzpatrick_scale: !1, category: "flags" }, gibraltar: { keywords: ["gi", "flag", "nation", "country", "banner"], char: "🇬🇮", fitzpatrick_scale: !1, category: "flags" }, greece: { keywords: ["gr", "flag", "nation", "country", "banner"], char: "🇬🇷", fitzpatrick_scale: !1, category: "flags" }, greenland: { keywords: ["gl", "flag", "nation", "country", "banner"], char: "🇬🇱", fitzpatrick_scale: !1, category: "flags" }, grenada: { keywords: ["gd", "flag", "nation", "country", "banner"], char: "🇬🇩", fitzpatrick_scale: !1, category: "flags" }, guadeloupe: { keywords: ["gp", "flag", "nation", "country", "banner"], char: "🇬🇵", fitzpatrick_scale: !1, category: "flags" }, guam: { keywords: ["gu", "flag", "nation", "country", "banner"], char: "🇬🇺", fitzpatrick_scale: !1, category: "flags" }, guatemala: { keywords: ["gt", "flag", "nation", "country", "banner"], char: "🇬🇹", fitzpatrick_scale: !1, category: "flags" }, guernsey: { keywords: ["gg", "flag", "nation", "country", "banner"], char: "🇬🇬", fitzpatrick_scale: !1, category: "flags" }, guinea: { keywords: ["gn", "flag", "nation", "country", "banner"], char: "🇬🇳", fitzpatrick_scale: !1, category: "flags" }, guinea_bissau: { keywords: ["gw", "bissau", "flag", "nation", "country", "banner"], char: "🇬🇼", fitzpatrick_scale: !1, category: "flags" }, guyana: { keywords: ["gy", "flag", "nation", "country", "banner"], char: "🇬🇾", fitzpatrick_scale: !1, category: "flags" }, haiti: { keywords: ["ht", "flag", "nation", "country", "banner"], char: "🇭🇹", fitzpatrick_scale: !1, category: "flags" }, honduras: { keywords: ["hn", "flag", "nation", "country", "banner"], char: "🇭🇳", fitzpatrick_scale: !1, category: "flags" }, hong_kong: { keywords: ["hong", "kong", "flag", "nation", "country", "banner"], char: "🇭🇰", fitzpatrick_scale: !1, category: "flags" }, hungary: { keywords: ["hu", "flag", "nation", "country", "banner"], char: "🇭🇺", fitzpatrick_scale: !1, category: "flags" }, iceland: { keywords: ["is", "flag", "nation", "country", "banner"], char: "🇮🇸", fitzpatrick_scale: !1, category: "flags" }, india: { keywords: ["in", "flag", "nation", "country", "banner"], char: "🇮🇳", fitzpatrick_scale: !1, category: "flags" }, indonesia: { keywords: ["flag", "nation", "country", "banner"], char: "🇮🇩", fitzpatrick_scale: !1, category: "flags" }, iran: { keywords: ["iran,", "islamic", "republic", "flag", "nation", "country", "banner"], char: "🇮🇷", fitzpatrick_scale: !1, category: "flags" }, iraq: { keywords: ["iq", "flag", "nation", "country", "banner"], char: "🇮🇶", fitzpatrick_scale: !1, category: "flags" }, ireland: { keywords: ["ie", "flag", "nation", "country", "banner"], char: "🇮🇪", fitzpatrick_scale: !1, category: "flags" }, isle_of_man: { keywords: ["isle", "man", "flag", "nation", "country", "banner"], char: "🇮🇲", fitzpatrick_scale: !1, category: "flags" }, israel: { keywords: ["il", "flag", "nation", "country", "banner"], char: "🇮🇱", fitzpatrick_scale: !1, category: "flags" }, it: { keywords: ["italy", "flag", "nation", "country", "banner"], char: "🇮🇹", fitzpatrick_scale: !1, category: "flags" }, cote_divoire: { keywords: ["ivory", "coast", "flag", "nation", "country", "banner"], char: "🇨🇮", fitzpatrick_scale: !1, category: "flags" }, jamaica: { keywords: ["jm", "flag", "nation", "country", "banner"], char: "🇯🇲", fitzpatrick_scale: !1, category: "flags" }, jp: { keywords: ["japanese", "nation", "flag", "country", "banner"], char: "🇯🇵", fitzpatrick_scale: !1, category: "flags" }, jersey: { keywords: ["je", "flag", "nation", "country", "banner"], char: "🇯🇪", fitzpatrick_scale: !1, category: "flags" }, jordan: { keywords: ["jo", "flag", "nation", "country", "banner"], char: "🇯🇴", fitzpatrick_scale: !1, category: "flags" }, kazakhstan: { keywords: ["kz", "flag", "nation", "country", "banner"], char: "🇰🇿", fitzpatrick_scale: !1, category: "flags" }, kenya: { keywords: ["ke", "flag", "nation", "country", "banner"], char: "🇰🇪", fitzpatrick_scale: !1, category: "flags" }, kiribati: { keywords: ["ki", "flag", "nation", "country", "banner"], char: "🇰🇮", fitzpatrick_scale: !1, category: "flags" }, kosovo: { keywords: ["xk", "flag", "nation", "country", "banner"], char: "🇽🇰", fitzpatrick_scale: !1, category: "flags" }, kuwait: { keywords: ["kw", "flag", "nation", "country", "banner"], char: "🇰🇼", fitzpatrick_scale: !1, category: "flags" }, kyrgyzstan: { keywords: ["kg", "flag", "nation", "country", "banner"], char: "🇰🇬", fitzpatrick_scale: !1, category: "flags" }, laos: { keywords: ["lao", "democratic", "republic", "flag", "nation", "country", "banner"], char: "🇱🇦", fitzpatrick_scale: !1, category: "flags" }, latvia: { keywords: ["lv", "flag", "nation", "country", "banner"], char: "🇱🇻", fitzpatrick_scale: !1, category: "flags" }, lebanon: { keywords: ["lb", "flag", "nation", "country", "banner"], char: "🇱🇧", fitzpatrick_scale: !1, category: "flags" }, lesotho: { keywords: ["ls", "flag", "nation", "country", "banner"], char: "🇱🇸", fitzpatrick_scale: !1, category: "flags" }, liberia: { keywords: ["lr", "flag", "nation", "country", "banner"], char: "🇱🇷", fitzpatrick_scale: !1, category: "flags" }, libya: { keywords: ["ly", "flag", "nation", "country", "banner"], char: "🇱🇾", fitzpatrick_scale: !1, category: "flags" }, liechtenstein: { keywords: ["li", "flag", "nation", "country", "banner"], char: "🇱🇮", fitzpatrick_scale: !1, category: "flags" }, lithuania: { keywords: ["lt", "flag", "nation", "country", "banner"], char: "🇱🇹", fitzpatrick_scale: !1, category: "flags" }, luxembourg: { keywords: ["lu", "flag", "nation", "country", "banner"], char: "🇱🇺", fitzpatrick_scale: !1, category: "flags" }, macau: { keywords: ["macao", "flag", "nation", "country", "banner"], char: "🇲🇴", fitzpatrick_scale: !1, category: "flags" }, macedonia: { keywords: ["macedonia,", "flag", "nation", "country", "banner"], char: "🇲🇰", fitzpatrick_scale: !1, category: "flags" }, madagascar: { keywords: ["mg", "flag", "nation", "country", "banner"], char: "🇲🇬", fitzpatrick_scale: !1, category: "flags" }, malawi: { keywords: ["mw", "flag", "nation", "country", "banner"], char: "🇲🇼", fitzpatrick_scale: !1, category: "flags" }, malaysia: { keywords: ["my", "flag", "nation", "country", "banner"], char: "🇲🇾", fitzpatrick_scale: !1, category: "flags" }, maldives: { keywords: ["mv", "flag", "nation", "country", "banner"], char: "🇲🇻", fitzpatrick_scale: !1, category: "flags" }, mali: { keywords: ["ml", "flag", "nation", "country", "banner"], char: "🇲🇱", fitzpatrick_scale: !1, category: "flags" }, malta: { keywords: ["mt", "flag", "nation", "country", "banner"], char: "🇲🇹", fitzpatrick_scale: !1, category: "flags" }, marshall_islands: { keywords: ["marshall", "islands", "flag", "nation", "country", "banner"], char: "🇲🇭", fitzpatrick_scale: !1, category: "flags" }, martinique: { keywords: ["mq", "flag", "nation", "country", "banner"], char: "🇲🇶", fitzpatrick_scale: !1, category: "flags" }, mauritania: { keywords: ["mr", "flag", "nation", "country", "banner"], char: "🇲🇷", fitzpatrick_scale: !1, category: "flags" }, mauritius: { keywords: ["mu", "flag", "nation", "country", "banner"], char: "🇲🇺", fitzpatrick_scale: !1, category: "flags" }, mayotte: { keywords: ["yt", "flag", "nation", "country", "banner"], char: "🇾🇹", fitzpatrick_scale: !1, category: "flags" }, mexico: { keywords: ["mx", "flag", "nation", "country", "banner"], char: "🇲🇽", fitzpatrick_scale: !1, category: "flags" }, micronesia: { keywords: ["micronesia,", "federated", "states", "flag", "nation", "country", "banner"], char: "🇫🇲", fitzpatrick_scale: !1, category: "flags" }, moldova: { keywords: ["moldova,", "republic", "flag", "nation", "country", "banner"], char: "🇲🇩", fitzpatrick_scale: !1, category: "flags" }, monaco: { keywords: ["mc", "flag", "nation", "country", "banner"], char: "🇲🇨", fitzpatrick_scale: !1, category: "flags" }, mongolia: { keywords: ["mn", "flag", "nation", "country", "banner"], char: "🇲🇳", fitzpatrick_scale: !1, category: "flags" }, montenegro: { keywords: ["me", "flag", "nation", "country", "banner"], char: "🇲🇪", fitzpatrick_scale: !1, category: "flags" }, montserrat: { keywords: ["ms", "flag", "nation", "country", "banner"], char: "🇲🇸", fitzpatrick_scale: !1, category: "flags" }, morocco: { keywords: ["ma", "flag", "nation", "country", "banner"], char: "🇲🇦", fitzpatrick_scale: !1, category: "flags" }, mozambique: { keywords: ["mz", "flag", "nation", "country", "banner"], char: "🇲🇿", fitzpatrick_scale: !1, category: "flags" }, myanmar: { keywords: ["mm", "flag", "nation", "country", "banner"], char: "🇲🇲", fitzpatrick_scale: !1, category: "flags" }, namibia: { keywords: ["na", "flag", "nation", "country", "banner"], char: "🇳🇦", fitzpatrick_scale: !1, category: "flags" }, nauru: { keywords: ["nr", "flag", "nation", "country", "banner"], char: "🇳🇷", fitzpatrick_scale: !1, category: "flags" }, nepal: { keywords: ["np", "flag", "nation", "country", "banner"], char: "🇳🇵", fitzpatrick_scale: !1, category: "flags" }, netherlands: { keywords: ["nl", "flag", "nation", "country", "banner"], char: "🇳🇱", fitzpatrick_scale: !1, category: "flags" }, new_caledonia: { keywords: ["new", "caledonia", "flag", "nation", "country", "banner"], char: "🇳🇨", fitzpatrick_scale: !1, category: "flags" }, new_zealand: { keywords: ["new", "zealand", "flag", "nation", "country", "banner"], char: "🇳🇿", fitzpatrick_scale: !1, category: "flags" }, nicaragua: { keywords: ["ni", "flag", "nation", "country", "banner"], char: "🇳🇮", fitzpatrick_scale: !1, category: "flags" }, niger: { keywords: ["ne", "flag", "nation", "country", "banner"], char: "🇳🇪", fitzpatrick_scale: !1, category: "flags" }, nigeria: { keywords: ["flag", "nation", "country", "banner"], char: "🇳🇬", fitzpatrick_scale: !1, category: "flags" }, niue: { keywords: ["nu", "flag", "nation", "country", "banner"], char: "🇳🇺", fitzpatrick_scale: !1, category: "flags" }, norfolk_island: { keywords: ["norfolk", "island", "flag", "nation", "country", "banner"], char: "🇳🇫", fitzpatrick_scale: !1, category: "flags" }, northern_mariana_islands: { keywords: ["northern", "mariana", "islands", "flag", "nation", "country", "banner"], char: "🇲🇵", fitzpatrick_scale: !1, category: "flags" }, north_korea: { keywords: ["north", "korea", "nation", "flag", "country", "banner"], char: "🇰🇵", fitzpatrick_scale: !1, category: "flags" }, norway: { keywords: ["no", "flag", "nation", "country", "banner"], char: "🇳🇴", fitzpatrick_scale: !1, category: "flags" }, oman: { keywords: ["om_symbol", "flag", "nation", "country", "banner"], char: "🇴🇲", fitzpatrick_scale: !1, category: "flags" }, pakistan: { keywords: ["pk", "flag", "nation", "country", "banner"], char: "🇵🇰", fitzpatrick_scale: !1, category: "flags" }, palau: { keywords: ["pw", "flag", "nation", "country", "banner"], char: "🇵🇼", fitzpatrick_scale: !1, category: "flags" }, palestinian_territories: { keywords: ["palestine", "palestinian", "territories", "flag", "nation", "country", "banner"], char: "🇵🇸", fitzpatrick_scale: !1, category: "flags" }, panama: { keywords: ["pa", "flag", "nation", "country", "banner"], char: "🇵🇦", fitzpatrick_scale: !1, category: "flags" }, papua_new_guinea: { keywords: ["papua", "new", "guinea", "flag", "nation", "country", "banner"], char: "🇵🇬", fitzpatrick_scale: !1, category: "flags" }, paraguay: { keywords: ["py", "flag", "nation", "country", "banner"], char: "🇵🇾", fitzpatrick_scale: !1, category: "flags" }, peru: { keywords: ["pe", "flag", "nation", "country", "banner"], char: "🇵🇪", fitzpatrick_scale: !1, category: "flags" }, philippines: { keywords: ["ph", "flag", "nation", "country", "banner"], char: "🇵🇭", fitzpatrick_scale: !1, category: "flags" }, pitcairn_islands: { keywords: ["pitcairn", "flag", "nation", "country", "banner"], char: "🇵🇳", fitzpatrick_scale: !1, category: "flags" }, poland: { keywords: ["pl", "flag", "nation", "country", "banner"], char: "🇵🇱", fitzpatrick_scale: !1, category: "flags" }, portugal: { keywords: ["pt", "flag", "nation", "country", "banner"], char: "🇵🇹", fitzpatrick_scale: !1, category: "flags" }, puerto_rico: { keywords: ["puerto", "rico", "flag", "nation", "country", "banner"], char: "🇵🇷", fitzpatrick_scale: !1, category: "flags" }, qatar: { keywords: ["qa", "flag", "nation", "country", "banner"], char: "🇶🇦", fitzpatrick_scale: !1, category: "flags" }, reunion: { keywords: ["réunion", "flag", "nation", "country", "banner"], char: "🇷🇪", fitzpatrick_scale: !1, category: "flags" }, romania: { keywords: ["ro", "flag", "nation", "country", "banner"], char: "🇷🇴", fitzpatrick_scale: !1, category: "flags" }, ru: { keywords: ["russian", "federation", "flag", "nation", "country", "banner"], char: "🇷🇺", fitzpatrick_scale: !1, category: "flags" }, rwanda: { keywords: ["rw", "flag", "nation", "country", "banner"], char: "🇷🇼", fitzpatrick_scale: !1, category: "flags" }, st_barthelemy: { keywords: ["saint", "barthélemy", "flag", "nation", "country", "banner"], char: "🇧🇱", fitzpatrick_scale: !1, category: "flags" }, st_helena: { keywords: ["saint", "helena", "ascension", "tristan", "cunha", "flag", "nation", "country", "banner"], char: "🇸🇭", fitzpatrick_scale: !1, category: "flags" }, st_kitts_nevis: { keywords: ["saint", "kitts", "nevis", "flag", "nation", "country", "banner"], char: "🇰🇳", fitzpatrick_scale: !1, category: "flags" }, st_lucia: { keywords: ["saint", "lucia", "flag", "nation", "country", "banner"], char: "🇱🇨", fitzpatrick_scale: !1, category: "flags" }, st_pierre_miquelon: { keywords: ["saint", "pierre", "miquelon", "flag", "nation", "country", "banner"], char: "🇵🇲", fitzpatrick_scale: !1, category: "flags" }, st_vincent_grenadines: { keywords: ["saint", "vincent", "grenadines", "flag", "nation", "country", "banner"], char: "🇻🇨", fitzpatrick_scale: !1, category: "flags" }, samoa: { keywords: ["ws", "flag", "nation", "country", "banner"], char: "🇼🇸", fitzpatrick_scale: !1, category: "flags" }, san_marino: { keywords: ["san", "marino", "flag", "nation", "country", "banner"], char: "🇸🇲", fitzpatrick_scale: !1, category: "flags" }, sao_tome_principe: { keywords: ["sao", "tome", "principe", "flag", "nation", "country", "banner"], char: "🇸🇹", fitzpatrick_scale: !1, category: "flags" }, saudi_arabia: { keywords: ["flag", "nation", "country", "banner"], char: "🇸🇦", fitzpatrick_scale: !1, category: "flags" }, senegal: { keywords: ["sn", "flag", "nation", "country", "banner"], char: "🇸🇳", fitzpatrick_scale: !1, category: "flags" }, serbia: { keywords: ["rs", "flag", "nation", "country", "banner"], char: "🇷🇸", fitzpatrick_scale: !1, category: "flags" }, seychelles: { keywords: ["sc", "flag", "nation", "country", "banner"], char: "🇸🇨", fitzpatrick_scale: !1, category: "flags" }, sierra_leone: { keywords: ["sierra", "leone", "flag", "nation", "country", "banner"], char: "🇸🇱", fitzpatrick_scale: !1, category: "flags" }, singapore: { keywords: ["sg", "flag", "nation", "country", "banner"], char: "🇸🇬", fitzpatrick_scale: !1, category: "flags" }, sint_maarten: { keywords: ["sint", "maarten", "dutch", "flag", "nation", "country", "banner"], char: "🇸🇽", fitzpatrick_scale: !1, category: "flags" }, slovakia: { keywords: ["sk", "flag", "nation", "country", "banner"], char: "🇸🇰", fitzpatrick_scale: !1, category: "flags" }, slovenia: { keywords: ["si", "flag", "nation", "country", "banner"], char: "🇸🇮", fitzpatrick_scale: !1, category: "flags" }, solomon_islands: { keywords: ["solomon", "islands", "flag", "nation", "country", "banner"], char: "🇸🇧", fitzpatrick_scale: !1, category: "flags" }, somalia: { keywords: ["so", "flag", "nation", "country", "banner"], char: "🇸🇴", fitzpatrick_scale: !1, category: "flags" }, south_africa: { keywords: ["south", "africa", "flag", "nation", "country", "banner"], char: "🇿🇦", fitzpatrick_scale: !1, category: "flags" }, south_georgia_south_sandwich_islands: { keywords: ["south", "georgia", "sandwich", "islands", "flag", "nation", "country", "banner"], char: "🇬🇸", fitzpatrick_scale: !1, category: "flags" }, kr: { keywords: ["south", "korea", "nation", "flag", "country", "banner"], char: "🇰🇷", fitzpatrick_scale: !1, category: "flags" }, south_sudan: { keywords: ["south", "sd", "flag", "nation", "country", "banner"], char: "🇸🇸", fitzpatrick_scale: !1, category: "flags" }, es: { keywords: ["spain", "flag", "nation", "country", "banner"], char: "🇪🇸", fitzpatrick_scale: !1, category: "flags" }, sri_lanka: { keywords: ["sri", "lanka", "flag", "nation", "country", "banner"], char: "🇱🇰", fitzpatrick_scale: !1, category: "flags" }, sudan: { keywords: ["sd", "flag", "nation", "country", "banner"], char: "🇸🇩", fitzpatrick_scale: !1, category: "flags" }, suriname: { keywords: ["sr", "flag", "nation", "country", "banner"], char: "🇸🇷", fitzpatrick_scale: !1, category: "flags" }, swaziland: { keywords: ["sz", "flag", "nation", "country", "banner"], char: "🇸🇿", fitzpatrick_scale: !1, category: "flags" }, sweden: { keywords: ["se", "flag", "nation", "country", "banner"], char: "🇸🇪", fitzpatrick_scale: !1, category: "flags" }, switzerland: { keywords: ["ch", "flag", "nation", "country", "banner"], char: "🇨🇭", fitzpatrick_scale: !1, category: "flags" }, syria: { keywords: ["syrian", "arab", "republic", "flag", "nation", "country", "banner"], char: "🇸🇾", fitzpatrick_scale: !1, category: "flags" }, taiwan: { keywords: ["tw", "flag", "nation", "country", "banner"], char: "🇹🇼", fitzpatrick_scale: !1, category: "flags" }, tajikistan: { keywords: ["tj", "flag", "nation", "country", "banner"], char: "🇹🇯", fitzpatrick_scale: !1, category: "flags" }, tanzania: { keywords: ["tanzania,", "united", "republic", "flag", "nation", "country", "banner"], char: "🇹🇿", fitzpatrick_scale: !1, category: "flags" }, thailand: { keywords: ["th", "flag", "nation", "country", "banner"], char: "🇹🇭", fitzpatrick_scale: !1, category: "flags" }, timor_leste: { keywords: ["timor", "leste", "flag", "nation", "country", "banner"], char: "🇹🇱", fitzpatrick_scale: !1, category: "flags" }, togo: { keywords: ["tg", "flag", "nation", "country", "banner"], char: "🇹🇬", fitzpatrick_scale: !1, category: "flags" }, tokelau: { keywords: ["tk", "flag", "nation", "country", "banner"], char: "🇹🇰", fitzpatrick_scale: !1, category: "flags" }, tonga: { keywords: ["to", "flag", "nation", "country", "banner"], char: "🇹🇴", fitzpatrick_scale: !1, category: "flags" }, trinidad_tobago: { keywords: ["trinidad", "tobago", "flag", "nation", "country", "banner"], char: "🇹🇹", fitzpatrick_scale: !1, category: "flags" }, tunisia: { keywords: ["tn", "flag", "nation", "country", "banner"], char: "🇹🇳", fitzpatrick_scale: !1, category: "flags" }, tr: { keywords: ["turkey", "flag", "nation", "country", "banner"], char: "🇹🇷", fitzpatrick_scale: !1, category: "flags" }, turkmenistan: { keywords: ["flag", "nation", "country", "banner"], char: "🇹🇲", fitzpatrick_scale: !1, category: "flags" }, turks_caicos_islands: { keywords: ["turks", "caicos", "islands", "flag", "nation", "country", "banner"], char: "🇹🇨", fitzpatrick_scale: !1, category: "flags" }, tuvalu: { keywords: ["flag", "nation", "country", "banner"], char: "🇹🇻", fitzpatrick_scale: !1, category: "flags" }, uganda: { keywords: ["ug", "flag", "nation", "country", "banner"], char: "🇺🇬", fitzpatrick_scale: !1, category: "flags" }, ukraine: { keywords: ["ua", "flag", "nation", "country", "banner"], char: "🇺🇦", fitzpatrick_scale: !1, category: "flags" }, united_arab_emirates: { keywords: ["united", "arab", "emirates", "flag", "nation", "country", "banner"], char: "🇦🇪", fitzpatrick_scale: !1, category: "flags" }, uk: { keywords: ["united", "kingdom", "great", "britain", "northern", "ireland", "flag", "nation", "country", "banner", "british", "UK", "english", "england", "union jack"], char: "🇬🇧", fitzpatrick_scale: !1, category: "flags" }, england: { keywords: ["flag", "english"], char: "🏴󠁧󠁢󠁥󠁮󠁧󠁿", fitzpatrick_scale: !1, category: "flags" }, scotland: { keywords: ["flag", "scottish"], char: "🏴󠁧󠁢󠁳󠁣󠁴󠁿", fitzpatrick_scale: !1, category: "flags" }, wales: { keywords: ["flag", "welsh"], char: "🏴󠁧󠁢󠁷󠁬󠁳󠁿", fitzpatrick_scale: !1, category: "flags" }, us: { keywords: ["united", "states", "america", "flag", "nation", "country", "banner"], char: "🇺🇸", fitzpatrick_scale: !1, category: "flags" }, us_virgin_islands: { keywords: ["virgin", "islands", "us", "flag", "nation", "country", "banner"], char: "🇻🇮", fitzpatrick_scale: !1, category: "flags" }, uruguay: { keywords: ["uy", "flag", "nation", "country", "banner"], char: "🇺🇾", fitzpatrick_scale: !1, category: "flags" }, uzbekistan: { keywords: ["uz", "flag", "nation", "country", "banner"], char: "🇺🇿", fitzpatrick_scale: !1, category: "flags" }, vanuatu: { keywords: ["vu", "flag", "nation", "country", "banner"], char: "🇻🇺", fitzpatrick_scale: !1, category: "flags" }, vatican_city: { keywords: ["vatican", "city", "flag", "nation", "country", "banner"], char: "🇻🇦", fitzpatrick_scale: !1, category: "flags" }, venezuela: { keywords: ["ve", "bolivarian", "republic", "flag", "nation", "country", "banner"], char: "🇻🇪", fitzpatrick_scale: !1, category: "flags" }, vietnam: { keywords: ["viet", "nam", "flag", "nation", "country", "banner"], char: "🇻🇳", fitzpatrick_scale: !1, category: "flags" }, wallis_futuna: { keywords: ["wallis", "futuna", "flag", "nation", "country", "banner"], char: "🇼🇫", fitzpatrick_scale: !1, category: "flags" }, western_sahara: { keywords: ["western", "sahara", "flag", "nation", "country", "banner"], char: "🇪🇭", fitzpatrick_scale: !1, category: "flags" }, yemen: { keywords: ["ye", "flag", "nation", "country", "banner"], char: "🇾🇪", fitzpatrick_scale: !1, category: "flags" }, zambia: { keywords: ["zm", "flag", "nation", "country", "banner"], char: "🇿🇲", fitzpatrick_scale: !1, category: "flags" }, zimbabwe: { keywords: ["zw", "flag", "nation", "country", "banner"], char: "🇿🇼", fitzpatrick_scale: !1, category: "flags" }, united_nations: { keywords: ["un", "flag", "banner"], char: "🇺🇳", fitzpatrick_scale: !1, category: "flags" }, pirate_flag: { keywords: ["skull", "crossbones", "flag", "banner"], char: "🏴‍☠️", fitzpatrick_scale: !1, category: "flags" } });
(function() {
  var v = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const L = (te, ze, Pe) => {
    var Qe;
    return Pe(te, ze.prototype) ? !0 : ((Qe = te.constructor) === null || Qe === void 0 ? void 0 : Qe.name) === ze.name;
  }, N = (te) => {
    const ze = typeof te;
    return te === null ? "null" : ze === "object" && Array.isArray(te) ? "array" : ze === "object" && L(te, String, (Pe, Qe) => Qe.isPrototypeOf(Pe)) ? "string" : ze;
  }, W = (te) => (ze) => N(ze) === te, ue = (te) => (ze) => typeof ze === te, ce = (te) => (ze) => te === ze, he = W("string"), pe = W("object"), Me = W("array"), Ze = ce(null), Ye = ue("boolean"), yt = (te) => te == null, jt = (te) => !yt(te), it = ue("function"), Rt = (te, ze) => {
    if (Me(te)) {
      for (let Pe = 0, Qe = te.length; Pe < Qe; ++Pe)
        if (!ze(te[Pe]))
          return !1;
      return !0;
    }
    return !1;
  }, en = () => {
  }, Gt = (te) => () => te, gt = (te, ze) => te === ze;
  class an {
    constructor(ze, Pe) {
      this.tag = ze, this.value = Pe;
    }
    static some(ze) {
      return new an(!0, ze);
    }
    static none() {
      return an.singletonNone;
    }
    fold(ze, Pe) {
      return this.tag ? Pe(this.value) : ze();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(ze) {
      return this.tag ? an.some(ze(this.value)) : an.none();
    }
    bind(ze) {
      return this.tag ? ze(this.value) : an.none();
    }
    exists(ze) {
      return this.tag && ze(this.value);
    }
    forall(ze) {
      return !this.tag || ze(this.value);
    }
    filter(ze) {
      return !this.tag || ze(this.value) ? this : an.none();
    }
    getOr(ze) {
      return this.tag ? this.value : ze;
    }
    or(ze) {
      return this.tag ? this : ze;
    }
    getOrThunk(ze) {
      return this.tag ? this.value : ze();
    }
    orThunk(ze) {
      return this.tag ? this : ze();
    }
    getOrDie(ze) {
      if (this.tag)
        return this.value;
      throw new Error(ze ?? "Called getOrDie on None");
    }
    static from(ze) {
      return jt(ze) ? an.some(ze) : an.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(ze) {
      this.tag && ze(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  an.singletonNone = new an(!1);
  const Ot = Array.prototype.indexOf, Ee = Array.prototype.push, wt = (te, ze) => Ot.call(te, ze), Se = (te, ze) => wt(te, ze) > -1, We = (te, ze) => {
    const Pe = te.length, Qe = new Array(Pe);
    for (let Ft = 0; Ft < Pe; Ft++) {
      const An = te[Ft];
      Qe[Ft] = ze(An, Ft);
    }
    return Qe;
  }, Cn = (te, ze) => {
    for (let Pe = 0, Qe = te.length; Pe < Qe; Pe++) {
      const Ft = te[Pe];
      ze(Ft, Pe);
    }
  }, ko = (te, ze, Pe) => (Cn(te, (Qe, Ft) => {
    Pe = ze(Pe, Qe, Ft);
  }), Pe), jn = (te) => {
    const ze = [];
    for (let Pe = 0, Qe = te.length; Pe < Qe; ++Pe) {
      if (!Me(te[Pe]))
        throw new Error("Arr.flatten item " + Pe + " was not an array, input: " + te);
      Ee.apply(ze, te[Pe]);
    }
    return ze;
  }, Xe = (te, ze) => jn(We(te, ze)), un = (te, ze) => {
    for (let Pe = 0; Pe < te.length; Pe++) {
      const Qe = ze(te[Pe], Pe);
      if (Qe.isSome())
        return Qe;
    }
    return an.none();
  }, M = (te, ze, Pe = gt) => te.exists((Qe) => Pe(Qe, ze)), Et = (te) => {
    const ze = [], Pe = (Qe) => {
      ze.push(Qe);
    };
    for (let Qe = 0; Qe < te.length; Qe++)
      te[Qe].each(Pe);
    return ze;
  }, ht = (te, ze) => te ? an.some(ze) : an.none(), mn = (te) => (ze) => ze.options.get(te), lo = (te) => {
    const ze = te.options.register;
    ze("link_assume_external_targets", {
      processor: (Pe) => {
        const Qe = he(Pe) || Ye(Pe);
        return Qe ? Pe === !0 ? {
          value: 1,
          valid: Qe
        } : Pe === "http" || Pe === "https" ? {
          value: Pe,
          valid: Qe
        } : {
          value: 0,
          valid: Qe
        } : {
          valid: !1,
          message: "Must be a string or a boolean."
        };
      },
      default: !1
    }), ze("link_context_toolbar", {
      processor: "boolean",
      default: !1
    }), ze("link_list", { processor: (Pe) => he(Pe) || it(Pe) || Rt(Pe, pe) }), ze("link_default_target", { processor: "string" }), ze("link_default_protocol", {
      processor: "string",
      default: "https"
    }), ze("link_target_list", {
      processor: (Pe) => Ye(Pe) || Rt(Pe, pe),
      default: !0
    }), ze("link_rel_list", {
      processor: "object[]",
      default: []
    }), ze("link_class_list", {
      processor: "object[]",
      default: []
    }), ze("link_title", {
      processor: "boolean",
      default: !0
    }), ze("allow_unsafe_link_target", {
      processor: "boolean",
      default: !1
    }), ze("link_quicklink", {
      processor: "boolean",
      default: !1
    });
  }, dt = mn("link_assume_external_targets"), Bn = mn("link_context_toolbar"), jr = mn("link_list"), Tt = mn("link_default_target"), yo = mn("link_default_protocol"), Ct = mn("link_target_list"), tn = mn("link_rel_list"), oa = mn("link_class_list"), Pn = mn("link_title"), Mo = mn("allow_unsafe_link_target"), K = mn("link_quicklink");
  var Go = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const Zi = (te) => he(te.value) ? te.value : "", er = (te) => he(te.text) ? te.text : he(te.title) ? te.title : "", Qr = (te, ze) => {
    const Pe = [];
    return Go.each(te, (Qe) => {
      const Ft = er(Qe);
      if (Qe.menu !== void 0) {
        const An = Qr(Qe.menu, ze);
        Pe.push({
          text: Ft,
          items: An
        });
      } else {
        const An = ze(Qe);
        Pe.push({
          text: Ft,
          value: An
        });
      }
    }), Pe;
  }, nc = (te = Zi) => (ze) => an.from(ze).map((Pe) => Qr(Pe, te)), oo = {
    sanitize: (te) => nc(Zi)(te),
    sanitizeWith: nc,
    createUi: (te, ze) => (Pe) => ({
      name: te,
      type: "listbox",
      label: ze,
      items: Pe
    }),
    getValue: Zi
  }, ut = Object.keys, kt = Object.hasOwnProperty, It = (te, ze) => {
    const Pe = ut(te);
    for (let Qe = 0, Ft = Pe.length; Qe < Ft; Qe++) {
      const An = Pe[Qe], so = te[An];
      ze(so, An);
    }
  }, ct = (te) => (ze, Pe) => {
    te[Pe] = ze;
  }, xn = (te, ze, Pe, Qe) => {
    It(te, (Ft, An) => {
      (ze(Ft, An) ? Pe : Qe)(Ft, An);
    });
  }, co = (te, ze) => {
    const Pe = {};
    return xn(te, ze, ct(Pe), en), Pe;
  }, Ko = (te, ze) => kt.call(te, ze), po = (te, ze) => Ko(te, ze) && te[ze] !== void 0 && te[ze] !== null;
  var Ra = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker"), Mr = tinymce.util.Tools.resolve("tinymce.util.URI");
  const ho = (te) => jt(te) && te.nodeName.toLowerCase() === "a", Ns = (te) => ho(te) && !!$r(te), Ca = (te, ze) => {
    if (te.collapsed)
      return [];
    {
      const Pe = te.cloneContents(), Qe = Pe.firstChild, Ft = new Ra(Qe, Pe), An = [];
      let so = Qe;
      do
        ze(so) && An.push(so);
      while (so = Ft.next());
      return An;
    }
  }, Zr = (te) => /^\w+:/i.test(te), $r = (te) => {
    var ze, Pe;
    return (Pe = (ze = te.getAttribute("data-mce-href")) !== null && ze !== void 0 ? ze : te.getAttribute("href")) !== null && Pe !== void 0 ? Pe : "";
  }, Po = (te, ze) => {
    const Pe = ["noopener"], Qe = te ? te.split(/\s+/) : [], Ft = ($n) => Go.trim($n.sort().join(" ")), An = ($n) => ($n = so($n), $n.length > 0 ? $n.concat(Pe) : Pe), so = ($n) => $n.filter((ds) => Go.inArray(Pe, ds) === -1), Zn = ze ? An(Qe) : so(Qe);
    return Zn.length > 0 ? Ft(Zn) : "";
  }, ha = (te) => te.replace(/\uFEFF/g, ""), ro = (te, ze) => (ze = ze || Ys(te.selection.getRng())[0] || te.selection.getNode(), mi(ze) ? an.from(te.dom.select("a[href]", ze)[0]) : an.from(te.dom.getParent(ze, "a[href]"))), cn = (te, ze) => ro(te, ze).isSome(), _n = (te, ze) => {
    const Pe = ze.fold(() => te.getContent({ format: "text" }), (Qe) => Qe.innerText || Qe.textContent || "");
    return ha(Pe);
  }, Ys = (te) => Ca(te, Ns), Si = (te) => Go.grep(te, Ns), Nt = (te) => Si(te).length > 0, fi = (te) => Ys(te).length > 0, Zo = (te) => {
    const ze = te.schema.getTextInlineElements(), Pe = (An) => An.nodeType === 1 && !ho(An) && !Ko(ze, An.nodeName.toLowerCase());
    if (ro(te).exists((An) => An.hasAttribute("data-mce-block")))
      return !1;
    const Ft = te.selection.getRng();
    return Ft.collapsed ? !0 : Ca(Ft, Pe).length === 0;
  }, mi = (te) => jt(te) && te.nodeName === "FIGURE" && /\bimage\b/i.test(te.className), kr = (te) => ko([
    "title",
    "rel",
    "class",
    "target"
  ], (Pe, Qe) => (te[Qe].each((Ft) => {
    Pe[Qe] = Ft.length > 0 ? Ft : null;
  }), Pe), { href: te.href }), Qu = (te, ze) => (ze === "http" || ze === "https") && !Zr(te) ? ze + "://" + te : te, ba = (te, ze) => {
    const Pe = { ...ze };
    if (tn(te).length === 0 && !Mo(te)) {
      const Qe = Po(Pe.rel, Pe.target === "_blank");
      Pe.rel = Qe || null;
    }
    return an.from(Pe.target).isNone() && Ct(te) === !1 && (Pe.target = Tt(te)), Pe.href = Qu(Pe.href, dt(te)), Pe;
  }, xc = (te, ze, Pe, Qe) => {
    Pe.each((Ft) => {
      Ko(ze, "innerText") ? ze.innerText = Ft : ze.textContent = Ft;
    }), te.dom.setAttribs(ze, Qe), te.selection.select(ze);
  }, _l = (te, ze, Pe, Qe) => {
    const Ft = te.dom;
    mi(ze) ? Xt(Ft, ze, Qe) : Pe.fold(() => {
      te.execCommand("mceInsertLink", !1, Qe);
    }, (An) => {
      te.insertContent(Ft.createHTML("a", Qe, Ft.encode(An)));
    });
  }, Wi = (te, ze, Pe) => {
    const Qe = te.selection.getNode(), Ft = ro(te, Qe), An = ba(te, kr(Pe));
    te.undoManager.transact(() => {
      Pe.href === ze.href && ze.attach(), Ft.fold(() => {
        _l(te, Qe, Pe.text, An);
      }, (so) => {
        te.focus(), xc(te, so, Pe.text, An);
      });
    });
  }, oc = (te) => {
    const ze = te.dom, Pe = te.selection, Qe = Pe.getBookmark(), Ft = Pe.getRng().cloneRange(), An = ze.getParent(Ft.startContainer, "a[href]", te.getBody()), so = ze.getParent(Ft.endContainer, "a[href]", te.getBody());
    An && Ft.setStartBefore(An), so && Ft.setEndAfter(so), Pe.setRng(Ft), te.execCommand("unlink"), Pe.moveToBookmark(Qe);
  }, Hr = (te) => {
    te.undoManager.transact(() => {
      const ze = te.selection.getNode();
      mi(ze) ? Xc(te, ze) : oc(te), te.focus();
    });
  }, Yn = (te) => {
    const {
      class: ze,
      href: Pe,
      rel: Qe,
      target: Ft,
      text: An,
      title: so
    } = te;
    return co({
      class: ze.getOrNull(),
      href: Pe,
      rel: Qe.getOrNull(),
      target: Ft.getOrNull(),
      text: An.getOrNull(),
      title: so.getOrNull()
    }, (Zn, $n) => Ze(Zn) === !1);
  }, qi = (te, ze) => {
    const Pe = te.options.get, Qe = {
      allow_html_data_urls: Pe("allow_html_data_urls"),
      allow_script_urls: Pe("allow_script_urls"),
      allow_svg_data_urls: Pe("allow_svg_data_urls")
    }, Ft = ze.href;
    return {
      ...ze,
      href: Mr.isDomSafe(Ft, "a", Qe) ? Ft : ""
    };
  }, Ei = (te, ze, Pe) => {
    const Qe = qi(te, Pe);
    te.hasPlugin("rtc", !0) ? te.execCommand("createlink", !1, Yn(Qe)) : Wi(te, ze, Qe);
  }, Cl = (te) => {
    te.hasPlugin("rtc", !0) ? te.execCommand("unlink") : Hr(te);
  }, Xc = (te, ze) => {
    var Pe;
    const Qe = te.dom.select("img", ze)[0];
    if (Qe) {
      const Ft = te.dom.getParents(Qe, "a[href]", ze)[0];
      Ft && ((Pe = Ft.parentNode) === null || Pe === void 0 || Pe.insertBefore(Qe, Ft), te.dom.remove(Ft));
    }
  }, Xt = (te, ze, Pe) => {
    var Qe;
    const Ft = te.select("img", ze)[0];
    if (Ft) {
      const An = te.create("a", Pe);
      (Qe = Ft.parentNode) === null || Qe === void 0 || Qe.insertBefore(An, Ft), An.appendChild(Ft);
    }
  }, Dd = (te) => po(te, "items"), es = (te, ze) => un(ze, (Pe) => Dd(Pe) ? es(te, Pe.items) : ht(Pe.value === te, Pe)), yf = (te, ze, Pe, Qe) => {
    const Ft = Qe[ze], An = te.length > 0;
    return Ft !== void 0 ? es(Ft, Pe).map((so) => ({
      url: {
        value: so.value,
        meta: {
          text: An ? te : so.text,
          attach: en
        }
      },
      text: An ? te : so.text
    })) : an.none();
  }, Rd = (te, ze) => ze === "link" ? te.link : ze === "anchor" ? te.anchor : an.none(), wc = {
    init: (te, ze) => {
      const Pe = {
        text: te.text,
        title: te.title
      }, Qe = ($n) => {
        var ds;
        return ht(Pe.title.length <= 0, an.from((ds = $n.meta) === null || ds === void 0 ? void 0 : ds.title).getOr(""));
      }, Ft = ($n) => {
        var ds;
        return ht(Pe.text.length <= 0, an.from((ds = $n.meta) === null || ds === void 0 ? void 0 : ds.text).getOr($n.value));
      }, An = ($n) => {
        const ds = Ft($n.url), Cr = Qe($n.url);
        return ds.isSome() || Cr.isSome() ? an.some({
          ...ds.map((Wr) => ({ text: Wr })).getOr({}),
          ...Cr.map((Wr) => ({ title: Wr })).getOr({})
        }) : an.none();
      }, so = ($n, ds) => {
        const Cr = Rd(ze, ds).getOr([]);
        return yf(Pe.text, ds, Cr, $n);
      };
      return { onChange: ($n, ds) => {
        const Cr = ds.name;
        return Cr === "url" ? An($n()) : Se([
          "anchor",
          "link"
        ], Cr) ? so($n(), Cr) : ((Cr === "text" || Cr === "title") && (Pe[Cr] = $n()[Cr]), an.none());
      } };
    },
    getDelta: yf
  };
  var pi = tinymce.util.Tools.resolve("tinymce.util.Delay");
  const ra = (te, ze, Pe) => {
    const Qe = te.selection.getRng();
    pi.setEditorTimeout(te, () => {
      te.windowManager.confirm(ze, (Ft) => {
        te.selection.setRng(Qe), Pe(Ft);
      });
    });
  }, Gi = (te) => {
    const ze = te.href;
    return ze.indexOf("@") > 0 && ze.indexOf("/") === -1 && ze.indexOf("mailto:") === -1 ? an.some({
      message: "The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?",
      preprocess: (Qe) => ({
        ...Qe,
        href: "mailto:" + ze
      })
    }) : an.none();
  }, vf = (te, ze) => (Pe) => {
    const Qe = Pe.href;
    return te === 1 && !Zr(Qe) || te === 0 && /^\s*www(\.|\d\.)/i.test(Qe) ? an.some({
      message: `The URL you entered seems to be an external link. Do you want to add the required ${ze}:// prefix?`,
      preprocess: (An) => ({
        ...An,
        href: ze + "://" + Qe
      })
    }) : an.none();
  }, tm = { preprocess: (te, ze) => un([
    Gi,
    vf(dt(te), yo(te))
  ], (Pe) => Pe(ze)).fold(() => Promise.resolve(ze), (Pe) => new Promise((Qe) => {
    ra(te, Pe.message, (Ft) => {
      Qe(Ft ? Pe.preprocess(ze) : ze);
    });
  })) }, Nd = { getAnchors: (te) => {
    const ze = te.dom.select("a:not([href])"), Pe = Xe(ze, (Qe) => {
      const Ft = Qe.name || Qe.id;
      return Ft ? [{
        text: Ft,
        value: "#" + Ft
      }] : [];
    });
    return Pe.length > 0 ? an.some([{
      text: "None",
      value: ""
    }].concat(Pe)) : an.none();
  } }, Ms = { getClasses: (te) => {
    const ze = oa(te);
    return ze.length > 0 ? oo.sanitize(ze) : an.none();
  } }, ni = (te) => {
    try {
      return an.some(JSON.parse(te));
    } catch {
      return an.none();
    }
  }, Md = { getLinks: (te) => {
    const ze = (Qe) => te.convertURL(Qe.value || Qe.url || "", "href"), Pe = jr(te);
    return new Promise((Qe) => {
      he(Pe) ? fetch(Pe).then((Ft) => Ft.ok ? Ft.text().then(ni) : Promise.reject()).then(Qe, () => Qe(an.none())) : it(Pe) ? Pe((Ft) => Qe(an.some(Ft))) : Qe(an.from(Pe));
    }).then((Qe) => Qe.bind(oo.sanitizeWith(ze)).map((Ft) => Ft.length > 0 ? [{
      text: "None",
      value: ""
    }].concat(Ft) : Ft));
  } }, cl = { getRels: (te, ze) => {
    const Pe = tn(te);
    if (Pe.length > 0) {
      const Qe = M(ze, "_blank"), Ft = Mo(te) === !1, An = (Zn) => Po(oo.getValue(Zn), Qe);
      return (Ft ? oo.sanitizeWith(An) : oo.sanitize)(Pe);
    }
    return an.none();
  } }, sa = [
    {
      text: "Current window",
      value: ""
    },
    {
      text: "New window",
      value: "_blank"
    }
  ], _r = { getTargets: (te) => {
    const ze = Ct(te);
    return Me(ze) ? oo.sanitize(ze).orThunk(() => an.some(sa)) : ze === !1 ? an.none() : an.some(sa);
  } }, Dr = (te, ze, Pe) => {
    const Qe = te.getAttrib(ze, Pe);
    return Qe !== null && Qe.length > 0 ? an.some(Qe) : an.none();
  }, El = (te, ze) => {
    const Pe = te.dom, Ft = Zo(te) ? an.some(_n(te.selection, ze)) : an.none(), An = ze.bind((Cr) => an.from(Pe.getAttrib(Cr, "href"))), so = ze.bind((Cr) => an.from(Pe.getAttrib(Cr, "target"))), Zn = ze.bind((Cr) => Dr(Pe, Cr, "rel")), $n = ze.bind((Cr) => Dr(Pe, Cr, "class")), ds = ze.bind((Cr) => Dr(Pe, Cr, "title"));
    return {
      url: An,
      text: Ft,
      title: ds,
      target: so,
      rel: Zn,
      linkClass: $n
    };
  }, Lc = { collect: (te, ze) => Md.getLinks(te).then((Pe) => {
    const Qe = El(te, ze);
    return {
      anchor: Qe,
      catalogs: {
        targets: _r.getTargets(te),
        rels: cl.getRels(te, Qe.target),
        classes: Ms.getClasses(te),
        anchor: Nd.getAnchors(te),
        link: Pe
      },
      optNode: ze,
      flags: { titleEnabled: Pn(te) }
    };
  }) }, kc = (te, ze) => (Pe) => {
    const Qe = Pe.getData();
    if (!Qe.url.value) {
      Cl(te), Pe.close();
      return;
    }
    const Ft = (Zn) => an.from(Qe[Zn]).filter(($n) => !M(ze.anchor[Zn], $n)), An = {
      href: Qe.url.value,
      text: Ft("text"),
      target: Ft("target"),
      rel: Ft("rel"),
      class: Ft("linkClass"),
      title: Ft("title")
    }, so = {
      href: Qe.url.value,
      attach: Qe.url.meta !== void 0 && Qe.url.meta.attach ? Qe.url.meta.attach : en
    };
    tm.preprocess(te, An).then((Zn) => {
      Ei(te, so, Zn);
    }), Pe.close();
  }, gu = (te) => {
    const ze = ro(te);
    return Lc.collect(te, ze);
  }, Na = (te, ze) => {
    const Pe = te.anchor, Qe = Pe.url.getOr("");
    return {
      url: {
        value: Qe,
        meta: { original: { value: Qe } }
      },
      text: Pe.text.getOr(""),
      title: Pe.title.getOr(""),
      anchor: Qe,
      link: Qe,
      rel: Pe.rel.getOr(""),
      target: Pe.target.or(ze).getOr(""),
      linkClass: Pe.linkClass.getOr("")
    };
  }, us = (te, ze, Pe) => {
    const Qe = [{
      name: "url",
      type: "urlinput",
      filetype: "file",
      label: "URL",
      picker_text: "Browse links"
    }], Ft = te.anchor.text.map(() => ({
      name: "text",
      type: "input",
      label: "Text to display"
    })).toArray(), An = te.flags.titleEnabled ? [{
      name: "title",
      type: "input",
      label: "Title"
    }] : [], so = an.from(Tt(Pe)), Zn = Na(te, so), $n = te.catalogs, ds = wc.init(Zn, $n);
    return {
      title: "Insert/Edit Link",
      size: "normal",
      body: {
        type: "panel",
        items: jn([
          Qe,
          Ft,
          An,
          Et([
            $n.anchor.map(oo.createUi("anchor", "Anchors")),
            $n.rels.map(oo.createUi("rel", "Rel")),
            $n.targets.map(oo.createUi("target", "Open link in...")),
            $n.link.map(oo.createUi("link", "Link list")),
            $n.classes.map(oo.createUi("linkClass", "Class"))
          ])
        ])
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: Zn,
      onChange: (Wr, { name: Ba }) => {
        ds.onChange(Wr.getData, { name: Ba }).each((ml) => {
          Wr.setData(ml);
        });
      },
      onSubmit: ze
    };
  }, Ma = (te) => {
    gu(te).then((Pe) => {
      const Qe = kc(te, Pe);
      return us(Pe, Qe, te);
    }).then((Pe) => {
      te.windowManager.open(Pe);
    });
  }, Us = (te) => {
    te.addCommand("mceLink", (ze, Pe) => {
      (Pe == null ? void 0 : Pe.dialog) === !0 || !K(te) ? Ma(te) : te.dispatch("contexttoolbar-show", { toolbarKey: "quicklink" });
    });
  };
  var dl = tinymce.util.Tools.resolve("tinymce.util.VK");
  const Rr = (te, ze) => {
    document.body.appendChild(te), te.dispatchEvent(ze), document.body.removeChild(te);
  }, Wa = (te) => {
    const ze = document.createElement("a");
    ze.target = "_blank", ze.href = te, ze.rel = "noreferrer noopener";
    const Pe = document.createEvent("MouseEvents");
    Pe.initMouseEvent("click", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), Rr(ze, Pe);
  }, zi = (te, ze) => te.dom.getParent(ze, "a[href]"), qa = (te) => zi(te, te.selection.getStart()), eo = (te) => te.altKey === !0 && te.shiftKey === !1 && te.ctrlKey === !1 && te.metaKey === !1, gi = (te, ze) => {
    if (ze) {
      const Pe = $r(ze);
      if (/^#/.test(Pe)) {
        const Qe = te.dom.select(Pe);
        Qe.length && te.selection.scrollIntoView(Qe[0], !0);
      } else
        Wa(ze.href);
    }
  }, js = (te) => () => {
    te.execCommand("mceLink", !1, { dialog: !0 });
  }, Sa = (te) => () => {
    gi(te, qa(te));
  }, Ki = (te) => {
    te.on("click", (ze) => {
      const Pe = zi(te, ze.target);
      Pe && dl.metaKeyPressed(ze) && (ze.preventDefault(), gi(te, Pe));
    }), te.on("keydown", (ze) => {
      if (!ze.isDefaultPrevented() && ze.keyCode === 13 && eo(ze)) {
        const Pe = qa(te);
        Pe && (ze.preventDefault(), gi(te, Pe));
      }
    });
  }, ts = (te, ze) => (te.on("NodeChange", ze), () => te.off("NodeChange", ze)), Bs = (te) => (ze) => {
    const Pe = () => {
      ze.setActive(!te.mode.isReadOnly() && cn(te, te.selection.getNode())), ze.setEnabled(te.selection.isEditable());
    };
    return Pe(), ts(te, Pe);
  }, sc = (te) => (ze) => {
    const Pe = () => {
      ze.setEnabled(te.selection.isEditable());
    };
    return Pe(), ts(te, Pe);
  }, qn = (te) => (te.selection.isCollapsed() ? Si(te.dom.getParents(te.selection.getStart())) : Ys(te.selection.getRng())).length === 1, ac = (te) => (ze) => {
    const Pe = () => ze.setEnabled(qn(te));
    return Pe(), ts(te, Pe);
  }, Yi = (te) => (ze) => {
    const Pe = (An) => Nt(An) || fi(te.selection.getRng()), Qe = te.dom.getParents(te.selection.getStart()), Ft = (An) => {
      ze.setEnabled(Pe(An) && te.selection.isEditable());
    };
    return Ft(Qe), ts(te, (An) => Ft(An.parents));
  }, Ts = (te) => {
    te.addShortcut("Meta+K", "", () => {
      te.execCommand("mceLink");
    });
  }, fl = (te) => {
    te.ui.registry.addToggleButton("link", {
      icon: "link",
      tooltip: "Insert/edit link",
      onAction: js(te),
      onSetup: Bs(te)
    }), te.ui.registry.addButton("openlink", {
      icon: "new-tab",
      tooltip: "Open link",
      onAction: Sa(te),
      onSetup: ac(te)
    }), te.ui.registry.addButton("unlink", {
      icon: "unlink",
      tooltip: "Remove link",
      onAction: () => Cl(te),
      onSetup: Yi(te)
    });
  }, Xs = (te) => {
    te.ui.registry.addMenuItem("openlink", {
      text: "Open link",
      icon: "new-tab",
      onAction: Sa(te),
      onSetup: ac(te)
    }), te.ui.registry.addMenuItem("link", {
      icon: "link",
      text: "Link...",
      shortcut: "Meta+K",
      onSetup: sc(te),
      onAction: js(te)
    }), te.ui.registry.addMenuItem("unlink", {
      icon: "unlink",
      text: "Remove link",
      onAction: () => Cl(te),
      onSetup: Yi(te)
    });
  }, hu = (te) => {
    const ze = "link unlink openlink", Pe = "link";
    te.ui.registry.addContextMenu("link", {
      update: (Qe) => te.dom.isEditable(Qe) ? Nt(te.dom.getParents(Qe, "a")) ? ze : Pe : ""
    });
  }, xf = (te) => {
    const ze = (Ft) => {
      Ft.selection.collapse(!1);
    }, Pe = (Ft) => {
      const An = te.selection.getNode();
      return Ft.setEnabled(cn(te, An)), en;
    }, Qe = (Ft) => {
      const An = ro(te), so = Zo(te);
      if (An.isNone() && so) {
        const Zn = _n(te.selection, An);
        return ht(Zn.length === 0, Ft);
      } else
        return an.none();
    };
    te.ui.registry.addContextForm("quicklink", {
      launch: {
        type: "contextformtogglebutton",
        icon: "link",
        tooltip: "Link",
        onSetup: Bs(te)
      },
      label: "Link",
      predicate: (Ft) => Bn(te) && cn(te, Ft),
      initValue: () => ro(te).fold(Gt(""), $r),
      commands: [
        {
          type: "contextformtogglebutton",
          icon: "link",
          tooltip: "Link",
          primary: !0,
          onSetup: (Ft) => {
            const An = te.selection.getNode();
            return Ft.setActive(cn(te, An)), Bs(te)(Ft);
          },
          onAction: (Ft) => {
            const An = Ft.getValue(), so = Qe(An);
            Ei(te, {
              href: An,
              attach: en
            }, {
              href: An,
              text: so,
              title: an.none(),
              rel: an.none(),
              target: an.none(),
              class: an.none()
            }), ze(te), Ft.hide();
          }
        },
        {
          type: "contextformbutton",
          icon: "unlink",
          tooltip: "Remove link",
          onSetup: Pe,
          onAction: (Ft) => {
            Cl(te), Ft.hide();
          }
        },
        {
          type: "contextformbutton",
          icon: "new-tab",
          tooltip: "Open link",
          onSetup: Pe,
          onAction: (Ft) => {
            Sa(te)(), Ft.hide();
          }
        }
      ]
    });
  };
  var ar = () => {
    v.add("link", (te) => {
      lo(te), fl(te), Xs(te), hu(te), xf(te), Ki(te), Us(te), Ts(te);
    });
  };
  ar();
})();
(function() {
  var v = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const L = (z, F, X) => {
    var _e;
    return X(z, F.prototype) ? !0 : ((_e = z.constructor) === null || _e === void 0 ? void 0 : _e.name) === F.name;
  }, N = (z) => {
    const F = typeof z;
    return z === null ? "null" : F === "object" && Array.isArray(z) ? "array" : F === "object" && L(z, String, (X, _e) => _e.isPrototypeOf(X)) ? "string" : F;
  }, W = (z) => (F) => N(F) === z, ue = (z) => (F) => typeof F === z, ce = W("string"), he = W("object"), pe = W("array"), Me = ue("boolean"), Ze = (z) => z == null, Ye = (z) => !Ze(z), yt = ue("function"), jt = ue("number"), it = () => {
  }, Rt = (z, F) => (X) => z(F(X)), en = (z) => () => z, Gt = (z, F) => z === F;
  function gt(z, ...F) {
    return (...X) => {
      const _e = F.concat(X);
      return z.apply(null, _e);
    };
  }
  const an = (z) => (F) => !z(F), Ot = en(!1);
  class Ee {
    constructor(F, X) {
      this.tag = F, this.value = X;
    }
    static some(F) {
      return new Ee(!0, F);
    }
    static none() {
      return Ee.singletonNone;
    }
    fold(F, X) {
      return this.tag ? X(this.value) : F();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(F) {
      return this.tag ? Ee.some(F(this.value)) : Ee.none();
    }
    bind(F) {
      return this.tag ? F(this.value) : Ee.none();
    }
    exists(F) {
      return this.tag && F(this.value);
    }
    forall(F) {
      return !this.tag || F(this.value);
    }
    filter(F) {
      return !this.tag || F(this.value) ? this : Ee.none();
    }
    getOr(F) {
      return this.tag ? this.value : F;
    }
    or(F) {
      return this.tag ? this : F;
    }
    getOrThunk(F) {
      return this.tag ? this.value : F();
    }
    orThunk(F) {
      return this.tag ? this : F();
    }
    getOrDie(F) {
      if (this.tag)
        return this.value;
      throw new Error(F ?? "Called getOrDie on None");
    }
    static from(F) {
      return Ye(F) ? Ee.some(F) : Ee.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(F) {
      this.tag && F(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Ee.singletonNone = new Ee(!1);
  const wt = Array.prototype.slice, Se = Array.prototype.indexOf, We = Array.prototype.push, Cn = (z, F) => Se.call(z, F), ko = (z, F) => Cn(z, F) > -1, jn = (z, F) => {
    for (let X = 0, _e = z.length; X < _e; X++) {
      const Oe = z[X];
      if (F(Oe, X))
        return !0;
    }
    return !1;
  }, Xe = (z, F) => {
    const X = z.length, _e = new Array(X);
    for (let Oe = 0; Oe < X; Oe++) {
      const zt = z[Oe];
      _e[Oe] = F(zt, Oe);
    }
    return _e;
  }, un = (z, F) => {
    for (let X = 0, _e = z.length; X < _e; X++) {
      const Oe = z[X];
      F(Oe, X);
    }
  }, M = (z, F) => {
    const X = [];
    for (let _e = 0, Oe = z.length; _e < Oe; _e++) {
      const zt = z[_e];
      F(zt, _e) && X.push(zt);
    }
    return X;
  }, Et = (z, F) => {
    if (z.length === 0)
      return [];
    {
      let X = F(z[0]);
      const _e = [];
      let Oe = [];
      for (let zt = 0, bn = z.length; zt < bn; zt++) {
        const ao = z[zt], Hn = F(ao);
        Hn !== X && (_e.push(Oe), Oe = []), X = Hn, Oe.push(ao);
      }
      return Oe.length !== 0 && _e.push(Oe), _e;
    }
  }, ht = (z, F, X) => (un(z, (_e, Oe) => {
    X = F(X, _e, Oe);
  }), X), mn = (z, F, X) => {
    for (let _e = 0, Oe = z.length; _e < Oe; _e++) {
      const zt = z[_e];
      if (F(zt, _e))
        return Ee.some(zt);
      if (X(zt, _e))
        break;
    }
    return Ee.none();
  }, lo = (z, F) => mn(z, F, Ot), dt = (z) => {
    const F = [];
    for (let X = 0, _e = z.length; X < _e; ++X) {
      if (!pe(z[X]))
        throw new Error("Arr.flatten item " + X + " was not an array, input: " + z);
      We.apply(F, z[X]);
    }
    return F;
  }, Bn = (z, F) => dt(Xe(z, F)), jr = (z) => {
    const F = wt.call(z, 0);
    return F.reverse(), F;
  }, Tt = (z, F) => F >= 0 && F < z.length ? Ee.some(z[F]) : Ee.none(), yo = (z) => Tt(z, 0), Ct = (z) => Tt(z, z.length - 1), tn = (z, F) => {
    const X = [], _e = yt(F) ? (Oe) => jn(X, (zt) => F(zt, Oe)) : (Oe) => ko(X, Oe);
    for (let Oe = 0, zt = z.length; Oe < zt; Oe++) {
      const bn = z[Oe];
      _e(bn) || X.push(bn);
    }
    return X;
  }, oa = (z, F, X = Gt) => z.exists((_e) => X(_e, F)), Pn = (z, F, X = Gt) => Mo(z, F, X).getOr(z.isNone() && F.isNone()), Mo = (z, F, X) => z.isSome() && F.isSome() ? Ee.some(X(z.getOrDie(), F.getOrDie())) : Ee.none(), K = 8, Go = 9, Zi = 11, er = 1, Qr = 3, nc = (z, F) => {
    const _e = (F || document).createElement("div");
    if (_e.innerHTML = z, !_e.hasChildNodes() || _e.childNodes.length > 1) {
      const Oe = "HTML does not have a single root node";
      throw console.error(Oe, z), new Error(Oe);
    }
    return oo(_e.childNodes[0]);
  }, So = (z, F) => {
    const _e = (F || document).createElement(z);
    return oo(_e);
  }, cr = (z, F) => {
    const _e = (F || document).createTextNode(z);
    return oo(_e);
  }, oo = (z) => {
    if (z == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: z };
  }, kt = {
    fromHtml: nc,
    fromTag: So,
    fromText: cr,
    fromDom: oo,
    fromPoint: (z, F, X) => Ee.from(z.dom.elementFromPoint(F, X)).map(oo)
  }, It = (z, F) => {
    const X = z.dom;
    if (X.nodeType !== er)
      return !1;
    {
      const _e = X;
      if (_e.matches !== void 0)
        return _e.matches(F);
      if (_e.msMatchesSelector !== void 0)
        return _e.msMatchesSelector(F);
      if (_e.webkitMatchesSelector !== void 0)
        return _e.webkitMatchesSelector(F);
      if (_e.mozMatchesSelector !== void 0)
        return _e.mozMatchesSelector(F);
      throw new Error("Browser lacks native selectors");
    }
  }, ct = (z, F) => z.dom === F.dom, xn = (z, F) => {
    const X = z.dom, _e = F.dom;
    return X === _e ? !1 : X.contains(_e);
  }, co = It, Ko = typeof window < "u" ? window : Function("return this;")(), po = (z, F) => {
    let X = F ?? Ko;
    for (let _e = 0; _e < z.length && X !== void 0 && X !== null; ++_e)
      X = X[z[_e]];
    return X;
  }, Ra = (z, F) => {
    const X = z.split(".");
    return po(X, F);
  }, Mr = (z, F) => Ra(z, F), ho = (z, F) => {
    const X = Mr(z, F);
    if (X == null)
      throw new Error(z + " not available on this browser");
    return X;
  }, Ns = Object.getPrototypeOf, Ca = (z) => ho("HTMLElement", z), Zr = (z) => {
    const F = Ra("ownerDocument.defaultView", z);
    return he(z) && (Ca(F).prototype.isPrototypeOf(z) || /^HTML\w*Element$/.test(Ns(z).constructor.name));
  }, $r = (z) => z.dom.nodeName.toLowerCase(), Po = (z) => z.dom.nodeType, ha = (z) => (F) => Po(F) === z, ro = (z) => Po(z) === K || $r(z) === "#comment", cn = (z) => _n(z) && Zr(z.dom), _n = ha(er), Ys = ha(Qr), Si = ha(Go), Nt = ha(Zi), fi = (z) => (F) => _n(F) && $r(F) === z, Zo = (z) => kt.fromDom(z.dom.ownerDocument), mi = (z) => Si(z) ? z : Zo(z), kr = (z) => Ee.from(z.dom.parentNode).map(kt.fromDom), Qu = (z) => Ee.from(z.dom.parentElement).map(kt.fromDom), ba = (z) => Ee.from(z.dom.nextSibling).map(kt.fromDom), xc = (z) => Xe(z.dom.childNodes, kt.fromDom), _l = (z, F) => {
    const X = z.dom.childNodes;
    return Ee.from(X[F]).map(kt.fromDom);
  }, Wi = (z) => _l(z, 0), oc = (z) => _l(z, z.dom.childNodes.length - 1), Hr = (z) => Nt(z) && Ye(z.dom.host), qi = yt(Element.prototype.attachShadow) && yt(Node.prototype.getRootNode) ? (z) => kt.fromDom(z.dom.getRootNode()) : mi, Ei = (z) => {
    const F = qi(z);
    return Hr(F) ? Ee.some(F) : Ee.none();
  }, Cl = (z) => kt.fromDom(z.dom.host), Xc = (z) => {
    const F = Ys(z) ? z.dom.parentNode : z.dom;
    if (F == null || F.ownerDocument === null)
      return !1;
    const X = F.ownerDocument;
    return Ei(kt.fromDom(F)).fold(() => X.body.contains(F), Rt(Xc, Cl));
  };
  var Xt = (z, F, X, _e, Oe) => z(X, _e) ? Ee.some(X) : yt(Oe) && Oe(X) ? Ee.none() : F(X, _e, Oe);
  const Dd = (z, F, X) => {
    let _e = z.dom;
    const Oe = yt(X) ? X : Ot;
    for (; _e.parentNode; ) {
      _e = _e.parentNode;
      const zt = kt.fromDom(_e);
      if (F(zt))
        return Ee.some(zt);
      if (Oe(zt))
        break;
    }
    return Ee.none();
  }, es = (z, F, X) => Xt((Oe, zt) => zt(Oe), Dd, z, F, X), yf = (z, F, X) => Dd(z, (_e) => It(_e, F), X), Rd = (z, F, X) => Xt((Oe, zt) => It(Oe, zt), yf, z, F, X), Ti = (z) => Rd(z, "[contenteditable]"), wc = (z, F = !1) => Xc(z) ? z.dom.isContentEditable : Ti(z).fold(en(F), (X) => pi(X) === "true"), pi = (z) => z.dom.contentEditable, ra = (z, F) => {
    kr(z).each((_e) => {
      _e.dom.insertBefore(F.dom, z.dom);
    });
  }, Gi = (z, F) => {
    ba(z).fold(() => {
      kr(z).each((Oe) => {
        rc(Oe, F);
      });
    }, (_e) => {
      ra(_e, F);
    });
  }, vf = (z, F) => {
    Wi(z).fold(() => {
      rc(z, F);
    }, (_e) => {
      z.dom.insertBefore(F.dom, _e.dom);
    });
  }, rc = (z, F) => {
    z.dom.appendChild(F.dom);
  }, tm = (z, F) => {
    un(F, (X) => {
      ra(z, X);
    });
  }, Sl = (z, F) => {
    un(F, (X) => {
      rc(z, X);
    });
  }, Nd = (z) => {
    z.dom.textContent = "", un(xc(z), (F) => {
      tr(F);
    });
  }, tr = (z) => {
    const F = z.dom;
    F.parentNode !== null && F.parentNode.removeChild(F);
  };
  var Ms = tinymce.util.Tools.resolve("tinymce.dom.RangeUtils"), ni = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker"), Jc = tinymce.util.Tools.resolve("tinymce.util.VK");
  const Md = (z) => Xe(z, kt.fromDom), Bd = Object.keys, cl = (z, F) => {
    const X = Bd(z);
    for (let _e = 0, Oe = X.length; _e < Oe; _e++) {
      const zt = X[_e], bn = z[zt];
      F(bn, zt);
    }
  }, sa = (z) => (F, X) => {
    z[X] = F;
  }, nm = (z, F, X, _e) => {
    cl(z, (Oe, zt) => {
      (F(Oe, zt) ? X : _e)(Oe, zt);
    });
  }, _r = (z, F) => {
    const X = {};
    return nm(z, F, sa(X), it), X;
  }, Dr = (z, F, X) => {
    if (ce(X) || Me(X) || jt(X))
      z.setAttribute(F, X + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", F, ":: Value ", X, ":: Element ", z), new Error("Attribute value was not simple");
  }, El = (z, F) => {
    const X = z.dom;
    cl(F, (_e, Oe) => {
      Dr(X, Oe, _e);
    });
  }, ul = (z) => ht(z.dom.attributes, (F, X) => (F[X.name] = X.value, F), {}), Lc = (z, F) => kt.fromDom(z.dom.cloneNode(F)), kc = (z) => Lc(z, !0), gu = (z, F) => {
    const X = kt.fromTag(F), _e = ul(z);
    return El(X, _e), X;
  }, Na = (z, F) => {
    const X = gu(z, F);
    Gi(z, X);
    const _e = xc(z);
    return Sl(X, _e), tr(z), X;
  };
  var us = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), Ma = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const Us = (z) => (F) => Ye(F) && F.nodeName.toLowerCase() === z, dl = (z) => (F) => Ye(F) && z.test(F.nodeName), Rr = (z) => Ye(z) && z.nodeType === 3, Wa = (z) => Ye(z) && z.nodeType === 1, zi = dl(/^(OL|UL|DL)$/), qa = dl(/^(OL|UL)$/), eo = Us("ol"), gi = dl(/^(LI|DT|DD)$/), js = dl(/^(DT|DD)$/), Sa = dl(/^(TH|TD)$/), Ki = Us("br"), ts = (z) => {
    var F;
    return ((F = z.parentNode) === null || F === void 0 ? void 0 : F.firstChild) === z;
  }, Bs = (z, F) => Ye(F) && F.nodeName in z.schema.getTextBlockElements(), sc = (z, F) => Ye(z) && z.nodeName in F, qn = (z, F) => Ye(F) && F.nodeName in z.schema.getVoidElements(), ac = (z, F) => Ki(F) ? z.isBlock(F.nextSibling) && !Ki(F.previousSibling) : !1, Yi = (z, F, X) => {
    const _e = z.isEmpty(F);
    return X && z.select("span[data-mce-type=bookmark]", F).length > 0 ? !1 : _e;
  }, Ts = (z, F) => z.isChildOf(F, z.getRoot()), fl = (z) => (F) => F.options.get(z), Xs = (z) => {
    const F = z.options.register;
    F("lists_indent_on_tab", {
      processor: "boolean",
      default: !0
    });
  }, hu = fl("lists_indent_on_tab"), xf = fl("forced_root_block"), ar = fl("forced_root_block_attrs"), te = (z, F) => {
    const X = z.dom, _e = z.schema.getBlockElements(), Oe = X.createFragment(), zt = xf(z), bn = ar(z);
    let ao, Hn, En = !1;
    for (Hn = X.create(zt, bn), sc(F.firstChild, _e) || Oe.appendChild(Hn); ao = F.firstChild; ) {
      const yr = ao.nodeName;
      !En && (yr !== "SPAN" || ao.getAttribute("data-mce-type") !== "bookmark") && (En = !0), sc(ao, _e) ? (Oe.appendChild(ao), Hn = null) : (Hn || (Hn = X.create(zt, bn), Oe.appendChild(Hn)), Hn.appendChild(ao));
    }
    return !En && Hn && Hn.appendChild(X.create("br", { "data-mce-bogus": "1" })), Oe;
  }, ze = us.DOM, Pe = (z, F, X) => {
    const _e = (En) => {
      const yr = En.parentNode;
      yr && Ma.each(Oe, (ws) => {
        yr.insertBefore(ws, X.parentNode);
      }), ze.remove(En);
    }, Oe = ze.select('span[data-mce-type="bookmark"]', F), zt = te(z, X), bn = ze.createRng();
    bn.setStartAfter(X), bn.setEndAfter(F);
    const ao = bn.extractContents();
    for (let En = ao.firstChild; En; En = En.firstChild)
      if (En.nodeName === "LI" && z.dom.isEmpty(En)) {
        ze.remove(En);
        break;
      }
    z.dom.isEmpty(ao) || ze.insertAfter(ao, F), ze.insertAfter(zt, F);
    const Hn = X.parentElement;
    Hn && Yi(z.dom, Hn) && _e(Hn), ze.remove(X), Yi(z.dom, F) && ze.remove(F);
  }, Qe = fi("dd"), Ft = fi("dt"), An = (z, F) => {
    Qe(F) ? Na(F, "dt") : Ft(F) && Qu(F).each((X) => Pe(z, X.dom, F.dom));
  }, so = (z) => {
    Ft(z) && Na(z, "dd");
  }, Zn = (z, F, X) => {
    F === "Indent" ? un(X, so) : un(X, (_e) => An(z, _e));
  }, $n = (z, F) => {
    if (Rr(z))
      return {
        container: z,
        offset: F
      };
    const X = Ms.getNode(z, F);
    return Rr(X) ? {
      container: X,
      offset: F >= z.childNodes.length ? X.data.length : 0
    } : X.previousSibling && Rr(X.previousSibling) ? {
      container: X.previousSibling,
      offset: X.previousSibling.data.length
    } : X.nextSibling && Rr(X.nextSibling) ? {
      container: X.nextSibling,
      offset: 0
    } : {
      container: z,
      offset: F
    };
  }, ds = (z) => {
    const F = z.cloneRange(), X = $n(z.startContainer, z.startOffset);
    F.setStart(X.container, X.offset);
    const _e = $n(z.endContainer, z.endOffset);
    return F.setEnd(_e.container, _e.offset), F;
  }, Cr = [
    "OL",
    "UL",
    "DL"
  ], Wr = Cr.join(","), Ba = (z, F) => {
    const X = F || z.selection.getStart(!0);
    return z.dom.getParent(X, Wr, oi(z, X));
  }, ml = (z, F) => Ye(z) && F.length === 1 && F[0] === z, nr = (z) => M(z.querySelectorAll(Wr), zi), wf = (z) => {
    const F = Ba(z), X = z.selection.getSelectedBlocks();
    return ml(F, X) ? nr(F) : M(X, (_e) => zi(_e) && F !== _e);
  }, Qc = (z, F) => {
    const X = Ma.map(F, (_e) => {
      const Oe = z.dom.getParent(_e, "li,dd,dt", oi(z, _e));
      return Oe || _e;
    });
    return tn(X);
  }, Ga = (z) => {
    const F = z.selection.getSelectedBlocks();
    return M(Qc(z, F), gi);
  }, Ld = (z) => M(Ga(z), js), aa = (z, F) => {
    const X = z.dom.getParents(F, "TD,TH");
    return X.length > 0 ? X[0] : z.getBody();
  }, sg = (z, F) => !zi(F) && !gi(F) && jn(Cr, (X) => z.isValidChild(F.nodeName, X)), oi = (z, F) => {
    const X = z.dom.getParents(F, z.dom.isBlock);
    return lo(X, (Oe) => sg(z.schema, Oe)).getOr(z.getBody());
  }, $l = (z) => kr(z).exists((F) => gi(F.dom) && Wi(F).exists((X) => !zi(X.dom)) && oc(F).exists((X) => !zi(X.dom))), kp = (z, F) => {
    const X = z.dom.getParents(F, "ol,ul", oi(z, F));
    return Ct(X);
  }, oh = (z) => {
    const F = kp(z, z.selection.getStart()), X = M(z.selection.getSelectedBlocks(), qa);
    return F.toArray().concat(X);
  }, Ht = (z) => {
    const F = z.selection.getStart();
    return z.dom.getParents(F, "ol,ul", oi(z, F));
  }, Pd = (z) => {
    const F = oh(z), X = Ht(z);
    return lo(X, (_e) => $l(kt.fromDom(_e))).fold(() => _p(z, F), (_e) => [_e]);
  }, _p = (z, F) => {
    const X = Xe(F, (_e) => kp(z, _e).getOr(_e));
    return tn(X);
  }, ed = (z) => /\btox\-/.test(z.className), ns = (z, F) => mn(z, zi, Sa).exists((X) => X.nodeName === F && !ed(X)), ag = (z, F) => F !== null && !z.dom.isEditable(F), Xi = (z) => {
    const F = Ba(z);
    return ag(z, F);
  }, Id = (z, F) => {
    const X = z.dom.getParent(F, "ol,ul,dl");
    return ag(z, X);
  }, Cp = (z, F) => {
    const X = z.selection.getNode();
    return F({
      parents: z.dom.getParents(X),
      element: X
    }), z.on("NodeChange", F), () => z.off("NodeChange", F);
  }, Pc = (z, F) => {
    const _e = (F || document).createDocumentFragment();
    return un(z, (Oe) => {
      _e.appendChild(Oe.dom);
    }), kt.fromDom(_e);
  }, bu = (z, F, X) => z.dispatch("ListMutation", {
    action: F,
    element: X
  }), Ea = ((z) => (F) => F.replace(z, ""))(/^\s+|\s+$/g), yu = (z) => z.length > 0, ig = (z) => !yu(z), eu = (z) => z.style !== void 0 && yt(z.style.getPropertyValue), om = (z, F, X) => {
    if (!ce(X))
      throw console.error("Invalid call to CSS.set. Property ", F, ":: Value ", X, ":: Element ", z), new Error("CSS value must be a string: " + X);
    eu(z) && z.style.setProperty(F, X);
  }, kf = (z, F, X) => {
    const _e = z.dom;
    om(_e, F, X);
  }, _c = (z) => co(z, "OL,UL"), Ic = (z) => co(z, "LI"), Eo = (z) => Wi(z).exists(_c), Fd = (z) => oc(z).exists(_c), ia = (z) => "listAttributes" in z, td = (z) => "isComment" in z, $d = (z) => "isFragment" in z, Ji = (z) => z.depth > 0, Zs = (z) => z.isSelected, nd = (z) => {
    const F = xc(z), X = Fd(z) ? F.slice(0, -1) : F;
    return Xe(X, kc);
  }, rm = (z, F, X) => kr(z).filter(_n).map((_e) => ({
    depth: F,
    dirty: !1,
    isSelected: X,
    content: nd(z),
    itemAttributes: ul(z),
    listAttributes: ul(_e),
    listType: $r(_e),
    isInPreviousLi: !1
  })), ya = (z, F) => {
    rc(z.item, F.list);
  }, Ls = (z) => {
    for (let F = 1; F < z.length; F++)
      ya(z[F - 1], z[F]);
  }, Vr = (z, F) => {
    Mo(Ct(z), yo(F), ya);
  }, zs = (z, F) => {
    const X = {
      list: kt.fromTag(F, z),
      item: kt.fromTag("li", z)
    };
    return rc(X.list, X.item), X;
  }, Qi = (z, F, X) => {
    const _e = [];
    for (let Oe = 0; Oe < X; Oe++)
      _e.push(zs(z, ia(F) ? F.listType : F.parentListType));
    return _e;
  }, Js = (z, F) => {
    for (let X = 0; X < z.length - 1; X++)
      kf(z[X].item, "list-style-type", "none");
    Ct(z).each((X) => {
      ia(F) && (El(X.list, F.listAttributes), El(X.item, F.itemAttributes)), Sl(X.item, F.content);
    });
  }, La = (z, F) => {
    $r(z.list) !== F.listType && (z.list = Na(z.list, F.listType)), El(z.list, F.listAttributes);
  }, xs = (z, F, X) => {
    const _e = kt.fromTag("li", z);
    return El(_e, F), Sl(_e, X), _e;
  }, Hd = (z, F) => {
    rc(z.list, F), z.item = F;
  }, Ws = (z, F, X) => {
    const _e = F.slice(0, X.depth);
    return Ct(_e).each((Oe) => {
      if (ia(X)) {
        const zt = xs(z, X.itemAttributes, X.content);
        Hd(Oe, zt), La(Oe, X);
      } else if ($d(X))
        Sl(Oe.item, X.content);
      else {
        const zt = kt.fromHtml(`<!--${X.content}-->`);
        rc(Oe.list, zt);
      }
    }), _e;
  }, va = (z, F, X) => {
    const _e = Qi(z, X, X.depth - F.length);
    return Ls(_e), Js(_e, X), Vr(F, _e), F.concat(_e);
  }, la = (z, F) => {
    let X = Ee.none();
    const _e = ht(F, (Oe, zt, bn) => td(zt) ? bn === 0 ? (X = Ee.some(zt), Oe) : Ws(z, Oe, zt) : zt.depth > Oe.length ? va(z, Oe, zt) : Ws(z, Oe, zt), []);
    return X.each((Oe) => {
      const zt = kt.fromHtml(`<!--${Oe.content}-->`);
      yo(_e).each((bn) => {
        vf(bn.list, zt);
      });
    }), yo(_e).map((Oe) => Oe.list);
  }, od = (z, F) => {
    switch (z) {
      case "Indent":
        F.depth++;
        break;
      case "Outdent":
        F.depth--;
        break;
      case "Flatten":
        F.depth = 0;
    }
    F.dirty = !0;
  }, os = (z, F) => {
    ia(z) && ia(F) && (z.listType = F.listType, z.listAttributes = { ...F.listAttributes });
  }, sm = (z) => {
    z.listAttributes = _r(z.listAttributes, (F, X) => X !== "start");
  }, vu = (z, F) => {
    const X = z[F].depth, _e = (zt) => zt.depth === X && !zt.dirty, Oe = (zt) => zt.depth < X;
    return mn(jr(z.slice(0, F)), _e, Oe).orThunk(() => mn(z.slice(F + 1), _e, Oe));
  }, Cc = (z) => (un(z, (F, X) => {
    vu(z, X).fold(() => {
      F.dirty && ia(F) && sm(F);
    }, (_e) => os(F, _e));
  }), z), To = (z) => {
    let F = z;
    return {
      get: () => F,
      set: (Oe) => {
        F = Oe;
      }
    };
  }, ca = (z, F, X, _e) => {
    var Oe;
    if (ro(_e))
      return [{
        depth: z + 1,
        content: (Oe = _e.dom.nodeValue) !== null && Oe !== void 0 ? Oe : "",
        dirty: !1,
        isSelected: !1,
        isComment: !0
      }];
    F.each((ao) => {
      ct(ao.start, _e) && X.set(!0);
    });
    const zt = rm(_e, z, X.get());
    F.each((ao) => {
      ct(ao.end, _e) && X.set(!1);
    });
    const bn = oc(_e).filter(_c).map((ao) => Oi(z, F, X, ao)).getOr([]);
    return zt.toArray().concat(bn);
  }, rd = (z, F, X, _e) => Wi(_e).filter(_c).fold(() => ca(z, F, X, _e), (Oe) => {
    const zt = ht(xc(_e), (bn, ao, Hn) => {
      if (Hn === 0)
        return bn;
      if (Ic(ao))
        return bn.concat(ca(z, F, X, ao));
      {
        const En = {
          isFragment: !0,
          depth: z,
          content: [ao],
          isSelected: !1,
          dirty: !1,
          parentListType: $r(Oe)
        };
        return bn.concat(En);
      }
    }, []);
    return Oi(z, F, X, Oe).concat(zt);
  }), Oi = (z, F, X, _e) => Bn(xc(_e), (Oe) => {
    const zt = _c(Oe) ? Oi : rd, bn = z + 1;
    return zt(bn, F, X, Oe);
  }), Vd = (z, F) => {
    const X = To(!1), _e = 0;
    return Xe(z, (Oe) => ({
      sourceList: Oe,
      entries: Oi(_e, F, X, Oe)
    }));
  }, Fc = (z, F) => {
    const X = Cc(F);
    return Xe(X, (_e) => {
      const Oe = td(_e) ? Pc([kt.fromHtml(`<!--${_e.content}-->`)]) : Pc(_e.content);
      return kt.fromDom(te(z, Oe.dom));
    });
  }, xu = (z, F) => {
    const X = Cc(F);
    return la(z.contentDocument, X).toArray();
  }, lg = (z, F) => Bn(Et(F, Ji), (X) => yo(X).exists(Ji) ? xu(z, X) : Fc(z, X)), wu = (z, F) => {
    un(M(z, Zs), (X) => od(F, X));
  }, ri = (z) => {
    const F = Xe(Ga(z), kt.fromDom);
    return Mo(lo(F, an(Eo)), lo(jr(F), an(Eo)), (X, _e) => ({
      start: X,
      end: _e
    }));
  }, Sp = (z, F, X) => {
    const _e = Vd(F, ri(z));
    un(_e, (Oe) => {
      wu(Oe.entries, X);
      const zt = lg(z, Oe.entries);
      un(zt, (bn) => {
        bu(z, X === "Indent" ? "IndentList" : "OutdentList", bn.dom);
      }), tm(Oe.sourceList, zt), tr(Oe.sourceList);
    });
  }, be = (z, F) => {
    const X = Md(Pd(z)), _e = Md(Ld(z));
    let Oe = !1;
    if (X.length || _e.length) {
      const zt = z.selection.getBookmark();
      Sp(z, X, F), Zn(z, F, _e), z.selection.moveToBookmark(zt), z.selection.setRng(ds(z.selection.getRng())), z.nodeChanged(), Oe = !0;
    }
    return Oe;
  }, Sc = (z, F) => !Xi(z) && be(z, F), Ai = (z) => Sc(z, "Indent"), tu = (z) => Sc(z, "Outdent"), _f = (z) => Sc(z, "Flatten"), sd = "\uFEFF", Le = (z) => z === sd, Dt = (z, F, X) => Dd(z, F, X).isSome(), vt = (z, F) => Dt(z, gt(ct, F));
  var Sn = tinymce.util.Tools.resolve("tinymce.dom.BookmarkManager");
  const Fo = us.DOM, ur = (z) => {
    const F = {}, X = (_e) => {
      let Oe = z[_e ? "startContainer" : "endContainer"], zt = z[_e ? "startOffset" : "endOffset"];
      if (Wa(Oe)) {
        const bn = Fo.create("span", { "data-mce-type": "bookmark" });
        Oe.hasChildNodes() ? (zt = Math.min(zt, Oe.childNodes.length - 1), _e ? Oe.insertBefore(bn, Oe.childNodes[zt]) : Fo.insertAfter(bn, Oe.childNodes[zt])) : Oe.appendChild(bn), Oe = bn, zt = 0;
      }
      F[_e ? "startContainer" : "endContainer"] = Oe, F[_e ? "startOffset" : "endOffset"] = zt;
    };
    return X(!0), z.collapsed || X(), F;
  }, Br = (z) => {
    const F = (_e) => {
      const Oe = (ao) => {
        var Hn;
        let En = (Hn = ao.parentNode) === null || Hn === void 0 ? void 0 : Hn.firstChild, yr = 0;
        for (; En; ) {
          if (En === ao)
            return yr;
          (!Wa(En) || En.getAttribute("data-mce-type") !== "bookmark") && yr++, En = En.nextSibling;
        }
        return -1;
      };
      let zt = z[_e ? "startContainer" : "endContainer"], bn = z[_e ? "startOffset" : "endOffset"];
      if (zt) {
        if (Wa(zt) && zt.parentNode) {
          const ao = zt;
          bn = Oe(zt), zt = zt.parentNode, Fo.remove(ao), !zt.hasChildNodes() && Fo.isBlock(zt) && zt.appendChild(Fo.create("br"));
        }
        z[_e ? "startContainer" : "endContainer"] = zt, z[_e ? "startOffset" : "endOffset"] = bn;
      }
    };
    F(!0), F();
    const X = Fo.createRng();
    return X.setStart(z.startContainer, z.startOffset), z.endContainer && X.setEnd(z.endContainer, z.endOffset), ds(X);
  }, Lr = (z) => {
    switch (z) {
      case "UL":
        return "ToggleUlList";
      case "OL":
        return "ToggleOlList";
      case "DL":
        return "ToggleDLList";
    }
  }, hi = (z, F, X) => {
    const _e = X["list-style-type"] ? X["list-style-type"] : null;
    z.setStyle(F, "list-style-type", _e);
  }, Nn = (z, F) => {
    Ma.each(F, (X, _e) => {
      z.setAttribute(_e, X);
    });
  }, Ps = (z, F, X) => {
    Nn(F, X["list-attributes"]), Ma.each(z.select("li", F), (_e) => {
      Nn(_e, X["list-item-attributes"]);
    });
  }, Di = (z, F, X) => {
    hi(z, F, X), Ps(z, F, X);
  }, cg = (z, F, X) => {
    Ma.each(X, (_e) => z.setStyle(F, _e, ""));
  }, Ec = (z, F) => Ye(F) && !sc(F, z.schema.getBlockElements()), Pr = (z, F, X, _e) => {
    let Oe = F[X ? "startContainer" : "endContainer"];
    const zt = F[X ? "startOffset" : "endOffset"];
    Wa(Oe) && (Oe = Oe.childNodes[Math.min(zt, Oe.childNodes.length - 1)] || Oe), !X && Ki(Oe.nextSibling) && (Oe = Oe.nextSibling);
    const bn = (Hn) => {
      for (; !z.dom.isBlock(Hn) && Hn.parentNode && _e !== Hn; )
        Hn = Hn.parentNode;
      return Hn;
    }, ao = (Hn, En) => {
      var yr;
      const ws = new ni(Hn, bn(Hn)), Ri = En ? "next" : "prev";
      let _u;
      for (; _u = ws[Ri](); )
        if (!(qn(z, _u) || Le(_u.textContent) || ((yr = _u.textContent) === null || yr === void 0 ? void 0 : yr.length) === 0))
          return Ee.some(_u);
      return Ee.none();
    };
    if (X && Rr(Oe))
      if (Le(Oe.textContent))
        Oe = ao(Oe, !1).getOr(Oe);
      else
        for (Oe.parentNode !== null && Ec(z, Oe.parentNode) && (Oe = Oe.parentNode); Oe.previousSibling !== null && (Ec(z, Oe.previousSibling) || Rr(Oe.previousSibling)); )
          Oe = Oe.previousSibling;
    if (!X && Rr(Oe))
      if (Le(Oe.textContent))
        Oe = ao(Oe, !0).getOr(Oe);
      else
        for (Oe.parentNode !== null && Ec(z, Oe.parentNode) && (Oe = Oe.parentNode); Oe.nextSibling !== null && (Ec(z, Oe.nextSibling) || Rr(Oe.nextSibling)); )
          Oe = Oe.nextSibling;
    for (; Oe.parentNode !== _e; ) {
      const Hn = Oe.parentNode;
      if (Bs(z, Oe) || /^(TD|TH)$/.test(Hn.nodeName))
        return Oe;
      Oe = Hn;
    }
    return Oe;
  }, Tc = (z, F, X) => {
    const _e = [], Oe = z.dom, zt = Pr(z, F, !0, X), bn = Pr(z, F, !1, X);
    let ao;
    const Hn = [];
    for (let En = zt; En && (Hn.push(En), En !== bn); En = En.nextSibling)
      ;
    return Ma.each(Hn, (En) => {
      var yr;
      if (Bs(z, En)) {
        _e.push(En), ao = null;
        return;
      }
      if (Oe.isBlock(En) || Ki(En)) {
        Ki(En) && Oe.remove(En), ao = null;
        return;
      }
      const ws = En.nextSibling;
      if (Sn.isBookmarkNode(En) && (zi(ws) || Bs(z, ws) || !ws && En.parentNode === X)) {
        ao = null;
        return;
      }
      ao || (ao = Oe.create("p"), (yr = En.parentNode) === null || yr === void 0 || yr.insertBefore(ao, En), _e.push(ao)), ao.appendChild(En);
    }), _e;
  }, qr = (z, F, X) => {
    const _e = z.getStyle(F, "list-style-type");
    let Oe = X ? X["list-style-type"] : "";
    return Oe = Oe === null ? "" : Oe, _e === Oe;
  }, xa = (z, F) => {
    const X = z.selection.getStart(!0), _e = Pr(z, F, !0, z.getBody());
    return vt(kt.fromDom(_e), kt.fromDom(F.commonAncestorContainer)) ? F.commonAncestorContainer : X;
  }, $c = (z, F, X) => {
    const _e = z.selection.getRng();
    let Oe = "LI";
    const zt = oi(z, xa(z, _e)), bn = z.dom;
    if (bn.getContentEditable(z.selection.getNode()) === "false")
      return;
    F = F.toUpperCase(), F === "DL" && (Oe = "DT");
    const ao = ur(_e), Hn = M(Tc(z, _e, zt), z.dom.isEditable);
    Ma.each(Hn, (En) => {
      let yr;
      const ws = En.previousSibling, Ri = En.parentNode;
      gi(Ri) || (ws && zi(ws) && ws.nodeName === F && qr(bn, ws, X) ? (yr = ws, En = bn.rename(En, Oe), ws.appendChild(En)) : (yr = bn.create(F), Ri.insertBefore(yr, En), yr.appendChild(En), En = bn.rename(En, Oe)), cg(bn, En, [
        "margin",
        "margin-right",
        "margin-bottom",
        "margin-left",
        "margin-top",
        "padding",
        "padding-right",
        "padding-bottom",
        "padding-left",
        "padding-top"
      ]), Di(bn, yr, X), Tl(z.dom, yr));
    }), z.selection.setRng(Br(ao));
  }, Ud = (z, F) => zi(z) && z.nodeName === (F == null ? void 0 : F.nodeName), am = (z, F, X) => {
    const _e = z.getStyle(F, "list-style-type", !0), Oe = z.getStyle(X, "list-style-type", !0);
    return _e === Oe;
  }, Ep = (z, F) => z.className === F.className, ku = (z, F, X) => Ud(F, X) && am(z, F, X) && Ep(F, X), Tl = (z, F) => {
    let X, _e = F.nextSibling;
    if (ku(z, F, _e)) {
      const Oe = _e;
      for (; X = Oe.firstChild; )
        F.appendChild(X);
      z.remove(Oe);
    }
    if (_e = F.previousSibling, ku(z, F, _e)) {
      const Oe = _e;
      for (; X = Oe.lastChild; )
        F.insertBefore(X, F.firstChild);
      z.remove(Oe);
    }
  }, pl = (z, F, X, _e) => {
    if (F.nodeName !== X) {
      const Oe = z.dom.rename(F, X);
      Di(z.dom, Oe, _e), bu(z, Lr(X), Oe);
    } else
      Di(z.dom, F, _e), bu(z, Lr(X), F);
  }, Gr = (z, F, X, _e) => {
    if (F.classList.forEach((Oe, zt, bn) => {
      Oe.startsWith("tox-") && (bn.remove(Oe), bn.length === 0 && F.removeAttribute("class"));
    }), F.nodeName !== X) {
      const Oe = z.dom.rename(F, X);
      Di(z.dom, Oe, _e), bu(z, Lr(X), Oe);
    } else
      Di(z.dom, F, _e), bu(z, Lr(X), F);
  }, ic = (z, F, X, _e, Oe) => {
    const zt = zi(F);
    if (zt && F.nodeName === _e && !Ta(Oe) && !ed(F))
      _f(z);
    else {
      $c(z, _e, Oe);
      const bn = ur(z.selection.getRng()), ao = zt ? [
        F,
        ...X
      ] : X, Hn = zt && ed(F) ? Gr : pl;
      Ma.each(ao, (En) => {
        Hn(z, En, _e, Oe);
      }), z.selection.setRng(Br(bn));
    }
  }, Ta = (z) => "list-style-type" in z, nu = (z, F, X, _e) => {
    if (F !== z.getBody())
      if (F)
        if (F.nodeName === X && !Ta(_e) && !ed(F))
          _f(z);
        else {
          const Oe = ur(z.selection.getRng());
          ed(F) && F.classList.forEach((bn, ao, Hn) => {
            bn.startsWith("tox-") && (Hn.remove(bn), Hn.length === 0 && F.removeAttribute("class"));
          }), Di(z.dom, F, _e);
          const zt = z.dom.rename(F, X);
          Tl(z.dom, zt), z.selection.setRng(Br(Oe)), $c(z, X, _e), bu(z, Lr(X), zt);
        }
      else
        $c(z, X, _e), bu(z, Lr(X), F);
  }, bi = (z, F, X) => {
    const _e = Ba(z);
    if (Id(z, _e))
      return;
    const Oe = wf(z), zt = he(X) ? X : {};
    Oe.length > 0 ? ic(z, _e, Oe, F, zt) : nu(z, _e, F, zt);
  }, ad = us.DOM, Qs = (z, F) => {
    const X = F.parentElement;
    if (X && X.nodeName === "LI" && X.firstChild === F) {
      const _e = X.previousSibling;
      _e && _e.nodeName === "LI" ? (_e.appendChild(F), Yi(z, X) && ad.remove(X)) : ad.setStyle(X, "listStyleType", "none");
    }
    if (zi(X)) {
      const _e = X.previousSibling;
      _e && _e.nodeName === "LI" && _e.appendChild(F);
    }
  }, ua = (z, F) => {
    const X = Ma.grep(z.select("ol,ul", F));
    Ma.each(X, (_e) => {
      Qs(z, _e);
    });
  }, si = (z, F, X, _e) => {
    let Oe = F.startContainer;
    const zt = F.startOffset;
    if (Rr(Oe) && (X ? zt < Oe.data.length : zt > 0))
      return Oe;
    const bn = z.schema.getNonEmptyElements();
    Wa(Oe) && (Oe = Ms.getNode(Oe, zt));
    const ao = new ni(Oe, _e);
    X && ac(z.dom, Oe) && ao.next();
    const Hn = X ? ao.next.bind(ao) : ao.prev2.bind(ao);
    for (; Oe = Hn(); )
      if (Oe.nodeName === "LI" && !Oe.hasChildNodes() || bn[Oe.nodeName] || Rr(Oe) && Oe.data.length > 0)
        return Oe;
    return null;
  }, st = (z, F) => {
    const X = F.childNodes;
    return X.length === 1 && !zi(X[0]) && z.isBlock(X[0]);
  }, zl = (z) => Ee.from(z).map(kt.fromDom).filter(cn).exists((F) => wc(F) && !ko(["details"], $r(F))), Lm = (z, F) => {
    st(z, F) && zl(F.firstChild) && z.remove(F.firstChild, !0);
  }, Is = (z, F, X) => {
    let _e;
    const Oe = st(z, X) ? X.firstChild : X;
    if (Lm(z, F), !Yi(z, F, !0))
      for (; _e = F.firstChild; )
        Oe.appendChild(_e);
  }, Pa = (z, F, X) => {
    let _e;
    const Oe = F.parentNode;
    if (!Ts(z, F) || !Ts(z, X))
      return;
    zi(X.lastChild) && (_e = X.lastChild), Oe === X.lastChild && Ki(Oe.previousSibling) && z.remove(Oe.previousSibling);
    const zt = X.lastChild;
    zt && Ki(zt) && F.hasChildNodes() && z.remove(zt), Yi(z, X, !0) && Nd(kt.fromDom(X)), Is(z, F, X), _e && X.appendChild(_e);
    const ao = xn(kt.fromDom(X), kt.fromDom(F)) ? z.getParents(F, zi, X) : [];
    z.remove(F), un(ao, (Hn) => {
      Yi(z, Hn) && Hn !== z.getRoot() && z.remove(Hn);
    });
  }, Ia = (z, F, X) => {
    Nd(kt.fromDom(X)), Pa(z.dom, F, X), z.selection.setCursorLocation(X, 0);
  }, el = (z, F, X, _e) => {
    const Oe = z.dom;
    if (Oe.isEmpty(_e))
      Ia(z, X, _e);
    else {
      const zt = ur(F);
      Pa(Oe, X, _e), z.selection.setRng(Br(zt));
    }
  }, jd = (z, F, X, _e) => {
    const Oe = ur(F);
    Pa(z.dom, X, _e);
    const zt = Br(Oe);
    z.selection.setRng(zt);
  }, Ka = (z, F) => {
    const X = z.dom, _e = z.selection, Oe = _e.getStart(), zt = aa(z, Oe), bn = X.getParent(_e.getStart(), "LI", zt);
    if (bn) {
      const ao = bn.parentElement;
      if (ao === z.getBody() && Yi(X, ao))
        return !0;
      const Hn = ds(_e.getRng()), En = X.getParent(si(z, Hn, F, zt), "LI", zt), yr = En && (F ? X.isChildOf(bn, En) : X.isChildOf(En, bn));
      if (En && En !== bn && !yr)
        return z.undoManager.transact(() => {
          F ? el(z, Hn, En, bn) : ts(bn) ? tu(z) : jd(z, Hn, bn, En);
        }), !0;
      if (yr && !F && En !== bn)
        return z.undoManager.transact(() => {
          if (Hn.commonAncestorContainer.parentElement) {
            const ws = ur(Hn), Ri = Hn.commonAncestorContainer.parentElement;
            Is(X, Hn.commonAncestorContainer.parentElement, En), Ri.remove();
            const _u = Br(ws);
            z.selection.setRng(_u);
          }
        }), !0;
      if (!En && !F && Hn.startOffset === 0 && Hn.endOffset === 0)
        return z.undoManager.transact(() => {
          _f(z);
        }), !0;
    }
    return !1;
  }, pr = (z, F, X) => {
    const _e = z.getParent(F.parentNode, z.isBlock, X);
    z.remove(F), _e && z.isEmpty(_e) && z.remove(_e);
  }, Hl = (z, F) => {
    const X = z.dom, _e = z.selection.getStart(), Oe = aa(z, _e), zt = X.getParent(_e, X.isBlock, Oe);
    if (zt && X.isEmpty(zt)) {
      const bn = ds(z.selection.getRng()), ao = X.getParent(si(z, bn, F, Oe), "LI", Oe);
      if (ao) {
        const Hn = (Ri) => ko([
          "td",
          "th",
          "caption"
        ], $r(Ri)), En = (Ri) => Ri.dom === Oe, yr = es(kt.fromDom(ao), Hn, En), ws = es(kt.fromDom(bn.startContainer), Hn, En);
        return Pn(yr, ws, ct) ? (z.undoManager.transact(() => {
          const Ri = ao.parentNode;
          pr(X, zt, Oe), Tl(X, Ri), z.selection.select(ao, !0), z.selection.collapse(F);
        }), !0) : !1;
      }
    }
    return !1;
  }, ea = (z, F) => Ka(z, F) || Hl(z, F), Nr = (z) => {
    const F = z.selection.getStart(), X = aa(z, F);
    return z.dom.getParent(F, "LI,DT,DD", X) || Ga(z).length > 0;
  }, Pm = (z) => Nr(z) ? (z.undoManager.transact(() => {
    z.execCommand("Delete"), ua(z.dom, z.getBody());
  }), !0) : !1, Vl = (z, F) => {
    const X = z.selection;
    return !Id(z, X.getNode()) && (X.isCollapsed() ? ea(z, F) : Pm(z));
  }, Ya = (z) => {
    z.on("ExecCommand", (F) => {
      const X = F.command.toLowerCase();
      (X === "delete" || X === "forwarddelete") && Nr(z) && ua(z.dom, z.getBody());
    }), z.on("keydown", (F) => {
      F.keyCode === Jc.BACKSPACE ? Vl(z, !1) && F.preventDefault() : F.keyCode === Jc.DELETE && Vl(z, !0) && F.preventDefault();
    });
  }, Ol = (z) => ({
    backspaceDelete: (F) => {
      Vl(z, F);
    }
  }), He = (z, F) => {
    const X = Ba(z);
    X === null || Id(z, X) || z.undoManager.transact(() => {
      he(F.styles) && z.dom.setStyles(X, F.styles), he(F.attrs) && cl(F.attrs, (_e, Oe) => z.dom.setAttrib(X, Oe, _e));
    });
  }, za = (z) => {
    const F = jr(Ea(z).split("")), X = Xe(F, (_e, Oe) => {
      const zt = _e.toUpperCase().charCodeAt(0) - "A".charCodeAt(0) + 1;
      return Math.pow(26, Oe) * zt;
    });
    return ht(X, (_e, Oe) => _e + Oe, 0);
  }, ou = (z) => {
    if (z--, z < 0)
      return "";
    {
      const F = z % 26, X = Math.floor(z / 26), _e = ou(X), Oe = String.fromCharCode("A".charCodeAt(0) + F);
      return _e + Oe;
    }
  }, Al = (z) => /^[A-Z]+$/.test(z), Fs = (z) => /^[a-z]+$/.test(z), rs = (z) => /^[0-9]+$/.test(z), fs = (z) => rs(z) ? 2 : Al(z) ? 0 : Fs(z) ? 1 : ig(z) ? 3 : 4, Ir = (z) => {
    switch (fs(z)) {
      case 2:
        return Ee.some({
          listStyleType: Ee.none(),
          start: z
        });
      case 0:
        return Ee.some({
          listStyleType: Ee.some("upper-alpha"),
          start: za(z).toString()
        });
      case 1:
        return Ee.some({
          listStyleType: Ee.some("lower-alpha"),
          start: za(z).toString()
        });
      case 3:
        return Ee.some({
          listStyleType: Ee.none(),
          start: ""
        });
      case 4:
        return Ee.none();
    }
  }, im = (z) => {
    const F = parseInt(z.start, 10);
    return oa(z.listStyleType, "upper-alpha") ? ou(F) : oa(z.listStyleType, "lower-alpha") ? ou(F).toLowerCase() : z.start;
  }, Ln = (z) => {
    const F = Ba(z);
    !eo(F) || Id(z, F) || z.windowManager.open({
      title: "List Properties",
      body: {
        type: "panel",
        items: [{
          type: "input",
          name: "start",
          label: "Start list at number",
          inputMode: "numeric"
        }]
      },
      initialData: {
        start: im({
          start: z.dom.getAttrib(F, "start", "1"),
          listStyleType: Ee.from(z.dom.getStyle(F, "list-style-type"))
        })
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      onSubmit: (X) => {
        const _e = X.getData();
        Ir(_e.start).each((Oe) => {
          z.execCommand("mceListUpdate", !1, {
            attrs: { start: Oe.start === "1" ? "" : Oe.start },
            styles: { "list-style-type": Oe.listStyleType.getOr("") }
          });
        }), X.close();
      }
    });
  }, Fa = (z, F) => () => {
    const X = Ba(z);
    return Ye(X) && X.nodeName === F;
  }, yi = (z) => {
    z.addCommand("mceListProps", () => {
      Ln(z);
    });
  }, dr = (z) => {
    z.on("BeforeExecCommand", (F) => {
      const X = F.command.toLowerCase();
      X === "indent" ? Ai(z) : X === "outdent" && tu(z);
    }), z.addCommand("InsertUnorderedList", (F, X) => {
      bi(z, "UL", X);
    }), z.addCommand("InsertOrderedList", (F, X) => {
      bi(z, "OL", X);
    }), z.addCommand("InsertDefinitionList", (F, X) => {
      bi(z, "DL", X);
    }), z.addCommand("RemoveList", () => {
      _f(z);
    }), yi(z), z.addCommand("mceListUpdate", (F, X) => {
      he(X) && He(z, X);
    }), z.addQueryStateHandler("InsertUnorderedList", Fa(z, "UL")), z.addQueryStateHandler("InsertOrderedList", Fa(z, "OL")), z.addQueryStateHandler("InsertDefinitionList", Fa(z, "DL"));
  };
  var wa = tinymce.util.Tools.resolve("tinymce.html.Node");
  const zc = (z) => z.type === 3, lc = (z) => z.length === 0, de = (z) => {
    const F = (Oe, zt) => {
      const bn = wa.create("li");
      un(Oe, (ao) => bn.append(ao)), zt ? z.insert(bn, zt, !0) : z.append(bn);
    }, X = (Oe, zt) => zc(zt) ? [
      ...Oe,
      zt
    ] : !lc(Oe) && !zc(zt) ? (F(Oe, zt), []) : Oe, _e = ht(z.children(), X, []);
    lc(_e) || F(_e);
  }, Hc = (z) => {
    z.on("PreInit", () => {
      const { parser: F } = z;
      F.addNodeFilter("ul,ol", (X) => un(X, de));
    });
  }, Oc = (z) => {
    z.on("keydown", (F) => {
      F.keyCode !== Jc.TAB || Jc.metaKeyPressed(F) || z.undoManager.transact(() => {
        (F.shiftKey ? tu(z) : Ai(z)) && F.preventDefault();
      });
    });
  }, ls = (z) => {
    hu(z) && Oc(z), Ya(z);
  }, Yo = (z, F) => (X) => {
    const _e = (Oe) => {
      X.setActive(ns(Oe.parents, F)), X.setEnabled(!Id(z, Oe.element) && z.selection.isEditable());
    };
    return X.setEnabled(z.selection.isEditable()), Cp(z, _e);
  }, id = (z) => {
    const F = (X) => () => z.execCommand(X);
    z.hasPlugin("advlist") || (z.ui.registry.addToggleButton("numlist", {
      icon: "ordered-list",
      active: !1,
      tooltip: "Numbered list",
      onAction: F("InsertOrderedList"),
      onSetup: Yo(z, "OL")
    }), z.ui.registry.addToggleButton("bullist", {
      icon: "unordered-list",
      active: !1,
      tooltip: "Bullet list",
      onAction: F("InsertUnorderedList"),
      onSetup: Yo(z, "UL")
    }));
  }, Ac = (z, F) => (X) => Cp(z, (Oe) => X.setEnabled(ns(Oe.parents, F) && !Id(z, Oe.element))), Cf = (z) => {
    const F = {
      text: "List properties...",
      icon: "ordered-list",
      onAction: () => z.execCommand("mceListProps"),
      onSetup: Ac(z, "OL")
    };
    z.ui.registry.addMenuItem("listprops", F), z.ui.registry.addContextMenu("lists", {
      update: (X) => {
        const _e = Ba(z, X);
        return eo(_e) ? ["listprops"] : [];
      }
    });
  };
  var da = () => {
    v.add("lists", (z) => (Xs(z), Hc(z), z.hasPlugin("rtc", !0) ? yi(z) : (ls(z), dr(z)), id(z), Cf(z), Ol(z)));
  };
  da();
})();
(function() {
  var v = tinymce.util.Tools.resolve("tinymce.PluginManager");
  const L = (C, R, q) => {
    var se;
    return q(C, R.prototype) ? !0 : ((se = C.constructor) === null || se === void 0 ? void 0 : se.name) === R.name;
  }, N = (C) => {
    const R = typeof C;
    return C === null ? "null" : R === "object" && Array.isArray(C) ? "array" : R === "object" && L(C, String, (q, se) => se.isPrototypeOf(q)) ? "string" : R;
  }, W = (C) => (R) => N(R) === C, ue = (C) => (R) => typeof R === C, ce = (C) => (R) => C === R, he = W("string"), pe = W("array"), Me = ue("boolean"), Ze = ce(void 0), Ye = (C) => C == null, yt = (C) => !Ye(C), jt = ue("function"), it = ue("number"), Rt = () => {
  }, en = (C, R) => (q) => C(R(q)), Gt = (C) => () => C, gt = (C) => C, an = (C, R) => C === R;
  function Ot(C, ...R) {
    return (...q) => {
      const se = R.concat(q);
      return C.apply(null, se);
    };
  }
  const Ee = (C) => {
    C();
  }, wt = Gt(!1), Se = Gt(!0);
  class We {
    constructor(R, q) {
      this.tag = R, this.value = q;
    }
    static some(R) {
      return new We(!0, R);
    }
    static none() {
      return We.singletonNone;
    }
    fold(R, q) {
      return this.tag ? q(this.value) : R();
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(R) {
      return this.tag ? We.some(R(this.value)) : We.none();
    }
    bind(R) {
      return this.tag ? R(this.value) : We.none();
    }
    exists(R) {
      return this.tag && R(this.value);
    }
    forall(R) {
      return !this.tag || R(this.value);
    }
    filter(R) {
      return !this.tag || R(this.value) ? this : We.none();
    }
    getOr(R) {
      return this.tag ? this.value : R;
    }
    or(R) {
      return this.tag ? this : R;
    }
    getOrThunk(R) {
      return this.tag ? this.value : R();
    }
    orThunk(R) {
      return this.tag ? this : R();
    }
    getOrDie(R) {
      if (this.tag)
        return this.value;
      throw new Error(R ?? "Called getOrDie on None");
    }
    static from(R) {
      return yt(R) ? We.some(R) : We.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(R) {
      this.tag && R(this.value);
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  We.singletonNone = new We(!1);
  const Cn = Object.keys, ko = Object.hasOwnProperty, jn = (C, R) => {
    const q = Cn(C);
    for (let se = 0, De = q.length; se < De; se++) {
      const rt = q[se], Pt = C[rt];
      R(Pt, rt);
    }
  }, Xe = (C) => (R, q) => {
    C[q] = R;
  }, un = (C, R, q, se) => {
    jn(C, (De, rt) => {
      (R(De, rt) ? q : se)(De, rt);
    });
  }, M = (C, R) => {
    const q = {};
    return un(C, R, Xe(q), Rt), q;
  }, Et = (C, R) => {
    const q = [];
    return jn(C, (se, De) => {
      q.push(R(se, De));
    }), q;
  }, ht = (C) => Et(C, gt), mn = (C) => Cn(C).length, lo = (C, R) => dt(C, R) ? We.from(C[R]) : We.none(), dt = (C, R) => ko.call(C, R), Bn = (C, R) => dt(C, R) && C[R] !== void 0 && C[R] !== null, jr = (C) => {
    for (const R in C)
      if (ko.call(C, R))
        return !1;
    return !0;
  }, Tt = Array.prototype.indexOf, yo = Array.prototype.push, Ct = (C, R) => Tt.call(C, R), tn = (C, R) => Ct(C, R) > -1, oa = (C, R) => {
    for (let q = 0, se = C.length; q < se; q++) {
      const De = C[q];
      if (R(De, q))
        return !0;
    }
    return !1;
  }, Pn = (C, R) => {
    const q = [];
    for (let se = 0; se < C; se++)
      q.push(R(se));
    return q;
  }, Mo = (C, R) => {
    const q = C.length, se = new Array(q);
    for (let De = 0; De < q; De++) {
      const rt = C[De];
      se[De] = R(rt, De);
    }
    return se;
  }, K = (C, R) => {
    for (let q = 0, se = C.length; q < se; q++) {
      const De = C[q];
      R(De, q);
    }
  }, Go = (C, R) => {
    for (let q = C.length - 1; q >= 0; q--) {
      const se = C[q];
      R(se, q);
    }
  }, Zi = (C, R) => {
    const q = [], se = [];
    for (let De = 0, rt = C.length; De < rt; De++) {
      const Pt = C[De];
      (R(Pt, De) ? q : se).push(Pt);
    }
    return {
      pass: q,
      fail: se
    };
  }, er = (C, R) => {
    const q = [];
    for (let se = 0, De = C.length; se < De; se++) {
      const rt = C[se];
      R(rt, se) && q.push(rt);
    }
    return q;
  }, Qr = (C, R, q) => (Go(C, (se, De) => {
    q = R(q, se, De);
  }), q), nc = (C, R, q) => (K(C, (se, De) => {
    q = R(q, se, De);
  }), q), So = (C, R, q) => {
    for (let se = 0, De = C.length; se < De; se++) {
      const rt = C[se];
      if (R(rt, se))
        return We.some(rt);
      if (q(rt, se))
        break;
    }
    return We.none();
  }, cr = (C, R) => So(C, R, wt), oo = (C) => {
    const R = [];
    for (let q = 0, se = C.length; q < se; ++q) {
      if (!pe(C[q]))
        throw new Error("Arr.flatten item " + q + " was not an array, input: " + C);
      yo.apply(R, C[q]);
    }
    return R;
  }, ut = (C, R) => oo(Mo(C, R)), kt = (C, R) => {
    for (let q = 0, se = C.length; q < se; ++q) {
      const De = C[q];
      if (R(De, q) !== !0)
        return !1;
    }
    return !0;
  }, It = (C, R) => {
    const q = {};
    for (let se = 0, De = C.length; se < De; se++) {
      const rt = C[se];
      q[String(rt)] = R(rt, se);
    }
    return q;
  }, ct = (C, R) => R >= 0 && R < C.length ? We.some(C[R]) : We.none(), xn = (C) => ct(C, 0), co = (C) => ct(C, C.length - 1), Ko = (C, R) => {
    for (let q = 0; q < C.length; q++) {
      const se = R(C[q], q);
      if (se.isSome())
        return se;
    }
    return We.none();
  }, po = 8, Ra = 9, Mr = 11, ho = 1, Ns = 3, Ca = (C, R) => {
    const se = (R || document).createElement("div");
    if (se.innerHTML = C, !se.hasChildNodes() || se.childNodes.length > 1) {
      const De = "HTML does not have a single root node";
      throw console.error(De, C), new Error(De);
    }
    return Po(se.childNodes[0]);
  }, Zr = (C, R) => {
    const se = (R || document).createElement(C);
    return Po(se);
  }, $r = (C, R) => {
    const se = (R || document).createTextNode(C);
    return Po(se);
  }, Po = (C) => {
    if (C == null)
      throw new Error("Node cannot be null or undefined");
    return { dom: C };
  }, ro = {
    fromHtml: Ca,
    fromTag: Zr,
    fromText: $r,
    fromDom: Po,
    fromPoint: (C, R, q) => We.from(C.dom.elementFromPoint(R, q)).map(Po)
  }, cn = (C, R) => {
    const q = C.dom;
    if (q.nodeType !== ho)
      return !1;
    {
      const se = q;
      if (se.matches !== void 0)
        return se.matches(R);
      if (se.msMatchesSelector !== void 0)
        return se.msMatchesSelector(R);
      if (se.webkitMatchesSelector !== void 0)
        return se.webkitMatchesSelector(R);
      if (se.mozMatchesSelector !== void 0)
        return se.mozMatchesSelector(R);
      throw new Error("Browser lacks native selectors");
    }
  }, _n = (C) => C.nodeType !== ho && C.nodeType !== Ra && C.nodeType !== Mr || C.childElementCount === 0, Ys = (C, R) => {
    const q = R === void 0 ? document : R.dom;
    return _n(q) ? [] : Mo(q.querySelectorAll(C), ro.fromDom);
  }, Si = (C, R) => {
    const q = R === void 0 ? document : R.dom;
    return _n(q) ? We.none() : We.from(q.querySelector(C)).map(ro.fromDom);
  }, Nt = (C, R) => C.dom === R.dom, fi = cn;
  typeof window < "u" || Function("return this;")();
  const Zo = (C) => C.dom.nodeName.toLowerCase(), mi = (C) => C.dom.nodeType, kr = (C) => (R) => mi(R) === C, Qu = (C) => mi(C) === po || Zo(C) === "#comment", ba = kr(ho), xc = kr(Ns), _l = kr(Ra), Wi = kr(Mr), oc = (C) => (R) => ba(R) && Zo(R) === C, Hr = (C) => ro.fromDom(C.dom.ownerDocument), Yn = (C) => _l(C) ? C : Hr(C), qi = (C) => We.from(C.dom.parentNode).map(ro.fromDom), Ei = (C, R) => {
    const q = jt(R) ? R : wt;
    let se = C.dom;
    const De = [];
    for (; se.parentNode !== null && se.parentNode !== void 0; ) {
      const rt = se.parentNode, Pt = ro.fromDom(rt);
      if (De.push(Pt), q(Pt) === !0)
        break;
      se = rt;
    }
    return De;
  }, Cl = (C) => We.from(C.dom.previousSibling).map(ro.fromDom), Xc = (C) => We.from(C.dom.nextSibling).map(ro.fromDom), Xt = (C) => Mo(C.dom.childNodes, ro.fromDom), Dd = (C, R) => {
    const q = C.dom.childNodes;
    return We.from(q[R]).map(ro.fromDom);
  }, es = (C) => Dd(C, 0), yf = (C) => Wi(C) && yt(C.dom.host), Ti = jt(Element.prototype.attachShadow) && jt(Node.prototype.getRootNode) ? (C) => ro.fromDom(C.dom.getRootNode()) : Yn, wc = (C) => {
    const R = Ti(C);
    return yf(R) ? We.some(R) : We.none();
  }, pi = (C) => ro.fromDom(C.dom.host), ra = (C) => {
    const R = xc(C) ? C.dom.parentNode : C.dom;
    if (R == null || R.ownerDocument === null)
      return !1;
    const q = R.ownerDocument;
    return wc(ro.fromDom(R)).fold(() => q.body.contains(R), en(ra, pi));
  };
  var Gi = (C, R, q, se, De) => C(q, se) ? We.some(q) : jt(De) && De(q) ? We.none() : R(q, se, De);
  const vf = (C, R, q) => {
    let se = C.dom;
    const De = jt(q) ? q : wt;
    for (; se.parentNode; ) {
      se = se.parentNode;
      const rt = ro.fromDom(se);
      if (R(rt))
        return We.some(rt);
      if (De(rt))
        break;
    }
    return We.none();
  }, rc = (C, R, q) => Gi((De, rt) => rt(De), vf, C, R, q), tm = (C, R) => {
    const q = (De) => R(ro.fromDom(De));
    return cr(C.dom.childNodes, q).map(ro.fromDom);
  }, Sl = (C, R, q) => vf(C, (se) => cn(se, R), q), Nd = (C, R) => tm(C, (q) => cn(q, R)), tr = (C, R) => Si(R, C), Ms = (C, R, q) => Gi((De, rt) => cn(De, rt), Sl, C, R, q), ni = (C) => Ms(C, "[contenteditable]"), Jc = (C, R = !1) => ra(C) ? C.dom.isContentEditable : ni(C).fold(Gt(R), (q) => Md(q) === "true"), Md = (C) => C.dom.contentEditable, Bd = (C) => C.nodeName.toLowerCase(), cl = (C) => ro.fromDom(C.getBody()), sa = (C) => (R) => Nt(R, cl(C)), nm = (C) => C ? C.replace(/px$/, "") : "", _r = (C) => /^\d+(\.\d+)?$/.test(C) ? C + "px" : C, Dr = (C) => ro.fromDom(C.selection.getStart()), El = (C) => ro.fromDom(C.selection.getEnd()), ul = (C) => rc(C, oc("table")).forall(Jc), Lc = (C, R) => er(Xt(C), R), kc = (C, R) => {
    let q = [];
    return K(Xt(C), (se) => {
      R(se) && (q = q.concat([se])), q = q.concat(kc(se, R));
    }), q;
  }, gu = (C, R) => Lc(C, (q) => cn(q, R)), Na = (C, R) => Ys(R, C), us = (C, R, q) => {
    if (he(q) || Me(q) || it(q))
      C.setAttribute(R, q + "");
    else
      throw console.error("Invalid call to Attribute.set. Key ", R, ":: Value ", q, ":: Element ", C), new Error("Attribute value was not simple");
  }, Ma = (C, R, q) => {
    us(C.dom, R, q);
  }, Us = (C, R) => {
    const q = C.dom;
    jn(R, (se, De) => {
      us(q, De, se);
    });
  }, dl = (C, R) => {
    const q = C.dom.getAttribute(R);
    return q === null ? void 0 : q;
  }, Rr = (C, R) => We.from(dl(C, R)), Wa = (C, R) => {
    C.dom.removeAttribute(R);
  }, zi = (C) => nc(C.dom.attributes, (R, q) => (R[q.name] = q.value, R), {}), qa = (C, R, q = an) => C.exists((se) => q(se, R)), eo = (C) => {
    const R = [], q = (se) => {
      R.push(se);
    };
    for (let se = 0; se < C.length; se++)
      C[se].each(q);
    return R;
  }, gi = (C, R, q) => C.isSome() && R.isSome() ? We.some(q(C.getOrDie(), R.getOrDie())) : We.none(), js = (C) => C.bind(gt), Sa = (C, R) => C ? We.some(R) : We.none(), Ki = (C, R) => C.substring(R), ts = (C, R, q) => R === "" || C.length >= R.length && C.substr(q, q + R.length) === R, Bs = (C, R) => sc(C, R) ? Ki(C, R.length) : C, sc = (C, R) => ts(C, R, 0), ac = ((C) => (R) => R.replace(C, ""))(/^\s+|\s+$/g), Yi = (C) => C.length > 0, Ts = (C) => !Yi(C), fl = (C, R = 10) => {
    const q = parseInt(C, R);
    return isNaN(q) ? We.none() : We.some(q);
  }, Xs = (C) => {
    const R = parseFloat(C);
    return isNaN(R) ? We.none() : We.some(R);
  }, hu = (C) => C.style !== void 0 && jt(C.style.getPropertyValue), xf = (C, R, q) => {
    if (!he(q))
      throw console.error("Invalid call to CSS.set. Property ", R, ":: Value ", q, ":: Element ", C), new Error("CSS value must be a string: " + q);
    hu(C) && C.style.setProperty(R, q);
  }, ar = (C, R) => {
    hu(C) && C.style.removeProperty(R);
  }, te = (C, R, q) => {
    const se = C.dom;
    xf(se, R, q);
  }, ze = (C, R) => {
    const q = C.dom, De = window.getComputedStyle(q).getPropertyValue(R);
    return De === "" && !ra(C) ? Pe(q, R) : De;
  }, Pe = (C, R) => hu(C) ? C.style.getPropertyValue(R) : "", Qe = (C, R) => {
    const q = C.dom, se = Pe(q, R);
    return We.from(se).filter((De) => De.length > 0);
  }, Ft = (C, R) => {
    const q = C.dom;
    ar(q, R), qa(Rr(C, "style").map(ac), "") && Wa(C, "style");
  }, An = (C, R, q = 0) => Rr(C, R).map((se) => parseInt(se, 10)).getOr(q), so = (C, R) => Zn(C, R, Se), Zn = (C, R, q) => ut(Xt(C), (se) => cn(se, R) ? q(se) ? [se] : [] : Zn(se, R, q)), $n = [
    "tfoot",
    "thead",
    "tbody",
    "colgroup"
  ], ds = (C) => tn($n, C), Cr = (C, R) => ({
    rows: C,
    columns: R
  }), Wr = (C, R, q) => ({
    element: C,
    rowspan: R,
    colspan: q
  }), Ba = (C, R, q, se, De, rt) => ({
    element: C,
    rowspan: R,
    colspan: q,
    row: se,
    column: De,
    isLocked: rt
  }), ml = (C, R, q) => ({
    element: C,
    cells: R,
    section: q
  }), nr = (C, R, q, se) => ({
    startRow: C,
    startCol: R,
    finishRow: q,
    finishCol: se
  }), wf = (C, R, q) => ({
    element: C,
    colspan: R,
    column: q
  }), Qc = (C, R) => ({
    element: C,
    columns: R
  }), Ga = (C, R, q = wt) => {
    if (q(R))
      return We.none();
    if (tn(C, Zo(R)))
      return We.some(R);
    const se = (De) => cn(De, "table") || q(De);
    return Sl(R, C.join(","), se);
  }, Ld = (C, R) => Ga([
    "td",
    "th"
  ], C, R), aa = (C) => so(C, "th,td"), sg = (C) => cn(C, "colgroup") ? gu(C, "col") : ut(kp(C), (R) => gu(R, "col")), oi = (C, R) => Ms(C, "table", R), $l = (C) => so(C, "tr"), kp = (C) => oi(C).fold(Gt([]), (R) => gu(R, "colgroup")), oh = (C, R) => Mo(C, (q) => {
    if (Zo(q) === "colgroup") {
      const se = Mo(sg(q), (De) => {
        const rt = An(De, "span", 1);
        return Wr(De, 1, rt);
      });
      return ml(q, se, "colgroup");
    } else {
      const se = Mo(aa(q), (De) => {
        const rt = An(De, "rowspan", 1), Pt = An(De, "colspan", 1);
        return Wr(De, rt, Pt);
      });
      return ml(q, se, R(q));
    }
  }), Ht = (C) => qi(C).map((R) => {
    const q = Zo(R);
    return ds(q) ? q : "tbody";
  }).getOr("tbody"), Pd = (C) => {
    const R = $l(C), se = [
      ...kp(C),
      ...R
    ];
    return oh(se, Ht);
  }, _p = "data-snooker-locked-cols", ed = (C) => Rr(C, _p).bind((R) => We.from(R.match(/\d+/g))).map((R) => It(R, Se)), ns = (C, R) => C + "," + R, ag = (C, R, q) => We.from(C.access[ns(R, q)]), Xi = (C, R, q) => {
    const se = Id(C, (De) => q(R, De.element));
    return se.length > 0 ? We.some(se[0]) : We.none();
  }, Id = (C, R) => {
    const q = ut(C.all, (se) => se.cells);
    return er(q, R);
  }, Cp = (C) => {
    const R = {};
    let q = 0;
    return K(C.cells, (se) => {
      const De = se.colspan;
      Pn(De, (rt) => {
        const Pt = q + rt;
        R[Pt] = wf(se.element, De, Pt);
      }), q += De;
    }), R;
  }, Pc = (C) => {
    const R = {}, q = [], De = xn(C).map((as) => as.element).bind(oi).bind(ed).getOr({});
    let rt = 0, Pt = 0, on = 0;
    const {
      pass: Tn,
      fail: uo
    } = Zi(C, (as) => as.section === "colgroup");
    K(uo, (as) => {
      const Ha = [];
      K(as.cells, (Xa) => {
        let su = 0;
        for (; R[ns(on, su)] !== void 0; )
          su++;
        const Um = Bn(De, su.toString()), Of = Ba(Xa.element, Xa.rowspan, Xa.colspan, on, su, Um);
        for (let or = 0; or < Xa.colspan; or++)
          for (let jm = 0; jm < Xa.rowspan; jm++) {
            const dd = on + jm, fd = su + or, Ap = ns(dd, fd);
            R[Ap] = Of, Pt = Math.max(Pt, fd + 1);
          }
        Ha.push(Of);
      }), rt++, q.push(ml(as.element, Ha, as.section)), on++;
    });
    const { columns: ks, colgroups: _o } = co(Tn).map((as) => {
      const Ha = Cp(as);
      return {
        colgroups: [Qc(as.element, ht(Ha))],
        columns: Ha
      };
    }).getOrThunk(() => ({
      colgroups: [],
      columns: {}
    }));
    return {
      grid: Cr(rt, Pt),
      access: R,
      all: q,
      columns: ks,
      colgroups: _o
    };
  }, eu = {
    fromTable: (C) => {
      const R = Pd(C);
      return Pc(R);
    },
    generate: Pc,
    getAt: ag,
    findItem: Xi,
    filterItems: Id,
    justCells: (C) => ut(C.all, (R) => R.cells),
    justColumns: (C) => ht(C.columns),
    hasColumns: (C) => Cn(C.columns).length > 0,
    getColumnAt: (C, R) => We.from(C.columns[R])
  };
  var om = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const kf = (C, R, q) => {
    const se = C.select("td,th", R);
    let De;
    for (let rt = 0; rt < se.length; rt++) {
      const Pt = C.getStyle(se[rt], q);
      if (Ze(De) && (De = Pt), De !== Pt)
        return "";
    }
    return De;
  }, _c = (C, R, q) => {
    om.each("left center right".split(" "), (se) => {
      se !== q && C.formatter.remove("align" + se, {}, R);
    }), q && C.formatter.apply("align" + q, {}, R);
  }, Ic = (C, R, q) => {
    om.each("top middle bottom".split(" "), (se) => {
      se !== q && C.formatter.remove("valign" + se, {}, R);
    }), q && C.formatter.apply("valign" + q, {}, R);
  }, Eo = (C, R, q) => {
    C.dispatch("TableModified", {
      ...q,
      table: R
    });
  }, Fd = (C, R) => Xs(C).getOr(R), ia = (C, R, q) => Fd(ze(C, R), q), td = (C, R, q, se) => {
    const De = ia(C, `padding-${q}`, 0), rt = ia(C, `padding-${se}`, 0), Pt = ia(C, `border-${q}-width`, 0), on = ia(C, `border-${se}-width`, 0);
    return R - De - rt - Pt - on;
  }, $d = (C, R) => {
    const q = C.dom, se = q.getBoundingClientRect().width || q.offsetWidth;
    return R === "border-box" ? se : td(C, se, "left", "right");
  }, Zs = (C) => $d(C, "content-box");
  var nd = tinymce.util.Tools.resolve("tinymce.Env");
  const rm = "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol", ya = Pn(5, (C) => {
    const R = `${C + 1}px`;
    return {
      title: R,
      value: R
    };
  }), Ls = Mo([
    "Solid",
    "Dotted",
    "Dashed",
    "Double",
    "Groove",
    "Ridge",
    "Inset",
    "Outset",
    "None",
    "Hidden"
  ], (C) => ({
    title: C,
    value: C.toLowerCase()
  })), Vr = "100%", zs = (C) => {
    var R;
    const q = C.dom, se = (R = q.getParent(C.selection.getStart(), q.isBlock)) !== null && R !== void 0 ? R : C.getBody();
    return Zs(ro.fromDom(se)) + "px";
  }, Qi = (C, R) => lg(C) || !Cc(C) ? R : xu(C) ? {
    ...R,
    width: zs(C)
  } : {
    ...R,
    width: Vr
  }, Js = (C, R) => lg(C) || Cc(C) ? R : xu(C) ? {
    ...R,
    width: zs(C)
  } : {
    ...R,
    width: Vr
  }, La = (C) => (R) => R.options.get(C), xs = (C) => {
    const R = C.options.register;
    R("table_border_widths", {
      processor: "object[]",
      default: ya
    }), R("table_border_styles", {
      processor: "object[]",
      default: Ls
    }), R("table_cell_advtab", {
      processor: "boolean",
      default: !0
    }), R("table_row_advtab", {
      processor: "boolean",
      default: !0
    }), R("table_advtab", {
      processor: "boolean",
      default: !0
    }), R("table_appearance_options", {
      processor: "boolean",
      default: !0
    }), R("table_grid", {
      processor: "boolean",
      default: !nd.deviceType.isTouch()
    }), R("table_cell_class_list", {
      processor: "object[]",
      default: []
    }), R("table_row_class_list", {
      processor: "object[]",
      default: []
    }), R("table_class_list", {
      processor: "object[]",
      default: []
    }), R("table_toolbar", {
      processor: "string",
      default: rm
    }), R("table_background_color_map", {
      processor: "object[]",
      default: []
    }), R("table_border_color_map", {
      processor: "object[]",
      default: []
    });
  }, Hd = La("table_sizing_mode"), Ws = La("table_border_widths"), va = La("table_border_styles"), la = La("table_cell_advtab"), od = La("table_row_advtab"), os = La("table_advtab"), sm = La("table_appearance_options"), vu = La("table_grid"), Cc = La("table_style_by_css"), To = La("table_cell_class_list"), ca = La("table_row_class_list"), rd = La("table_class_list"), Oi = La("table_toolbar"), Vd = La("table_background_color_map"), Fc = La("table_border_color_map"), xu = (C) => Hd(C) === "fixed", lg = (C) => Hd(C) === "responsive", wu = (C) => {
    const R = C.options, q = R.get("table_default_styles");
    return R.isSet("table_default_styles") ? q : Qi(C, q);
  }, ri = (C) => {
    const R = C.options, q = R.get("table_default_attributes");
    return R.isSet("table_default_attributes") ? q : Js(C, q);
  }, Sp = (C, R) => R.column >= C.startCol && R.column + R.colspan - 1 <= C.finishCol && R.row >= C.startRow && R.row + R.rowspan - 1 <= C.finishRow, be = (C, R) => {
    let q = !0;
    const se = Ot(Sp, R);
    for (let De = R.startRow; De <= R.finishRow; De++)
      for (let rt = R.startCol; rt <= R.finishCol; rt++)
        q = q && eu.getAt(C, De, rt).exists(se);
    return q ? We.some(R) : We.none();
  }, Sc = (C, R) => nr(Math.min(C.row, R.row), Math.min(C.column, R.column), Math.max(C.row + C.rowspan - 1, R.row + R.rowspan - 1), Math.max(C.column + C.colspan - 1, R.column + R.colspan - 1)), Ai = (C, R, q) => {
    const se = eu.findItem(C, R, Nt), De = eu.findItem(C, q, Nt);
    return se.bind((rt) => De.map((Pt) => Sc(rt, Pt)));
  }, tu = (C, R, q) => Ai(C, R, q).bind((se) => be(C, se)), _f = (C, R, q) => {
    const se = sd(C);
    return tu(se, R, q);
  }, sd = eu.fromTable, Le = (C, R) => {
    qi(C).each((se) => {
      se.dom.insertBefore(R.dom, C.dom);
    });
  }, Dt = (C, R) => {
    Xc(C).fold(() => {
      qi(C).each((De) => {
        Sn(De, R);
      });
    }, (se) => {
      Le(se, R);
    });
  }, vt = (C, R) => {
    es(C).fold(() => {
      Sn(C, R);
    }, (se) => {
      C.dom.insertBefore(R.dom, se.dom);
    });
  }, Sn = (C, R) => {
    C.dom.appendChild(R.dom);
  }, Fo = (C, R) => {
    Le(C, R), Sn(R, C);
  }, ur = (C, R) => {
    K(R, (q, se) => {
      const De = se === 0 ? C : R[se - 1];
      Dt(De, q);
    });
  }, Br = (C, R) => {
    K(R, (q) => {
      Sn(C, q);
    });
  }, Lr = (C) => {
    const R = C.dom;
    R.parentNode !== null && R.parentNode.removeChild(R);
  }, hi = (C) => {
    const R = Xt(C);
    R.length > 0 && ur(C, R), Lr(C);
  }, Ps = ((C, R) => {
    const q = (rt) => {
      if (!C(rt))
        throw new Error("Can only get " + R + " value of a " + R + " node");
      return se(rt).getOr("");
    }, se = (rt) => C(rt) ? We.from(rt.dom.nodeValue) : We.none();
    return {
      get: q,
      getOption: se,
      set: (rt, Pt) => {
        if (!C(rt))
          throw new Error("Can only set raw " + R + " value of a " + R + " node");
        rt.dom.nodeValue = Pt;
      }
    };
  })(xc, "text"), Di = (C) => Ps.get(C), cg = (C, R) => Ps.set(C, R);
  var Ec = [
    "body",
    "p",
    "div",
    "article",
    "aside",
    "figcaption",
    "figure",
    "footer",
    "header",
    "nav",
    "section",
    "ol",
    "ul",
    "li",
    "table",
    "thead",
    "tbody",
    "tfoot",
    "caption",
    "tr",
    "td",
    "th",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "blockquote",
    "pre",
    "address"
  ], Pr = () => {
    const C = (uo) => ro.fromDom(uo.dom.cloneNode(!1)), R = (uo) => Yn(uo).dom, q = (uo) => ba(uo) ? Zo(uo) === "body" ? !0 : tn(Ec, Zo(uo)) : !1, se = (uo) => ba(uo) ? tn([
      "br",
      "img",
      "hr",
      "input"
    ], Zo(uo)) : !1, De = (uo) => ba(uo) && dl(uo, "contenteditable") === "false", rt = (uo, ks) => uo.dom.compareDocumentPosition(ks.dom), Pt = (uo, ks) => {
      const _o = zi(uo);
      Us(ks, _o);
    }, on = (uo) => {
      const ks = Zo(uo);
      return tn([
        "script",
        "noscript",
        "iframe",
        "noframes",
        "noembed",
        "title",
        "style",
        "textarea",
        "xmp"
      ], ks);
    }, Tn = (uo) => ba(uo) ? Rr(uo, "lang") : We.none();
    return {
      up: Gt({
        selector: Sl,
        closest: Ms,
        predicate: vf,
        all: Ei
      }),
      down: Gt({
        selector: Na,
        predicate: kc
      }),
      styles: Gt({
        get: ze,
        getRaw: Qe,
        set: te,
        remove: Ft
      }),
      attrs: Gt({
        get: dl,
        set: Ma,
        remove: Wa,
        copyTo: Pt
      }),
      insert: Gt({
        before: Le,
        after: Dt,
        afterAll: ur,
        append: Sn,
        appendAll: Br,
        prepend: vt,
        wrap: Fo
      }),
      remove: Gt({
        unwrap: hi,
        remove: Lr
      }),
      create: Gt({
        nu: ro.fromTag,
        clone: C,
        text: ro.fromText
      }),
      query: Gt({
        comparePosition: rt,
        prevSibling: Cl,
        nextSibling: Xc
      }),
      property: Gt({
        children: Xt,
        name: Zo,
        parent: qi,
        document: R,
        isText: xc,
        isComment: Qu,
        isElement: ba,
        isSpecial: on,
        getLanguage: Tn,
        getText: Di,
        setText: cg,
        isBoundary: q,
        isEmptyTag: se,
        isNonEditable: De
      }),
      eq: Nt,
      is: fi
    };
  };
  const Tc = (C, R, q, se) => {
    const De = q[0], rt = q.slice(1);
    return se(C, R, De, rt);
  }, qr = (C, R, q) => q.length > 0 ? Tc(C, R, q, xa) : We.none(), xa = (C, R, q, se) => {
    const De = R(C, q);
    return Qr(se, (rt, Pt) => {
      const on = R(C, Pt);
      return $c(C, rt, on);
    }, De);
  }, $c = (C, R, q) => R.bind((se) => q.filter(Ot(C.eq, se))), Ud = qr, am = Pr(), Ep = (C, R) => Ud(am, (q, se) => C(se), R), ku = (C) => Sl(C, "table"), Tl = (C, R) => {
    const q = Na(C, R);
    return q.length > 0 ? We.some(q) : We.none();
  }, pl = (C, R, q) => tr(C, R).bind((se) => tr(C, q).bind((De) => Ep(ku, [
    se,
    De
  ]).map((rt) => ({
    first: se,
    last: De,
    table: rt
  })))), Gr = (C, R) => Tl(C, R), ic = (C, R, q) => pl(C, R, q).bind((se) => {
    const De = (Tn) => Nt(C, Tn), rt = "thead,tfoot,tbody,table", Pt = Sl(se.first, rt, De), on = Sl(se.last, rt, De);
    return Pt.bind((Tn) => on.bind((uo) => Nt(Tn, uo) ? _f(se.table, se.first, se.last) : We.none()));
  }), Ta = (C) => Mo(C, ro.fromDom), nu = "data-mce-selected", bi = "td[" + nu + "],th[" + nu + "]", ad = "data-mce-first-selected", Qs = "td[" + ad + "],th[" + ad + "]", ua = "data-mce-last-selected", si = "td[" + ua + "],th[" + ua + "]", st = {
    selected: nu,
    selectedSelector: bi,
    firstSelected: ad,
    firstSelectedSelector: Qs,
    lastSelected: ua,
    lastSelectedSelector: si
  }, zl = (C) => oi(C).bind((R) => Gr(R, st.firstSelectedSelector)).fold(Gt(C), (R) => R[0]), Lm = (C) => (R, q) => {
    const se = Zo(R), De = se === "col" || se === "colgroup" ? zl(R) : R;
    return Ms(De, C, q);
  }, Is = Lm("th,td,caption"), Pa = Lm("th,td"), Ia = (C) => Ta(C.model.table.getSelectedCells()), el = (C, R) => {
    const q = Pa(C), se = q.bind((De) => oi(De)).map((De) => $l(De));
    return gi(q, se, (De, rt) => er(rt, (Pt) => oa(Ta(Pt.dom.cells), (on) => dl(on, R) === "1" || Nt(on, De)))).getOr([]);
  }, jd = [
    {
      text: "None",
      value: ""
    },
    {
      text: "Top",
      value: "top"
    },
    {
      text: "Middle",
      value: "middle"
    },
    {
      text: "Bottom",
      value: "bottom"
    }
  ], Ka = (C) => ({ value: Nr(C) }), pr = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, Hl = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, ea = (C) => pr.test(C) || Hl.test(C), Nr = (C) => Bs(C, "#").toUpperCase(), Pm = (C) => ea(C) ? We.some({ value: Nr(C) }) : We.none(), Vl = (C) => {
    const R = C.toString(16);
    return (R.length === 1 ? "0" + R : R).toUpperCase();
  }, Ya = (C) => {
    const R = Vl(C.red) + Vl(C.green) + Vl(C.blue);
    return Ka(R);
  }, Ol = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i, He = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i, za = (C, R, q, se) => ({
    red: C,
    green: R,
    blue: q,
    alpha: se
  }), ou = (C, R, q, se) => {
    const De = parseInt(C, 10), rt = parseInt(R, 10), Pt = parseInt(q, 10), on = parseFloat(se);
    return za(De, rt, Pt, on);
  }, Al = (C) => {
    if (C === "transparent")
      return We.some(za(0, 0, 0, 0));
    const R = Ol.exec(C);
    if (R !== null)
      return We.some(ou(R[1], R[2], R[3], "1"));
    const q = He.exec(C);
    return q !== null ? We.some(ou(q[1], q[2], q[3], q[4])) : We.none();
  }, Fs = (C) => Pm(C).orThunk(() => Al(C).map(Ya)).getOrThunk(() => {
    const R = document.createElement("canvas");
    R.height = 1, R.width = 1;
    const q = R.getContext("2d");
    q.clearRect(0, 0, R.width, R.height), q.fillStyle = "#FFFFFF", q.fillStyle = C, q.fillRect(0, 0, 1, 1);
    const se = q.getImageData(0, 0, 1, 1).data, De = se[0], rt = se[1], Pt = se[2], on = se[3];
    return Ya(za(De, rt, Pt, on));
  }), rs = (C) => Al(C).map(Ya).map((R) => "#" + R.value).getOr(C), fs = (C) => {
    let R = C;
    return {
      get: () => R,
      set: (De) => {
        R = De;
      }
    };
  }, Ir = (C) => {
    const R = fs(We.none()), q = () => R.get().each(C);
    return {
      clear: () => {
        q(), R.set(We.none());
      },
      isSet: () => R.get().isSome(),
      get: () => R.get(),
      set: (on) => {
        q(), R.set(We.some(on));
      }
    };
  }, im = () => Ir((C) => C.unbind()), Ln = (C, R, q) => (se) => {
    const De = im(), rt = Ts(q), Pt = () => {
      const on = Ia(C), Tn = (uo) => C.formatter.match(R, { value: q }, uo.dom, rt);
      rt ? (se.setActive(!oa(on, Tn)), De.set(C.formatter.formatChanged(R, (uo) => se.setActive(!uo), !0))) : (se.setActive(kt(on, Tn)), De.set(C.formatter.formatChanged(R, se.setActive, !1, { value: q })));
    };
    return C.initialized ? Pt() : C.on("init", Pt), De.clear;
  }, Fa = (C) => Bn(C, "menu"), yi = (C) => Mo(C, (R) => {
    const q = R.text || R.title || "";
    return Fa(R) ? {
      text: q,
      items: yi(R.menu)
    } : {
      text: q,
      value: R.value
    };
  }), dr = (C, R, q, se) => Mo(R, (De) => {
    const rt = De.text || De.title;
    return Fa(De) ? {
      type: "nestedmenuitem",
      text: rt,
      getSubmenuItems: () => dr(C, De.menu, q, se)
    } : {
      text: rt,
      type: "togglemenuitem",
      onAction: () => se(De.value),
      onSetup: Ln(C, q, De.value)
    };
  }), wa = (C, R) => (q) => {
    C.execCommand("mceTableApplyCellStyle", !1, { [R]: q });
  }, zc = (C) => ut(C, (R) => Fa(R) ? [{
    ...R,
    menu: zc(R.menu)
  }] : Yi(R.value) ? [R] : []), lc = (C, R, q, se) => (De) => De(dr(C, R, q, se)), de = (C, R, q) => {
    const se = Mo(R, (De) => ({
      text: De.title,
      value: "#" + Fs(De.value).value,
      type: "choiceitem"
    }));
    return [{
      type: "fancymenuitem",
      fancytype: "colorswatch",
      initData: {
        colors: se.length > 0 ? se : void 0,
        allowCustomColors: !1
      },
      onAction: (De) => {
        const rt = De.value === "remove" ? "" : De.value;
        C.execCommand("mceTableApplyCellStyle", !1, { [q]: rt });
      }
    }];
  }, Hc = (C) => () => {
    const q = C.queryCommandValue("mceTableRowType") === "header" ? "body" : "header";
    C.execCommand("mceTableRowType", !1, { type: q });
  }, Oc = (C) => () => {
    const q = C.queryCommandValue("mceTableColType") === "th" ? "td" : "th";
    C.execCommand("mceTableColType", !1, { type: q });
  }, ls = (C) => {
    const R = yi(To(C));
    return R.length > 0 ? We.some({
      name: "class",
      type: "listbox",
      label: "Class",
      items: R
    }) : We.none();
  }, Yo = [
    {
      name: "width",
      type: "input",
      label: "Width"
    },
    {
      name: "height",
      type: "input",
      label: "Height"
    },
    {
      name: "celltype",
      type: "listbox",
      label: "Cell type",
      items: [
        {
          text: "Cell",
          value: "td"
        },
        {
          text: "Header cell",
          value: "th"
        }
      ]
    },
    {
      name: "scope",
      type: "listbox",
      label: "Scope",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Row",
          value: "row"
        },
        {
          text: "Column",
          value: "col"
        },
        {
          text: "Row group",
          value: "rowgroup"
        },
        {
          text: "Column group",
          value: "colgroup"
        }
      ]
    },
    {
      name: "halign",
      type: "listbox",
      label: "Horizontal align",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Left",
          value: "left"
        },
        {
          text: "Center",
          value: "center"
        },
        {
          text: "Right",
          value: "right"
        }
      ]
    },
    {
      name: "valign",
      type: "listbox",
      label: "Vertical align",
      items: jd
    }
  ], id = (C) => Yo.concat(ls(C).toArray()), Ac = (C, R) => {
    const se = [
      {
        name: "borderstyle",
        type: "listbox",
        label: "Border style",
        items: [{
          text: "Select...",
          value: ""
        }].concat(yi(va(C)))
      },
      {
        name: "bordercolor",
        type: "colorinput",
        label: "Border color"
      },
      {
        name: "backgroundcolor",
        type: "colorinput",
        label: "Background color"
      }
    ];
    return {
      title: "Advanced",
      name: "advanced",
      items: R === "cell" ? [{
        name: "borderwidth",
        type: "input",
        label: "Border width"
      }].concat(se) : se
    };
  }, da = { normal: (C, R) => {
    const q = C.dom;
    return {
      setAttrib: (Pt, on) => {
        q.setAttrib(R, Pt, on);
      },
      setStyle: (Pt, on) => {
        q.setStyle(R, Pt, on);
      },
      setFormat: (Pt, on) => {
        on === "" ? C.formatter.remove(Pt, { value: null }, R, !0) : C.formatter.apply(Pt, { value: on }, R);
      }
    };
  } }, z = oc("th"), F = (C, R) => C && R ? "sectionCells" : C ? "section" : "cells", X = (C) => {
    const R = C.section === "thead", q = qa(_e(C.cells), "th");
    return C.section === "tfoot" ? { type: "footer" } : R || q ? {
      type: "header",
      subType: F(R, q)
    } : { type: "body" };
  }, _e = (C) => {
    const R = er(C, (q) => z(q.element));
    return R.length === 0 ? We.some("td") : R.length === C.length ? We.some("th") : We.none();
  }, Oe = (C) => {
    const R = Mo(C, (De) => X(De).type), q = tn(R, "header"), se = tn(R, "footer");
    if (!q && !se)
      return We.some("body");
    {
      const De = tn(R, "body");
      return q && !De && !se ? We.some("header") : !q && !De && se ? We.some("footer") : We.none();
    }
  }, zt = (C) => {
    let R = !1, q;
    return (...se) => (R || (R = !0, q = C.apply(null, se)), q);
  }, bn = (C, R) => Ko(C.all, (q) => cr(q.cells, (se) => Nt(R, se.element))), ao = (C, R, q) => {
    const se = Mo(R.selection, (rt) => Ld(rt).bind((Pt) => bn(C, Pt)).filter(q)), De = eo(se);
    return Sa(De.length > 0, De);
  }, Hn = (C, R) => R.mergable, En = (C, R) => R.unmergable, yr = (C, R) => ao(C, R, Se), ws = (C, R) => bn(C, R).exists((q) => !q.isLocked), Ri = (C, R) => kt(R, (q) => ws(C, q)), _u = (C, R) => Hn(C, R).filter((q) => Ri(C, q.cells)), Ni = (C, R) => En(C, R).filter((q) => Ri(C, q));
  ({ ...{ generate: (C) => {
    if (!pe(C))
      throw new Error("cases must be an array");
    if (C.length === 0)
      throw new Error("there must be at least one case");
    const R = [], q = {};
    return K(C, (se, De) => {
      const rt = Cn(se);
      if (rt.length !== 1)
        throw new Error("one and only one name per case");
      const Pt = rt[0], on = se[Pt];
      if (q[Pt] !== void 0)
        throw new Error("duplicate key detected:" + Pt);
      if (Pt === "cata")
        throw new Error("cannot have a case named cata (sorry)");
      if (!pe(on))
        throw new Error("case arguments must be an array");
      R.push(Pt), q[Pt] = (...Tn) => {
        const uo = Tn.length;
        if (uo !== on.length)
          throw new Error("Wrong number of arguments to case " + Pt + ". Expected " + on.length + " (" + on + "), got " + uo);
        return {
          fold: (..._o) => {
            if (_o.length !== C.length)
              throw new Error("Wrong number of arguments to fold. Expected " + C.length + ", got " + _o.length);
            return _o[De].apply(null, Tn);
          },
          match: (_o) => {
            const fr = Cn(_o);
            if (R.length !== fr.length)
              throw new Error("Wrong number of arguments to match. Expected: " + R.join(",") + `
Actual: ` + fr.join(","));
            if (!kt(R, (Ha) => tn(fr, Ha)))
              throw new Error("Not all branches were specified when using match. Specified: " + fr.join(", ") + `
Required: ` + R.join(", "));
            return _o[Pt].apply(null, Tn);
          },
          log: (_o) => {
            console.log(_o, {
              constructors: R,
              constructor: Pt,
              params: Tn
            });
          }
        };
      };
    }), q;
  } }.generate([
    { none: [] },
    { only: ["index"] },
    {
      left: [
        "index",
        "next"
      ]
    },
    {
      middle: [
        "prev",
        "index",
        "next"
      ]
    },
    {
      right: [
        "prev",
        "index"
      ]
    }
  ]) });
  const wn = (C, R) => {
    const q = eu.fromTable(C);
    return yr(q, R).bind((De) => {
      const rt = De[De.length - 1], Pt = De[0].row, on = rt.row + rt.rowspan, Tn = q.all.slice(Pt, on);
      return Oe(Tn);
    }).getOr("");
  }, ta = (C) => sc(C, "rgb") ? rs(C) : C, gl = (C) => {
    const R = ro.fromDom(C);
    return {
      borderwidth: Qe(R, "border-width").getOr(""),
      borderstyle: Qe(R, "border-style").getOr(""),
      bordercolor: Qe(R, "border-color").map(ta).getOr(""),
      backgroundcolor: Qe(R, "background-color").map(ta).getOr("")
    };
  }, Vc = (C) => {
    const R = C[0], q = C.slice(1);
    return K(q, (se) => {
      K(Cn(R), (De) => {
        jn(se, (rt, Pt) => {
          const on = R[De];
          on !== "" && De === Pt && on !== rt && (R[De] = "");
        });
      });
    }), R;
  }, Ul = (C, R, q, se) => cr(C, (De) => !Ze(q.formatter.matchNode(se, R + De))).getOr(""), Zd = Ot(Ul, [
    "left",
    "center",
    "right"
  ], "align"), Tp = Ot(Ul, [
    "top",
    "middle",
    "bottom"
  ], "valign"), ug = (C, R) => {
    const q = wu(C), se = ri(C), De = () => ({
      borderstyle: lo(q, "border-style").getOr(""),
      bordercolor: ta(lo(q, "border-color").getOr("")),
      backgroundcolor: ta(lo(q, "background-color").getOr(""))
    }), rt = {
      height: "",
      width: "100%",
      cellspacing: "",
      cellpadding: "",
      caption: !1,
      class: "",
      align: "",
      border: ""
    }, Pt = () => {
      const ks = q["border-width"];
      return Cc(C) && ks ? { border: ks } : lo(se, "border").fold(() => ({}), (_o) => ({ border: _o }));
    }, on = R ? De() : {}, Tn = () => {
      const ks = lo(q, "border-spacing").or(lo(se, "cellspacing")).fold(() => ({}), (fr) => ({ cellspacing: fr })), _o = lo(q, "border-padding").or(lo(se, "cellpadding")).fold(() => ({}), (fr) => ({ cellpadding: fr }));
      return {
        ...ks,
        ..._o
      };
    };
    return {
      ...rt,
      ...q,
      ...se,
      ...on,
      ...Pt(),
      ...Tn()
    };
  }, ru = (C) => oi(ro.fromDom(C)).map((R) => {
    const q = { selection: Ta(C.cells) };
    return wn(R, q);
  }).getOr(""), sh = (C, R, q) => {
    const se = (on, Tn) => {
      const uo = Qe(ro.fromDom(Tn), "border-width");
      return Cc(C) && uo.isSome() ? uo.getOr("") : on.getAttrib(Tn, "border") || kf(C.dom, Tn, "border-width") || kf(C.dom, Tn, "border") || "";
    }, De = C.dom, rt = Cc(C) ? De.getStyle(R, "border-spacing") || De.getAttrib(R, "cellspacing") : De.getAttrib(R, "cellspacing") || De.getStyle(R, "border-spacing"), Pt = Cc(C) ? kf(De, R, "padding") || De.getAttrib(R, "cellpadding") : De.getAttrib(R, "cellpadding") || kf(De, R, "padding");
    return {
      width: De.getStyle(R, "width") || De.getAttrib(R, "width"),
      height: De.getStyle(R, "height") || De.getAttrib(R, "height"),
      cellspacing: rt ?? "",
      cellpadding: Pt ?? "",
      border: se(De, R),
      caption: !!De.select("caption", R)[0],
      class: De.getAttrib(R, "class", ""),
      align: Zd(C, R),
      ...q ? gl(R) : {}
    };
  }, Cu = (C, R, q) => {
    const se = C.dom;
    return {
      height: se.getStyle(R, "height") || se.getAttrib(R, "height"),
      class: se.getAttrib(R, "class", ""),
      type: ru(R),
      align: Zd(C, R),
      ...q ? gl(R) : {}
    };
  }, Wd = (C, R, q, se) => {
    const De = C.dom, rt = se.getOr(R), Pt = (on, Tn) => De.getStyle(on, Tn) || De.getAttrib(on, Tn);
    return {
      width: Pt(rt, "width"),
      height: Pt(R, "height"),
      scope: De.getAttrib(R, "scope"),
      celltype: Bd(R),
      class: De.getAttrib(R, "class", ""),
      halign: Zd(C, R),
      valign: Tp(C, R),
      ...q ? gl(R) : {}
    };
  }, Uc = (C, R) => {
    const q = eu.fromTable(C), se = eu.justCells(q), De = er(se, (rt) => oa(R, (Pt) => Nt(rt.element, Pt)));
    return Mo(De, (rt) => ({
      element: rt.element.dom,
      column: eu.getColumnAt(q, rt.column).map((Pt) => Pt.element.dom)
    }));
  }, At = (C, R, q, se) => {
    se("scope") && C.setAttrib("scope", q.scope), se("class") && C.setAttrib("class", q.class), se("height") && C.setStyle("height", _r(q.height)), se("width") && R.setStyle("width", _r(q.width));
  }, Fm = (C, R, q) => {
    q("backgroundcolor") && C.setFormat("tablecellbackgroundcolor", R.backgroundcolor), q("bordercolor") && C.setFormat("tablecellbordercolor", R.bordercolor), q("borderstyle") && C.setFormat("tablecellborderstyle", R.borderstyle), q("borderwidth") && C.setFormat("tablecellborderwidth", _r(R.borderwidth));
  }, qd = (C, R, q, se) => {
    const De = R.length === 1;
    K(R, (rt) => {
      const Pt = rt.element, on = De ? Se : se, Tn = da.normal(C, Pt), uo = rt.column.map((ks) => da.normal(C, ks)).getOr(Tn);
      At(Tn, uo, q, on), la(C) && Fm(Tn, q, on), se("halign") && _c(C, Pt, q.halign), se("valign") && Ic(C, Pt, q.valign);
    });
  }, Gd = (C, R) => {
    C.execCommand("mceTableCellType", !1, {
      type: R.celltype,
      no_events: !0
    });
  }, Dl = (C, R, q, se) => {
    const De = M(se, (rt, Pt) => q[Pt] !== rt);
    mn(De) > 0 && R.length >= 1 && oi(R[0]).each((rt) => {
      const Pt = Uc(rt, R), on = mn(M(De, (uo, ks) => ks !== "scope" && ks !== "celltype")) > 0, Tn = dt(De, "celltype");
      (on || dt(De, "scope")) && qd(C, Pt, se, Ot(dt, De)), Tn && Gd(C, se), Eo(C, rt.dom, {
        structure: Tn,
        style: on
      });
    });
  }, lm = (C, R, q, se) => {
    const De = se.getData();
    se.close(), C.undoManager.transact(() => {
      Dl(C, R, q, De), C.focus();
    });
  }, cs = (C, R) => {
    const q = oi(R[0]).map((se) => Mo(Uc(se, R), (De) => Wd(C, De.element, la(C), De.column)));
    return Vc(q.getOrDie());
  }, Rl = (C) => {
    const R = Ia(C);
    if (R.length === 0)
      return;
    const q = cs(C, R), se = {
      type: "tabpanel",
      tabs: [
        {
          title: "General",
          name: "general",
          items: id(C)
        },
        Ac(C, "cell")
      ]
    }, De = {
      type: "panel",
      items: [{
        type: "grid",
        columns: 2,
        items: id(C)
      }]
    };
    C.windowManager.open({
      title: "Cell Properties",
      size: "normal",
      body: la(C) ? se : De,
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: q,
      onSubmit: Ot(lm, C, R, q)
    });
  }, cc = (C) => {
    const R = yi(ca(C));
    return R.length > 0 ? We.some({
      name: "class",
      type: "listbox",
      label: "Class",
      items: R
    }) : We.none();
  }, Kr = [
    {
      type: "listbox",
      name: "type",
      label: "Row type",
      items: [
        {
          text: "Header",
          value: "header"
        },
        {
          text: "Body",
          value: "body"
        },
        {
          text: "Footer",
          value: "footer"
        }
      ]
    },
    {
      type: "listbox",
      name: "align",
      label: "Alignment",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Left",
          value: "left"
        },
        {
          text: "Center",
          value: "center"
        },
        {
          text: "Right",
          value: "right"
        }
      ]
    },
    {
      label: "Height",
      name: "height",
      type: "input"
    }
  ], Sf = (C) => Kr.concat(cc(C).toArray()), Io = (C, R, q) => {
    q("class") && C.setAttrib("class", R.class), q("height") && C.setStyle("height", _r(R.height));
  }, pn = (C, R, q) => {
    q("backgroundcolor") && C.setStyle("background-color", R.backgroundcolor), q("bordercolor") && C.setStyle("border-color", R.bordercolor), q("borderstyle") && C.setStyle("border-style", R.borderstyle);
  }, Kd = (C, R, q, se) => {
    const rt = R.length === 1 ? Se : se;
    K(R, (Pt) => {
      const on = da.normal(C, Pt);
      Io(on, q, rt), od(C) && pn(on, q, rt), se("align") && _c(C, Pt, q.align);
    });
  }, zp = (C, R) => {
    C.execCommand("mceTableRowType", !1, {
      type: R.type,
      no_events: !0
    });
  }, Ef = (C, R, q, se) => {
    const De = M(se, (rt, Pt) => q[Pt] !== rt);
    if (mn(De) > 0) {
      const rt = dt(De, "type"), Pt = rt ? mn(De) > 1 : !0;
      Pt && Kd(C, R, se, Ot(dt, De)), rt && zp(C, se), oi(ro.fromDom(R[0])).each((on) => Eo(C, on.dom, {
        structure: rt,
        style: Pt
      }));
    }
  }, uc = (C, R, q, se) => {
    const De = se.getData();
    se.close(), C.undoManager.transact(() => {
      Ef(C, R, q, De), C.focus();
    });
  }, Bo = (C) => {
    const R = el(Dr(C), st.selected);
    if (R.length === 0)
      return;
    const q = Mo(R, (Pt) => Cu(C, Pt.dom, od(C))), se = Vc(q), De = {
      type: "tabpanel",
      tabs: [
        {
          title: "General",
          name: "general",
          items: Sf(C)
        },
        Ac(C, "row")
      ]
    }, rt = {
      type: "panel",
      items: [{
        type: "grid",
        columns: 2,
        items: Sf(C)
      }]
    };
    C.windowManager.open({
      title: "Row Properties",
      size: "normal",
      body: od(C) ? De : rt,
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: se,
      onSubmit: Ot(uc, C, Mo(R, (Pt) => Pt.dom), se)
    });
  }, $a = (C, R, q) => {
    const se = q ? [
      {
        type: "input",
        name: "cols",
        label: "Cols",
        inputMode: "numeric"
      },
      {
        type: "input",
        name: "rows",
        label: "Rows",
        inputMode: "numeric"
      }
    ] : [], De = [
      {
        type: "input",
        name: "width",
        label: "Width"
      },
      {
        type: "input",
        name: "height",
        label: "Height"
      }
    ], rt = sm(C) ? [
      {
        type: "input",
        name: "cellspacing",
        label: "Cell spacing",
        inputMode: "numeric"
      },
      {
        type: "input",
        name: "cellpadding",
        label: "Cell padding",
        inputMode: "numeric"
      },
      {
        type: "input",
        name: "border",
        label: "Border width"
      },
      {
        type: "label",
        label: "Caption",
        items: [{
          type: "checkbox",
          name: "caption",
          label: "Show caption"
        }]
      }
    ] : [], Pt = [{
      type: "listbox",
      name: "align",
      label: "Alignment",
      items: [
        {
          text: "None",
          value: ""
        },
        {
          text: "Left",
          value: "left"
        },
        {
          text: "Center",
          value: "center"
        },
        {
          text: "Right",
          value: "right"
        }
      ]
    }], on = R.length > 0 ? [{
      type: "listbox",
      name: "class",
      label: "Class",
      items: R
    }] : [];
    return se.concat(De).concat(rt).concat(Pt).concat(on);
  }, $m = (C, R, q, se) => {
    if (R.tagName === "TD" || R.tagName === "TH")
      he(q) && yt(se) ? C.setStyle(R, q, se) : C.setStyles(R, q);
    else if (R.children)
      for (let De = 0; De < R.children.length; De++)
        $m(C, R.children[De], q, se);
  }, ft = (C, R, q, se) => {
    const De = C.dom, rt = {}, Pt = {}, on = Cc(C), Tn = os(C);
    if (Ze(q.class) || (rt.class = q.class), Pt.height = _r(q.height), on ? Pt.width = _r(q.width) : De.getAttrib(R, "width") && (rt.width = nm(q.width)), on ? (Pt["border-width"] = _r(q.border), Pt["border-spacing"] = _r(q.cellspacing)) : (rt.border = q.border, rt.cellpadding = q.cellpadding, rt.cellspacing = q.cellspacing), on && R.children) {
      const uo = {};
      if (se.border && (uo["border-width"] = _r(q.border)), se.cellpadding && (uo.padding = _r(q.cellpadding)), Tn && se.bordercolor && (uo["border-color"] = q.bordercolor), !jr(uo))
        for (let ks = 0; ks < R.children.length; ks++)
          $m(De, R.children[ks], uo);
    }
    if (Tn) {
      const uo = q;
      Pt["background-color"] = uo.backgroundcolor, Pt["border-color"] = uo.bordercolor, Pt["border-style"] = uo.borderstyle;
    }
    De.setStyles(R, {
      ...wu(C),
      ...Pt
    }), De.setAttribs(R, {
      ...ri(C),
      ...rt
    });
  }, dc = (C, R, q, se) => {
    const De = C.dom, rt = se.getData(), Pt = M(rt, (on, Tn) => q[Tn] !== on);
    se.close(), rt.class === "" && delete rt.class, C.undoManager.transact(() => {
      if (!R) {
        const on = fl(rt.cols).getOr(1), Tn = fl(rt.rows).getOr(1);
        C.execCommand("mceInsertTable", !1, {
          rows: Tn,
          columns: on
        }), R = Pa(Dr(C), sa(C)).bind((uo) => oi(uo, sa(C))).map((uo) => uo.dom).getOrDie();
      }
      if (mn(Pt) > 0) {
        const on = {
          border: dt(Pt, "border"),
          bordercolor: dt(Pt, "bordercolor"),
          cellpadding: dt(Pt, "cellpadding")
        };
        ft(C, R, rt, on);
        const Tn = De.select("caption", R)[0];
        (Tn && !rt.caption || !Tn && rt.caption) && C.execCommand("mceTableToggleCaption"), _c(C, R, rt.align);
      }
      if (C.focus(), C.addVisual(), mn(Pt) > 0) {
        const on = dt(Pt, "caption"), Tn = on ? mn(Pt) > 1 : !0;
        Eo(C, R, {
          structure: on,
          style: Tn
        });
      }
    });
  }, ld = (C, R) => {
    const q = C.dom;
    let se, De = ug(C, os(C));
    R ? (De.cols = "1", De.rows = "1", os(C) && (De.borderstyle = "", De.bordercolor = "", De.backgroundcolor = "")) : (se = q.getParent(C.selection.getStart(), "table", C.getBody()), se ? De = sh(C, se, os(C)) : os(C) && (De.borderstyle = "", De.bordercolor = "", De.backgroundcolor = ""));
    const rt = yi(rd(C));
    rt.length > 0 && De.class && (De.class = De.class.replace(/\s*mce\-item\-table\s*/g, ""));
    const Pt = {
      type: "grid",
      columns: 2,
      items: $a(C, rt, R)
    }, on = () => ({
      type: "panel",
      items: [Pt]
    }), Tn = () => ({
      type: "tabpanel",
      tabs: [
        {
          title: "General",
          name: "general",
          items: [Pt]
        },
        Ac(C, "table")
      ]
    }), uo = os(C) ? Tn() : on();
    C.windowManager.open({
      title: "Table Properties",
      size: "normal",
      body: uo,
      onSubmit: Ot(dc, C, se, De),
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: !0
        }
      ],
      initialData: De
    });
  }, cd = (C) => {
    const R = (q) => {
      ul(Dr(C)) && q();
    };
    jn({
      mceTableProps: Ot(ld, C, !1),
      mceTableRowProps: Ot(Bo, C),
      mceTableCellProps: Ot(Rl, C),
      mceInsertTableDialog: Ot(ld, C, !0)
    }, (q, se) => C.addCommand(se, () => R(q)));
  }, Yd = (C, R) => Nd(C, R).isSome(), Su = gt, jl = (C) => {
    const R = (se, De) => Rr(se, De).exists((rt) => parseInt(rt, 10) > 1), q = (se) => R(se, "rowspan") || R(se, "colspan");
    return C.length > 0 && kt(C, q) ? We.some(C) : We.none();
  }, Xd = (C, R, q) => R.length <= 1 ? We.none() : ic(C, q.firstSelectedSelector, q.lastSelectedSelector).map((se) => ({
    bounds: se,
    cells: R
  })), ss = (C) => ({
    element: C,
    mergable: We.none(),
    unmergable: We.none(),
    selection: [C]
  }), ud = (C, R, q) => ({
    element: q,
    mergable: Xd(R, C, st),
    unmergable: jl(C),
    selection: Su(C)
  }), eb = (C) => {
    const R = fs(We.none()), q = fs([]);
    let se = We.none();
    const De = oc("caption"), rt = (Oo) => se.forall((Sr) => !Sr[Oo]), Pt = () => Is(Dr(C), sa(C)), on = () => Is(El(C), sa(C)), Tn = () => Pt().bind((Oo) => js(gi(oi(Oo), on().bind(oi), (Sr, xi) => Nt(Sr, xi) ? De(Oo) ? We.some(ss(Oo)) : We.some(ud(Ia(C), Sr, Oo)) : We.none()))), uo = (Oo) => oi(Oo.element).map((xi) => {
      const vr = eu.fromTable(xi), fg = yr(vr, Oo).getOr([]), $s = nc(fg, (_s, nl) => (nl.isLocked && (_s.onAny = !0, nl.column === 0 ? _s.onFirst = !0 : nl.column + nl.colspan >= vr.grid.columns && (_s.onLast = !0)), _s), {
        onAny: !1,
        onFirst: !1,
        onLast: !1
      });
      return {
        mergeable: _u(vr, Oo).isSome(),
        unmergeable: Ni(vr, Oo).isSome(),
        locked: $s
      };
    }), ks = () => {
      R.set(zt(Tn)()), se = R.get().bind(uo), K(q.get(), Ee);
    }, _o = (Oo) => (Oo(), q.set(q.get().concat([Oo])), () => {
      q.set(er(q.get(), (Sr) => Sr !== Oo));
    }), fr = (Oo, Sr) => _o(() => R.get().fold(() => {
      Oo.setEnabled(!1);
    }, (xi) => {
      Oo.setEnabled(!Sr(xi) && C.selection.isEditable());
    })), as = (Oo, Sr, xi) => _o(() => R.get().fold(() => {
      Oo.setEnabled(!1), Oo.setActive(!1);
    }, (vr) => {
      Oo.setEnabled(!Sr(vr) && C.selection.isEditable()), Oo.setActive(xi(vr));
    })), Ha = (Oo) => se.exists((Sr) => Sr.locked[Oo]), Xa = (Oo) => fr(Oo, (Sr) => !1), su = (Oo) => fr(Oo, (Sr) => De(Sr.element)), Um = (Oo) => (Sr) => fr(Sr, (xi) => De(xi.element) || Ha(Oo)), Of = (Oo) => (Sr) => fr(Sr, (xi) => De(xi.element) || Oo().isNone()), or = (Oo, Sr) => (xi) => fr(xi, (vr) => De(vr.element) || Oo().isNone() || Ha(Sr)), jm = (Oo) => fr(Oo, (Sr) => rt("mergeable")), dd = (Oo) => fr(Oo, (Sr) => rt("unmergeable")), fd = (Oo) => as(Oo, wt, (Sr) => oi(Sr.element, sa(C)).exists((vr) => Yd(vr, "caption"))), Ap = (Oo, Sr) => (xi) => as(xi, (vr) => De(vr.element), () => C.queryCommandValue(Oo) === Sr), dg = Ap("mceTableRowType", "header"), md = Ap("mceTableColType", "th");
    return C.on("NodeChange ExecCommand TableSelectorChange", ks), {
      onSetupTable: Xa,
      onSetupCellOrRow: su,
      onSetupColumn: Um,
      onSetupPasteable: Of,
      onSetupPasteableColumn: or,
      onSetupMergeable: jm,
      onSetupUnmergeable: dd,
      resetTargets: ks,
      onSetupTableWithCaption: fd,
      onSetupTableRowHeaders: dg,
      onSetupTableColumnHeaders: md,
      targets: R.get
    };
  };
  var hl = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
  const Hm = "x-tinymce/dom-table-", tl = Hm + "rows", cm = Hm + "columns", Eu = (C) => {
    var R;
    const q = (R = hl.read()) !== null && R !== void 0 ? R : [];
    return Ko(q, (se) => We.from(se.getType(C)));
  }, Jd = () => Eu(tl), Tu = () => Eu(cm), Tf = (C) => (R) => {
    const q = () => {
      R.setEnabled(C.selection.isEditable());
    };
    return C.on("NodeChange", q), q(), () => {
      C.off("NodeChange", q);
    };
  }, um = (C, R) => {
    C.ui.registry.addMenuButton("table", {
      tooltip: "Table",
      icon: "table",
      onSetup: Tf(C),
      fetch: (on) => on("inserttable | cell row column | advtablesort | tableprops deletetable")
    });
    const q = (on) => () => C.execCommand(on), se = (on, Tn) => {
      C.queryCommandSupported(Tn.command) && C.ui.registry.addButton(on, {
        ...Tn,
        onAction: jt(Tn.onAction) ? Tn.onAction : q(Tn.command)
      });
    }, De = (on, Tn) => {
      C.queryCommandSupported(Tn.command) && C.ui.registry.addToggleButton(on, {
        ...Tn,
        onAction: jt(Tn.onAction) ? Tn.onAction : q(Tn.command)
      });
    };
    se("tableprops", {
      tooltip: "Table properties",
      command: "mceTableProps",
      icon: "table",
      onSetup: R.onSetupTable
    }), se("tabledelete", {
      tooltip: "Delete table",
      command: "mceTableDelete",
      icon: "table-delete-table",
      onSetup: R.onSetupTable
    }), se("tablecellprops", {
      tooltip: "Cell properties",
      command: "mceTableCellProps",
      icon: "table-cell-properties",
      onSetup: R.onSetupCellOrRow
    }), se("tablemergecells", {
      tooltip: "Merge cells",
      command: "mceTableMergeCells",
      icon: "table-merge-cells",
      onSetup: R.onSetupMergeable
    }), se("tablesplitcells", {
      tooltip: "Split cell",
      command: "mceTableSplitCells",
      icon: "table-split-cells",
      onSetup: R.onSetupUnmergeable
    }), se("tableinsertrowbefore", {
      tooltip: "Insert row before",
      command: "mceTableInsertRowBefore",
      icon: "table-insert-row-above",
      onSetup: R.onSetupCellOrRow
    }), se("tableinsertrowafter", {
      tooltip: "Insert row after",
      command: "mceTableInsertRowAfter",
      icon: "table-insert-row-after",
      onSetup: R.onSetupCellOrRow
    }), se("tabledeleterow", {
      tooltip: "Delete row",
      command: "mceTableDeleteRow",
      icon: "table-delete-row",
      onSetup: R.onSetupCellOrRow
    }), se("tablerowprops", {
      tooltip: "Row properties",
      command: "mceTableRowProps",
      icon: "table-row-properties",
      onSetup: R.onSetupCellOrRow
    }), se("tableinsertcolbefore", {
      tooltip: "Insert column before",
      command: "mceTableInsertColBefore",
      icon: "table-insert-column-before",
      onSetup: R.onSetupColumn("onFirst")
    }), se("tableinsertcolafter", {
      tooltip: "Insert column after",
      command: "mceTableInsertColAfter",
      icon: "table-insert-column-after",
      onSetup: R.onSetupColumn("onLast")
    }), se("tabledeletecol", {
      tooltip: "Delete column",
      command: "mceTableDeleteCol",
      icon: "table-delete-column",
      onSetup: R.onSetupColumn("onAny")
    }), se("tablecutrow", {
      tooltip: "Cut row",
      command: "mceTableCutRow",
      icon: "cut-row",
      onSetup: R.onSetupCellOrRow
    }), se("tablecopyrow", {
      tooltip: "Copy row",
      command: "mceTableCopyRow",
      icon: "duplicate-row",
      onSetup: R.onSetupCellOrRow
    }), se("tablepasterowbefore", {
      tooltip: "Paste row before",
      command: "mceTablePasteRowBefore",
      icon: "paste-row-before",
      onSetup: R.onSetupPasteable(Jd)
    }), se("tablepasterowafter", {
      tooltip: "Paste row after",
      command: "mceTablePasteRowAfter",
      icon: "paste-row-after",
      onSetup: R.onSetupPasteable(Jd)
    }), se("tablecutcol", {
      tooltip: "Cut column",
      command: "mceTableCutCol",
      icon: "cut-column",
      onSetup: R.onSetupColumn("onAny")
    }), se("tablecopycol", {
      tooltip: "Copy column",
      command: "mceTableCopyCol",
      icon: "duplicate-column",
      onSetup: R.onSetupColumn("onAny")
    }), se("tablepastecolbefore", {
      tooltip: "Paste column before",
      command: "mceTablePasteColBefore",
      icon: "paste-column-before",
      onSetup: R.onSetupPasteableColumn(Tu, "onFirst")
    }), se("tablepastecolafter", {
      tooltip: "Paste column after",
      command: "mceTablePasteColAfter",
      icon: "paste-column-after",
      onSetup: R.onSetupPasteableColumn(Tu, "onLast")
    }), se("tableinsertdialog", {
      tooltip: "Insert table",
      command: "mceInsertTableDialog",
      icon: "table",
      onSetup: Tf(C)
    });
    const rt = zc(rd(C));
    rt.length !== 0 && C.queryCommandSupported("mceTableToggleClass") && C.ui.registry.addMenuButton("tableclass", {
      icon: "table-classes",
      tooltip: "Table styles",
      fetch: lc(C, rt, "tableclass", (on) => C.execCommand("mceTableToggleClass", !1, on)),
      onSetup: R.onSetupTable
    });
    const Pt = zc(To(C));
    Pt.length !== 0 && C.queryCommandSupported("mceTableCellToggleClass") && C.ui.registry.addMenuButton("tablecellclass", {
      icon: "table-cell-classes",
      tooltip: "Cell styles",
      fetch: lc(C, Pt, "tablecellclass", (on) => C.execCommand("mceTableCellToggleClass", !1, on)),
      onSetup: R.onSetupCellOrRow
    }), C.queryCommandSupported("mceTableApplyCellStyle") && (C.ui.registry.addMenuButton("tablecellvalign", {
      icon: "vertical-align",
      tooltip: "Vertical align",
      fetch: lc(C, jd, "tablecellverticalalign", wa(C, "vertical-align")),
      onSetup: R.onSetupCellOrRow
    }), C.ui.registry.addMenuButton("tablecellborderwidth", {
      icon: "border-width",
      tooltip: "Border width",
      fetch: lc(C, Ws(C), "tablecellborderwidth", wa(C, "border-width")),
      onSetup: R.onSetupCellOrRow
    }), C.ui.registry.addMenuButton("tablecellborderstyle", {
      icon: "border-style",
      tooltip: "Border style",
      fetch: lc(C, va(C), "tablecellborderstyle", wa(C, "border-style")),
      onSetup: R.onSetupCellOrRow
    }), C.ui.registry.addMenuButton("tablecellbackgroundcolor", {
      icon: "cell-background-color",
      tooltip: "Background color",
      fetch: (on) => on(de(C, Vd(C), "background-color")),
      onSetup: R.onSetupCellOrRow
    }), C.ui.registry.addMenuButton("tablecellbordercolor", {
      icon: "cell-border-color",
      tooltip: "Border color",
      fetch: (on) => on(de(C, Fc(C), "border-color")),
      onSetup: R.onSetupCellOrRow
    })), De("tablecaption", {
      tooltip: "Table caption",
      icon: "table-caption",
      command: "mceTableToggleCaption",
      onSetup: R.onSetupTableWithCaption
    }), De("tablerowheader", {
      tooltip: "Row header",
      icon: "table-top-header",
      command: "mceTableRowType",
      onAction: Hc(C),
      onSetup: R.onSetupTableRowHeaders
    }), De("tablecolheader", {
      tooltip: "Column header",
      icon: "table-left-header",
      command: "mceTableColType",
      onAction: Oc(C),
      onSetup: R.onSetupTableColumnHeaders
    });
  }, hn = (C) => {
    const R = (se) => C.dom.is(se, "table") && C.getBody().contains(se) && C.dom.isEditable(se.parentNode), q = Oi(C);
    q.length > 0 && C.ui.registry.addContextToolbar("table", {
      predicate: R,
      items: q,
      scope: "node",
      position: "node"
    });
  }, Op = (C) => (R) => {
    const q = () => {
      R.setEnabled(C.selection.isEditable());
    };
    return C.on("NodeChange", q), q(), () => {
      C.off("NodeChange", q);
    };
  }, Vm = (C, R) => {
    const q = (_o) => () => C.execCommand(_o), se = (_o, fr) => C.queryCommandSupported(fr.command) ? (C.ui.registry.addMenuItem(_o, {
      ...fr,
      onAction: jt(fr.onAction) ? fr.onAction : q(fr.command)
    }), !0) : !1, De = (_o, fr) => {
      C.queryCommandSupported(fr.command) && C.ui.registry.addToggleMenuItem(_o, {
        ...fr,
        onAction: jt(fr.onAction) ? fr.onAction : q(fr.command)
      });
    }, rt = (_o) => {
      C.execCommand("mceInsertTable", !1, {
        rows: _o.numRows,
        columns: _o.numColumns
      });
    }, Pt = [
      se("tableinsertrowbefore", {
        text: "Insert row before",
        icon: "table-insert-row-above",
        command: "mceTableInsertRowBefore",
        onSetup: R.onSetupCellOrRow
      }),
      se("tableinsertrowafter", {
        text: "Insert row after",
        icon: "table-insert-row-after",
        command: "mceTableInsertRowAfter",
        onSetup: R.onSetupCellOrRow
      }),
      se("tabledeleterow", {
        text: "Delete row",
        icon: "table-delete-row",
        command: "mceTableDeleteRow",
        onSetup: R.onSetupCellOrRow
      }),
      se("tablerowprops", {
        text: "Row properties",
        icon: "table-row-properties",
        command: "mceTableRowProps",
        onSetup: R.onSetupCellOrRow
      }),
      se("tablecutrow", {
        text: "Cut row",
        icon: "cut-row",
        command: "mceTableCutRow",
        onSetup: R.onSetupCellOrRow
      }),
      se("tablecopyrow", {
        text: "Copy row",
        icon: "duplicate-row",
        command: "mceTableCopyRow",
        onSetup: R.onSetupCellOrRow
      }),
      se("tablepasterowbefore", {
        text: "Paste row before",
        icon: "paste-row-before",
        command: "mceTablePasteRowBefore",
        onSetup: R.onSetupPasteable(Jd)
      }),
      se("tablepasterowafter", {
        text: "Paste row after",
        icon: "paste-row-after",
        command: "mceTablePasteRowAfter",
        onSetup: R.onSetupPasteable(Jd)
      })
    ], on = [
      se("tableinsertcolumnbefore", {
        text: "Insert column before",
        icon: "table-insert-column-before",
        command: "mceTableInsertColBefore",
        onSetup: R.onSetupColumn("onFirst")
      }),
      se("tableinsertcolumnafter", {
        text: "Insert column after",
        icon: "table-insert-column-after",
        command: "mceTableInsertColAfter",
        onSetup: R.onSetupColumn("onLast")
      }),
      se("tabledeletecolumn", {
        text: "Delete column",
        icon: "table-delete-column",
        command: "mceTableDeleteCol",
        onSetup: R.onSetupColumn("onAny")
      }),
      se("tablecutcolumn", {
        text: "Cut column",
        icon: "cut-column",
        command: "mceTableCutCol",
        onSetup: R.onSetupColumn("onAny")
      }),
      se("tablecopycolumn", {
        text: "Copy column",
        icon: "duplicate-column",
        command: "mceTableCopyCol",
        onSetup: R.onSetupColumn("onAny")
      }),
      se("tablepastecolumnbefore", {
        text: "Paste column before",
        icon: "paste-column-before",
        command: "mceTablePasteColBefore",
        onSetup: R.onSetupPasteableColumn(Tu, "onFirst")
      }),
      se("tablepastecolumnafter", {
        text: "Paste column after",
        icon: "paste-column-after",
        command: "mceTablePasteColAfter",
        onSetup: R.onSetupPasteableColumn(Tu, "onLast")
      })
    ], Tn = [
      se("tablecellprops", {
        text: "Cell properties",
        icon: "table-cell-properties",
        command: "mceTableCellProps",
        onSetup: R.onSetupCellOrRow
      }),
      se("tablemergecells", {
        text: "Merge cells",
        icon: "table-merge-cells",
        command: "mceTableMergeCells",
        onSetup: R.onSetupMergeable
      }),
      se("tablesplitcells", {
        text: "Split cell",
        icon: "table-split-cells",
        command: "mceTableSplitCells",
        onSetup: R.onSetupUnmergeable
      })
    ];
    vu(C) ? C.ui.registry.addNestedMenuItem("inserttable", {
      text: "Table",
      icon: "table",
      getSubmenuItems: () => [{
        type: "fancymenuitem",
        fancytype: "inserttable",
        onAction: rt
      }],
      onSetup: Op(C)
    }) : C.ui.registry.addMenuItem("inserttable", {
      text: "Table",
      icon: "table",
      onAction: q("mceInsertTableDialog"),
      onSetup: Op(C)
    }), C.ui.registry.addMenuItem("inserttabledialog", {
      text: "Insert table",
      icon: "table",
      onAction: q("mceInsertTableDialog"),
      onSetup: Op(C)
    }), se("tableprops", {
      text: "Table properties",
      onSetup: R.onSetupTable,
      command: "mceTableProps"
    }), se("deletetable", {
      text: "Delete table",
      icon: "table-delete-table",
      onSetup: R.onSetupTable,
      command: "mceTableDelete"
    }), tn(Pt, !0) && C.ui.registry.addNestedMenuItem("row", {
      type: "nestedmenuitem",
      text: "Row",
      getSubmenuItems: Gt("tableinsertrowbefore tableinsertrowafter tabledeleterow tablerowprops | tablecutrow tablecopyrow tablepasterowbefore tablepasterowafter")
    }), tn(on, !0) && C.ui.registry.addNestedMenuItem("column", {
      type: "nestedmenuitem",
      text: "Column",
      getSubmenuItems: Gt("tableinsertcolumnbefore tableinsertcolumnafter tabledeletecolumn | tablecutcolumn tablecopycolumn tablepastecolumnbefore tablepastecolumnafter")
    }), tn(Tn, !0) && C.ui.registry.addNestedMenuItem("cell", {
      type: "nestedmenuitem",
      text: "Cell",
      getSubmenuItems: Gt("tablecellprops tablemergecells tablesplitcells")
    }), C.ui.registry.addContextMenu("table", {
      update: () => (R.resetTargets(), R.targets().fold(Gt(""), (_o) => Zo(_o.element) === "caption" ? "tableprops deletetable" : "cell row column | advtablesort | tableprops deletetable"))
    });
    const uo = zc(rd(C));
    uo.length !== 0 && C.queryCommandSupported("mceTableToggleClass") && C.ui.registry.addNestedMenuItem("tableclass", {
      icon: "table-classes",
      text: "Table styles",
      getSubmenuItems: () => dr(C, uo, "tableclass", (_o) => C.execCommand("mceTableToggleClass", !1, _o)),
      onSetup: R.onSetupTable
    });
    const ks = zc(To(C));
    ks.length !== 0 && C.queryCommandSupported("mceTableCellToggleClass") && C.ui.registry.addNestedMenuItem("tablecellclass", {
      icon: "table-cell-classes",
      text: "Cell styles",
      getSubmenuItems: () => dr(C, ks, "tablecellclass", (_o) => C.execCommand("mceTableCellToggleClass", !1, _o)),
      onSetup: R.onSetupCellOrRow
    }), C.queryCommandSupported("mceTableApplyCellStyle") && (C.ui.registry.addNestedMenuItem("tablecellvalign", {
      icon: "vertical-align",
      text: "Vertical align",
      getSubmenuItems: () => dr(C, jd, "tablecellverticalalign", wa(C, "vertical-align")),
      onSetup: R.onSetupCellOrRow
    }), C.ui.registry.addNestedMenuItem("tablecellborderwidth", {
      icon: "border-width",
      text: "Border width",
      getSubmenuItems: () => dr(C, Ws(C), "tablecellborderwidth", wa(C, "border-width")),
      onSetup: R.onSetupCellOrRow
    }), C.ui.registry.addNestedMenuItem("tablecellborderstyle", {
      icon: "border-style",
      text: "Border style",
      getSubmenuItems: () => dr(C, va(C), "tablecellborderstyle", wa(C, "border-style")),
      onSetup: R.onSetupCellOrRow
    }), C.ui.registry.addNestedMenuItem("tablecellbackgroundcolor", {
      icon: "cell-background-color",
      text: "Background color",
      getSubmenuItems: () => de(C, Vd(C), "background-color"),
      onSetup: R.onSetupCellOrRow
    }), C.ui.registry.addNestedMenuItem("tablecellbordercolor", {
      icon: "cell-border-color",
      text: "Border color",
      getSubmenuItems: () => de(C, Fc(C), "border-color"),
      onSetup: R.onSetupCellOrRow
    })), De("tablecaption", {
      icon: "table-caption",
      text: "Table caption",
      command: "mceTableToggleCaption",
      onSetup: R.onSetupTableWithCaption
    }), De("tablerowheader", {
      text: "Row header",
      icon: "table-top-header",
      command: "mceTableRowType",
      onAction: Hc(C),
      onSetup: R.onSetupTableRowHeaders
    }), De("tablecolheader", {
      text: "Column header",
      icon: "table-left-header",
      command: "mceTableColType",
      onAction: Oc(C),
      onSetup: R.onSetupTableRowHeaders
    });
  }, zf = (C) => {
    const R = eb(C);
    xs(C), cd(C), Vm(C, R), um(C, R), hn(C);
  };
  var tb = () => {
    v.add("table", zf);
  };
  tb();
})();
var mK = [
  "onActivate",
  "onAddUndo",
  "onBeforeAddUndo",
  "onBeforeExecCommand",
  "onBeforeGetContent",
  "onBeforeRenderUI",
  "onBeforeSetContent",
  "onBeforePaste",
  "onBlur",
  "onChange",
  "onClearUndos",
  "onClick",
  "onContextMenu",
  "onCopy",
  "onCut",
  "onDblclick",
  "onDeactivate",
  "onDirty",
  "onDrag",
  "onDragDrop",
  "onDragEnd",
  "onDragGesture",
  "onDragOver",
  "onDrop",
  "onExecCommand",
  "onFocus",
  "onFocusIn",
  "onFocusOut",
  "onGetContent",
  "onHide",
  "onInit",
  "onKeyDown",
  "onKeyPress",
  "onKeyUp",
  "onLoadContent",
  "onMouseDown",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp",
  "onNodeChange",
  "onObjectResizeStart",
  "onObjectResized",
  "onObjectSelected",
  "onPaste",
  "onPostProcess",
  "onPostRender",
  "onPreProcess",
  "onProgressState",
  "onRedo",
  "onRemove",
  "onReset",
  "onSaveContent",
  "onSelectionChange",
  "onSetAttrib",
  "onSetContent",
  "onShow",
  "onSubmit",
  "onUndo",
  "onVisualAid"
], pK = function(v) {
  return mK.map(function(L) {
    return L.toLowerCase();
  }).indexOf(v.toLowerCase()) !== -1;
}, gK = function(v, L, N) {
  Object.keys(L).filter(pK).forEach(function(W) {
    var ue = L[W];
    typeof ue == "function" && (W === "onInit" ? ue(v, N) : N.on(W.substring(2), function(ce) {
      return ue(ce, N);
    }));
  });
}, hK = function(v, L, N, W) {
  var ue = v.modelEvents ? v.modelEvents : null, ce = Array.isArray(ue) ? ue.join(" ") : ue;
  Od(W, function(he, pe) {
    N && typeof he == "string" && he !== pe && he !== N.getContent({ format: v.outputFormat }) && N.setContent(he);
  }), N.on(ce || "change input undo redo", function() {
    L.emit("update:modelValue", N.getContent({ format: v.outputFormat }));
  });
}, bK = function(v, L, N, W, ue, ce) {
  W.setContent(ce()), N.attrs["onUpdate:modelValue"] && hK(L, N, W, ue), gK(v, N.attrs, W);
}, FF = 0, YF = function(v) {
  var L = Date.now(), N = Math.floor(Math.random() * 1e9);
  return FF++, v + "_" + N + FF + String(L);
}, yK = function(v) {
  return v !== null && v.tagName.toLowerCase() === "textarea";
}, $F = function(v) {
  return typeof v > "u" || v === "" ? [] : Array.isArray(v) ? v : v.split(" ");
}, vK = function(v, L) {
  return $F(v).concat($F(L));
}, xK = function(v) {
  return v == null;
}, HF = function() {
  return {
    listeners: [],
    scriptId: YF("tiny-script"),
    scriptLoaded: !1
  };
}, wK = function() {
  var v = HF(), L = function(ue, ce, he, pe) {
    var Me = ce.createElement("script");
    Me.referrerPolicy = "origin", Me.type = "application/javascript", Me.id = ue, Me.src = he;
    var Ze = function() {
      Me.removeEventListener("load", Ze), pe();
    };
    Me.addEventListener("load", Ze), ce.head && ce.head.appendChild(Me);
  }, N = function(ue, ce, he) {
    v.scriptLoaded ? he() : (v.listeners.push(he), ue.getElementById(v.scriptId) || L(v.scriptId, ue, ce, function() {
      v.listeners.forEach(function(pe) {
        return pe();
      }), v.scriptLoaded = !0;
    }));
  }, W = function() {
    v = HF();
  };
  return {
    load: N,
    reinitialize: W
  };
}, kK = wK(), _K = function() {
  return typeof window < "u" ? window : global;
}, yw = function() {
  var v = _K();
  return v && v.tinymce ? v.tinymce : null;
}, CK = {
  apiKey: String,
  cloudChannel: String,
  id: String,
  init: Object,
  initialValue: String,
  inline: Boolean,
  modelEvents: [String, Array],
  plugins: [String, Array],
  tagName: String,
  toolbar: [String, Array],
  modelValue: String,
  disabled: Boolean,
  tinymceScriptSrc: String,
  outputFormat: {
    type: String,
    validator: function(v) {
      return v === "html" || v === "text";
    }
  }
}, zy = globalThis && globalThis.__assign || function() {
  return zy = Object.assign || function(v) {
    for (var L, N = 1, W = arguments.length; N < W; N++) {
      L = arguments[N];
      for (var ue in L)
        Object.prototype.hasOwnProperty.call(L, ue) && (v[ue] = L[ue]);
    }
    return v;
  }, zy.apply(this, arguments);
}, SK = function(v, L, N, W) {
  return v(W || "div", {
    id: L,
    ref: N
  });
}, EK = function(v, L, N) {
  return v("textarea", {
    id: L,
    visibility: "hidden",
    ref: N
  });
}, g8 = { selector: void 0, target: void 0 }, TK = em({
  props: CK,
  setup: function(v, L) {
    var N = v.init ? zy(zy({}, v.init), g8) : zy({}, g8), W = Bq(v), ue = W.disabled, ce = W.modelValue, he = W.tagName, pe = Jr(null), Me = null, Ze = v.id || YF("tiny-vue"), Ye = v.init && v.init.inline || v.inline, yt = !!L.attrs["onUpdate:modelValue"], jt = !0, it = v.initialValue ? v.initialValue : "", Rt = "", en = function(an) {
      return yt ? function() {
        return ce != null && ce.value ? ce.value : "";
      } : function() {
        return an ? it : Rt;
      };
    }, Gt = function() {
      var an = en(jt), Ot = zy(zy({}, N), { readonly: v.disabled, target: pe.value, plugins: vK(N.plugins, v.plugins), toolbar: v.toolbar || N.toolbar, inline: Ye, setup: function(Ee) {
        Me = Ee, Ee.on("init", function(wt) {
          return bK(wt, v, L, Ee, ce, an);
        }), typeof N.setup == "function" && N.setup(Ee);
      } });
      yK(pe.value) && (pe.value.style.visibility = ""), yw().init(Ot), jt = !1;
    };
    Od(ue, function(an) {
      var Ot;
      Me !== null && (typeof ((Ot = Me.mode) === null || Ot === void 0 ? void 0 : Ot.set) == "function" ? Me.mode.set(an ? "readonly" : "design") : Me.setMode(an ? "readonly" : "design"));
    }), Od(he, function(an) {
      var Ot;
      yt || (Rt = Me.getContent()), (Ot = yw()) === null || Ot === void 0 || Ot.remove(Me), I5(function() {
        return Gt();
      });
    }), Ad(function() {
      if (yw() !== null)
        Gt();
      else if (pe.value && pe.value.ownerDocument) {
        var an = v.cloudChannel ? v.cloudChannel : "6", Ot = v.apiKey ? v.apiKey : "no-api-key", Ee = xK(v.tinymceScriptSrc) ? "https://cdn.tiny.cloud/1/".concat(Ot, "/tinymce/").concat(an, "/tinymce.min.js") : v.tinymceScriptSrc;
        kK.load(pe.value.ownerDocument, Ee, Gt);
      }
    }), Lq(function() {
      yw() !== null && yw().remove(Me);
    }), Ye || (Pq(function() {
      jt || Gt();
    }), Iq(function() {
      var an;
      yt || (Rt = Me.getContent()), (an = yw()) === null || an === void 0 || an.remove(Me);
    }));
    var gt = function(an) {
      var Ot;
      Rt = Me.getContent(), (Ot = yw()) === null || Ot === void 0 || Ot.remove(Me), N = zy(zy(zy({}, N), an), g8), I5(function() {
        return Gt();
      });
    };
    return L.expose({
      rerender: gt,
      getEditor: function() {
        return Me;
      }
    }), function() {
      return Ye ? SK(Xu, Ze, pe, v.tagName) : EK(Xu, Ze, pe);
    };
  }
});
const zK = {
  __name: "Wysiwyg",
  props: {
    plugins: {
      default: "lists link table code help wordcount"
    },
    toolbar: {
      default: "undo redo | styles | bold italic numlist bullist | link"
    },
    menubar: {
      default: !1
    },
    height: {
      default: 500
    }
  },
  setup(v) {
    return (L, N) => (kn(), Ju(ng(TK), {
      "api-key": "no-api-key",
      init: {
        plugins: v.plugins,
        toolbar: v.toolbar,
        menubar: v.menubar,
        height: v.height
      }
    }, null, 8, ["init"]));
  }
}, OK = { key: 0 }, AK = ["for"], DK = { class: "cursor-pointer ml-2 align-middle" }, RK = {
  key: 0,
  class: "text-red-600 ml-1"
}, NK = { key: 1 }, MK = ["for"], BK = {
  key: 0,
  class: "text-red-600 ml-1"
}, LK = { key: 2 }, PK = ["id", "rows", "value", "placeholder", "disabled"], IK = {
  key: 7,
  class: "flex items-center"
}, FK = ["id", "value", "placeholder", "autocomplete", "required", "disabled", "min", "max", "step"], $K = ["id", "type", "value", "placeholder", "autocomplete", "required", "disabled", "min", "max", "step"], HK = ["innerHTML"], VK = {
  __name: "InputControl",
  props: {
    modelValue: {},
    placeholder: {},
    autocomplete: {},
    required: {},
    disabled: {},
    id: {
      type: String,
      default() {
        return Math.random().toString(36).slice(2);
      }
    },
    label: {
      type: String
    },
    type: {
      type: String,
      default() {
        return "text";
      }
    },
    multiple: {
      type: [Boolean, Object],
      default() {
        return !1;
      }
    },
    select: {
      type: Object
    },
    wysiwyg: {
      type: Object
    },
    errors: {
      type: [Array, String],
      default() {
        return [];
      }
    },
    attachments: {
      type: Array,
      default() {
        return [];
      }
    },
    acceptableTypes: {
      type: Array
    },
    maxSize: {
      type: [Number, String],
      default: "10MB"
    },
    info: {
      type: String
    },
    hideCheckbox: {
      type: Boolean,
      default: !1
    },
    indicateRequired: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update:modelValue", "remove-attachment", "preview"],
  setup(v, { emit: L }) {
    const N = v, W = L, ue = Qo(() => typeof N.errors == "string" ? [N.errors] : N.errors), ce = Qo(() => N.type.indexOf("textarea") === 0 ? N.type.split(":")[1] ?? "10" : "10"), he = Qo(() => N.type.split(":")[0]), pe = Qo(() => {
      const en = N.type.match(/:min=|:max=|:step=/g), Gt = N.type.split(/:min=|:max=|:step=/g);
      return en ? Object.fromEntries(
        en.map((gt, an) => [gt.replace(":", "").replace("=", ""), Gt[an + 1] ?? null])
      ) : {};
    }), Me = Qo(() => pe.value.hasOwnProperty("min") ? pe.value.min : null), Ze = Qo(() => pe.value.hasOwnProperty("max") ? pe.value.max : null), Ye = Qo(() => pe.value.hasOwnProperty("step") ? pe.value.step : null), yt = Jr(N.modelValue);
    Od(() => N.modelValue, (en) => {
      yt.value = en;
    });
    function jt(en) {
      W("update:modelValue", en);
    }
    const it = Jr(he.value === "currency" && N.modelValue ? (parseFloat(N.modelValue) || 0).toFixed(2) : null);
    function Rt(en) {
      it.value = en || en === 0 ? (parseFloat(en) || 0).toFixed(2) : null, W("update:modelValue", it.value);
    }
    return (en, Gt) => {
      var gt, an, Ot, Ee, wt;
      return kn(), no("div", {
        class: tc({ error: (gt = ue.value) == null ? void 0 : gt.length, required: v.indicateRequired && v.required })
      }, [
        v.type === "checkbox" ? (kn(), no("div", OK, [
          Co("label", {
            for: v.id,
            class: tc(["checkbox-label", { disabled: v.disabled }])
          }, [
            Qf(Gq, {
              id: v.id,
              checked: v.modelValue,
              "onUpdate:checked": jt,
              required: v.required,
              disabled: v.disabled,
              class: tc({ hidden: v.hideCheckbox })
            }, null, 8, ["id", "checked", "required", "disabled", "class"]),
            kl(en.$slots, "svg"),
            Co("span", DK, [
              Bm(ji(v.label), 1),
              v.indicateRequired && v.required ? (kn(), no("span", RK, "*")) : Ks("", !0)
            ])
          ], 10, AK)
        ])) : (kn(), no("div", NK, [
          v.label ? (kn(), no("label", {
            key: 0,
            for: v.id,
            class: tc(["input-label", { disabled: v.disabled }])
          }, [
            Bm(ji(v.label), 1),
            v.indicateRequired && v.required ? (kn(), no("span", BK, "*")) : Ks("", !0)
          ], 10, MK)) : Ks("", !0),
          v.select ? (kn(), Ju(EG, {
            key: 1,
            id: v.id,
            type: v.select.type,
            multiple: v.select.multiple,
            url: v.select.url,
            field: v.select.field,
            label: v.select.label,
            options: v.select.options,
            filters: v.select.filters,
            "search-columns": v.select.searchColumns,
            limit: v.select.limit,
            preload: v.select.preload,
            modelValue: yt.value,
            "onUpdate:modelValue": [
              Gt[0] || (Gt[0] = (Se) => yt.value = Se),
              Gt[1] || (Gt[1] = (Se) => en.$emit("update:modelValue", Se))
            ],
            disabled: v.disabled,
            required: v.required,
            placeholder: v.placeholder ? v.placeholder : v.label
          }, null, 8, ["id", "type", "multiple", "url", "field", "label", "options", "filters", "search-columns", "limit", "preload", "modelValue", "disabled", "required", "placeholder"])) : v.type === "attachments" ? (kn(), no("div", LK, [
            Qf($G, {
              attachments: v.attachments,
              onRemove: Gt[2] || (Gt[2] = (Se) => W("remove-attachment", Se))
            }, null, 8, ["attachments"]),
            Qf(IF, {
              multiple: "",
              id: v.id,
              modelValue: yt.value,
              "onUpdate:modelValue": [
                Gt[3] || (Gt[3] = (Se) => yt.value = Se),
                Gt[4] || (Gt[4] = (Se) => en.$emit("update:modelValue", Se))
              ],
              "acceptable-types": v.acceptableTypes,
              "max-size": v.maxSize,
              placeholder: v.placeholder,
              disabled: v.disabled,
              onPreview: Gt[5] || (Gt[5] = (Se) => en.$emit("preview", Se))
            }, null, 8, ["id", "modelValue", "acceptable-types", "max-size", "placeholder", "disabled"])
          ])) : v.type === "wysiwyg" || v.wysiwyg ? (kn(), Ju(zK, {
            key: 3,
            modelValue: yt.value,
            "onUpdate:modelValue": [
              Gt[6] || (Gt[6] = (Se) => yt.value = Se),
              Gt[7] || (Gt[7] = (Se) => en.$emit("update:modelValue", Se))
            ],
            height: (an = v.wysiwyg) == null ? void 0 : an.height,
            menubar: (Ot = v.wysiwyg) == null ? void 0 : Ot.menubar,
            plugins: (Ee = v.wysiwyg) == null ? void 0 : Ee.plugins,
            toolbar: (wt = v.wysiwyg) == null ? void 0 : wt.toolbar
          }, null, 8, ["modelValue", "height", "menubar", "plugins", "toolbar"])) : v.type === "image" || v.type === "file" ? (kn(), Ju(IF, {
            key: 4,
            id: v.id,
            modelValue: yt.value,
            "onUpdate:modelValue": [
              Gt[8] || (Gt[8] = (Se) => yt.value = Se),
              Gt[9] || (Gt[9] = (Se) => en.$emit("update:modelValue", Se))
            ],
            "acceptable-types": v.acceptableTypes,
            "max-size": v.maxSize,
            placeholder: v.placeholder,
            disabled: v.disabled,
            onPreview: Gt[10] || (Gt[10] = (Se) => en.$emit("preview", Se))
          }, null, 8, ["id", "modelValue", "acceptable-types", "max-size", "placeholder", "disabled"])) : he.value === "textarea" ? (kn(), no("textarea", {
            key: 5,
            id: v.id,
            class: "input-textarea",
            rows: ce.value,
            value: v.modelValue,
            onInput: Gt[11] || (Gt[11] = (Se) => en.$emit("update:modelValue", Se.target.value)),
            placeholder: v.placeholder ? v.placeholder : v.label,
            disabled: v.disabled
          }, null, 40, PK)) : v.multiple ? (kn(), Ju(MG, {
            key: 6,
            id: v.id,
            type: v.type,
            field: v.multiple.field,
            label: v.multiple.label,
            "can-add": v.multiple.canAdd,
            taggable: v.multiple.taggable,
            options: v.multiple.options,
            modelValue: yt.value,
            "onUpdate:modelValue": [
              Gt[12] || (Gt[12] = (Se) => yt.value = Se),
              Gt[13] || (Gt[13] = (Se) => en.$emit("update:modelValue", Se))
            ],
            class: "mt-1",
            placeholder: v.placeholder ? v.placeholder : v.label,
            disabled: v.disabled
          }, null, 8, ["id", "type", "field", "label", "can-add", "taggable", "options", "modelValue", "placeholder", "disabled"])) : he.value === "currency" ? (kn(), no("div", IK, [
            Gt[18] || (Gt[18] = Co("div", { class: "input-text !bg-zinc-100 !rounded-r-none !border-r-0 !w-auto" }, "$", -1)),
            Co("input", {
              id: v.id,
              class: "input-text !rounded-l-none",
              type: "number",
              value: it.value,
              onChange: Gt[14] || (Gt[14] = (Se) => Rt(Se.target.value)),
              placeholder: v.placeholder ? v.placeholder : v.label,
              autocomplete: v.autocomplete,
              required: v.required,
              disabled: v.disabled,
              min: Me.value,
              max: Ze.value,
              step: Ye.value,
              onWheel: Gt[15] || (Gt[15] = (Se) => Se.target.blur())
            }, null, 40, FK)
          ])) : (kn(), no("input", {
            key: 8,
            id: v.id,
            class: "input-text",
            type: he.value,
            value: v.modelValue,
            onInput: Gt[16] || (Gt[16] = (Se) => en.$emit("update:modelValue", Se.target.value)),
            placeholder: v.placeholder ? v.placeholder : v.label,
            autocomplete: v.autocomplete,
            required: v.required,
            disabled: v.disabled,
            min: Me.value,
            max: Ze.value,
            step: Ye.value,
            onWheel: Gt[17] || (Gt[17] = (Se) => Se.target.blur())
          }, null, 40, $K))
        ])),
        v.info ? (kn(), no("div", {
          key: 2,
          class: "text-sm text-gray-400",
          innerHTML: v.info
        }, null, 8, HK)) : Ks("", !0),
        (kn(!0), no(th, null, Oy(ue.value, (Se) => (kn(), Ju(Wq, {
          message: Se.replaceAll(".file", "")
        }, null, 8, ["message"]))), 256))
      ], 2);
    };
  }
}, UK = {
  __name: "FormInput",
  props: {
    form: {
      type: Object,
      required: !0
    },
    field: {
      type: String,
      required: !0
    },
    id: {},
    idSuffix: {},
    label: {
      type: String
    },
    type: {
      type: String
    },
    multiple: {
      type: [Boolean, Object],
      default() {
        return !1;
      }
    },
    select: {
      type: Object
    },
    wysiwyg: {
      type: Object
    },
    acceptableTypes: {
      type: Array
    },
    maxSize: {
      type: [Number, String],
      default: "10MB"
    },
    info: {
      type: String
    },
    placeholder: {},
    autocomplete: {},
    required: {},
    disabled: {},
    indicateRequired: {
      type: Boolean,
      default: !1
    },
    errors: {}
  },
  setup(v) {
    const L = v, N = Qo(() => L.id ? L.id : L.field + "_" + (L.idSuffix ?? Math.random().toString(36).slice(2))), W = Qo(() => L.label ? L.label : z8(L.field)), ue = Qo(() => {
      const he = L.errors ?? L.form.errors;
      let pe = L.field + (L.type === "file" ? ".file" : "");
      return he && he[pe] ? he[pe] : [];
    });
    function ce(he) {
      L.form.attachments = L.form.attachments.filter((pe) => pe.id != he.id);
    }
    return (he, pe) => (kn(), Ju(VK, {
      id: N.value,
      type: v.type,
      multiple: v.multiple,
      select: v.select,
      wysiwyg: v.wysiwyg,
      label: W.value,
      modelValue: v.form[v.field],
      "onUpdate:modelValue": pe[0] || (pe[0] = (Me) => v.form[v.field] = Me),
      attachments: v.form.attachments,
      "acceptable-types": v.acceptableTypes,
      "max-size": v.maxSize,
      errors: ue.value,
      placeholder: v.placeholder,
      autocomplete: v.autocomplete,
      required: v.required,
      disabled: v.disabled,
      info: v.info,
      "indicate-required": v.indicateRequired,
      onRemoveAttachment: ce
    }, null, 8, ["id", "type", "multiple", "select", "wysiwyg", "label", "modelValue", "attachments", "acceptable-types", "max-size", "errors", "placeholder", "autocomplete", "required", "disabled", "info", "indicate-required"]));
  }
}, jK = {
  __name: "FormInputGroup",
  props: {
    id: {},
    class: {},
    form: {
      type: Object,
      required: !0
    },
    inputs: {
      type: Array,
      default() {
        return [];
      }
    },
    indicateRequired: {
      type: Boolean,
      default: !1
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    errors: {}
  },
  setup(v) {
    const L = v, N = Qo(() => L.class ? L.class : "space-y-6");
    return (W, ue) => (kn(), no("div", {
      class: tc(N.value)
    }, [
      (kn(!0), no(th, null, Oy(v.inputs, (ce) => (kn(), Ju(UK, {
        form: v.form,
        field: ce.field,
        id: ce.id,
        "id-suffix": v.id,
        class: tc(ce.class),
        type: ce.type,
        multiple: ce.multiple,
        "acceptable-types": ce.acceptableTypes,
        "max-size": ce.maxSize,
        select: ce.select,
        wysiwyg: ce.wysiwyg,
        label: ce.label,
        placeholder: ce.placeholder,
        autocomplete: ce.autocomplete,
        required: ce.required,
        disabled: ce.disabled || v.disabled,
        info: ce.info,
        "indicate-required": typeof ce.indicateRequired < "u" ? ce.indicateRequired : v.indicateRequired,
        errors: v.errors
      }, null, 8, ["form", "field", "id", "id-suffix", "class", "type", "multiple", "acceptable-types", "max-size", "select", "wysiwyg", "label", "placeholder", "autocomplete", "required", "disabled", "info", "indicate-required", "errors"]))), 256)),
      kl(W.$slots, "default")
    ], 2));
  }
}, ZK = ["href"], WK = ["type"], hT = {
  __name: "FormButton",
  props: {
    context: {
      type: String,
      default: "form-btn-primary"
    },
    type: {
      type: String,
      default: "submit"
    },
    href: {
      type: String
    }
  },
  setup(v) {
    return (L, N) => v.type === "link" ? (kn(), no("a", {
      key: 0,
      href: v.href,
      class: tc(v.context)
    }, [
      kl(L.$slots, "default")
    ], 10, ZK)) : (kn(), no("button", {
      key: 1,
      type: v.type,
      class: tc(v.context)
    }, [
      kl(L.$slots, "default")
    ], 10, WK));
  }
};
function O8(v) {
  typeof queueMicrotask == "function" ? queueMicrotask(v) : Promise.resolve().then(v).catch((L) => setTimeout(() => {
    throw L;
  }));
}
function vT() {
  let v = [], L = { addEventListener(N, W, ue, ce) {
    return N.addEventListener(W, ue, ce), L.add(() => N.removeEventListener(W, ue, ce));
  }, requestAnimationFrame(...N) {
    let W = requestAnimationFrame(...N);
    L.add(() => cancelAnimationFrame(W));
  }, nextFrame(...N) {
    L.requestAnimationFrame(() => {
      L.requestAnimationFrame(...N);
    });
  }, setTimeout(...N) {
    let W = setTimeout(...N);
    L.add(() => clearTimeout(W));
  }, microTask(...N) {
    let W = { current: !0 };
    return O8(() => {
      W.current && N[0]();
    }), L.add(() => {
      W.current = !1;
    });
  }, style(N, W, ue) {
    let ce = N.style.getPropertyValue(W);
    return Object.assign(N.style, { [W]: ue }), this.add(() => {
      Object.assign(N.style, { [W]: ce });
    });
  }, group(N) {
    let W = vT();
    return N(W), this.add(() => W.dispose());
  }, add(N) {
    return v.push(N), () => {
      let W = v.indexOf(N);
      if (W >= 0)
        for (let ue of v.splice(W, 1))
          ue();
    };
  }, dispose() {
    for (let N of v.splice(0))
      N();
  } };
  return L;
}
var VF;
let qK = Symbol("headlessui.useid"), GK = 0;
const _w = (VF = NF.useId) != null ? VF : function() {
  return NF.inject(qK, () => `${++GK}`)();
};
function pu(v) {
  var L;
  if (v == null || v.value == null)
    return null;
  let N = (L = v.value.$el) != null ? L : v.value;
  return N instanceof Node ? N : null;
}
function Dy(v, L, ...N) {
  if (v in L) {
    let ue = L[v];
    return typeof ue == "function" ? ue(...N) : ue;
  }
  let W = new Error(`Tried to handle "${v}" but there is no handler defined. Only defined handlers are: ${Object.keys(L).map((ue) => `"${ue}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(W, Dy), W;
}
var KK = Object.defineProperty, YK = (v, L, N) => L in v ? KK(v, L, { enumerable: !0, configurable: !0, writable: !0, value: N }) : v[L] = N, UF = (v, L, N) => (YK(v, typeof L != "symbol" ? L + "" : L, N), N);
let XK = class {
  constructor() {
    UF(this, "current", this.detect()), UF(this, "currentId", 0);
  }
  set(L) {
    this.current !== L && (this.currentId = 0, this.current = L);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
}, xT = new XK();
function X2(v) {
  if (xT.isServer)
    return null;
  if (v instanceof Node)
    return v.ownerDocument;
  if (v != null && v.hasOwnProperty("value")) {
    let L = pu(v);
    if (L)
      return L.ownerDocument;
  }
  return document;
}
let v8 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((v) => `${v}:not([tabindex='-1'])`).join(",");
var bv = ((v) => (v[v.First = 1] = "First", v[v.Previous = 2] = "Previous", v[v.Next = 4] = "Next", v[v.Last = 8] = "Last", v[v.WrapAround = 16] = "WrapAround", v[v.NoScroll = 32] = "NoScroll", v))(bv || {}), XF = ((v) => (v[v.Error = 0] = "Error", v[v.Overflow = 1] = "Overflow", v[v.Success = 2] = "Success", v[v.Underflow = 3] = "Underflow", v))(XF || {}), JK = ((v) => (v[v.Previous = -1] = "Previous", v[v.Next = 1] = "Next", v))(JK || {});
function QK(v = document.body) {
  return v == null ? [] : Array.from(v.querySelectorAll(v8)).sort((L, N) => Math.sign((L.tabIndex || Number.MAX_SAFE_INTEGER) - (N.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var JF = ((v) => (v[v.Strict = 0] = "Strict", v[v.Loose = 1] = "Loose", v))(JF || {});
function eY(v, L = 0) {
  var N;
  return v === ((N = X2(v)) == null ? void 0 : N.body) ? !1 : Dy(L, { 0() {
    return v.matches(v8);
  }, 1() {
    let W = v;
    for (; W !== null; ) {
      if (W.matches(v8))
        return !0;
      W = W.parentElement;
    }
    return !1;
  } });
}
var tY = ((v) => (v[v.Keyboard = 0] = "Keyboard", v[v.Mouse = 1] = "Mouse", v))(tY || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (v) => {
  v.metaKey || v.altKey || v.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (v) => {
  v.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : v.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function kw(v) {
  v == null || v.focus({ preventScroll: !0 });
}
let nY = ["textarea", "input"].join(",");
function oY(v) {
  var L, N;
  return (N = (L = v == null ? void 0 : v.matches) == null ? void 0 : L.call(v, nY)) != null ? N : !1;
}
function rY(v, L = (N) => N) {
  return v.slice().sort((N, W) => {
    let ue = L(N), ce = L(W);
    if (ue === null || ce === null)
      return 0;
    let he = ue.compareDocumentPosition(ce);
    return he & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : he & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function P5(v, L, { sorted: N = !0, relativeTo: W = null, skipElements: ue = [] } = {}) {
  var ce;
  let he = (ce = Array.isArray(v) ? v.length > 0 ? v[0].ownerDocument : document : v == null ? void 0 : v.ownerDocument) != null ? ce : document, pe = Array.isArray(v) ? N ? rY(v) : v : QK(v);
  ue.length > 0 && pe.length > 1 && (pe = pe.filter((Rt) => !ue.includes(Rt))), W = W ?? he.activeElement;
  let Me = (() => {
    if (L & 5)
      return 1;
    if (L & 10)
      return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), Ze = (() => {
    if (L & 1)
      return 0;
    if (L & 2)
      return Math.max(0, pe.indexOf(W)) - 1;
    if (L & 4)
      return Math.max(0, pe.indexOf(W)) + 1;
    if (L & 8)
      return pe.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), Ye = L & 32 ? { preventScroll: !0 } : {}, yt = 0, jt = pe.length, it;
  do {
    if (yt >= jt || yt + jt <= 0)
      return 0;
    let Rt = Ze + yt;
    if (L & 16)
      Rt = (Rt + jt) % jt;
    else {
      if (Rt < 0)
        return 3;
      if (Rt >= jt)
        return 1;
    }
    it = pe[Rt], it == null || it.focus(Ye), yt += Me;
  } while (it !== he.activeElement);
  return L & 6 && oY(it) && it.select(), 2;
}
function QF() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function sY() {
  return /Android/gi.test(window.navigator.userAgent);
}
function aY() {
  return QF() || sY();
}
function M5(v, L, N) {
  xT.isServer || Jh((W) => {
    document.addEventListener(v, L, N), W(() => document.removeEventListener(v, L, N));
  });
}
function e$(v, L, N) {
  xT.isServer || Jh((W) => {
    window.addEventListener(v, L, N), W(() => window.removeEventListener(v, L, N));
  });
}
function iY(v, L, N = Qo(() => !0)) {
  function W(ce, he) {
    if (!N.value || ce.defaultPrevented)
      return;
    let pe = he(ce);
    if (pe === null || !pe.getRootNode().contains(pe))
      return;
    let Me = function Ze(Ye) {
      return typeof Ye == "function" ? Ze(Ye()) : Array.isArray(Ye) || Ye instanceof Set ? Ye : [Ye];
    }(v);
    for (let Ze of Me) {
      if (Ze === null)
        continue;
      let Ye = Ze instanceof HTMLElement ? Ze : pu(Ze);
      if (Ye != null && Ye.contains(pe) || ce.composed && ce.composedPath().includes(Ye))
        return;
    }
    return !eY(pe, JF.Loose) && pe.tabIndex !== -1 && ce.preventDefault(), L(ce, pe);
  }
  let ue = Jr(null);
  M5("pointerdown", (ce) => {
    var he, pe;
    N.value && (ue.value = ((pe = (he = ce.composedPath) == null ? void 0 : he.call(ce)) == null ? void 0 : pe[0]) || ce.target);
  }, !0), M5("mousedown", (ce) => {
    var he, pe;
    N.value && (ue.value = ((pe = (he = ce.composedPath) == null ? void 0 : he.call(ce)) == null ? void 0 : pe[0]) || ce.target);
  }, !0), M5("click", (ce) => {
    aY() || ue.value && (W(ce, () => ue.value), ue.value = null);
  }, !0), M5("touchend", (ce) => W(ce, () => ce.target instanceof HTMLElement ? ce.target : null), !0), e$("blur", (ce) => W(ce, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
var $5 = ((v) => (v[v.None = 0] = "None", v[v.RenderStrategy = 1] = "RenderStrategy", v[v.Static = 2] = "Static", v))($5 || {}), yv = ((v) => (v[v.Unmount = 0] = "Unmount", v[v.Hidden = 1] = "Hidden", v))(yv || {});
function rg({ visible: v = !0, features: L = 0, ourProps: N, theirProps: W, ...ue }) {
  var ce;
  let he = n$(W, N), pe = Object.assign(ue, { props: he });
  if (v || L & 2 && he.static)
    return h8(pe);
  if (L & 1) {
    let Me = (ce = he.unmount) == null || ce ? 0 : 1;
    return Dy(Me, { 0() {
      return null;
    }, 1() {
      return h8({ ...ue, props: { ...he, hidden: !0, style: { display: "none" } } });
    } });
  }
  return h8(pe);
}
function h8({ props: v, attrs: L, slots: N, slot: W, name: ue }) {
  var ce, he;
  let { as: pe, ...Me } = o$(v, ["unmount", "static"]), Ze = (ce = N.default) == null ? void 0 : ce.call(N, W), Ye = {};
  if (W) {
    let yt = !1, jt = [];
    for (let [it, Rt] of Object.entries(W))
      typeof Rt == "boolean" && (yt = !0), Rt === !0 && jt.push(it);
    yt && (Ye["data-headlessui-state"] = jt.join(" "));
  }
  if (pe === "template") {
    if (Ze = t$(Ze ?? []), Object.keys(Me).length > 0 || Object.keys(L).length > 0) {
      let [yt, ...jt] = Ze ?? [];
      if (!lY(yt) || jt.length > 0)
        throw new Error(['Passing props on "template"!', "", `The current component <${ue} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(Me).concat(Object.keys(L)).map((en) => en.trim()).filter((en, Gt, gt) => gt.indexOf(en) === Gt).sort((en, Gt) => en.localeCompare(Gt)).map((en) => `  - ${en}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map((en) => `  - ${en}`).join(`
`)].join(`
`));
      let it = n$((he = yt.props) != null ? he : {}, Me, Ye), Rt = Fq(yt, it, !0);
      for (let en in it)
        en.startsWith("on") && (Rt.props || (Rt.props = {}), Rt.props[en] = it[en]);
      return Rt;
    }
    return Array.isArray(Ze) && Ze.length === 1 ? Ze[0] : Ze;
  }
  return Xu(pe, Object.assign({}, Me, Ye), { default: () => Ze });
}
function t$(v) {
  return v.flatMap((L) => L.type === th ? t$(L.children) : [L]);
}
function n$(...v) {
  if (v.length === 0)
    return {};
  if (v.length === 1)
    return v[0];
  let L = {}, N = {};
  for (let W of v)
    for (let ue in W)
      ue.startsWith("on") && typeof W[ue] == "function" ? (N[ue] != null || (N[ue] = []), N[ue].push(W[ue])) : L[ue] = W[ue];
  if (L.disabled || L["aria-disabled"])
    return Object.assign(L, Object.fromEntries(Object.keys(N).map((W) => [W, void 0])));
  for (let W in N)
    Object.assign(L, { [W](ue, ...ce) {
      let he = N[W];
      for (let pe of he) {
        if (ue instanceof Event && ue.defaultPrevented)
          return;
        pe(ue, ...ce);
      }
    } });
  return L;
}
function o$(v, L = []) {
  let N = Object.assign({}, v);
  for (let W of L)
    W in N && delete N[W];
  return N;
}
function lY(v) {
  return v == null ? !1 : typeof v.type == "string" || typeof v.type == "object" || typeof v.type == "function";
}
var H5 = ((v) => (v[v.None = 1] = "None", v[v.Focusable = 2] = "Focusable", v[v.Hidden = 4] = "Hidden", v))(H5 || {});
let x8 = em({ name: "Hidden", props: { as: { type: [Object, String], default: "div" }, features: { type: Number, default: 1 } }, setup(v, { slots: L, attrs: N }) {
  return () => {
    var W;
    let { features: ue, ...ce } = v, he = { "aria-hidden": (ue & 2) === 2 ? !0 : (W = ce["aria-hidden"]) != null ? W : void 0, hidden: (ue & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(ue & 4) === 4 && (ue & 2) !== 2 && { display: "none" } } };
    return rg({ ourProps: he, theirProps: ce, slot: {}, attrs: N, slots: L, name: "Hidden" });
  };
} }), r$ = Symbol("Context");
var og = ((v) => (v[v.Open = 1] = "Open", v[v.Closed = 2] = "Closed", v[v.Closing = 4] = "Closing", v[v.Opening = 8] = "Opening", v))(og || {});
function cY() {
  return A8() !== null;
}
function A8() {
  return nh(r$, null);
}
function uY(v) {
  Ay(r$, v);
}
var s$ = ((v) => (v.Space = " ", v.Enter = "Enter", v.Escape = "Escape", v.Backspace = "Backspace", v.Delete = "Delete", v.ArrowLeft = "ArrowLeft", v.ArrowUp = "ArrowUp", v.ArrowRight = "ArrowRight", v.ArrowDown = "ArrowDown", v.Home = "Home", v.End = "End", v.PageUp = "PageUp", v.PageDown = "PageDown", v.Tab = "Tab", v))(s$ || {});
function dY(v) {
  function L() {
    document.readyState !== "loading" && (v(), document.removeEventListener("DOMContentLoaded", L));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", L), L());
}
let xw = [];
dY(() => {
  function v(L) {
    L.target instanceof HTMLElement && L.target !== document.body && xw[0] !== L.target && (xw.unshift(L.target), xw = xw.filter((N) => N != null && N.isConnected), xw.splice(10));
  }
  window.addEventListener("click", v, { capture: !0 }), window.addEventListener("mousedown", v, { capture: !0 }), window.addEventListener("focus", v, { capture: !0 }), document.body.addEventListener("click", v, { capture: !0 }), document.body.addEventListener("mousedown", v, { capture: !0 }), document.body.addEventListener("focus", v, { capture: !0 });
});
function a$(v, L, N, W) {
  xT.isServer || Jh((ue) => {
    v = v ?? window, v.addEventListener(L, N, W), ue(() => v.removeEventListener(L, N, W));
  });
}
var bT = ((v) => (v[v.Forwards = 0] = "Forwards", v[v.Backwards = 1] = "Backwards", v))(bT || {});
function fY() {
  let v = Jr(0);
  return e$("keydown", (L) => {
    L.key === "Tab" && (v.value = L.shiftKey ? 1 : 0);
  }), v;
}
function i$(v) {
  if (!v)
    return /* @__PURE__ */ new Set();
  if (typeof v == "function")
    return new Set(v());
  let L = /* @__PURE__ */ new Set();
  for (let N of v.value) {
    let W = pu(N);
    W instanceof HTMLElement && L.add(W);
  }
  return L;
}
var l$ = ((v) => (v[v.None = 1] = "None", v[v.InitialFocus = 2] = "InitialFocus", v[v.TabLock = 4] = "TabLock", v[v.FocusLock = 8] = "FocusLock", v[v.RestoreFocus = 16] = "RestoreFocus", v[v.All = 30] = "All", v))(l$ || {});
let mT = Object.assign(em({ name: "FocusTrap", props: { as: { type: [Object, String], default: "div" }, initialFocus: { type: Object, default: null }, features: { type: Number, default: 30 }, containers: { type: [Object, Function], default: Jr(/* @__PURE__ */ new Set()) } }, inheritAttrs: !1, setup(v, { attrs: L, slots: N, expose: W }) {
  let ue = Jr(null);
  W({ el: ue, $el: ue });
  let ce = Qo(() => X2(ue)), he = Jr(!1);
  Ad(() => he.value = !0), Qh(() => he.value = !1), pY({ ownerDocument: ce }, Qo(() => he.value && !!(v.features & 16)));
  let pe = gY({ ownerDocument: ce, container: ue, initialFocus: Qo(() => v.initialFocus) }, Qo(() => he.value && !!(v.features & 2)));
  hY({ ownerDocument: ce, container: ue, containers: v.containers, previousActiveElement: pe }, Qo(() => he.value && !!(v.features & 8)));
  let Me = fY();
  function Ze(it) {
    let Rt = pu(ue);
    Rt && ((en) => en())(() => {
      Dy(Me.value, { [bT.Forwards]: () => {
        P5(Rt, bv.First, { skipElements: [it.relatedTarget] });
      }, [bT.Backwards]: () => {
        P5(Rt, bv.Last, { skipElements: [it.relatedTarget] });
      } });
    });
  }
  let Ye = Jr(!1);
  function yt(it) {
    it.key === "Tab" && (Ye.value = !0, requestAnimationFrame(() => {
      Ye.value = !1;
    }));
  }
  function jt(it) {
    if (!he.value)
      return;
    let Rt = i$(v.containers);
    pu(ue) instanceof HTMLElement && Rt.add(pu(ue));
    let en = it.relatedTarget;
    en instanceof HTMLElement && en.dataset.headlessuiFocusGuard !== "true" && (c$(Rt, en) || (Ye.value ? P5(pu(ue), Dy(Me.value, { [bT.Forwards]: () => bv.Next, [bT.Backwards]: () => bv.Previous }) | bv.WrapAround, { relativeTo: it.target }) : it.target instanceof HTMLElement && kw(it.target)));
  }
  return () => {
    let it = {}, Rt = { ref: ue, onKeydown: yt, onFocusout: jt }, { features: en, initialFocus: Gt, containers: gt, ...an } = v;
    return Xu(th, [!!(en & 4) && Xu(x8, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: Ze, features: H5.Focusable }), rg({ ourProps: Rt, theirProps: { ...L, ...an }, slot: it, attrs: L, slots: N, name: "FocusTrap" }), !!(en & 4) && Xu(x8, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: Ze, features: H5.Focusable })]);
  };
} }), { features: l$ });
function mY(v) {
  let L = Jr(xw.slice());
  return Od([v], ([N], [W]) => {
    W === !0 && N === !1 ? O8(() => {
      L.value.splice(0);
    }) : W === !1 && N === !0 && (L.value = xw.slice());
  }, { flush: "post" }), () => {
    var N;
    return (N = L.value.find((W) => W != null && W.isConnected)) != null ? N : null;
  };
}
function pY({ ownerDocument: v }, L) {
  let N = mY(L);
  Ad(() => {
    Jh(() => {
      var W, ue;
      L.value || ((W = v.value) == null ? void 0 : W.activeElement) === ((ue = v.value) == null ? void 0 : ue.body) && kw(N());
    }, { flush: "post" });
  }), Qh(() => {
    L.value && kw(N());
  });
}
function gY({ ownerDocument: v, container: L, initialFocus: N }, W) {
  let ue = Jr(null), ce = Jr(!1);
  return Ad(() => ce.value = !0), Qh(() => ce.value = !1), Ad(() => {
    Od([L, N, W], (he, pe) => {
      if (he.every((Ze, Ye) => (pe == null ? void 0 : pe[Ye]) === Ze) || !W.value)
        return;
      let Me = pu(L);
      Me && O8(() => {
        var Ze, Ye;
        if (!ce.value)
          return;
        let yt = pu(N), jt = (Ze = v.value) == null ? void 0 : Ze.activeElement;
        if (yt) {
          if (yt === jt) {
            ue.value = jt;
            return;
          }
        } else if (Me.contains(jt)) {
          ue.value = jt;
          return;
        }
        yt ? kw(yt) : P5(Me, bv.First | bv.NoScroll) === XF.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), ue.value = (Ye = v.value) == null ? void 0 : Ye.activeElement;
      });
    }, { immediate: !0, flush: "post" });
  }), ue;
}
function hY({ ownerDocument: v, container: L, containers: N, previousActiveElement: W }, ue) {
  var ce;
  a$((ce = v.value) == null ? void 0 : ce.defaultView, "focus", (he) => {
    if (!ue.value)
      return;
    let pe = i$(N);
    pu(L) instanceof HTMLElement && pe.add(pu(L));
    let Me = W.value;
    if (!Me)
      return;
    let Ze = he.target;
    Ze && Ze instanceof HTMLElement ? c$(pe, Ze) ? (W.value = Ze, kw(Ze)) : (he.preventDefault(), he.stopPropagation(), kw(Me)) : kw(W.value);
  }, !0);
}
function c$(v, L) {
  for (let N of v)
    if (N.contains(L))
      return !0;
  return !1;
}
function bY(v) {
  let L = $q(v.getSnapshot());
  return Qh(v.subscribe(() => {
    L.value = v.getSnapshot();
  })), L;
}
function yY(v, L) {
  let N = v(), W = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return N;
  }, subscribe(ue) {
    return W.add(ue), () => W.delete(ue);
  }, dispatch(ue, ...ce) {
    let he = L[ue].call(N, ...ce);
    he && (N = he, W.forEach((pe) => pe()));
  } };
}
function vY() {
  let v;
  return { before({ doc: L }) {
    var N;
    let W = L.documentElement;
    v = ((N = L.defaultView) != null ? N : window).innerWidth - W.clientWidth;
  }, after({ doc: L, d: N }) {
    let W = L.documentElement, ue = W.clientWidth - W.offsetWidth, ce = v - ue;
    N.style(W, "paddingRight", `${ce}px`);
  } };
}
function xY() {
  return QF() ? { before({ doc: v, d: L, meta: N }) {
    function W(ue) {
      return N.containers.flatMap((ce) => ce()).some((ce) => ce.contains(ue));
    }
    L.microTask(() => {
      var ue;
      if (window.getComputedStyle(v.documentElement).scrollBehavior !== "auto") {
        let pe = vT();
        pe.style(v.documentElement, "scrollBehavior", "auto"), L.add(() => L.microTask(() => pe.dispose()));
      }
      let ce = (ue = window.scrollY) != null ? ue : window.pageYOffset, he = null;
      L.addEventListener(v, "click", (pe) => {
        if (pe.target instanceof HTMLElement)
          try {
            let Me = pe.target.closest("a");
            if (!Me)
              return;
            let { hash: Ze } = new URL(Me.href), Ye = v.querySelector(Ze);
            Ye && !W(Ye) && (he = Ye);
          } catch {
          }
      }, !0), L.addEventListener(v, "touchstart", (pe) => {
        if (pe.target instanceof HTMLElement)
          if (W(pe.target)) {
            let Me = pe.target;
            for (; Me.parentElement && W(Me.parentElement); )
              Me = Me.parentElement;
            L.style(Me, "overscrollBehavior", "contain");
          } else
            L.style(pe.target, "touchAction", "none");
      }), L.addEventListener(v, "touchmove", (pe) => {
        if (pe.target instanceof HTMLElement) {
          if (pe.target.tagName === "INPUT")
            return;
          if (W(pe.target)) {
            let Me = pe.target;
            for (; Me.parentElement && Me.dataset.headlessuiPortal !== "" && !(Me.scrollHeight > Me.clientHeight || Me.scrollWidth > Me.clientWidth); )
              Me = Me.parentElement;
            Me.dataset.headlessuiPortal === "" && pe.preventDefault();
          } else
            pe.preventDefault();
        }
      }, { passive: !1 }), L.add(() => {
        var pe;
        let Me = (pe = window.scrollY) != null ? pe : window.pageYOffset;
        ce !== Me && window.scrollTo(0, ce), he && he.isConnected && (he.scrollIntoView({ block: "nearest" }), he = null);
      });
    });
  } } : {};
}
function wY() {
  return { before({ doc: v, d: L }) {
    L.style(v.documentElement, "overflow", "hidden");
  } };
}
function kY(v) {
  let L = {};
  for (let N of v)
    Object.assign(L, N(L));
  return L;
}
let ww = yY(() => /* @__PURE__ */ new Map(), { PUSH(v, L) {
  var N;
  let W = (N = this.get(v)) != null ? N : { doc: v, count: 0, d: vT(), meta: /* @__PURE__ */ new Set() };
  return W.count++, W.meta.add(L), this.set(v, W), this;
}, POP(v, L) {
  let N = this.get(v);
  return N && (N.count--, N.meta.delete(L)), this;
}, SCROLL_PREVENT({ doc: v, d: L, meta: N }) {
  let W = { doc: v, d: L, meta: kY(N) }, ue = [xY(), vY(), wY()];
  ue.forEach(({ before: ce }) => ce == null ? void 0 : ce(W)), ue.forEach(({ after: ce }) => ce == null ? void 0 : ce(W));
}, SCROLL_ALLOW({ d: v }) {
  v.dispose();
}, TEARDOWN({ doc: v }) {
  this.delete(v);
} });
ww.subscribe(() => {
  let v = ww.getSnapshot(), L = /* @__PURE__ */ new Map();
  for (let [N] of v)
    L.set(N, N.documentElement.style.overflow);
  for (let N of v.values()) {
    let W = L.get(N.doc) === "hidden", ue = N.count !== 0;
    (ue && !W || !ue && W) && ww.dispatch(N.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", N), N.count === 0 && ww.dispatch("TEARDOWN", N);
  }
});
function _Y(v, L, N) {
  let W = bY(ww), ue = Qo(() => {
    let ce = v.value ? W.value.get(v.value) : void 0;
    return ce ? ce.count > 0 : !1;
  });
  return Od([v, L], ([ce, he], [pe], Me) => {
    if (!ce || !he)
      return;
    ww.dispatch("PUSH", ce, N);
    let Ze = !1;
    Me(() => {
      Ze || (ww.dispatch("POP", pe ?? ce, N), Ze = !0);
    });
  }, { immediate: !0 }), ue;
}
let b8 = /* @__PURE__ */ new Map(), pT = /* @__PURE__ */ new Map();
function jF(v, L = Jr(!0)) {
  Jh((N) => {
    var W;
    if (!L.value)
      return;
    let ue = pu(v);
    if (!ue)
      return;
    N(function() {
      var he;
      if (!ue)
        return;
      let pe = (he = pT.get(ue)) != null ? he : 1;
      if (pe === 1 ? pT.delete(ue) : pT.set(ue, pe - 1), pe !== 1)
        return;
      let Me = b8.get(ue);
      Me && (Me["aria-hidden"] === null ? ue.removeAttribute("aria-hidden") : ue.setAttribute("aria-hidden", Me["aria-hidden"]), ue.inert = Me.inert, b8.delete(ue));
    });
    let ce = (W = pT.get(ue)) != null ? W : 0;
    pT.set(ue, ce + 1), ce === 0 && (b8.set(ue, { "aria-hidden": ue.getAttribute("aria-hidden"), inert: ue.inert }), ue.setAttribute("aria-hidden", "true"), ue.inert = !0);
  });
}
function CY({ defaultContainers: v = [], portals: L, mainTreeNodeRef: N } = {}) {
  let W = Jr(null), ue = X2(W);
  function ce() {
    var he, pe, Me;
    let Ze = [];
    for (let Ye of v)
      Ye !== null && (Ye instanceof HTMLElement ? Ze.push(Ye) : "value" in Ye && Ye.value instanceof HTMLElement && Ze.push(Ye.value));
    if (L != null && L.value)
      for (let Ye of L.value)
        Ze.push(Ye);
    for (let Ye of (he = ue == null ? void 0 : ue.querySelectorAll("html > *, body > *")) != null ? he : [])
      Ye !== document.body && Ye !== document.head && Ye instanceof HTMLElement && Ye.id !== "headlessui-portal-root" && (Ye.contains(pu(W)) || Ye.contains((Me = (pe = pu(W)) == null ? void 0 : pe.getRootNode()) == null ? void 0 : Me.host) || Ze.some((yt) => Ye.contains(yt)) || Ze.push(Ye));
    return Ze;
  }
  return { resolveContainers: ce, contains(he) {
    return ce().some((pe) => pe.contains(he));
  }, mainTreeNodeRef: W, MainTreeNode() {
    return N != null ? null : Xu(x8, { features: H5.Hidden, ref: W });
  } };
}
let u$ = Symbol("ForcePortalRootContext");
function SY() {
  return nh(u$, !1);
}
let w8 = em({ name: "ForcePortalRoot", props: { as: { type: [Object, String], default: "template" }, force: { type: Boolean, default: !1 } }, setup(v, { slots: L, attrs: N }) {
  return Ay(u$, v.force), () => {
    let { force: W, ...ue } = v;
    return rg({ theirProps: ue, ourProps: {}, slot: {}, slots: L, attrs: N, name: "ForcePortalRoot" });
  };
} }), d$ = Symbol("StackContext");
var k8 = ((v) => (v[v.Add = 0] = "Add", v[v.Remove = 1] = "Remove", v))(k8 || {});
function EY() {
  return nh(d$, () => {
  });
}
function TY({ type: v, enabled: L, element: N, onUpdate: W }) {
  let ue = EY();
  function ce(...he) {
    W == null || W(...he), ue(...he);
  }
  Ad(() => {
    Od(L, (he, pe) => {
      he ? ce(0, v, N) : pe === !0 && ce(1, v, N);
    }, { immediate: !0, flush: "sync" });
  }), Qh(() => {
    L.value && ce(1, v, N);
  }), Ay(d$, ce);
}
let f$ = Symbol("DescriptionContext");
function zY() {
  let v = nh(f$, null);
  if (v === null)
    throw new Error("Missing parent");
  return v;
}
function OY({ slot: v = Jr({}), name: L = "Description", props: N = {} } = {}) {
  let W = Jr([]);
  function ue(ce) {
    return W.value.push(ce), () => {
      let he = W.value.indexOf(ce);
      he !== -1 && W.value.splice(he, 1);
    };
  }
  return Ay(f$, { register: ue, slot: v, name: L, props: N }), Qo(() => W.value.length > 0 ? W.value.join(" ") : void 0);
}
em({ name: "Description", props: { as: { type: [Object, String], default: "p" }, id: { type: String, default: null } }, setup(v, { attrs: L, slots: N }) {
  var W;
  let ue = (W = v.id) != null ? W : `headlessui-description-${_w()}`, ce = zY();
  return Ad(() => Qh(ce.register(ue))), () => {
    let { name: he = "Description", slot: pe = Jr({}), props: Me = {} } = ce, { ...Ze } = v, Ye = { ...Object.entries(Me).reduce((yt, [jt, it]) => Object.assign(yt, { [jt]: ng(it) }), {}), id: ue };
    return rg({ ourProps: Ye, theirProps: Ze, slot: pe.value, attrs: L, slots: N, name: he });
  };
} });
function AY(v) {
  let L = X2(v);
  if (!L) {
    if (v === null)
      return null;
    throw new Error(`[Headless UI]: Cannot find ownerDocument for contextElement: ${v}`);
  }
  let N = L.getElementById("headlessui-portal-root");
  if (N)
    return N;
  let W = L.createElement("div");
  return W.setAttribute("id", "headlessui-portal-root"), L.body.appendChild(W);
}
const _8 = /* @__PURE__ */ new WeakMap();
function DY(v) {
  var L;
  return (L = _8.get(v)) != null ? L : 0;
}
function ZF(v, L) {
  let N = L(DY(v));
  return N <= 0 ? _8.delete(v) : _8.set(v, N), N;
}
let m$ = em({ name: "Portal", props: { as: { type: [Object, String], default: "div" } }, setup(v, { slots: L, attrs: N }) {
  let W = Jr(null), ue = Qo(() => X2(W)), ce = SY(), he = nh(p$, null), pe = Jr(ce === !0 || he == null ? AY(W.value) : he.resolveTarget());
  pe.value && ZF(pe.value, (jt) => jt + 1);
  let Me = Jr(!1);
  Ad(() => {
    Me.value = !0;
  }), Jh(() => {
    ce || he != null && (pe.value = he.resolveTarget());
  });
  let Ze = nh(C8, null), Ye = !1, yt = Hq();
  return Od(W, () => {
    if (Ye || !Ze)
      return;
    let jt = pu(W);
    jt && (Qh(Ze.register(jt), yt), Ye = !0);
  }), Qh(() => {
    var jt, it;
    let Rt = (jt = ue.value) == null ? void 0 : jt.getElementById("headlessui-portal-root");
    !Rt || pe.value !== Rt || ZF(pe.value, (en) => en - 1) || pe.value.children.length > 0 || (it = pe.value.parentElement) == null || it.removeChild(pe.value);
  }), () => {
    if (!Me.value || pe.value === null)
      return null;
    let jt = { ref: W, "data-headlessui-portal": "" };
    return Xu(Vq, { to: pe.value }, rg({ ourProps: jt, theirProps: v, slot: {}, attrs: N, slots: L, name: "Portal" }));
  };
} }), C8 = Symbol("PortalParentContext");
function RY() {
  let v = nh(C8, null), L = Jr([]);
  function N(ce) {
    return L.value.push(ce), v && v.register(ce), () => W(ce);
  }
  function W(ce) {
    let he = L.value.indexOf(ce);
    he !== -1 && L.value.splice(he, 1), v && v.unregister(ce);
  }
  let ue = { register: N, unregister: W, portals: L };
  return [L, em({ name: "PortalWrapper", setup(ce, { slots: he }) {
    return Ay(C8, ue), () => {
      var pe;
      return (pe = he.default) == null ? void 0 : pe.call(he);
    };
  } })];
}
let p$ = Symbol("PortalGroupContext"), NY = em({ name: "PortalGroup", props: { as: { type: [Object, String], default: "template" }, target: { type: Object, default: null } }, setup(v, { attrs: L, slots: N }) {
  let W = Uq({ resolveTarget() {
    return v.target;
  } });
  return Ay(p$, W), () => {
    let { target: ue, ...ce } = v;
    return rg({ theirProps: ce, ourProps: {}, slot: {}, attrs: L, slots: N, name: "PortalGroup" });
  };
} });
var MY = ((v) => (v[v.Open = 0] = "Open", v[v.Closed = 1] = "Closed", v))(MY || {});
let S8 = Symbol("DialogContext");
function wT(v) {
  let L = nh(S8, null);
  if (L === null) {
    let N = new Error(`<${v} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(N, wT), N;
  }
  return L;
}
let B5 = "DC8F892D-2EBD-447C-A4C8-A03058436FF4", BY = em({ name: "Dialog", inheritAttrs: !1, props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, open: { type: [Boolean, String], default: B5 }, initialFocus: { type: Object, default: null }, id: { type: String, default: null }, role: { type: String, default: "dialog" } }, emits: { close: (v) => !0 }, setup(v, { emit: L, attrs: N, slots: W, expose: ue }) {
  var ce, he;
  let pe = (ce = v.id) != null ? ce : `headlessui-dialog-${_w()}`, Me = Jr(!1);
  Ad(() => {
    Me.value = !0;
  });
  let Ze = !1, Ye = Qo(() => v.role === "dialog" || v.role === "alertdialog" ? v.role : (Ze || (Ze = !0, console.warn(`Invalid role [${Ye}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog")), yt = Jr(0), jt = A8(), it = Qo(() => v.open === B5 && jt !== null ? (jt.value & og.Open) === og.Open : v.open), Rt = Jr(null), en = Qo(() => X2(Rt));
  if (ue({ el: Rt, $el: Rt }), !(v.open !== B5 || jt !== null))
    throw new Error("You forgot to provide an `open` prop to the `Dialog`.");
  if (typeof it.value != "boolean")
    throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${it.value === B5 ? void 0 : v.open}`);
  let Gt = Qo(() => Me.value && it.value ? 0 : 1), gt = Qo(() => Gt.value === 0), an = Qo(() => yt.value > 1), Ot = nh(S8, null) !== null, [Ee, wt] = RY(), { resolveContainers: Se, mainTreeNodeRef: We, MainTreeNode: Cn } = CY({ portals: Ee, defaultContainers: [Qo(() => {
    var Tt;
    return (Tt = lo.panelRef.value) != null ? Tt : Rt.value;
  })] }), ko = Qo(() => an.value ? "parent" : "leaf"), jn = Qo(() => jt !== null ? (jt.value & og.Closing) === og.Closing : !1), Xe = Qo(() => Ot || jn.value ? !1 : gt.value), un = Qo(() => {
    var Tt, yo, Ct;
    return (Ct = Array.from((yo = (Tt = en.value) == null ? void 0 : Tt.querySelectorAll("body > *")) != null ? yo : []).find((tn) => tn.id === "headlessui-portal-root" ? !1 : tn.contains(pu(We)) && tn instanceof HTMLElement)) != null ? Ct : null;
  });
  jF(un, Xe);
  let M = Qo(() => an.value ? !0 : gt.value), Et = Qo(() => {
    var Tt, yo, Ct;
    return (Ct = Array.from((yo = (Tt = en.value) == null ? void 0 : Tt.querySelectorAll("[data-headlessui-portal]")) != null ? yo : []).find((tn) => tn.contains(pu(We)) && tn instanceof HTMLElement)) != null ? Ct : null;
  });
  jF(Et, M), TY({ type: "Dialog", enabled: Qo(() => Gt.value === 0), element: Rt, onUpdate: (Tt, yo) => {
    if (yo === "Dialog")
      return Dy(Tt, { [k8.Add]: () => yt.value += 1, [k8.Remove]: () => yt.value -= 1 });
  } });
  let ht = OY({ name: "DialogDescription", slot: Qo(() => ({ open: it.value })) }), mn = Jr(null), lo = { titleId: mn, panelRef: Jr(null), dialogState: Gt, setTitleId(Tt) {
    mn.value !== Tt && (mn.value = Tt);
  }, close() {
    L("close", !1);
  } };
  Ay(S8, lo);
  let dt = Qo(() => !(!gt.value || an.value));
  iY(Se, (Tt, yo) => {
    Tt.preventDefault(), lo.close(), I5(() => yo == null ? void 0 : yo.focus());
  }, dt);
  let Bn = Qo(() => !(an.value || Gt.value !== 0));
  a$((he = en.value) == null ? void 0 : he.defaultView, "keydown", (Tt) => {
    Bn.value && (Tt.defaultPrevented || Tt.key === s$.Escape && (Tt.preventDefault(), Tt.stopPropagation(), lo.close()));
  });
  let jr = Qo(() => !(jn.value || Gt.value !== 0 || Ot));
  return _Y(en, jr, (Tt) => {
    var yo;
    return { containers: [...(yo = Tt.containers) != null ? yo : [], Se] };
  }), Jh((Tt) => {
    if (Gt.value !== 0)
      return;
    let yo = pu(Rt);
    if (!yo)
      return;
    let Ct = new ResizeObserver((tn) => {
      for (let oa of tn) {
        let Pn = oa.target.getBoundingClientRect();
        Pn.x === 0 && Pn.y === 0 && Pn.width === 0 && Pn.height === 0 && lo.close();
      }
    });
    Ct.observe(yo), Tt(() => Ct.disconnect());
  }), () => {
    let { open: Tt, initialFocus: yo, ...Ct } = v, tn = { ...N, ref: Rt, id: pe, role: Ye.value, "aria-modal": Gt.value === 0 ? !0 : void 0, "aria-labelledby": mn.value, "aria-describedby": ht.value }, oa = { open: Gt.value === 0 };
    return Xu(w8, { force: !0 }, () => [Xu(m$, () => Xu(NY, { target: Rt.value }, () => Xu(w8, { force: !1 }, () => Xu(mT, { initialFocus: yo, containers: Se, features: gt.value ? Dy(ko.value, { parent: mT.features.RestoreFocus, leaf: mT.features.All & ~mT.features.FocusLock }) : mT.features.None }, () => Xu(wt, {}, () => rg({ ourProps: tn, theirProps: { ...Ct, ...N }, slot: oa, attrs: N, slots: W, visible: Gt.value === 0, features: $5.RenderStrategy | $5.Static, name: "Dialog" })))))), Xu(Cn)]);
  };
} }), LY = em({ name: "DialogOverlay", props: { as: { type: [Object, String], default: "div" }, id: { type: String, default: null } }, setup(v, { attrs: L, slots: N }) {
  var W;
  let ue = (W = v.id) != null ? W : `headlessui-dialog-overlay-${_w()}`, ce = wT("DialogOverlay");
  function he(pe) {
    pe.target === pe.currentTarget && (pe.preventDefault(), pe.stopPropagation(), ce.close());
  }
  return () => {
    let { ...pe } = v;
    return rg({ ourProps: { id: ue, "aria-hidden": !0, onClick: he }, theirProps: pe, slot: { open: ce.dialogState.value === 0 }, attrs: L, slots: N, name: "DialogOverlay" });
  };
} });
em({ name: "DialogBackdrop", props: { as: { type: [Object, String], default: "div" }, id: { type: String, default: null } }, inheritAttrs: !1, setup(v, { attrs: L, slots: N, expose: W }) {
  var ue;
  let ce = (ue = v.id) != null ? ue : `headlessui-dialog-backdrop-${_w()}`, he = wT("DialogBackdrop"), pe = Jr(null);
  return W({ el: pe, $el: pe }), Ad(() => {
    if (he.panelRef.value === null)
      throw new Error("A <DialogBackdrop /> component is being used, but a <DialogPanel /> component is missing.");
  }), () => {
    let { ...Me } = v, Ze = { id: ce, ref: pe, "aria-hidden": !0 };
    return Xu(w8, { force: !0 }, () => Xu(m$, () => rg({ ourProps: Ze, theirProps: { ...L, ...Me }, slot: { open: he.dialogState.value === 0 }, attrs: L, slots: N, name: "DialogBackdrop" })));
  };
} });
em({ name: "DialogPanel", props: { as: { type: [Object, String], default: "div" }, id: { type: String, default: null } }, setup(v, { attrs: L, slots: N, expose: W }) {
  var ue;
  let ce = (ue = v.id) != null ? ue : `headlessui-dialog-panel-${_w()}`, he = wT("DialogPanel");
  W({ el: he.panelRef, $el: he.panelRef });
  function pe(Me) {
    Me.stopPropagation();
  }
  return () => {
    let { ...Me } = v, Ze = { id: ce, ref: he.panelRef, onClick: pe };
    return rg({ ourProps: Ze, theirProps: Me, slot: { open: he.dialogState.value === 0 }, attrs: L, slots: N, name: "DialogPanel" });
  };
} });
let PY = em({ name: "DialogTitle", props: { as: { type: [Object, String], default: "h2" }, id: { type: String, default: null } }, setup(v, { attrs: L, slots: N }) {
  var W;
  let ue = (W = v.id) != null ? W : `headlessui-dialog-title-${_w()}`, ce = wT("DialogTitle");
  return Ad(() => {
    ce.setTitleId(ue), Qh(() => ce.setTitleId(null));
  }), () => {
    let { ...he } = v;
    return rg({ ourProps: { id: ue }, theirProps: he, slot: { open: ce.dialogState.value === 0 }, attrs: L, slots: N, name: "DialogTitle" });
  };
} });
function IY(v) {
  let L = { called: !1 };
  return (...N) => {
    if (!L.called)
      return L.called = !0, v(...N);
  };
}
function y8(v, ...L) {
  v && L.length > 0 && v.classList.add(...L);
}
function L5(v, ...L) {
  v && L.length > 0 && v.classList.remove(...L);
}
var E8 = ((v) => (v.Finished = "finished", v.Cancelled = "cancelled", v))(E8 || {});
function FY(v, L) {
  let N = vT();
  if (!v)
    return N.dispose;
  let { transitionDuration: W, transitionDelay: ue } = getComputedStyle(v), [ce, he] = [W, ue].map((pe) => {
    let [Me = 0] = pe.split(",").filter(Boolean).map((Ze) => Ze.includes("ms") ? parseFloat(Ze) : parseFloat(Ze) * 1e3).sort((Ze, Ye) => Ye - Ze);
    return Me;
  });
  return ce !== 0 ? N.setTimeout(() => L("finished"), ce + he) : L("finished"), N.add(() => L("cancelled")), N.dispose;
}
function WF(v, L, N, W, ue, ce) {
  let he = vT(), pe = ce !== void 0 ? IY(ce) : () => {
  };
  return L5(v, ...ue), y8(v, ...L, ...N), he.nextFrame(() => {
    L5(v, ...N), y8(v, ...W), he.add(FY(v, (Me) => (L5(v, ...W, ...L), y8(v, ...ue), pe(Me))));
  }), he.add(() => L5(v, ...L, ...N, ...W, ...ue)), he.add(() => pe("cancelled")), he.dispose;
}
function vw(v = "") {
  return v.split(/\s+/).filter((L) => L.length > 1);
}
let D8 = Symbol("TransitionContext");
var $Y = ((v) => (v.Visible = "visible", v.Hidden = "hidden", v))($Y || {});
function HY() {
  return nh(D8, null) !== null;
}
function VY() {
  let v = nh(D8, null);
  if (v === null)
    throw new Error("A <TransitionChild /> is used but it is missing a parent <TransitionRoot />.");
  return v;
}
function UY() {
  let v = nh(R8, null);
  if (v === null)
    throw new Error("A <TransitionChild /> is used but it is missing a parent <TransitionRoot />.");
  return v;
}
let R8 = Symbol("NestingContext");
function V5(v) {
  return "children" in v ? V5(v.children) : v.value.filter(({ state: L }) => L === "visible").length > 0;
}
function g$(v) {
  let L = Jr([]), N = Jr(!1);
  Ad(() => N.value = !0), Qh(() => N.value = !1);
  function W(ce, he = yv.Hidden) {
    let pe = L.value.findIndex(({ id: Me }) => Me === ce);
    pe !== -1 && (Dy(he, { [yv.Unmount]() {
      L.value.splice(pe, 1);
    }, [yv.Hidden]() {
      L.value[pe].state = "hidden";
    } }), !V5(L) && N.value && (v == null || v()));
  }
  function ue(ce) {
    let he = L.value.find(({ id: pe }) => pe === ce);
    return he ? he.state !== "visible" && (he.state = "visible") : L.value.push({ id: ce, state: "visible" }), () => W(ce, yv.Unmount);
  }
  return { children: L, register: ue, unregister: W };
}
let h$ = $5.RenderStrategy, T8 = em({ props: { as: { type: [Object, String], default: "div" }, show: { type: [Boolean], default: null }, unmount: { type: [Boolean], default: !0 }, appear: { type: [Boolean], default: !1 }, enter: { type: [String], default: "" }, enterFrom: { type: [String], default: "" }, enterTo: { type: [String], default: "" }, entered: { type: [String], default: "" }, leave: { type: [String], default: "" }, leaveFrom: { type: [String], default: "" }, leaveTo: { type: [String], default: "" } }, emits: { beforeEnter: () => !0, afterEnter: () => !0, beforeLeave: () => !0, afterLeave: () => !0 }, setup(v, { emit: L, attrs: N, slots: W, expose: ue }) {
  let ce = Jr(0);
  function he() {
    ce.value |= og.Opening, L("beforeEnter");
  }
  function pe() {
    ce.value &= ~og.Opening, L("afterEnter");
  }
  function Me() {
    ce.value |= og.Closing, L("beforeLeave");
  }
  function Ze() {
    ce.value &= ~og.Closing, L("afterLeave");
  }
  if (!HY() && cY())
    return () => Xu(b$, { ...v, onBeforeEnter: he, onAfterEnter: pe, onBeforeLeave: Me, onAfterLeave: Ze }, W);
  let Ye = Jr(null), yt = Qo(() => v.unmount ? yv.Unmount : yv.Hidden);
  ue({ el: Ye, $el: Ye });
  let { show: jt, appear: it } = VY(), { register: Rt, unregister: en } = UY(), Gt = Jr(jt.value ? "visible" : "hidden"), gt = { value: !0 }, an = _w(), Ot = { value: !1 }, Ee = g$(() => {
    !Ot.value && Gt.value !== "hidden" && (Gt.value = "hidden", en(an), Ze());
  });
  Ad(() => {
    let M = Rt(an);
    Qh(M);
  }), Jh(() => {
    if (yt.value === yv.Hidden && an) {
      if (jt.value && Gt.value !== "visible") {
        Gt.value = "visible";
        return;
      }
      Dy(Gt.value, { hidden: () => en(an), visible: () => Rt(an) });
    }
  });
  let wt = vw(v.enter), Se = vw(v.enterFrom), We = vw(v.enterTo), Cn = vw(v.entered), ko = vw(v.leave), jn = vw(v.leaveFrom), Xe = vw(v.leaveTo);
  Ad(() => {
    Jh(() => {
      if (Gt.value === "visible") {
        let M = pu(Ye);
        if (M instanceof Comment && M.data === "")
          throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
      }
    });
  });
  function un(M) {
    let Et = gt.value && !it.value, ht = pu(Ye);
    !ht || !(ht instanceof HTMLElement) || Et || (Ot.value = !0, jt.value && he(), jt.value || Me(), M(jt.value ? WF(ht, wt, Se, We, Cn, (mn) => {
      Ot.value = !1, mn === E8.Finished && pe();
    }) : WF(ht, ko, jn, Xe, Cn, (mn) => {
      Ot.value = !1, mn === E8.Finished && (V5(Ee) || (Gt.value = "hidden", en(an), Ze()));
    })));
  }
  return Ad(() => {
    Od([jt], (M, Et, ht) => {
      un(ht), gt.value = !1;
    }, { immediate: !0 });
  }), Ay(R8, Ee), uY(Qo(() => Dy(Gt.value, { visible: og.Open, hidden: og.Closed }) | ce.value)), () => {
    let { appear: M, show: Et, enter: ht, enterFrom: mn, enterTo: lo, entered: dt, leave: Bn, leaveFrom: jr, leaveTo: Tt, ...yo } = v, Ct = { ref: Ye }, tn = { ...yo, ...it.value && jt.value && xT.isServer ? { class: tc([N.class, yo.class, ...wt, ...Se]) } : {} };
    return rg({ theirProps: tn, ourProps: Ct, slot: {}, slots: W, attrs: N, features: h$, visible: Gt.value === "visible", name: "TransitionChild" });
  };
} }), jY = T8, b$ = em({ inheritAttrs: !1, props: { as: { type: [Object, String], default: "div" }, show: { type: [Boolean], default: null }, unmount: { type: [Boolean], default: !0 }, appear: { type: [Boolean], default: !1 }, enter: { type: [String], default: "" }, enterFrom: { type: [String], default: "" }, enterTo: { type: [String], default: "" }, entered: { type: [String], default: "" }, leave: { type: [String], default: "" }, leaveFrom: { type: [String], default: "" }, leaveTo: { type: [String], default: "" } }, emits: { beforeEnter: () => !0, afterEnter: () => !0, beforeLeave: () => !0, afterLeave: () => !0 }, setup(v, { emit: L, attrs: N, slots: W }) {
  let ue = A8(), ce = Qo(() => v.show === null && ue !== null ? (ue.value & og.Open) === og.Open : v.show);
  Jh(() => {
    if (![!0, !1].includes(ce.value))
      throw new Error('A <Transition /> is used but it is missing a `:show="true | false"` prop.');
  });
  let he = Jr(ce.value ? "visible" : "hidden"), pe = g$(() => {
    he.value = "hidden";
  }), Me = Jr(!0), Ze = { show: ce, appear: Qo(() => v.appear || !Me.value) };
  return Ad(() => {
    Jh(() => {
      Me.value = !1, ce.value ? he.value = "visible" : V5(pe) || (he.value = "hidden");
    });
  }), Ay(R8, pe), Ay(D8, Ze), () => {
    let Ye = o$(v, ["show", "appear", "unmount", "onBeforeEnter", "onBeforeLeave", "onAfterEnter", "onAfterLeave"]), yt = { unmount: v.unmount };
    return rg({ ourProps: { ...yt, as: "template" }, theirProps: {}, slot: {}, slots: { ...W, default: () => [Xu(jY, { onBeforeEnter: () => L("beforeEnter"), onAfterEnter: () => L("afterEnter"), onBeforeLeave: () => L("beforeLeave"), onAfterLeave: () => L("afterLeave"), ...N, ...yt, ...Ye }, W.default)] }, attrs: {}, features: h$, visible: he.value === "visible", name: "Transition" });
  };
} });
const ZY = { class: "flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0" }, WY = { class: "inline-block align-bottom bg-white rounded-lg px-4 pt-5 pb-4 text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full sm:p-6" }, qY = { class: "sm:flex sm:items-start" }, GY = { class: "mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left" }, KY = { class: "mt-2" }, YY = ["innerHTML"], XY = { class: "mt-5 sm:mt-4 sm:flex sm:flex-row-reverse" }, JY = {
  __name: "DeleteConfirmModal",
  props: {
    open: {
      type: Boolean,
      default() {
        return !1;
      }
    },
    message: {
      type: String,
      default: "Are you sure you want to delete this record?"
    },
    title: {
      type: String,
      default: "Delete"
    },
    buttonName: {
      type: String,
      default: "Delete"
    }
  },
  setup(v) {
    return (L, N) => (kn(), Ju(ng(b$), {
      as: "template",
      show: v.open
    }, {
      default: bf(() => [
        Qf(ng(BY), {
          as: "div",
          class: "fixed z-10 inset-0 overflow-y-auto",
          onClose: N[2] || (N[2] = (W) => v.open = !1)
        }, {
          default: bf(() => [
            Co("div", ZY, [
              Qf(ng(T8), {
                as: "template",
                enter: "ease-out duration-300",
                "enter-from": "opacity-0",
                "enter-to": "opacity-100",
                leave: "ease-in duration-200",
                "leave-from": "opacity-100",
                "leave-to": "opacity-0"
              }, {
                default: bf(() => [
                  Qf(ng(LY), { class: "fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity" })
                ]),
                _: 1
              }),
              N[4] || (N[4] = Co("span", {
                class: "hidden sm:inline-block sm:align-middle sm:h-screen",
                "aria-hidden": "true"
              }, "​", -1)),
              Qf(ng(T8), {
                as: "template",
                enter: "ease-out duration-300",
                "enter-from": "opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95",
                "enter-to": "opacity-100 translate-y-0 sm:scale-100",
                leave: "ease-in duration-200",
                "leave-from": "opacity-100 translate-y-0 sm:scale-100",
                "leave-to": "opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
              }, {
                default: bf(() => [
                  Co("div", WY, [
                    Co("div", qY, [
                      N[3] || (N[3] = Co("div", { class: "mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100 sm:mx-0 sm:h-10 sm:w-10" }, [
                        Co("svg", {
                          xmlns: "http://www.w3.org/2000/svg",
                          fill: "none",
                          viewBox: "0 0 24 24",
                          "stroke-width": "1.5",
                          stroke: "currentColor",
                          class: "h-6 w-6 text-red-600"
                        }, [
                          Co("path", {
                            "stroke-linecap": "round",
                            "stroke-linejoin": "round",
                            d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
                          })
                        ])
                      ], -1)),
                      Co("div", GY, [
                        Qf(ng(PY), {
                          as: "h3",
                          class: "text-lg leading-6 font-medium text-gray-900"
                        }, {
                          default: bf(() => [
                            Bm(ji(v.title), 1)
                          ]),
                          _: 1
                        }),
                        Co("div", KY, [
                          Co("p", {
                            class: "text-sm text-gray-500",
                            innerHTML: v.message
                          }, null, 8, YY)
                        ])
                      ])
                    ]),
                    Co("div", XY, [
                      Co("button", {
                        type: "button",
                        class: "w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-red-600 text-base font-medium text-white hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 sm:ml-3 sm:w-auto sm:text-sm",
                        onClick: N[0] || (N[0] = (W) => L.$emit("destroy"))
                      }, ji(v.buttonName), 1),
                      Co("button", {
                        type: "button",
                        class: "mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-base font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 sm:mt-0 sm:w-auto sm:text-sm",
                        onClick: N[1] || (N[1] = (W) => L.$emit("close")),
                        ref: "cancelButtonRef"
                      }, "Cancel", 512)
                    ])
                  ])
                ]),
                _: 1
              })
            ])
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["show"]));
  }
}, QY = {
  __name: "DeleteForm",
  setup(v) {
    const L = Jr(!1);
    return (N, W) => (kn(), no("div", null, [
      Qf(hT, {
        onClick: W[0] || (W[0] = vc((ue) => L.value = !0, ["prevent"])),
        context: "form-btn-red"
      }, {
        default: bf(() => W[3] || (W[3] = [
          Bm(" Delete ")
        ])),
        _: 1
      }),
      Qf(JY, {
        open: L.value,
        onDestroy: W[1] || (W[1] = (ue) => N.$emit("destroy")),
        onClose: W[2] || (W[2] = (ue) => L.value = !1)
      }, null, 8, ["open"])
    ]));
  }
}, eX = { class: "vue-form-components bg-white border shadow-md sm:rounded-md" }, tX = { class: "text-2xl font-medium leading-6 text-gray-800" }, nX = {
  key: 0,
  class: "mt-1 text-sm text-gray-500"
}, oX = {
  key: 0,
  class: "animate-spin -ml-1 mr-3 h-5 w-5 text-green-200",
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 24 24"
}, wX = {
  __name: "ModelForm",
  props: {
    modelValue: {
      type: Object
    },
    loading: {
      type: Boolean,
      default() {
        return !1;
      }
    },
    sections: {
      type: Array,
      default() {
        return [{ title: null }];
      }
    },
    footerClass: {
      type: String
    },
    footerStyle: {
      type: String
    },
    buttonsContainerClass: {
      type: String
    },
    cancelAction: {
      type: Function
    },
    cancelUrl: {
      type: String
    },
    backOnCancel: {
      type: Boolean,
      default: !1
    },
    cancelName: {
      type: String,
      default: "Cancel"
    },
    submitName: {
      type: String,
      default: "Save"
    },
    submitDisabled: {
      type: Boolean,
      default: !1
    },
    hideCancel: {
      type: Boolean,
      default: !1
    },
    hideDelete: {
      type: Boolean,
      default: !1
    },
    confirmDelete: {
      type: Boolean,
      default: !1
    },
    hideFooter: {
      type: Boolean,
      default: !1
    },
    disabled: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["submit", "destroy", "update:modelValue", "cancel"],
  setup(v, { emit: L }) {
    const N = L, W = v;
    Qo({
      get() {
        return W.modelValue;
      },
      set(pe) {
        N("update:modelValue", pe);
      }
    });
    function ue() {
      N("submit", W.modelValue);
    }
    function ce() {
      W.cancelAction ? W.cancelAction() : W.backOnCancel ? history.back() : N("cancel");
    }
    function he() {
      N("destroy", W.modelValue);
    }
    return Od(
      () => W.modelValue.errors,
      (pe) => {
        for (let Me = 0; Me < W.sections.length; Me++)
          W.sections[Me].model && (W.sections[Me].model.errors = pe);
      },
      { deep: !0 }
    ), (pe, Me) => (kn(), no("section", eX, [
      (kn(!0), no(th, null, Oy(v.sections, (Ze, Ye) => (kn(), no("div", {
        class: tc(["p-6 space-y-6 border-b-2", Ze.class]),
        style: Y2(Ze.style)
      }, [
        Ze.title ? (kn(), no("div", {
          key: 0,
          class: tc(Ze.headerClass)
        }, [
          Co("h3", tX, ji(Ze.title), 1),
          Ze.description ? (kn(), no("p", nX, ji(Ze.description), 1)) : Ks("", !0)
        ], 2)) : Ks("", !0),
        Co("div", {
          class: tc(Ze.bodyClass)
        }, [
          kl(pe.$slots, `beforeGroupSection${Ye}`),
          Qf(jK, {
            form: Ze.model ?? v.modelValue,
            id: Ze.id,
            inputs: Ze.inputs,
            class: tc(Ze.inputGroupClass),
            disabled: v.disabled,
            "indicate-required": Ze.indicateRequired
          }, null, 8, ["form", "id", "inputs", "class", "disabled", "indicate-required"]),
          kl(pe.$slots, `afterGroupSection${Ye}`)
        ], 2)
      ], 6))), 256)),
      kl(pe.$slots, "default"),
      v.hideFooter ? Ks("", !0) : (kn(), no("div", {
        key: 0,
        class: tc(["px-6 py-3 bg-gray-100 text-right rounded-b flex items-center", v.footerClass]),
        style: Y2(v.footerStyle)
      }, [
        kl(pe.$slots, "footer"),
        Co("div", {
          class: tc(["flex-1 flex justify-end", v.buttonsContainerClass])
        }, [
          v.confirmDelete && !v.hideDelete && v.modelValue.id ? (kn(), Ju(QY, {
            key: 0,
            class: "mr-auto",
            onDestroy: he
          })) : !v.hideDelete && v.modelValue.id ? (kn(), Ju(hT, {
            key: 1,
            context: "form-btn-red",
            class: "mr-auto",
            onClick: he
          }, {
            default: bf(() => Me[0] || (Me[0] = [
              Bm("Delete")
            ])),
            _: 1
          })) : Ks("", !0),
          !v.cancelUrl && !v.hideCancel ? (kn(), Ju(hT, {
            key: 2,
            context: "form-btn-white",
            onClick: vc(ce, ["prevent"])
          }, {
            default: bf(() => [
              Bm(ji(v.cancelName), 1)
            ]),
            _: 1
          })) : v.hideCancel ? Ks("", !0) : (kn(), Ju(hT, {
            key: 3,
            type: "link",
            context: "form-btn-white",
            href: v.cancelUrl
          }, {
            default: bf(() => [
              Bm(ji(v.cancelName), 1)
            ]),
            _: 1
          }, 8, ["href"])),
          Qf(hT, {
            class: "ml-4 flex",
            context: "form-btn-primary",
            disabled: v.loading || v.submitDisabled || v.disabled,
            onClick: ue
          }, {
            default: bf(() => [
              v.loading ? (kn(), no("svg", oX, Me[1] || (Me[1] = [
                Co("circle", {
                  class: "opacity-25",
                  cx: "12",
                  cy: "12",
                  r: "10",
                  stroke: "currentColor",
                  "stroke-width": "4"
                }, null, -1),
                Co("path", {
                  class: "opacity-75",
                  fill: "currentColor",
                  d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                }, null, -1)
              ]))) : Ks("", !0),
              Bm(" " + ji(v.submitName), 1)
            ]),
            _: 1
          }, 8, ["disabled"])
        ], 2)
      ], 6))
    ]));
  }
};
export {
  UK as FormInput,
  jK as FormInputGroup,
  VK as InputControl,
  wX as ModelForm
};
